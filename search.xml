<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2021年终总结</title>
    <url>/2021/12/31/2021%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>又要到元旦了，打开各种APP都是“年终XX总结”—年终听歌总结、年终支付总结、年终电影总结等等等等。各种社交媒体上各路英雄好汉也晒出了自己的这一年的收获，那这篇文章的开场也是我这一年的各项总结：<br><img data-src="/images/2021%E6%80%BB%E7%BB%93.png"></p>
<p>拿到这张图，发现我这一年游戏玩的是真多。PES2019玩了好久了，一直没卸载的原因是有时候周末看球后，一激动就来一盘，甚至有时候跳健身环的时候也在大师联赛模式挂机。今年主要玩的大游戏就是《如龙7》+《起源》+《英灵殿》+《switch：马里奥-奥德赛》，都是打折的时候买的，加起来大约花了1000多块吧。这几个都是开放类游戏，各种探索加解密肯定花了老子不少时间。这里面也就《鬼泣5》的时间花费最少了，打穿了主线看了剧情就到此为止了，没有继续深挖，话说《鬼泣5》也是解压的好作品，在重金属的BGM熏陶下嗷嗷砍人，而且砍人不重要，打的炫才重要。话说今年打游戏，手柄用的多，双十一的时候还买了一个新手柄和新鼠标(买新手柄的原因就是之前玩《只狼》砸手柄太多，给砸钝了…)。</p>
<p>话说玩这种开放类游戏的好处就是云旅游，现在各地疫情反复，还不能出国的现实条件下，只能在游戏的沙盘里各种游荡、各种拍照。但是现在游戏好剧情不多了，《只狼》的剧情很不错，但是今年这几个都没有达到像它那种“可以让人细细品味”的高度（《英灵殿》用了这种碎片化的叙事结构，通过正传跟神话DLC的结合，最后知道了主人公、西格德等人其实都是北欧的神转世)，不过画面做的都是一顶一的好看。不过我觉得还是当年被《只狼》虐的太狠，导致我玩动作类游戏总想着招架弹刀，而《英灵殿》的弹刀判决又不没那么爽脆，所以没少挨揍。</p>
<p>看书方面的话，还是历史和小说的书读得多。相比较以往，财经类、心里学、哲学的书都没咋看。我今年买了一本《三个火枪手》，发现以前小时候没读的国外名著长大了都主动补回来了。除了读书，上班地铁里有空也听听各位历史教授的各种近代史讲座，话说好讲座不易得，又要讲的好又要音质好还要教授说普通话，这真的太难了。</p>
<p>至于其他电影电视剧综艺节目嘛，统计下来发现自己看的比预期的挺多。我今年大陆电视剧为零，原本还看了几集的《小敏家》，后来发现有狗血的趋势就果断放弃了，不过今年日剧看的也不多，好像只看了《全裸导演2》，豆瓣上好评的《短剧开始了》打算在春节抽空左右补掉。台湾剧《想见你》是表妹推荐的，当时看的很上头，不过主人公大学泡妞那段我基本快进的。其实我电影电视剧的来源主要还是来自豆瓣：拿到名字后，先去豆瓣查一下，基本7分以上的就端正态度，7分以下的就漫不经心了。今年电影里看的印象最深的就是《血观音》，这个片儿在2018年金马奖里上大杀特杀，也凭借此片拿下第二个金马影后的惠英红女士在里面的表现真的太好了，当然这种全员恶女的本子也让人兴奋。 </p>
<p>年初的时候电影圈最火就是《李焕英》，国庆的时候是《长津湖》。不过他们仅仅是局限在大陆，而《鱿鱼游戏》是今年全球的大火剧，在Google排名高居不下，我也是在国庆期间就突击看完的，记得那时候是白天在南京自驾游玩，晚上在酒店一集又一集，也正是趁着这个“大逃杀”热，看了《大逃杀》、《活死人黎明》以及同样是网飞的《弥留之国的爱丽丝 第一季》。</p>
<p>写到这里想起来了，今年还看一个同样是台湾的但是大陆封杀的《KANO》，一个很棒青春有热血的体育励志片儿。我发现了，如果日剧没什么好看的，就去看台剧，无论是黑暗人性还是小清新，这两拨还是有非常非常相似的地方的。现在香港年轻演员式微了， 不过台湾还是有很多年轻的宝藏演员的。</p>
<p>至于博客，今年的确在博客上写的东西不多，一共才23篇，而且集中在Django和MySQL，从博客文章数量来说算这几年比较少的了，主要的原因就是在公司的文档写的东西实在太多了，前几天看了一下年度总结报告，写了几乎十万字，平均每天就300多字，我现在除了工作之外就是一个无情的答疑机器人：<br><img data-src="/images/%E8%AF%AD%E9%9B%80%E6%8A%A5%E5%91%8A.png"></p>
<p>不过要说今年最大的两个生活上的收获一个是买了一辆车，第二就是房子装修完毕顺利入住。买了新车就总心痒痒想去跑个自驾游，有了新房子也是有用没用的东西买了一堆，在这两件事儿上花了我今年总消费的70%以上。不过这俩事儿有喜也有悲：车子在这半年多一点的时间里剐蹭了也被人追尾了；搬了新家虽然香但是离公司更远了，现在通勤的时间花费了更久。2022年公司又更改了通勤政策，由全报销打车费改成了每个月800打车补贴。将来加班肯定要减少了，但是到公司的时间不可以还是这么晚了。正好新的师弟入职了，我可得好好培养他，以后大促的重担就交给家近的年轻人。</p>
<p>今年工作上的收获也不少，我在这个公司已经二年了，很多事情有了新的感悟，工作也驾轻就熟了很多，趁着大促的机会刷了不少脸也拿到了一些奖，在部门的影响力也提升了一点。今年大环境很不景气，从房地产到电商，从在线教育到互联网长视频，越到年关各大厂裁人的消息越多。无疑又是一个寒冬，社交媒体上很多大V都说“这是未来几年内最好的一年了”。看样子在“疫情+政策”的双重夹击下，这一代打工人，尤其是要养家生三胎的打工人肯定是很难熬的，当然，惨淡的所有原因都可以很不要脸的推给疫情。不过还是衷心希望疫情早点结束，整个社会再次生机勃勃起来，大家赚到更多的钱，至少丈母娘家门口的7-11和水果店能再次复活，至少让我买烤肠和咖啡能更方便一点。整个互联网上也减少一些戾气和抖机灵，世界和平number 1。</p>
<p>文章写到此了，实在不立点flag是多少有点说不过去，这个环节还是不能免俗，不过为了不食言还是立的少立一点：在2022年里，先把《巫师3》和《仁王1》打掉吧，switch上买的《死亡细胞》也之前没咋玩，其他的游戏再说。家里还有一本看了两页的《包法利夫人》，争取早日看完。MacOS里还有不少的电子书，找机会啃一啃，说起来有点丢人，我还没彻底好好的读过《红楼梦》，这个优先级也提前吧。毕竟是四大名著，不读不是中国人。总而言之，2022年在游戏和读书上会花点时间但是不会花很多钱，能白嫖还是白嫖。</p>
<p>除此之外，还想学点技能，比如吉他、比如摄影、比如日语，我觉得可以先从日语开始。</p>
<p>个人生活方面，减肥是永恒的主旋律，最近实在的胖的太过分。然后也而立之年好几天了，琢磨琢磨该布点也算要个孩子了，减肥下来孩子的质量也更好，这个还需要多攒钱多做媳妇的思想工作，但愿新的一年能顺利，每年有点小进步就挺好的。</p>
<p>我也看了有一些网友写的新年愿望是“拒绝无效社交”，这个出发点肯定是好的。但是我担心这样把握不好，会让人会变得势力和现实。因为他们会与人的相处时第一件事就是判断“这个人对我有用没用，有用就是有效社交，没用就是无效社交”。所以说如何把握好这个判断的尺度，才是一个人重要思考的问题。<br><img data-src="/images/%E4%BA%8E%E5%92%8C%E4%BC%9F.webp"></p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>2022年终总结</title>
    <url>/2023/01/29/2022%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>惰性拖延症由于新冠阳了后久久赖床而屡屡发作，于是这篇年终总结放在了兔年除夕之后才慢悠悠的搞，按理说这都不应该算是阳历的年度总结了。</p>
<p>先上一个简单的个人业务时间花费项目:<br><img data-src="/images/2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93.png"></p>
<p>今年游戏玩的比较少了，《死亡细胞》有段时间玩的比较疯，基本下班到家就是打开switch一顿狂剁，后来打吐了就没兴趣了。后来世界杯的时候，正好育碧搞了一个什么活动，买DLC省钱，于是乎就买了《英灵殿》的DLC，在世界杯期间打通了主线，拿了一些装备。《战神4》下载了但是目前没打完，有动力不足的倾向。前段时间知道了暴雪跟网易谈崩的消息，但也没有啥冲动想再去魔兽里看看了，估计未来时间里游戏都会玩的比较少了。但是我还是想把《战神4》通关掉，然后找时间玩玩大名鼎鼎的老头环。</p>
<p>今年看书用的时间多了一点，多数都是用在看历史书和经济学书上了。故事书也看，主要是两类，一类就是奇谈类：比如冯骥才先生的《三寸金莲》，老威的《中国底层访谈录》，古龙的《天涯明月刀》。还有就是侦探类的：埃勒里奎因的《哲瑞雷恩的最后一案》和古龙的《楚留香之蝙蝠传奇》。话说古龙的书的确很好读，他的书也就三四十万字，基本找个周末熬个大夜就读完了，而且很上瘾，上瘾的原因是古龙毕竟也算是半个江湖人士，总有各种千奇百怪的故事通过他那装满酒精和文采的脑袋一加工就是一个引人入胜的文字，让人完全停不下来，可惜的就是拍成影视剧比较少，所以受众面小了很多，讨论的圈子也比较窄。而《最后一案》这本书是我在公司内网里跟其他同事交换的，利用在贵州团建那几天看完。如果说《楚留香之蝙蝠传奇》是古龙大胆的在武侠小说里尝试写侦探故事，那么这个《最后一案》也是一个大胆的尝试，结局特别大胆。</p>
<p>今年看的比较多的历史书跟经济书里，我最有感觉的就是《兴盛与危机》。它是我无意之间从公司的公共书架上发现的，然后就一发不可收拾。这是一个本关于统治学的好书，它里面讲古中国意识形态是如何控制知识精英进而对大一统的作用那里给我很大的启示，很多道理放到今天仍不过时，不过它最后一章用数学模型参与历史研究那一块让我看的有点懵逼。以这本书为引子，结合最近的老龄化、烂尾房、政府债务等等社会热点问题，我就顺藤找到了《人口大逆转》、《大国大城》、《置身事内》等书，它们更多的是经济方面的内容，跟现实政策关系较近，毕竟经济也是统治维稳的重要任务。通过这些书让我明白了一些生存游戏基本规则和具体的一些玩法（比如土地的特质是银行等债权人喜欢的，而土地的多次估值可以用来借贷买更多的土地，这样杠杆越来越大等等骚操作）。越多的了解，越让我改变了对于某些社会现象的看法。现在是一个几乎人人都有负债的年代，如何处理自己的债务和对资产进行良好的管理往往比低头苦逼挣钱还要有用。</p>
<p>我记得书里有一个例子，讲的是买房。一个哥们A在疫情之前买了一个房子，当时正是房价高点，银行的加点比较高，那么从银行手里贷款了100万，连本带利需要还200万。但是疫情三年，房地产业萧条，银行为了刺激“刚需”，银行自己加点调整比之前低很多，那么此时利息就很低。那么这个哥们算一算，假设还欠下银行本金50万，算上利息一共要还100万。那么他可以找亲戚或者朋友借到50万去办理提前还贷。这样房子就彻底是自己的了，然后把这个房子抵押给银行借出来50万，因为此时利息低，借出来50万，可能只要还80万，那么这个哥们把从银行抵押出来的50万拿出来还给亲戚朋友抹平欠款外，就只需要还给银行80万够了。这么一来一往，房子的所属权还是银行，但是原本需要给银行还100万，现在只需要还80万，立减20万。</p>
<p>至于“以工代赈”，那么可以清晰的看出这个模式下会出现大量的腐败。比如某个村子要翻修一条路，那么这个工程如果是专业的工程队来搞，可能需要10个人，1个月搞定，大约花费5万块。但是由于“以工代赈”，那么就要用老乡用人力来搞，这样估计就要30个老乡，2个月搞定。那么负责该项目的领导就需要去打一个报告，说明“30个老乡，2个月搞定”的必然性，然后按照老乡一天XXX元，来申请一笔经费，而这笔经费肯定大于等于5万块，比如申请到10万块。</p>
<p>那么负责人拿到了这10万块，首先先拿出5万块去找一个工程队来干活。剩下的5万块拿出2万块去免费按2个月发给老乡，这个数字肯定远小于上面的<code>XXX元</code>，老乡白拿到钱自然对这个事儿闭嘴。剩下1万块负责人自己贪污掉，然后最后2万块留着打点上面派来的督察队。</p>
<p>这才叫对《大明王朝1566》的活学活用啊…<br><img data-src="/images/2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%932.JPG"></p>
<p>这几本书将来还要再拿出来读一遍，只翻一次真的是不够，毕竟人生还有养老保险、事业保险等等等等乱七八糟但是有跟自身利益紧密相关的事儿需要挖掘。我算了一下，过去一年读了大约12本书，平均每个月一本。读书速度在可接受范围内，新的一年估计还是会以这个速率继续…</p>
<p>多读书、多看报对酒桌上吹牛逼也是很有好处的，就像这次回家过年喝酒有些亲戚抱怨说自己家孩子有代沟了，在酒桌上也是沉默寡言跟气氛格格不入。其实就是孩子们还没有融入到社会，他们觉得拿学校里的东西跟家长交流没啥意思，而家长的那套社会磕他们又不关心。我劝这些亲戚“等孩子们遭到了社会的毒打了，有个人的感悟了，跟家长自然就沟通顺畅了”，所以各位家长们都先别急。</p>
<p>看书的时候也会在想，如何把书里的内容融会贯通，但是有时候又不会搞出来几百字几千字的读后感，于是我今年就把读到某一处突然有了什么一句话哪怕十几个字的感悟就随手记在笔记本里，零零散散的就当读后笔记了，顺便还能练练钢笔字，这年头有手好字真的是让人羡慕。</p>
<p>今年抗疫政策的急转弯、对外关系的导向、大片烂尾楼的民间纠纷也能从书里找到一些只言片语，或者对未来走势的一点过去经验分享。有时候真的是觉得各位领导们平时日理万机凑在一起开个会不容易，但是这些会到现在一看很多都TMD白瞎了。</p>
<p>今年看的电影其实蛮多的，上面那个xmind列举出来的只是少少的一部分，好多的院线电影我都没写，比如《流浪地球2》、《满江红》、《蝙蝠侠》甚至是《奇异博士2》，还看了很多老电影，比如陈可辛的《甜蜜蜜》。今年总体来说还是一个电影小年，给我留下深刻印象的主要是三个电影—《大佛普拉斯》、《红辣椒》和《瞬息全宇宙》。前一个比较闷骚写实，透着一股淡淡的忧伤，后两个脑洞都超级大，属于脑洞启动起来就刹不住车型。一部好电影前提需要一个逻辑性能靠得住的故事，《满江红》张艺谋把这个故事说明白了，但是整个逻辑实在让人难以信服，就像当年《英雄》也是一片骂声一样。我想主要的原因就是这是有一个真实历史人物（真的就秦桧这么一个）的虚构故事，编好了就是甄嬛传三国演义大明王朝1566，让观众看完了还要去Google一下历史上是不是真的有这么一段。而编砸了，那就只能挨骂甚至要打官司了。</p>
<p>看完电影后，后来刷手机也看到了不少男性年轻人在观影后当场复诵《满江红》这样的短视频，他们是为了拍短视频挣钱搏流量吗？我真的是无语，我对简中圈的舆论导向其实一直都是无语。</p>
<p>电视剧这一part，发现今年投入的时间也不少。日剧里面今年印象比较深的是二宫和也的《我的家》，难得跟我媳妇能一起看完一部剧，里面多部未华子刷了我一波好感。山下智久的《诚实房地产》完全就是当下饭番看的，而《弥留之国的爱丽斯 第二季》完全大失所望，美人投票跟猜项圈花色的这两个原生游戏都没有拍好，而非原生游戏又显得比较弱智，基本主人公一顿嘴炮就搞定了，剧中人物的智力完全没有碾压沙发上的我。《鬼灭之刃 游郭篇》火的时候，是一个周末一口气看完的，整个画风和气氛跟火车篇大不相同。然后就在B站找了一个比较不错的漫画解说UP主，把剩下的鬼灭之刃跟《电锯人》一起搞定了。看漫画的好处就是要保持脑洞，保持天马行空的感觉，同时跟年轻人还能有点话题，话说《异兽魔都》还往下拍不拍了？</p>
<p>2022总体的趋势还是向好的，比过去两年死气沉沉的强多了，虽然自己阳康至今还有点咳嗽，但是阿根廷拿了世界杯冠军让我这个梅西球迷很兴奋。现在疫情也结束一段时间了，专家们都说了“新冠病毒有些传不动了”，可见之前不能谈的“群体免疫”现在可以变相的谈了。虽然过去三年的经济下行不会一年就扭转现状，但是应该可以一定程度上的止血，而且为了GDP好看，今年加大投资力度是显而易见的。今年依旧不是一个ToC的小规模创业的好时机，所谓的报复性消费除了在旅游之外的其他项目上都还差得远，还要再观察。不过目前可以出国了，希望可以拿到年终奖之后，在五月份左右可以去一趟日本玩！</p>
<p>至于工作方面，我在这个公司已经三年醇了，等春节假期结束后要去换新工牌带了。这一年的工作内容主要是降本增效，写代码比以前少多了，更多的写也是SQL或者Python脚本这样的，给开发出这种那种降本的方案，然后执行拿到省钱的收益。这个工作估计将来要转型，看起来我就是一个技术版的财务BP，所以这一年写的技术文章也少了，甚至Excel啥的都开始来凑数了…2023这一年平安度过之后，就可以0元认领此刻敲字的这个笔记本了。工作上的小目标就是在公司继续苟住，平稳的达到五年陈，进而坚持到40岁。我今年很多买书的钱用的就是公司的奖项费用，公司的奖金除了买书就只能是吃饭，所以多拿奖除了有了好绩效还能多买书，顺便又支持自己家的线上店铺，双赢~</p>
<p>2023，希望它是一个有希望的一年！</p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>2023年终总结</title>
    <url>/2024/02/14/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><img data-src="/images/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93.png" title="时间分布情况"></p>
<p>电影今年看了20部左右，总体来说后劲儿最大的是《迷雾》，结局超级震撼，我觉得它讲了两个东西：一个是社会实验一个是个人心理，改变一个群体的确是一个很难的事儿，具备“说服别人”能力的人每个月是应该多拿点钱，这也就是为啥管理者总是上层，总之《迷雾》它可以排到今年的no.1。第二档里《特工》、《百元之恋》跟《奥本海默》要高一档，比《首尔之春》和《被解救的姜戈》高一丢丢。最烂的是雷佳音的那俩，一个《第二十条》，我还是花钱去春节档影院看的，结果拍了一个四不象。另一个《交换人生》更是扯淡，剧情太tmd弱智了。</p>
<p>今年看电影还有一个最大的感悟：张艺谋和刘德华的电影，以后若是花钱支持就要三思了，踩雷的几率很大。</p>
<p>今年游戏玩的依旧不是很多，现在这种给游戏打分、给影视剧打分、给综艺打分的网站越来越多，让人可以去参考避雷。于是我也基本按照这些网站的推荐玩了几个游戏，今年碰的最佳游戏就是《荒野大镖客2》，那段时间玩的很疯，看了一下steam，一共玩了130+小时。话说我现在估计是老了，对新游戏有点玩不进去。比如足球篮球街霸互殴这种游戏，不需要什么故事背景人物关系，开机就是人机大战。但是rpg这种扮演型的游戏，我要投入到剧情里里的时间发现耗时越来越久。《荒野大镖客2》我也是到了10个小时之后才慢慢明白这个游戏的玩法。</p>
<p>“大表哥2”我就不多说了，之前已经专门写过一篇文章感慨了，无论是剧情还是游戏体验都称得上是“神作中的神作”。不过与之相比的，《gta6》我玩了两次都没玩进去。《埃尔登法环》我也没玩进去，安装卸载了两次，估计是我手笨，跟着攻略跳都跳不明白，明明人家一跳就过去，我就摔死或者被火烧死。打算2024年找个好心情再来挑战一次。</p>
<p>《审判之逝 湮灭的记忆》总体来说还可以，量大管饱。而且里面的推理逻辑总体来说还是比较合理的，尤其是最后法庭上对电话录音的那段辩论是很精彩的，倒是那个学校各种社团的任务让我兴致寥寥。整个打戏手感也不错，sega、capcom、koei这三个公司的打击感都没个说。相反打击感比较拉的就是《刺客信条3》，整个的操作起来很费劲，康纳嗑药变老虎变老鹰的DLC我玩了一半没玩下去。</p>
<p>其实整体来说今年游戏上的时间投入的也不少，我今年一次团建的机会学会了打《三国杀》，于是手机上下载了一个单机版的《三国杀》，应该玩了有100盘了，没事就来一把，最爱用的就是郭嘉。<br><img data-src="/images/%E4%B8%89%E5%9B%BD%E6%9D%80.jpg" title="这个游戏的ai太睿智，经常7个人盯着你干"></p>
<p>电视剧今年看的不算多，不过看的几个都还挺经典。《奇巧计程车》主打碎片化的拼图故事，《相扑避难所》是传统的浪子回头+传统体育的路线，而且通过这个片我get到了忽那汐里的短发颜。《漫长的季节》和《重启人生》是今年的两个大爆款。《VIVANT》今年卡司很强大，但是故事我没怎么看进去。《沉默的舰队》也是今年日剧小年里一个消磨时间的选择，这俩总体来说不如上面那俩。<br><img data-src="/images/%E5%BF%BD%E9%82%A3%E6%B1%90%E9%87%8C.webp" title="短发比长发好看多了！"></p>
<p>这里多说说《真探 第一季》，这个片有奥斯卡影帝马修-麦康纳的加持，整部剧既有动作戏也讨论宗教和人的关系，让台词也比较高大上，最重要的是这部片里很多妙龄女郎大尺度的演出，让人也血脉喷张，暗暗嫉妒男二号伍迪-哈迪森艳福不浅。其实伍迪哈迪森这个角色就像我们普通人：在单位争取一个好人缘，办事能力也算不错但是算不上业务超级精英级别，然后也想“家里红旗不倒，外面彩旗飘飘”，自我开脱是因为“压力太大”导致。除此之外也有基本的良知和正义感。而主人公马修-麦康纳则是一个有故事的人，种种经历让他有独特的悲观诗人气质进而吸引观众，果然，帅气又忧郁的男人看起来就让观众觉得很苦。</p>
<p><img data-src="/images/%E7%9C%9F%E6%8E%A2%E7%AC%AC%E4%B8%80%E5%AD%A31.JPG"></p>
<p>话说我以前追着看NBA的时候，还不脸盲，那么多黑人哥哥都能叫上来名号，但是看美剧里的黑人我却有点脸盲了，要是没啥特征，我真的容易懵逼。</p>
<p>《三体》无论是电视剧还是书都没看过，我今年的flag就是要搞定它！《进击的巨人》也打算彻底看完。</p>
<p>综艺今年的确没什么爆款，所以还是比较老的选择。话说现在b站上看最新全时长的《月曜日夜未央》也挺费劲了，但是天津和成都那两集非常的经典，笑喷了，但是想想《月曜》还是主要采访各种不安套路出牌的人，除了北京上海天津成都重庆，其他地方的确对节目来说吸引力一般。《女女怒夜》也挺不错，get到了田中美奈实这种卡通萌感的绿茶bitch的特色。不过这个片资源更少，后来这个节目也改版了，更找不到完整又连续的资源了。</p>
<p>读书方面，今年最大的收获就是读了冯友兰先生的《中国哲学简史》，虽然冯友兰先生个人历史经历比较复杂，但是这本书写的还是挺好的。让我彻底对春秋战国的几个思想家又了更深的认识，尤其是荀子，《解蔽篇》简直牛逼开花了，话说一个《简史》都这么棒，那《全史》简直就是艺术品啊！《极权政治下的臣民心理》这本有点虎头蛇尾，后来查了一下原来这个作者写了一半突发疾病去世了，怪不得后面沦落成了一个讲历史故事的读物，跟开头的几个不错的论点成云泥之别。《现代西方思想讲义》这个算是一本对西方哲学的入门科普读物，对我还是挺友好的，毕竟我对西方哲学其实了解并不算多。</p>
<p>其实读书跟播客放一起说比较好，毕竟有时候上班或者打三国杀的时候，也想顺便耳朵听点东西。现在还在更新的教授好像也就剩秦晖老师和几个台湾的教授了，其他大陆的教授都不出新的讲座了，在b站也只能翻出来老的讲座止渴。鲍鹏山教授今年的讲座听的相对比较多，《水浒》系列、《商君书》系列都挺赞的。</p>
<p>可以说我这一年的休闲时间主要就用在以上这些地方了，剩余一些就是看看球，看看公众号或者其他新闻和文章。有段时间看微信短视频比较多，后来觉得浪费时间，就干脆把那个功能从微信页面上去掉了。宁可拿这个时间去打三国杀踢FC24，话说现在短视频上虚假信息太多了，除此之外很多政府报纸一天就转网络热点视频，花花草草猫猫狗狗孩子打呼放屁这种东西，完全不做媒体监督的责任。</p>
<p>新一年基本我的任务就是全面接管大促队长的工作了，个人感觉我越来越像一个PMO，要管理和监督进度，了解并解除风险，配合上下游。所以技术相关的文档会越来越少，操心的碎事也越来越多。对事情们拆解和和大促成员们的管理会是我今年的一个大挑战，同时还要了解一下ITIL4 Foundation，看看有没有空考个证书。</p>
<p>第二个工作任务就是继续管理预算和营收，还有工时人效的工作，也要对数据分析有所学习，总之这两个活都是对我个人工作领域的一个丰富。不知不觉我都36岁了，还是要抓机会多学一点东西，深是学不了了，毕竟一年的代码也没写几行，未来也会越写越少。那就宽一点的拓展，越学越宽。</p>
<p>今年春节也是我爹妈和我奶第一次来杭州过年，我春节也是陪他们在嘉兴和无锡溜达溜达，人多就觉得自己的89平小房子很拥挤，看看明年有没有好的机会，趁房价低就置换一下，再不给自己很大的经济压力的前提下，提升到110平左右，同时也多攒一点钱，毕竟我不觉得我40岁之后还有那么大的拼劲挣钱了。<br><img data-src="/images/%E6%9A%B4%E5%AF%8C.jpg" title="暴富是一个美好的愿望，还是要记得不要再没用的地方上吃苦，吃战略的苦不要吃战术的苦"></p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
        <tag>读书</tag>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title>2019年的个人读书总结</title>
    <url>/2020/02/03/2019%E5%B9%B4%E7%9A%84%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>整个2019年过去了，2020年全世界也不算开了一个很好的头。于是这个年度回顾了也跟着来的晚了点。本文里就不扯那些事业上的进步blablabla的，重点说说我这一年读的书。<br><img data-src="/images/2019book.jpg" alt="akb48"></p>
<p>我不去在文艺作品里批评作者的三观，因为所有脱离当时时代背景就说三观不正的行为都是耍流氓。</p>
<h2 id="基督山伯爵"><a href="#基督山伯爵" class="headerlink" title="基督山伯爵"></a>基督山伯爵</h2><p>说实话，这本书我是当爽文看的，里面对人物的描写走的是“三突出，高大全”的路线—-好人一颦一笑都好的洋溢，坏人无论做什么都是坏，而且特别的磕碜。</p>
<p>我本身就读外国书不多，一大主要原因是外国人名太长，看了后面忘了前面，要是都是“汤姆”、“约翰”、“史蒂芬”这样的还好。偏偏这本法国书里很多人的姓都是四五个字的，幸好整套书看下来设计的人物不算多，人与人的关系还算捋得清。尤其是艾德蒙-唐代斯，念出来的时候还挺有气势。</p>
<p>读过这本书的人太多了，我也不多做什么分析，各种大神都已经分析烂了，甚至不少大作家也有借鉴它的结构，比如金庸先生的《连城诀》。《基督山伯爵》就是一部剧情跌宕起伏的文学小说而已，现实意义哲学道理神马的的确没有那么多，它给人带来的就是阅读快感。里面很多的情话读起来肉麻的刚好，有一些人物的内心揣摩也很真实，比如检察官维尔福宽恕自己的想法：“如果发现世人都有罪，自己身上的负罪感就会减轻”。不过说来说去，我倒是觉得检察官全家死光的安排有点狠，而唐会计最后被宽恕了到有点轻。除此之外，我也想表达的是“复仇与创业一样，要保持热情和初心是挺难的”。</p>
<p>“等待与希望”，的确是对人来说很重要的两个事儿，厉害的人好像比普通的人就是多了那么一点点的耐心。</p>
<h2 id="主角"><a href="#主角" class="headerlink" title="主角"></a>主角</h2><p>《主角》这本书是我看《圆桌派》的时候，王蒙老先生提到的，于是就买了一本，《主角》是一本比较新的书，第一版是2018年1月。不过这部“茅盾文学奖”得主貌似并不受豆瓣青年的喜爱，我看了一下目前的得分是6.7分。在短评里很多人打出了三星以下的得分，我想主要原因就是作者把主人公忆秦娥写的太憋屈了，于是剧情党很是不满。</p>
<p>忆秦娥这个角色，让作者写的有点“小龙女+罗德曼”的味道，说她小龙女呢，是因为她长相美丽又不食人间烟火；说她罗德曼呢，是因为她跟罗德曼一样，靠磨炼技术去逃避自己对现实的不满。所以我想当作者安排她把处女之身给了刘红兵的时候，应该心里是比较波折的。其实开始我心里也是反对这门亲事，因为刘红兵虽然爹比较硬、家庭比较好、嘴巴会说，但是毕竟是一个毫无事业的人，而且性格也过于社会。但是作者这么安排我想也有他的良苦用心，第二部中期作者开始逐渐对刘红兵有了一些正面的描述，比如说他做了一手好面、人高马大、英俊帅气（就是后来被忆秦娥打掉一个门牙），合着除了业务能力不咋地之外，这人就没啥缺点了。他追忆秦娥追了一年多，用物质砸，用手段哄，拿出了“烈女怕缠男、打死不退”的劲儿。作者也锲而不舍的描述他有多么的体贴入微：忆秦娥在中南海因为表演吹火而下场吐了一地，刘红兵二话不说直接脱了外套，用衣服把呕吐物包起来又把地面收拾了。这个细节的确把我打动了，换成我，我估计我就做不出来。</p>
<p>整本书看完，忆秦娥除去了主角光环，她的人生和爱情悲剧成分居多，这跟她自己的成长经历有很大的关系，书里的安排也是符合现实的。她前半段人生欲扬先抑，靠着一股痴劲儿遇到了不少好伯乐来提升她的技术。但是她毕竟不喜读书，遇事自己没主意，更多的时候只会“手背捂着嘴”，自己本来就傻，还不喜欢别人说她傻。早期米兰给她一本字典，后来秦八娃也让她去买书看，但是她更想睡觉。再加上性格自卑孤僻圈子小，封潇潇一出局，周围除了一个死缠烂打的刘红兵也就没有几个适龄男子了。不选他选谁？</p>
<p>不过说实话啊，烈女与缠男的戏码，古往今来、艺术现实，基本都没有好结局，因为毕竟“强扭的瓜不甜”。缠男多半是图烈女的貌馋她的身子，他就是坚持100年也是为了多滚几次床单而不是特别图她的性格。一旦要了女子的身子，新鲜劲儿又过了，缠男自然就受不了烈女的脾气。忆秦娥是一个性冷淡，刘红兵出轨是再正常不过的安排。</p>
<p>诚然，同样是西北文学。《主角》的光辉跟《白鹿原》是没法比的。虽然故事基本都是发生在一个小圈子，也有男女之间的破鞋烂事儿。但是《白鹿原》的故事背景太大了，而且达到了从小孔窥大局的高度。而《主角》重心更多是描写京剧这门艺术、新老剧的冲突和封闭的剧团内部争风吃醋的现象。</p>
<h2 id="长夜难明"><a href="#长夜难明" class="headerlink" title="长夜难明"></a>长夜难明</h2><p>这本书我好像一下午就读完了，它不算是一本推理小说，更多的是一部反腐小说，作者也下了一番功夫在故事的曲折性和现实的映射中找平衡。从故事情节来看，很棒，很悲壮，把正义与腐败的斗争写的很真实，尤其是江阳按下按钮后将设备从公寓窗口抛出闭眼等死那一段，可以说是写的非常有画面感，让人不禁激动落泪。有时候我也在反思：人们茶余饭后吹的那些正邪斗争的牛逼，真实情况里付出的代价太沉重了。</p>
<p>当全世界都在阻挠你做一个正确的事情，还能有几个人坚持下去呢？</p>
<p>如果要说缺点，就是有些文笔比较粗糙和纸面化，感觉像是长篇纪实文学了。但是对司法体系和刑事程序的描写很真实。后来我也看了作者紫金陈的《谋杀官员》系列，个人最喜欢的是第一部徐策的故事。</p>
<p>中国14亿人口，每天出现的故事上千万。如果将来真的有一天取消了审查制度，我相信会有很多优秀感人的文艺作品问世的。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>至于其他的一些书，比如《论人类不平等的起源与基础》，《思考，快与慢》，《彷徨》，《逆境无赖—开司麻将篇》（漫画也算进来了…）这些书的感受不太容易马上写出来,这次就先不写了。最后我要补充一句，都说鲁迅杂文写的牛逼，但是他写景也是一绝。</p>
<p><img data-src="/images/%E7%A7%91%E6%AF%94%E5%BC%BA%E7%A1%AC%E9%98%B2%E5%AE%88%E5%AE%89%E4%B8%9C%E5%B0%BC2.gif" alt="akb48" title="曼巴一路走好吧！"></p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>Ansible-Playbook判断进程是否存在</title>
    <url>/2019/06/27/Ansible-Playbook%E5%88%A4%E6%96%AD%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8/</url>
    <content><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>部署有一个需求，要将所有的模块服务器里添加一个叫agentmizar的日志采集模块。但是有一些服务器提前有部署过，那么判断一下如果服务器里有此进程就跳过，如果没有此进程就传包并修改配置文件然后启动。</p>
<p>与playbook搭配的yaml内容如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">- hosts: <span class="built_in">all</span>		<span class="comment">#默认执行hosts里的所有IP</span></span><br><span class="line">  remote_user: root</span><br><span class="line">  any_errors_fatal: no</span><br><span class="line">  gather_facts: no		<span class="comment">#不采集对方机器的数据，提高执行速度</span></span><br><span class="line">  serial:</span><br><span class="line">  - <span class="number">5</span>		<span class="comment">#5台机器一组</span></span><br><span class="line">  tasks:</span><br><span class="line">  - name: judge agent process <span class="keyword">is</span> exits</span><br><span class="line">    shell: ps -aux | grep agent</span><br><span class="line">    ignore_errors: <span class="literal">True</span>		<span class="comment">#如果命令执行不成功，即 echo $?不为0，则在其语句后面的ansible语句不会被执行，导致整个程序中止。</span></span><br><span class="line">    register: result</span><br><span class="line"></span><br><span class="line">  - name: agent <span class="keyword">is</span> running</span><br><span class="line">    shell: echo <span class="string">&quot;agent is running&quot;</span></span><br><span class="line">    when: result.stdout.find(<span class="string">&#x27;agent.conf&#x27;</span>) != -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">  - name: agent <span class="built_in">dir</span> <span class="keyword">is</span> exits</span><br><span class="line">    shell: ls /opt/agentmizar</span><br><span class="line">	ignore_errors: <span class="literal">True</span></span><br><span class="line"> 		register: dirresult</span><br><span class="line"></span><br><span class="line">  - name: copy packages</span><br><span class="line">    copy:</span><br><span class="line">      src: /tmp/agentmizar.<span class="built_in">zip</span></span><br><span class="line">      dest: /opt</span><br><span class="line">      owner: root</span><br><span class="line">    when: dirresult <span class="keyword">is</span> failed		<span class="comment">#如果文件夹存在就是dirresult is succeeded</span></span><br><span class="line"> </span><br><span class="line">  - name: unzip agentmizar</span><br><span class="line">    unarchive:				<span class="comment">#如果你并不喜欢用unzip的话，那么可以shell:unzip -o 对应.zip的方式来达到不用输入y的效果，但是更推荐用unarchive</span></span><br><span class="line">      <span class="comment">#extra_opts: -j		#将zip里的所有递归文件都放到本目录</span></span><br><span class="line">      src: /opt/agentmizar.<span class="built_in">zip</span></span><br><span class="line">      dest: /opt  </span><br><span class="line">      remote_src: yes </span><br><span class="line">    when: result.stdout.find(<span class="string">&#x27;agent.conf&#x27;</span>) == -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">  - name: backup old <span class="keyword">and</span> unpack new package</span><br><span class="line">    shell: cp -rf /opt/build/* /opt/	<span class="comment">#由于zip包也解压缩出来是一个build文件夹，需要再扒一层</span></span><br><span class="line">    when: result.stdout.find(<span class="string">&#x27;agent.conf&#x27;</span>) == -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">  - name: update agent.conf</span><br><span class="line">    lineinfile:</span><br><span class="line">      dest: /opt/agentmizar/agent.conf</span><br><span class="line">      regexp: <span class="string">&quot;kafka = 192.168.0.1:9092,192.168.0.2:9092,192.168.0.3:9092&quot;</span>		<span class="comment">#修改配置文件</span></span><br><span class="line">      line: <span class="string">&quot;kafka = 172.0.10.1:9092&quot;</span></span><br><span class="line">    when: result.stdout.find(<span class="string">&#x27;agent.conf&#x27;</span>) == -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">  - name: start agentmizar</span><br><span class="line">    shell: cd /opt/agentmizar/ &amp;&amp; /<span class="built_in">bin</span>/bash /opt/agentmizar/start_agent.sh</span><br><span class="line">    when: result.stdout.find(<span class="string">&#x27;agent.conf&#x27;</span>) == -<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>这个yaml，我执行<code>ps -aux | grep agent</code>，并将结果存储到<code>result</code>这个<code>register</code>里。然后从<code>register</code>里去find关键字<code>agent.conf</code>，如果不存在就返回-1，那么可以判断当前机器里没有agentmizar进程。</p>
<p>如果说进程是一个守护进程，那么在判断进程（比如是systemctl status apache2）是否存在可以这么写：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">- name: Check <span class="keyword">if</span> Apache <span class="keyword">is</span> running</span><br><span class="line">  command: systemctl status apache2</span><br><span class="line">  ignore_errors: yes</span><br><span class="line">  changed_when: false</span><br><span class="line">  register: service_apache_status</span><br><span class="line"></span><br><span class="line">- name: Report status of Apache</span><br><span class="line">  fail:</span><br><span class="line">    msg: |</span><br><span class="line">      Service apache2 <span class="keyword">is</span> <span class="keyword">not</span> running.</span><br><span class="line">      Output of `systemctl status apache2`:</span><br><span class="line">      &#123;&#123; service_apache_status.stdout &#125;&#125;</span><br><span class="line">      &#123;&#123; service_apache_status.stderr &#125;&#125;</span><br><span class="line">  when: service_apache_status | failed</span><br></pre></td></tr></table></figure></p>
<p>注意！如果when条件判断句中有变量的话要将用（）来括变量，如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">when: ansible_default_ipv4.address == &#123;&#123; ETCD_NODE03 &#125;&#125;		<span class="comment">#错误写法</span></span><br><span class="line">when: ansible_default_ipv4.address == (ETCD_NODE03)			<span class="comment">#正确写法</span></span><br></pre></td></tr></table></figure></p>
<p>再注意！<code>register</code>变量的命名不能用-（中横线），比如<code>dev-sda6_result</code>，则会被解析成<code>sda6_result</code>，dev会被丢掉！</p>
<h2 id="yum一次性安装多个模块的问题"><a href="#yum一次性安装多个模块的问题" class="headerlink" title="yum一次性安装多个模块的问题"></a>yum一次性安装多个模块的问题</h2><p>新版本的ansible-playbook已经不支持在yum安装多个模块里使用的方式了，也就是说<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tasks</span><br><span class="line">- name: 安装最新版本的命令</span><br><span class="line">yum: name=&#123;&#123; item &#125;&#125; state=latest</span><br><span class="line">with_items:</span><br><span class="line">   - unzip</span><br><span class="line">   - psmisc</span><br><span class="line">   - java-<span class="number">1.8</span><span class="number">.0</span>-openjdk*</span><br></pre></td></tr></table></figure></p>
<p>这么写在老版本还OK，但是在2.8以后，还这么写就会有错误：<code>[DEPRECATION WARNING]: Invoking &quot;yum&quot; only once while using a loop via squash_actions is deprecated. Instead of using a loop to supply multiple items and specifying name: &quot;&#123;&#123; item &#125;&#125;&quot;, please  use name: [&#39;unzip&#39;, &#39;psmisc&#39;, &#39;java-1.8.0-openjdk*&#39;] and remove the loop. This feature will be removed in version 2.11. Deprecation warnings can be disabled by setting deprecation_warnings=False in ansible.cfg</code>.要改成如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tasks:           </span><br><span class="line">- name: 安装最新版本的命令</span><br><span class="line">yum:           </span><br><span class="line">  state: latest</span><br><span class="line">  name:        </span><br><span class="line">    - unzip </span><br><span class="line">    - psmisc</span><br><span class="line">    - java-<span class="number">1.8</span><span class="number">.0</span>-openjdk*</span><br></pre></td></tr></table></figure></p>
<h2 id="如何在task之间传递变量"><a href="#如何在task之间传递变量" class="headerlink" title="如何在task之间传递变量"></a>如何在task之间传递变量</h2><p>某个变量想从一个task给另一个，可以按照如下的方式写：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: <span class="built_in">all</span></span><br><span class="line">  gather_facts: no</span><br><span class="line">  tasks:</span><br><span class="line">    - name: register <span class="built_in">vars</span></span><br><span class="line">      shell: hostname</span><br><span class="line">      register: info</span><br><span class="line"></span><br><span class="line">    - name: display <span class="built_in">vars</span></span><br><span class="line">      debug: msg=<span class="string">&quot;&#123;&#123;info.stdout&#125;&#125;&quot;</span></span><br></pre></td></tr></table></figure><br>第一个shell执行完后，使用register获取数据到info里，info是一个key value字典，debug输出info.stdout的具体内容。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.ibm.com/developerworks/cn/linux/1608_lih_ansible/index.html">https://www.ibm.com/developerworks/cn/linux/1608_lih_ansible/index.html</a><br><a href="https://blog.51cto.com/liuzhengwei521/1962382">https://blog.51cto.com/liuzhengwei521/1962382</a>	（条件判断）<br><img data-src="/images/DH12-1.gif" alt="akb48" title="2009年东部半决赛魔术VS骑士"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>ansible</tag>
        <tag>批量部署</tag>
      </tags>
  </entry>
  <entry>
    <title>2024年终总结</title>
    <url>/2025/02/06/2024%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><img data-src="/images/2024%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93.png" title="时间分布情况"></p>
<h2 id="电影-电视剧-读书"><a href="#电影-电视剧-读书" class="headerlink" title="电影&amp;电视剧&amp;读书"></a>电影&amp;电视剧&amp;读书</h2><p>今年电影没少看，但是看的基本都是老片，《哪吒2》我去看了一下，只能说它是春节里面拔大个的产物，占尽了天时地利人和。在我的评价里，《哪吒》根本没啥可吹的，内核跟什么《千与千寻》、《红辣椒》简直没法比，感觉就是讲了一个伊利丹的故事，而且“你要是碰我家人，我杀你全家”这种初级黑社会打手级别的台词，让人感觉很肤浅，对于我这种快四十的人来说，“我命由我不由天”这样的鸡血台词早就免疫了。</p>
<p>这几个片里，我觉得很棒的有：《达拉斯买家俱乐部》、《无耻混蛋》、《暗花》、《怪物》。排名有先后，这几个无论是故事性还是镜头感都超级好的作品。尤其是《无耻混蛋》，虽然是抗德奇侠片，但是台词的讲究、镜头的运用、音乐的搭配，不得不说，只要故事讲得好，架空同人的剧本也一样受欢迎。《达拉斯卖家俱乐部》就不用说了，太经典的片子，两个男演员的演技把整部剧撑起来了。</p>
<p>第二梯队的是《摩加迪沙》、《卧虎藏龙》、《好东西》、《柔道龙虎榜》、《周处除三害》、《死侍与金刚狼》、《最后的里程》、《城市猎人》、《许三观》、《抓娃娃》。排名有先后，这里面《抓娃娃》是陪我爸妈春节一起看的合家欢，搞笑是挺搞笑的。但是说实话这种夸张的“中国式没苦硬吃的教育”也让我蛮震撼，尤其是马继业最后在“秘密基地”里对沈腾马丽他俩的那句“你俩是哪位老师，墙上没有你俩”。我觉得这句话，任何家长听到了都会崩溃。</p>
<p>《卧虎藏龙》这玩意说实话，我第一次看完后除了章子怡的凸点之外没啥特别印象了，完全不懂为啥它能拿那么多奖。后来看了几个B站的讲解，朦朦胧胧的懂了一点，但是还是没有特别深的感触，可能就是中西方文化的不同。打算2025年抽空把《一代宗师》看了，让我更加有体感一些。</p>
<p>《好东西》今年是一个爆款，我觉得它要是在春节档出来，票房也不会差。我觉得它这个电影里主要讲述的就是“不要在乎啥也不懂的人的看法，他们只会起哄，看法就是狗屁，自己怎么舒服怎么来才是对的”以及这个世界在某些事情上对女性的不公正。当然，其实这种不公正的偏见也很大一部分来自女性自己。“girls help girls”这话听听就得了。</p>
<p>至于今年读书，主要就是两本，一本《许三观卖血记》，这个是在冬天肺炎打点滴的时候，趁机会读完。整本书感觉还是蛮震撼的，余华说这本书主要讲究的是一个“公平”，我倒没觉得，我觉得讲的就是普通的没本事的中国人是怎么以最低贱的方式来面对生活中的苦难的，没权的普通人要活下来真的好难。另一本就是《金阁寺》，尤海燕先生翻译的，这个书简直就是犯罪心理文学，读起来让我感觉很舒服很孤独。而且我有段时间上班也是处于一种很压抑的心理状态里，也有一种把一切付之一炬的潜在想法。只不过《金阁寺》表达出来的更黑暗更深邃，给我留下最深印象的其实是军官在跟他的恋人分别时，恋人挤出自己的乳汁给军官喝。</p>
<p>电视剧的话，我今年上半年几乎一口气把传说中的神剧《绝命毒师》给看完了，果然很爽，不愧是第一美剧，看完后我深深的觉得辛爽应该看了这部剧不下20次。而我最近在啃《风骚律师》，进度没有《绝命毒师》那么快。</p>
<h2 id="综艺-游戏-博客"><a href="#综艺-游戏-博客" class="headerlink" title="综艺&amp;游戏&amp;博客"></a>综艺&amp;游戏&amp;博客</h2><p>今年没啥好综艺，整个大陆的综艺都在走下坡路。在朋友推荐下看了几集腾讯的《单排喜剧大赛》，没有几个特别有印象的段子，感觉就是把短视频的内容拿到了舞台上。到了淘汰赛，参赛者所有的节目质量有所下降，逐渐成了参赛者自嗨的节目了。</p>
<p>至于游戏，我这几年一直都是电子阳痿。啥游戏都没啥动力玩的很投入，带玩不玩的搞了一下《三国无双 起源》，这个游戏画面不错，招式绚烂，操作的手感还可以，格挡反馈也很爽。跟以往的《三国无双》不同，它其实完全可以独立坐成一个动作类游戏了，不必非要依赖三国这个背景。除此之外，我一直有蹲《对马岛之鬼》，等降价到200以内就考虑入了。</p>
<p>闲暇之余听的博客其实还是关注文学闲谈、讲座、哲学、足球相关的，基本那几个up主有更新就会抽空听一听。</p>
<h2 id="说说网络主播"><a href="#说说网络主播" class="headerlink" title="说说网络主播"></a>说说网络主播</h2><p>我在元旦的时候，无意间接触到了B站的主播。然后也看了几个女主播，也给其中几个女主播刷了礼物上了舰，不过我这个人三分钟热度，一个月后热情骤减，开始觉得看这种直播很无聊很浪费时间，也觉得这些女主播每天都要播6个小时简直就是“坐牢”。尤其是没啥人气的主播，直播间里常驻的就1～2个人，很多人来了连欢迎词都没念完就出去了。我很理解体操冠军吴柳芳说她自己没成名的时候说“自己那时候没有甚么人气，还不让玩手机，只能干坐着”。</p>
<p>我后来看了一了一些关注主播的文章和统计数据，不露脸只出声的女主播一般也就2～3个月就毕业了。主要是声音主播的能提供的新鲜感其实很少，只能靠不停的上新人来给新人灌入“初始的新鲜感”维持，老人听多了就腻了，自然不会继续真金白银的投入，所以这种声音主播里能活3个月的舰长都很少，更别说遇到多金的大哥了。</p>
<p>去年中国经济情况不好，大量工厂裁员，外加元旦和春节挨的很近，很多女学生和女工都在寒假期间进入了主播这个行业。他们99%也都签了工会，靠粉丝们打赏的流水转正，然后拿每天133元的低保，但是负责他们的运营也心知肚明这里面的女学生当主播就是来玩票的，而不露脸不擦边的主播也注定没啥大金主，所以运营肯定也会把精力用到其他更吸金的女主播里去。所以女主播自己不努力不做内容，无法给到粉丝更新的刺激，的确很难把粉丝留住。</p>
<p>插播一句，“擦边”这个词最近堂而皇之的被人在各种场合提起，可见“软色情”在这个经济下行的时代里，成了不少人的精神寄托。</p>
<p>但是毕竟B站和Uki这两个app上白嫖的粉丝居多，女主播自己也觉得自己活的像一个网络乞丐，要点礼物要做很久的心理建设。所以感觉女主播自己也慢慢转变了心态，粉丝不打赏就不互动，说了甜甜的话肯定就是找大哥要流水，不得不说进入了这个圈子后，放大了欲望，享受到了快钱，人都物质了很多。</p>
<p>最后补一句，uki这个app做的是真烂，语音厅的页面很烂，安装包的大小竟然要200多兆，整的手机超级卡。他们的技术应该看看淘宝才多大，B站才多大，再看看自己的优化能力。然后语音厅的那种pk玩法也是纯纯的圈粉丝钱，惩罚无非就是输的一方来一段数来宝或者是一段含水唱征服，真一点意思没有。</p>
<h2 id="新年的flag"><a href="#新年的flag" class="headerlink" title="新年的flag"></a>新年的flag</h2><p>flag这个东西虽然很俗气，虽然大概率还是完不成，但是出于流程，还是要立一下。</p>
<p>首先就是减肥，这个已经老生常谈十几年了，不过今年减肥的欲望特别旺盛，估计是因为我春节又成功了给一条牛仔裤的裤裆穿破了，实在不能再这么放纵下去了。我现在有了点小心得，目前3周用下了10斤，还要持续，争取夏天的时候能骚起来。</p>
<p>其次，高峰电影打算再看20部，《风骚律师》全集看完后看看《广告狂人》，书呢，打算看至少5本。</p>
<p>然后就是要思考，思考自己想要什么样的生活，然后开启新的生活。</p>
<p>2024我的家人不少都遇到了一点小坎坷，希望2025我周围的人都能平平安安。</p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
        <tag>读书</tag>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title>Ansible部署模块的时候出现中文乱码的问题</title>
    <url>/2018/01/27/Ansible%E9%83%A8%E7%BD%B2%E6%A8%A1%E5%9D%97%E7%9A%84%E6%97%B6%E5%80%99%E5%87%BA%E7%8E%B0%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>今天在部署服务的时候遇到了一个很罕见的现象，线上有15台服务器是手机推送消息的服务，新来的小运维使用ansible批量跑部署脚本的时候，发现手机端接收到来的消息全是乱码，然后登陆到服务器，查看日志发现，日志里面就是乱码，如图：<br><img data-src="/images/luanma1.png"></p>
<p>由于这个问题用户是有感知的，所以属于“事故”级别了，于是小boss大怒，叫运维赶快回滚，然后让开发赶紧重新检查代码，然后开骂测试都是吃屎的么这么大的一个问题都看不出来真是一群猪伤不起啊。</p>
<p>开发看了半天自己的代码，发现没有任何问题，战战兢兢跑来跟新来的小运维窃窃私语，结果我发现这个模块用手动单独部署，日志却是正常的，中文显示十分OK。<br><img data-src="/images/luanma2.png"></p>
<p>这一下开发就腰杆硬了，说这不是我的锅啊我是无辜的啊老子天天辛苦加班没有功劳也有苦劳没有苦劳也有疲劳老子的代码经得住考验这一切就是部署的问题。</p>
<p>于是我就查看了一下ansible的配置文件，<code>vim /etc/ansible/ansible.cfg</code>，发现了问题所在：<br><img data-src="/images/luanma3.png"></p>
<p>这里最后三行需要改成下面的样子，这样就解决了乱码问题。<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#module_lang    = C</span><br><span class="line">#module_set_locale = <span class="title class_">False</span></span><br><span class="line">module_lang    = zh_CN.<span class="property">UTF</span>-<span class="number">8</span></span><br><span class="line">module_set_locale = <span class="title class_">True</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>ansible</tag>
        <tag>自动化部署</tag>
      </tags>
  </entry>
  <entry>
    <title>Ansible的几个基本语句</title>
    <url>/2018/01/17/Ansible%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h2 id="开篇的废话"><a href="#开篇的废话" class="headerlink" title="开篇的废话"></a>开篇的废话</h2><p>批处理工具我最早接触的是pssh，因为它实在很简单粗暴，但是它由于太简单粗暴了，应付十台二十台机器还OK，应付五十台一百台服务器就心有余力不足了（而且xshell右键有一个“发送键入到所有会话”的功能，与pssh效果几乎一样），而且我还不太喜欢puppet，总觉得那玩意跟我八字不合，于是乎，在新头头的推荐下，我把目光放在了Ansible。</p>
<p>Ansible的安装很简单，在Redhat环境下直接<code>yum install -y ansible</code>就行。Redhat已经将Ansible公司收购了，所以在安装上提供了不小的便利。</p>
<p>Ansible在安装完毕之后，会在<code>/etc/ansible/</code>目录下看见一个叫hosts的文件，这里是所有你要控制的服务器的ip们，可以排列写，比如：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.122</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.133</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.144</span></span><br></pre></td></tr></table></figure><br>也可以分组写，比如：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[aliyun]</span><br><span class="line"><span class="number">10.22</span><span class="number">.33</span><span class="number">.44</span></span><br><span class="line"><span class="number">10.22</span><span class="number">.33</span><span class="number">.45</span></span><br><span class="line">[jinshanyun]</span><br><span class="line"><span class="number">121.23</span><span class="number">.45</span><span class="number">.66</span></span><br><span class="line"><span class="number">121.23</span><span class="number">.45</span><span class="number">.67</span></span><br><span class="line"><span class="number">121.23</span><span class="number">.45</span><span class="number">.68</span>:<span class="number">2222</span>  （这个不是使用ssh默认的<span class="number">22</span>端口，就需要特别指出）</span><br></pre></td></tr></table></figure></p>
<p>默认情况下，Ansible会把命令全用于这个hosts文件，比如<br>    ansible all -m ping  -u ashin<br>这句话意思是整个hosts里的机器以ashin账户启动，而且都要ping 一下当前本机。</p>
<h2 id="具体语句"><a href="#具体语句" class="headerlink" title="具体语句"></a>具体语句</h2><p>怎么连接主机与要控制的远程机器请按之前写的“<a href="http://chenx1242.blog.51cto.com/10430133/1763978%E2%80%9D%E4%B8%80%E6%96%87%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C%EF%BC%8C%E8%BF%99%E9%87%8C%E5%85%88%E8%AF%B4%E5%87%A0%E4%B8%AA%E5%91%BD%E4%BB%A4%E8%AF%AD%E5%8F%A5%EF%BC%9A">http://chenx1242.blog.51cto.com/10430133/1763978”一文进行操作，这里先说几个命令语句：</a></p>
<p>1)<code>ansible all -m shell -a &quot;/bin/echo hello&quot;</code><br>对hosts里所有的机器一起使用”输出hello这个文字”。-m shell可以忽略不写，但是不是shell而是其他的模块就要写出来；</p>
<p>2)<code>ansible aliyun -m copy -a &quot;src=~/projects/tests/t.py dest=~&quot;</code><br>把hosts里aliyun组的机器的&#x2F;projects&#x2F;tests&#x2F;t.py复制到~目录下；<br>[注意！]copy模块不支持变量路径，也就是说如果目标服务器的部署路径不同，copy不会很智能的去访问.bash_profile来得到用户的自定义变量，写变量替换路径是不会达到目的的。</p>
<p>3)<code>ansible jinshanyun[0:9] -i -m file -a &quot;dest=~/tests state=absent&quot;</code><br>把hosts里jinshanyun组中从0~9这十台机器的&#x2F;tests文件夹删除掉，absent是“缺席，不在”的意思；</p>
<p>4)<code>ansible 192.168.1.133 -m ping</code><br>这句话&#x3D;<code>ping 192.168.1.133</code>；</p>
<p>5)<code>ansible v1 -m service -a &quot;name=mysql state=started&quot; -u ashin --sudo -K</code><br>以用户名为ashin登陆hosts里所有v1组的机器，然后检查mysql是否是started状态，若不是就start，同时要输入root的密码作为确认；</p>
<p>6)<code>ansible 10.11.22.* -m user -a &quot;name=foo password=foo&quot; --sudo -K</code><br>hosts文件里所有10.11.22开头的机器，都要添加一个新的用户名foo，同时密码是foo，并且输入root密码确认身份；</p>
<p>7)<code>ansible v1:!v2 -m apt -a &quot;name=git state=latest&quot;</code><br>检查所有属于v1组同时还不属于v2组的机器里的git文件是否是最新版本；</p>
<p>8)<code>ansible webservers:&amp;dbservers -a &quot;/sbin/reboot&quot; -f 10 --sudo -K</code><br>重新启动既是webservers组又是dbservers组的所有机器；</p>
<p>9)<code>ansible webservers -m raw -a &#39;yum -y install python-simplejson&#39;</code><br>用ansible去链接低版本的centos时，就乎出现“ansible requires a json module, none found! ”的错误，需要远程机安装samplejson包。raw模块是靠底层ssh的通讯，不依靠python的模块，所以如果碰到低版本的系统，如果command和shell模块无法使用，可以先用这条命令安装完需要的包。</p>
<p>10)<code>ansible all -m synchronize -a &quot;src=/chenshuo/1.sh dest=/chenshuo delete=yes&quot; </code><br>synchronize原意是“同步”，而这个模块是分发模块，这句话的意思是把控制端的&#x2F;chenshuo&#x2F;1.sh分发给host文件里的所有ip服务器，delete&#x3D;yes意思是以控制端服务器的文件为准。</p>
<p>11)<code>ansible 10.168.194.89 -m synchronize -a &quot;mode=pull src=/chenshuo/nba.txt dest=/chenshuo/a.txt&quot;</code><br>将10.168.194.89这台服务器上的&#x2F;chenshuo&#x2F;nba.txt拉到控制服务器的&#x2F;chenshuo文件夹下，顺便改名叫a.txt。</p>
<p>12)<code>ansible all -m get_url -a &quot;url=https://pypi.python.org/packages/56/2b/9c9c113fb88082950067a42cc99e3c61f1df72035f89bb0bdf0a60308ca0/pexpect-4.1.0.tar.gz#md5=562a1a21f2a60b36dfd5d906dbf0943e dest=/chenshuo&quot;</code><br>把那一大串网址的下载连接下载到host文件里的所有ip的&#x2F;chenshuo文件夹下。</p>
<p>13)<code>ansible 10.117.14.37 -m script -a &quot;/chenshuo/free.sh&quot;</code><br>在10.117.14.37上执行操作端的free.sh，注意操作端必须要有free.sh这个脚本，而10.117.14.37这台机器上并不一定要有。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>如果ansible启动的时候爆RequestsDependencyWarning: urllib3 (1.21.1) or chardet (2.2.1) doesn’t match a supported version!的错误，需要pip卸载urllib3和chardet，再pip安装requests即可。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.csdn.net/iloveyin/article/details/46982023">http://blog.csdn.net/iloveyin/article/details/46982023</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Ansible</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ansible-playbook批量更改sudoers文件里的NOPASSWD:ALL</title>
    <url>/2019/08/02/Ansible-playbook%E6%89%B9%E9%87%8F%E6%9B%B4%E6%94%B9sudoers%E6%96%87%E4%BB%B6%E9%87%8C%E7%9A%84NOPASSWD-ALL/</url>
    <content><![CDATA[<p>由于我们有海外业务，于是就要接受GDPR检查，在检查里有一项就是要求不可以在<code>/etc/sudoers</code>文件里配置<code>普通用户  ALL=(root) NOPASSWD:ALL</code>这一项，要根据实际需要缩小范围，于是就要用ansible-playbook去批量修改这个问题。</p>
<h2 id="获取AWS的外网IP"><a href="#获取AWS的外网IP" class="headerlink" title="获取AWS的外网IP"></a>获取AWS的外网IP</h2><p>AWS的EC2控制台跟阿里云不一样，不提供一个类似excel表格来获取当前区域内所有云服务器的资料。于是只能通过API获取，不过好在AWS的python SDK比较简单。</p>
<p>首先先<code>pip install boto3</code>和<code>pip install awscli</code>。然后再命令行执行<code>aws configure</code>，分别输入自己的AK、SK以及其他资料如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">AWS Access Key ID [<span class="literal">None</span>]: 你的AK</span><br><span class="line">AWS Secret Access Key [<span class="literal">None</span>]: 你的SK</span><br><span class="line">Default region name [<span class="literal">None</span>]: 对应区域			详情可见：https://docs.aws.amazon.com/general/latest/gr/rande.html</span><br><span class="line">Default output <span class="built_in">format</span> [<span class="literal">None</span>]: json		<span class="comment">#建议选择json</span></span><br></pre></td></tr></table></figure></p>
<p>然后就会在<code>/root/.aws</code>（普通用户就会在&#x2F;homt&#x2F;用户名&#x2F;）下看到<code>config</code>和<code>credentials</code>，这里面就是你刚刚输入的内容。</p>
<p>获取所有running状态的ec2的内网IP地址的脚本如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> boto3</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    ec2 = boto3.resource(<span class="string">&#x27;ec2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    instances = ec2.instances.<span class="built_in">filter</span>(</span><br><span class="line">        Filters=[&#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;instance-state-name&#x27;</span>, <span class="string">&#x27;Values&#x27;</span>: [<span class="string">&#x27;running&#x27;</span>]&#125;]</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">for</span> instance <span class="keyword">in</span> instances:</span><br><span class="line">        <span class="built_in">print</span>(instance.private_ip_address)		<span class="comment"># 获取内网IP地址</span></span><br><span class="line">		<span class="built_in">print</span>(instance.public_ip_address)		<span class="comment"># 获取公网IP地址</span></span><br><span class="line">		<span class="built_in">print</span>(instance.tags)		<span class="comment">#服务器名称</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p>
<p>简单的一匹。</p>
<h2 id="编写play-book"><a href="#编写play-book" class="headerlink" title="编写play-book"></a>编写play-book</h2><p>获取到了该区域所有的服务器内网IP之后，先在vim状态下使用<code>:g/^172./d</code>，把老网段的服务器(172开头)的IP过滤掉。然后编写playbook，如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">- hosts: <span class="built_in">all</span>        <span class="comment">#默认执行hosts里的所有IP</span></span><br><span class="line">  remote_user: root</span><br><span class="line">  any_errors_fatal: no</span><br><span class="line">  gather_facts: no        <span class="comment">#不采集对方机器的数据，提高执行速度</span></span><br><span class="line">  serial:</span><br><span class="line">  - <span class="number">5</span>     <span class="comment">#5台机器一组</span></span><br><span class="line">  tasks:</span><br><span class="line">  - name: judge NOPASSWD:ALL</span><br><span class="line">    shell: grep <span class="string">&quot;zabbix  ALL=(root) NOPASSWD&quot;</span> /etc/sudoers</span><br><span class="line">    ignore_errors: <span class="literal">True</span> </span><br><span class="line">    register: result</span><br><span class="line">           </span><br><span class="line">  - name: change </span><br><span class="line">    lineinfile: </span><br><span class="line">        dest: /etc/sudoers                                                                     </span><br><span class="line">        state: present        </span><br><span class="line">		regexp: <span class="string">&#x27;^zabbix &#x27;</span></span><br><span class="line">        line: <span class="string">&#x27;zabbix  ALL=(root) NOPASSWD: /usr/bin/python&#x27;</span></span><br><span class="line">    when: result.stdout.find(<span class="string">&quot;NOPASSWD:ALL&quot;</span>) != -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">  - name: <span class="keyword">del</span>                                                                                                                                                                                     </span><br><span class="line">   	lineinfile:              </span><br><span class="line">       	dest: /etc/sudoers   </span><br><span class="line">       	state: absent        </span><br><span class="line">       	regexp: <span class="string">&#x27;NOPASSWD:ALL$&#x27;</span>				<span class="comment"># 将所有NOPASSWD:ALL结尾的字段删除</span></span><br></pre></td></tr></table></figure></p>
<p>这里有一点要注意，如果使用shell去用<code>sed -i</code>写的话，那么面临一个很尬的境地：ansible-playbook对<code>冒号空格</code>的搭配默认会识别成<code>key:value</code>的形式。</p>
<p>比如说，在shell里使用<code>sed -i &#39;s/NOPASSWD:ALL/NOPASSWD: \/usr\/bin\/python/g&#39; /etc/sudoers</code>是OK的，但是在shell就会爆格式错误，然后执意要走shell的话，就会可能掉入嵌套地狱…</p>
<h2 id="如果想要在文件后追加多行"><a href="#如果想要在文件后追加多行" class="headerlink" title="如果想要在文件后追加多行"></a>如果想要在文件后追加多行</h2><p>ansible里的<code>lineinfile</code>模块是常见的修改文件内容的模块，但是如果要在文件末尾追加多行内容，一般人可能会想到使用<code>with_items</code>搭配<code>lineinfile</code>做循环。其实在ansible 2+的版本有一个更加优雅的方法：<code>blockinfile</code>，写法如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tasks:         </span><br><span class="line">- name: addApollo</span><br><span class="line">  blockinfile: |</span><br><span class="line">    dest=/tmp/chenprofile 	<span class="comment">#目标文件</span></span><br><span class="line">    backup=yes</span><br><span class="line">    content=<span class="string">&quot;export public_cloud_config_host=apollo.imou.com                                 </span></span><br><span class="line"><span class="string">        export public_cloud_config_port=28080</span></span><br><span class="line"><span class="string">        export public_cloud_config_group=default         </span></span><br><span class="line"><span class="string">  export public_cloud_config_namespace=imou.commonsource.mysql,imou.commonsource.cs,imou.commonsource.redis,imou.commonsource.mq,imou.commonsource.lb,imou.saascommonconfig,imou.originalcommonconfig,application&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>然后去对应的文件就能看到结果，但是要注意，这里使用等号，而不是冒号，用冒号会报错，可能是ansible的一个小bug。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ol>
<li>如果发现本机已经安装了<code>awscli</code>，但是爆错<code>aws: command not found</code>，检查一下python的<code>virtualenv</code>环境是否正确；</li>
<li>如果目标机器不在默认的<code>inventory</code>文件里被设置，可以通过加逗号的方式被ansible识别，比如<code>ansible all -i 172.16.1.7, -m ping</code>；</li>
<li>如果playbook想指定其他<code>inventory</code>文件，使用-i参数；</li>
</ol>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>ansible</tag>
        <tag>AWS</tag>
      </tags>
  </entry>
  <entry>
    <title>关于阿里云CDN的两个故障解决</title>
    <url>/2017/12/28/CDN%E7%BD%91%E7%AB%99%E4%B8%80%E6%AC%A1%E6%89%93%E4%B8%8D%E5%BC%80%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>测试中心今天在测试时候发现了一个问题：官方的A网站做了域名跳转，跳转到阿里云CDN，但是在浏览器里输入A地址栏的时候，发现域名的确变成了CDN的域名，但是页面是403。</p>
<p>如图：<br><img data-src="/images/cdn403.png" alt="跳转CDN出现403" title="跳转CDN出现403"></p>
<p>但是奇怪的是，再在浏览器点击一下回车，网页就神奇的打开了。</p>
<p>这个原因就是阿里云的CDN有一个“Refer防盗链”，需要在防盗链里面把A域名添加到白名单，这样的话就可以直接访问了。至于为什么第二次回车就可以访问，是因为那时候域名已经成CDN自己的域名了，当然可以访问。<br><img data-src="/images/referer.png" alt="refer防盗链配置" title="在这里添加防盗链的白名单"></p>
<p>但是这个防盗链也要注意！毕竟白&#x2F;黑名单添加都是一个危险举动，一定三思后行。有可能你的css\js是用cdn加速的，一旦加上了白名单，可能css就会变得很难看。</p>
<p>不就之后，商城也下来一个需求，说公司有两个多年不用的域名B和C，打算废物利用，两个都要达到直接“跳转官网”的目的。</p>
<p>于是我就到阿里云域名管理的那里搜索一下，发现目前官网域名后端绑定的是一个CDN，于是也把域名B和域名C做一个CNAME到这个域名，不过登陆浏览器发现域名B和域名C都反馈502。</p>
<p>于是我就到电子商城后端的nginx.conf里查看，确认server_name字段没有写错，然后把域名B和域名C的CNAME直接改成了CDN的域名，再通过了dig确认。但是等于浏览器还是发现502。</p>
<p>最后找了阿里云的人了解，原来阿里云规定“一个CDN只能绑定一个域名，因为节点上没有那两个域名的配置，所以只要不符合节点上有配置文件信息的，全部502”。所以B和C是无法访问的。要解决这个问题有两招，1）把域名B和域名C直接A记录绑定CDN后面的SLB上，但是代价就是访问速度不如CDN快；2）重新购买两个CDN，都绑定SLB，然后把这两个CDN分别绑定到域名B和域名C上，代价是多收一点流量费…</p>
<p><img data-src="/images/messi.jpg" alt="梅西在国家德比进球" title="在伯纳乌进球感觉真好！"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>CDN</tag>
        <tag>网站技术</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 6.x安装php 5.6和redis扩展的全过程</title>
    <url>/2018/01/26/CentOS-6-x%E5%AE%89%E8%A3%85php-5-6%E5%92%8Credis%E6%89%A9%E5%B1%95%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="安装PHP-5-6"><a href="#安装PHP-5-6" class="headerlink" title="安装PHP 5.6"></a>安装PHP 5.6</h2><p>过程如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum update    整体升级一下yum包</span><br><span class="line">yum install -y epel-release</span><br><span class="line">yum list installed | grep php    检查时候安装过<span class="variable constant_">PHP</span></span><br><span class="line">rpm -<span class="title class_">Uvh</span> <span class="attr">http</span>:<span class="comment">//mirror.webtatic.com/yum/el6/latest.rpm </span></span><br><span class="line">yum -y install php56w.<span class="property">x86_64</span></span><br><span class="line">yum -y --enablerepo=webtatic install php56w-devel</span><br><span class="line">yum -y install php56w-xml.<span class="property">x86_64</span> php56w-gd.<span class="property">x86_64</span> php56w-ldap.<span class="property">x86_64</span> php56w-mbstring.<span class="property">x86_64</span> php56w-mcrypt.<span class="property">x86_64</span> php56w-mysql.<span class="property">x86_64</span> php56w-pdo.<span class="property">x86_64</span> php56w-opcache.<span class="property">x86_64</span></span><br><span class="line">yum -y install php56w-fpm</span><br><span class="line">chkconfig php-fpm on    开机自启动</span><br><span class="line">/etc/init.<span class="property">d</span>/php-fpm start    启动进程</span><br><span class="line">php -v    查看是否安装成功</span><br></pre></td></tr></table></figure></p>
<p><img data-src="/images/php1.png"><br>注1：如果想更换到php5.5或5.4版本, 直接把上面的56w换成55w或者54w就可以了；<br>注2：php-opcache和php-xcache会有效的提高php执行速度；</p>
<p>装php的扩展其实不是很麻烦，主要的步骤如下：<br>1）在扩展模块的客户端文件夹里面使用phpize，这样会生成一个configure文件；<br>2）执行configure文件，后面要加上php的路径；<br>3）将“模块.so”文件名添加到php.ini文件里，重启php-fpm进程；<br>4）通过so文件去调用扩展模块的客户端，实现连接对应的模块；</p>
<h2 id="安装redis扩展"><a href="#安装redis扩展" class="headerlink" title="安装redis扩展"></a>安装redis扩展</h2><p>过程如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">redis-cli -v    检查是否安装了redis</span><br><span class="line">redis-server -v</span><br><span class="line">wget <span class="attr">http</span>:<span class="comment">//pecl.php.net/get/redis-2.2.8.tgz </span></span><br><span class="line">tar -zxvf redis-<span class="number">2.2</span><span class="number">.8</span>.<span class="property">tgz</span></span><br><span class="line">cd redis-<span class="number">2.2</span><span class="number">.8</span>    </span><br><span class="line">phpize    一个专门挂接php扩展的工具，该命令一定要使用在php的模块文件夹主目录下，这里报错<span class="title class_">Cannot</span> find config.<span class="property">m4</span>。因为phpize要根据模块生成模块的配置文件放在模块文件夹下面</span><br></pre></td></tr></table></figure></p>
<p><img data-src="/images/php2.png"><br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">./configure --<span class="keyword">with</span>-php-config=<span class="regexp">/usr/</span>bin/php-config</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">make test</span><br><span class="line">vim /etc/php.<span class="property">ini</span>      在php.<span class="property">ini</span>里添加一句“extension=<span class="string">&quot;redis.so&quot;</span>”</span><br><span class="line">service php-fpm restart</span><br></pre></td></tr></table></figure></p>
<p><img data-src="/images/php3.png"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
        <tag>php</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Atlas出了一个很诡异的bug</title>
    <url>/2019/03/26/Atlas%E5%87%BA%E4%BA%86%E4%B8%80%E4%B8%AA%E5%BE%88%E8%AF%A1%E5%BC%82%E7%9A%84bug/</url>
    <content><![CDATA[<p>这几天数据库更换密码，就在原有的atlas文件基础上拷贝出来一个新文件，修改了密码，然后启动进程。但是启动之后，发现虽然端口起来了，但是atlas没有连接数据库成功，如图:<br><img data-src="/images/atlas14.png" alt="akb48"></p>
<p>登录到atlas后台一看，竟然是双down:<br><img data-src="/images/atlas15.png" alt="akb48"></p>
<p>可是在atlas服务器上单独直连阿里云数据库是没任何问题的，而且数据库的监控也没有任何异常。我怀疑是密码含有了atlas不识别的特殊符号，改成了纯数字和字母的组合，重新启动还是不行，这就很尴尬了，明明原来的配置文件可以启动，我就更改了密码和端口，怎么新的进程就不好使？</p>
<p><img data-src="/images/atlas16.png" alt="akb48" title="一边好使，一边不好使"></p>
<p>于是我尝试抓包，使用<code>tcpdump -s 0 -i any -v port 3318 and src host mysql的ip -w test.pcap</code>，结果发现3318的包少的可怜，于是我就改用<code>tcpdump -s 0 -i any -v host mysql的ip -w test2.pcap</code>扩大了范围，然后发现包有这样的字样：<br><img data-src="/images/atlas17.png" alt="akb48"></p>
<p>可见atlas一直以root去请求数据库，但是我这个是阿里云的RDS服务（Mysql 5.6.7)，本身是没有root的，所以就爆“User not exist”。</p>
<p>这就很尴尬了，为什么会突然以root身份请求数据库？莫非这是atlas的BUG？先把问题记录下来，然后慢慢解决…</p>
<p>**PS.**这个BUG后来修复了，需要重新编译安装，新的安装包地址见：<a href="https://github.com/RorschachChan/noroot-atlas">https://github.com/RorschachChan/noroot-atlas</a><br><img data-src="/images/%E5%A6%B9%E5%AD%90.jpg" alt="akb48"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>atlas</tag>
        <tag>读写分离</tag>
      </tags>
  </entry>
  <entry>
    <title>Awk获取最大值、最小值、平均值和求和</title>
    <url>/2019/04/22/Awk%E8%8E%B7%E5%8F%96%E6%9C%80%E5%A4%A7%E5%80%BC%E3%80%81%E6%9C%80%E5%B0%8F%E5%80%BC%E3%80%81%E5%B9%B3%E5%9D%87%E5%80%BC%E5%92%8C%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<h2 id="背景交代"><a href="#背景交代" class="headerlink" title="背景交代"></a>背景交代</h2><p>在zabbix的监控中，很多场合需要监控到日志里的一些数字，比如下面这个日志：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-04-<span class="number">22</span> <span class="number">10</span>:<span class="number">43</span>:<span class="number">53.231</span> [pool-<span class="number">12</span>-thread-<span class="number">2</span>] INFO com.hswx.css.ads.pojo.M3uFile [<span class="number">221</span>]  cloud upload index success, CloudfileName=/4J0463CPAG1FEDD_record/cloud_1/<span class="number">20190422</span>104242898_0_c3237911422543f8a66816d043eabb50.m3udeviceId4J0463CPAG1FEDD cost:<span class="number">7</span></span><br><span class="line"><span class="number">2019</span>-04-<span class="number">22</span> <span class="number">10</span>:<span class="number">43</span>:<span class="number">52.795</span> [pool-<span class="number">9</span>-thread-<span class="number">13</span>] INFO com.hswx.css.ads.pojo.M3uFile [<span class="number">333</span>]  cloud upload record success, CloudFileName=/4G00B65PAG1C125_record/cloud_1/<span class="number">20190422</span>103141454_0_9d3ccc60d3f6429c8b5d79aa3222991f_365b2bc872ed42d59de82f0af9b1016d-<span class="number">68237400_1047356.</span>dav deviceId=4G00B65PAG1C125 cost:<span class="number">12</span></span><br><span class="line"><span class="number">2019</span>-04-<span class="number">22</span> <span class="number">10</span>:<span class="number">43</span>:<span class="number">52.888</span> [pool-<span class="number">9</span>-thread-<span class="number">19</span>] INFO com.hswx.css.ads.pojo.M3uFile [<span class="number">333</span>]  cloud upload record success, CloudFileName=/4G00B65PAG7A8B1_record/cloud_1/<span class="number">20190422</span>104014516_0_76184831e6e0400994cf6baf45952368_fdbe495eee81458a8e55ec0bfdebecd5-<span class="number">8385407_1045239.</span>dav deviceId=4G00B65PAG7A8B1 cost:<span class="number">16</span></span><br><span class="line"><span class="number">2019</span>-04-<span class="number">22</span> <span class="number">10</span>:<span class="number">43</span>:<span class="number">52.939</span> [pool-<span class="number">9</span>-thread-<span class="number">7</span>] INFO com.hswx.css.ads.pojo.M3uFile [<span class="number">333</span>]  cloud upload record success, CloudFileName=/5A00D4EPBZE212D_record/cloud_1/<span class="number">20190422</span>104228493_0_2165fd85c6064b43abf0398bdf9c0916_fd279fa8809f45279ae76577629d27f5-<span class="number">43910516_1058372.</span>dav deviceId=5A00D4EPBZE212D cost:<span class="number">12</span></span><br></pre></td></tr></table></figure></p>
<p>这段日志主要记录m3u录像文件上传到云存储的情况，后面”cost:”那部分就是记录本次上传操作耗时的时间，我们现在要监控这个时间，如果这个时间大于100，我们就认为线路出了问题。</p>
<p>但是这里有一个问题，因为日志量比较大，一秒钟会刷出来很多的值，比如使用<code>tail 日志文件路径|grep &quot;cost:&quot; | cut -d &quot;:&quot; -f 4</code>：<br><img data-src="/images/mrs5.png" alt="akb48"></p>
<p>那么我们就要从这里面取出最大值，这样的场景用awk是最方便的。</p>
<h2 id="具体语句"><a href="#具体语句" class="headerlink" title="具体语句"></a>具体语句</h2><p>求最大值：<code>awk &#39;BEGIN {max = 0} {if ($1+0 &gt; max+0) max=$1} END {print &quot;&quot;, max}&#39;</code><br>求最小值：<code>awk &#39;BEGIN {min = 65536} {if ($1+0 &lt; min+0) min=$1} END {print &quot;Min=&quot;, min}&#39;</code><br>求和：<code>awk &#39;{sum+=$1} END {print &quot;Sum= &quot;, sum}&#39;</code><br>求平均值：<code>awk &#39;{sum+=$1} END {print &quot;Avg= &quot;, sum/NR}&#39;</code></p>
<p>把上面的语句用于本次案例中，效果如下：<br><img data-src="/images/mrs6.png" alt="akb48"></p>
<p>然后就是配置到<code>zabbix-agent.conf</code>里即可。如果要用zabbix用户登录bash，使用命令：<code>su -s /bin/bash zabbix</code>。<br><img data-src="/images/durant3+1.gif" alt="akb48"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
        <tag>Awk</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos6安装git1.9安装过程</title>
    <url>/2018/06/13/Centos6%E5%AE%89%E8%A3%85git1-9%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><p>Centos 6.x用yum安装git的话，默认是<code>1.7.1</code>。它在执行<code>git push</code>的时候会报错:<code>error: The requested URL returned error: 401 Unauthorized while accessing </code>。这种情况升级git可破。</p>
<p>具体的升级方法如下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel		#先准备一下环境</span><br><span class="line">cd /root</span><br><span class="line">wget https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/git-core/git-1.9.0.tar.gz		#下载1.9的包</span><br><span class="line">tar -zvxf git-1.9.0.tar.gz</span><br><span class="line">cd git-1.9.0</span><br><span class="line">make prefix=/usr/local/git all		#安装到/usr/local里</span><br><span class="line">make prefix=/usr/local/git install</span><br><span class="line">ln -s /usr/local/git/bin/* /usr/bin/		#建立软连接</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure></p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>随便列举几个常用命令：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin http://xxxxxxx		#将后面那个网址作为remote的源站</span><br><span class="line">git remote rm origin	#将刚刚建立的那个源站删了 </span><br><span class="line">git pull origin master		#把remote的master分支的内容down到本地</span><br><span class="line">git reset --hard HEAD 	#撤销未提交的文件</span><br><span class="line">git fetch -p 	#更新最新的远程分支，如果远程分支已删除，则删除本地对应标记的远程分支</span><br><span class="line">git branch -a 	#查看所有分支</span><br><span class="line">git checkout -b  feature/test origin/feature/test  #在本地新增对应的远程分支并切换到 新增的分支上</span><br><span class="line">git branch -D feature/test 	#删除本地feature/test分支  这个命令慎用，生产环境后期一般留个4,5个版本的release开头的分支,可以通过此命令删除一些早期版本的分支</span><br><span class="line">git branch checkout feature/test   #通过此命令可以来回切换本地分支，当存在线上代码需要回滚的时候，可以进行次命令切换到之前的release分支</span><br></pre></td></tr></table></figure></p>
<h2 id="配置忽视文件"><a href="#配置忽视文件" class="headerlink" title="配置忽视文件"></a>配置忽视文件</h2><p>每一个项目肯定都会有一些不会变的文件，比如日志等，那么这种“不想要加入版本库”的文件就要做一个忽视，这样每一次push或者pull都回节约一点时间。</p>
<p>要对这种“被忽视”文件进行配置，首先要先在git的文件夹里打开<code>.gitignore</code>，把要忽视的文件或者文件夹路径写进去，<font color=red>注意，这里的根目录是git文件夹而不是传统的根目录。</font>然后<code>git add .gitignore</code>，此时<code>git commit -m &#39;添加忽视文件&#39;</code>和<code>git push</code>给远程gitlab提交一个版本，然后到目标文件夹去，<code>git rm -r --cached 要忽视的文件名</code>，然后<code>git status</code>看一下这个文件是否已经被gitlab上删除了，如果真的删除掉了同时本地文件也没有丢失，就可以再一次的<code>git commit + git push</code>，去gitlab网页检查时候这个文件应该就不会出现在网页里了，以后这个文件也不会参与任何的更改。</p>
<p><img data-src="/images/gakki1.gif" alt="akb48" title="元气满满的刚巴得~~~"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7安装部署Hadoop集群</title>
    <url>/2019/03/07/Centos6%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2Hadoop%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<p>目前大环境感觉不好，哪哪都是裁人的消息，所以这个时候更是要摆正心态、沉淀自己。</p>
<p>今年我个人的小目标是：Hadoop+k8s+python开发，这次就先写Hadoop的部署过程，可能会有一些名词看不懂，等下一篇再说名词解释。</p>
<p>先说环境：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.86</span>	Master	华为云Centos7<span class="number">.5</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.165</span>	Salve	华为云Centos7<span class="number">.5</span></span><br></pre></td></tr></table></figure></p>
<p>为了高可用，还要部署zookeeper来监视节点心跳情况，我这个例子里没有，如果有需要可以单独部署。</p>
<h2 id="所有机器都要操作"><a href="#所有机器都要操作" class="headerlink" title="所有机器都要操作"></a>所有机器都要操作</h2><p><font color=red size=3>本段过程是所有的服务器都要一起操作的！</font></p>
<ol>
<li><p>先<code>yum update -y</code>，在等待的时候，我们就新开一个窗口，<code>wget http://apache.01link.hk/hadoop/common/hadoop-3.1.2/hadoop-3.1.2.tar.gz</code> 下载3.1.2版本的hadoop，下载完毕后，解压缩<code>hadoop-3.1.2.tar.gz</code>到<code>/opt</code>下，然后把hadoop-3.1.2改名叫hadoop。</p>
</li>
<li><p>在<code>yum update -y</code>完成之后，我们还要<code>yum install java-1.8.0-openjdk* -y</code>，安装完毕之后，执行<code>java -version</code>确认已经安装java 1.8成功。</p>
</li>
<li><p>在<code>/etc/hosts</code>文件里添加：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.86</span>	master</span><br><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.165</span>	slave</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件，hadoop所有的配置文件都在<code>/opt/hadoop/etc/hadoop</code>路径下。<br>先修改<code>hadoop-env.sh</code>，添加一句<code>export JAVA_HOME=/usr</code>，因为我们直接用yum安装的，java默认就会安装到<code>/usr/bin/java</code>。所以这里写&#x2F;usr即可，如果是另外方法安装需要写具体的路径而且要修改<code>/etc/profile</code>和<code>source /etc/profile</code>。</p>
</li>
</ol>
<p>在<code>core-site.xml</code>里的<code>configuration</code>里添加如下内容：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;!-- 指定hadoop运行时产生文件的存储目录,可以指定自己熟悉的目录，默认/tmp/hadoop-$&#123;user.name&#125; --&gt;</span><br><span class="line">&lt;<span class="built_in">property</span>&gt;</span><br><span class="line">    &lt;name&gt;hadoop.tmp.<span class="built_in">dir</span>&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;/opt/hadoop/tmp&lt;/value&gt;</span><br><span class="line">&lt;/<span class="built_in">property</span>&gt;</span><br><span class="line">&lt;!-- 指定hadoop使用的文件系统，HDFS的老大NameNode的地址 --&gt;</span><br><span class="line">&lt;<span class="built_in">property</span>&gt;</span><br><span class="line">    &lt;name&gt;fs.default.name&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;hdfs://master:<span class="number">9000</span>&lt;/value&gt;</span><br><span class="line">&lt;/<span class="built_in">property</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>在<code>hdfs-site.xml</code>里的<code>configuration</code>里添加如下内容：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">      &lt;!-- 指定HDFS副本数量，默认<span class="number">3</span> --&gt;</span><br><span class="line">      &lt;<span class="built_in">property</span>&gt;</span><br><span class="line">         &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">         &lt;value&gt;<span class="number">2</span>&lt;/value&gt;</span><br><span class="line">      &lt;/<span class="built_in">property</span>&gt;</span><br><span class="line">      &lt;<span class="built_in">property</span>&gt;</span><br><span class="line">         &lt;name&gt;dfs.name.<span class="built_in">dir</span>&lt;/name&gt;</span><br><span class="line">         &lt;value&gt;/opt/hadoop/dfs/name&lt;/value&gt;</span><br><span class="line">      &lt;/<span class="built_in">property</span>&gt;</span><br><span class="line">      &lt;<span class="built_in">property</span>&gt;</span><br><span class="line">         &lt;name&gt;dfs.data.<span class="built_in">dir</span>&lt;/name&gt;</span><br><span class="line">         &lt;value&gt;/opt/hadoop/dfs/data&lt;/value&gt;</span><br><span class="line">      &lt;/<span class="built_in">property</span>&gt;</span><br><span class="line">      &lt;<span class="built_in">property</span>&gt;</span><br><span class="line">         &lt;name&gt;dfs.permissions&lt;/name&gt;</span><br><span class="line">         &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">      &lt;/<span class="built_in">property</span>&gt;</span><br><span class="line">      &lt;<span class="built_in">property</span>&gt;</span><br><span class="line">         &lt;name&gt;dfs.http.address&lt;/name&gt;</span><br><span class="line">         &lt;value&gt;<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">50070</span>&lt;/value&gt;</span><br><span class="line">&lt;!-- 如果不加这句话，<span class="number">50070</span>端口打不开 --&gt;</span><br><span class="line">      &lt;/<span class="built_in">property</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>在<code>mapred-site.xml</code>里的<code>configuration</code>里添加如下内容：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 指定mapred运行时的框架：yarn，默认local --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapred.job.tracker&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;master:49001&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapred.local.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;/opt/hadoop/var&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure></p>
<p>在<code>yarn-site.xml</code>里的<code>configuration</code>里添加如下内容：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> &lt;<span class="built_in">property</span>&gt;</span><br><span class="line">     &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;master&lt;/value&gt;</span><br><span class="line">&lt;/<span class="built_in">property</span>&gt;</span><br><span class="line">&lt;<span class="built_in">property</span>&gt;</span><br><span class="line">     &lt;description&gt;The address of the applications manager interface <span class="keyword">in</span> the RM.&lt;/description&gt;</span><br><span class="line">     &lt;name&gt;yarn.resourcemanager.address&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;$&#123;yarn.resourcemanager.hostname&#125;:<span class="number">8032</span>&lt;/value&gt;</span><br><span class="line">&lt;/<span class="built_in">property</span>&gt;</span><br><span class="line">&lt;<span class="built_in">property</span>&gt;</span><br><span class="line">     &lt;description&gt;The address of the scheduler interface.&lt;/description&gt;</span><br><span class="line">     &lt;name&gt;yarn.resourcemanager.scheduler.address&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;$&#123;yarn.resourcemanager.hostname&#125;:<span class="number">8030</span>&lt;/value&gt;</span><br><span class="line">&lt;/<span class="built_in">property</span>&gt;</span><br><span class="line">&lt;<span class="built_in">property</span>&gt;</span><br><span class="line">     &lt;description&gt;The http address of the RM web application.&lt;/description&gt;</span><br><span class="line">     &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;$&#123;yarn.resourcemanager.hostname&#125;:<span class="number">8088</span>&lt;/value&gt;</span><br><span class="line">&lt;/<span class="built_in">property</span>&gt;</span><br><span class="line">&lt;<span class="built_in">property</span>&gt;</span><br><span class="line">     &lt;description&gt;The https adddress of the RM web application.&lt;/description&gt;</span><br><span class="line">     &lt;name&gt;yarn.resourcemanager.webapp.https.address&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;$&#123;yarn.resourcemanager.hostname&#125;:<span class="number">8090</span>&lt;/value&gt;</span><br><span class="line">&lt;/<span class="built_in">property</span>&gt;</span><br><span class="line">&lt;<span class="built_in">property</span>&gt;</span><br><span class="line">     &lt;name&gt;yarn.resourcemanager.resource-tracker.address&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;$&#123;yarn.resourcemanager.hostname&#125;:<span class="number">8031</span>&lt;/value&gt;</span><br><span class="line">&lt;/<span class="built_in">property</span>&gt;</span><br><span class="line">&lt;<span class="built_in">property</span>&gt;</span><br><span class="line">     &lt;description&gt;The address of the RM admin interface.&lt;/description&gt;</span><br><span class="line">     &lt;name&gt;yarn.resourcemanager.admin.address&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;$&#123;yarn.resourcemanager.hostname&#125;:<span class="number">8033</span>&lt;/value&gt;</span><br><span class="line">&lt;/<span class="built_in">property</span>&gt;</span><br><span class="line">&lt;<span class="built_in">property</span>&gt;</span><br><span class="line">     &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">&lt;/<span class="built_in">property</span>&gt;</span><br><span class="line">&lt;<span class="built_in">property</span>&gt;</span><br><span class="line">     &lt;name&gt;yarn.scheduler.maximum-allocation-mb&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;<span class="number">1024</span>&lt;/value&gt;</span><br><span class="line">     &lt;discription&gt;每个节点可用内存,单位MB,默认8182MB&lt;/discription&gt;</span><br><span class="line">&lt;/<span class="built_in">property</span>&gt;</span><br><span class="line">&lt;<span class="built_in">property</span>&gt;</span><br><span class="line">     &lt;name&gt;yarn.nodemanager.vmem-pmem-ratio&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;<span class="number">2.1</span>&lt;/value&gt;</span><br><span class="line">&lt;/<span class="built_in">property</span>&gt;</span><br><span class="line">&lt;<span class="built_in">property</span>&gt;</span><br><span class="line">     &lt;name&gt;yarn.nodemanager.resource.memory-mb&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;<span class="number">1024</span>&lt;/value&gt;</span><br><span class="line">&lt;/<span class="built_in">property</span>&gt;</span><br></pre></td></tr></table></figure></p>
<ol start="5">
<li>把workers这个文件里的localhost替换成slave，2.X版本hadoop里的workers文件叫slaves。</li>
</ol>
<p>至此，所有机器操作的部分完毕，要确认两边的内容必须保持一致，不然启动的时候就会出现优先级出错的故障。</p>
<h2 id="只有Master操作"><a href="#只有Master操作" class="headerlink" title="只有Master操作"></a>只有Master操作</h2><p><font color=red size=3>以下操作只有master操作！</font></p>
<p>由于Master是namenode，slave是datanode，现在就需要对namenode进行一个初始化的操作，即是hdfs的一个初始化。</p>
<p>进入<code>/opt/hadoop/bin</code>里，执行<code>./hadoop namenode -format</code> ，格式化一个新的分布式文件系统，如果不报错那就说明成功。完毕之后，可以去<code>/opt/hadoop/dfs/name</code>这个目录下发现多了一个current文件夹。</p>
<h2 id="配置普通用户免密码登录"><a href="#配置普通用户免密码登录" class="headerlink" title="配置普通用户免密码登录"></a>配置普通用户免密码登录</h2><p>至此整个部署过程就完毕了，如果是root用户就可以直接去<code>/opt/hadoop/hadoop-2.8.0/sbin</code>下执行<code>./start-all.sh</code>了，但是为了安全，我们不要用root用户去启动hadoop，而是用普通用户去启动它。</p>
<p>于是我们先在两台机器上<code>adduser hadoop</code>，这里不设置密码。然后<code>chown -R /opt/hadoop</code>，把整个hadoop文件夹的权限都给hadoop用户。</p>
<p>然后执行<code>ssh-keygen -t rsa</code>，一顿回车之后发现在<code>/home/hadoop/.ssh</code>下有了<code>id_rsa</code>和<code>id_rsa.pub</code>这俩文件。这俩就是root用户的ssh公钥和私钥文件，<code>su hadoop</code>切换到hadoop用户上，同样的操作一遍，获取到hadoop用户的ssh公钥和私钥文件。</p>
<p>master和slave都在<code>/home/hadoop/.ssh</code>下新建一个文件叫<code>authorized_keys</code>，并且互相复制对方的hadoop的<code>id_rsa.pub</code>到自己的<code>authorized_keys</code>里，然后再复制自己的root的<code>id_rsa.pub</code>到自己的<code>authorized_keys</code>里。</p>
<p>修改<code>authorized_keys</code>的权限是600，此时无论是master还是salve的hadoop用户都应该可以无密码登录自己和对方，如图：<br><img data-src="/images/hadoop1.png" alt="akb48" title="在slave也要能互相登录和登录自己"></p>
<h2 id="启动Hadoop"><a href="#启动Hadoop" class="headerlink" title="启动Hadoop"></a>启动Hadoop</h2><p>当前用户是hadoop，在master机器上执行<code>/opt/hadoop/sbin/start-all.sh</code>即启动hadoop，如图：<br><img data-src="/images/hadoop2.png" alt="akb48"></p>
<p>此时在slave机器上会看到有两个进程启动：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hadoop   <span class="number">13552</span>     <span class="number">1</span>  <span class="number">2</span> <span class="number">10</span>:<span class="number">35</span> ?        <span class="number">00</span>:<span class="number">00</span>:03 /usr//<span class="built_in">bin</span>/java -Dproc_datanode -Djava.net.preferIPv4Stack=true -Dhadoop.security.logger=ERROR,RFAS -Dyarn.log.<span class="built_in">dir</span>=/opt/hadoop/logs -Dyarn.log.file=hadoop-hadoop-datanode-slave.log -Dyarn.home.<span class="built_in">dir</span>=/opt/hadoop -Dyarn.root.logger=INFO,console -Djava.library.path=/opt/hadoop/lib/native -Dhadoop.log.<span class="built_in">dir</span>=/opt/hadoop/logs -Dhadoop.log.file=hadoop-hadoop-datanode-slave.log -Dhadoop.home.<span class="built_in">dir</span>=/opt/hadoop -Dhadoop.<span class="built_in">id</span>.<span class="built_in">str</span>=hadoop -Dhadoop.root.logger=INFO,RFA -Dhadoop.policy.file=hadoop-policy.xml org.apache.hadoop.hdfs.server.datanode.DataNode</span><br><span class="line">hadoop   <span class="number">13670</span>     <span class="number">1</span>  <span class="number">3</span> <span class="number">10</span>:<span class="number">35</span> ?        <span class="number">00</span>:<span class="number">00</span>:04 /usr//<span class="built_in">bin</span>/java -Dproc_nodemanager -Djava.net.preferIPv4Stack=true -Dyarn.log.<span class="built_in">dir</span>=/opt/hadoop/logs -Dyarn.log.file=hadoop-hadoop-nodemanager-slave.log -Dyarn.home.<span class="built_in">dir</span>=/opt/hadoop -Dyarn.root.logger=INFO,console -Djava.library.path=/opt/hadoop/lib/native -Dhadoop.log.<span class="built_in">dir</span>=/opt/hadoop/logs -Dhadoop.log.file=hadoop-hadoop-nodemanager-slave.log -Dhadoop.home.<span class="built_in">dir</span>=/opt/hadoop -Dhadoop.<span class="built_in">id</span>.<span class="built_in">str</span>=hadoop -Dhadoop.root.logger=INFO,RFA -Dhadoop.policy.file=hadoop-policy.xml -Dhadoop.security.logger=INFO,NullAppender org.apache.hadoop.yarn.server.nodemanager.NodeManager</span><br></pre></td></tr></table></figure></p>
<p>或者使用jps命令在双方机器上查看启动的进程名：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[root@slave hadoop]<span class="comment"># jps</span></span><br><span class="line"><span class="number">13552</span> DataNode</span><br><span class="line"><span class="number">13670</span> NodeManager</span><br><span class="line"><span class="number">1543</span> WrapperSimpleApp</span><br><span class="line"><span class="number">13790</span> Jps</span><br></pre></td></tr></table></figure></p>
<p>在华为云的安全组里对这俩服务器打开50070端口和8088的公网访问端口，然后在浏览器里输入<code>http://master公网IP:50070</code>即可查看效果：<br><img data-src="/images/hadoop3.png" alt="akb48"></p>
<p>而输入<code>http://master公网IP:8088</code>就会看到cluster页面：<br><img data-src="/images/hadoop4.png" alt="akb48"></p>
<p>如果要关闭，就在master执行<code>/opt/hadoop/sbin/stop-all.sh</code>，至此一个简单的hadoop集群搭建和启动完毕。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/charlesblc/p/6030008.html">https://www.cnblogs.com/charlesblc/p/6030008.html</a><br><a href="https://blog.wuwii.com/linux-hadoop.html">https://blog.wuwii.com/linux-hadoop.html</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Alertmanager配置微信告警和钉钉告警</title>
    <url>/2019/10/29/Alertmanager%E9%85%8D%E7%BD%AE%E5%BE%AE%E4%BF%A1%E5%91%8A%E8%AD%A6%E5%92%8C%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/</url>
    <content><![CDATA[<h2 id="配置微信告警"><a href="#配置微信告警" class="headerlink" title="配置微信告警"></a>配置微信告警</h2><p>首先先去搞一个微信企业号，创建一个新的应用：<br><img data-src="/images/prometheus16.png" alt="akb48"></p>
<p>创建微信企业号的过程可以见<a href="https://rorschachchan.github.io/2018/01/10/Zabbix3-0%E6%90%AD%E9%85%8D%E5%BE%AE%E4%BF%A1%E4%BC%81%E4%B8%9A%E5%8F%B7%E6%8A%A5%E8%AD%A6/">https://rorschachchan.github.io/2018/01/10/Zabbix3-0%E6%90%AD%E9%85%8D%E5%BE%AE%E4%BF%A1%E4%BC%81%E4%B8%9A%E5%8F%B7%E6%8A%A5%E8%AD%A6/</a> 这篇文章。</p>
<p>来到prometheus服务器里，编辑<code>alertmanager.yml</code>如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">global</span>:</span><br><span class="line">  resolve_timeout: 5m</span><br><span class="line">  smtp_smarthost: <span class="string">&#x27;smtp.163.com:465&#x27;</span></span><br><span class="line">  smtp_from: <span class="string">&#x27;chenx1242@163.com&#x27;</span></span><br><span class="line">  smtp_auth_username: <span class="string">&#x27;chenx1242@163.com&#x27;</span></span><br><span class="line">  smtp_auth_password: <span class="string">&#x27;邮箱密码&#x27;</span></span><br><span class="line">  smtp_require_tls: false</span><br><span class="line">  wechat_api_url: http://qyapi.weixin.qq.com/cgi-<span class="built_in">bin</span>/		<span class="comment">#这里是wechat对外接口</span></span><br><span class="line"></span><br><span class="line">templates:</span><br><span class="line">  - <span class="string">&#x27;./template/*.tmpl&#x27;</span>		<span class="comment"># 模板的地址</span></span><br><span class="line"></span><br><span class="line">route:</span><br><span class="line">  group_by: [<span class="string">&#x27;chentest&#x27;</span>]</span><br><span class="line">  group_wait: 10s</span><br><span class="line">  group_interval: 30s</span><br><span class="line">  repeat_interval: 30m</span><br><span class="line">  receiver: <span class="string">&#x27;GOOGLE-email&#x27;</span></span><br><span class="line">  routes:	<span class="comment"># 这里做了一个路由</span></span><br><span class="line">  - receiver: <span class="string">&#x27;wechat&#x27;</span></span><br><span class="line">    group_wait: 30s	<span class="comment"># 这个路由会覆盖上面的值</span></span><br><span class="line"></span><br><span class="line">receivers:</span><br><span class="line">- name: <span class="string">&#x27;GOOGLE-email&#x27;</span></span><br><span class="line">  email_configs:</span><br><span class="line">  - send_resolved: true</span><br><span class="line">    to: <span class="string">&#x27;chenshuo955@gmail.com&#x27;</span></span><br><span class="line">    html: <span class="string">&#x27;&#123;&#123; template &quot;email.html&quot; . &#125;&#125;&#x27;</span></span><br><span class="line">    headers: &#123; Subject: <span class="string">&quot;[WARN]Prometheus告警邮件&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">- name: <span class="string">&#x27;wechat&#x27;</span></span><br><span class="line">  wechat_configs:</span><br><span class="line">  - corp_id: <span class="string">&#x27;XXXX&#x27;</span>		<span class="comment"># 企业信息(&quot;我的企业&quot;---&gt;&quot;CorpID&quot;[在底部])</span></span><br><span class="line">    to_user: <span class="string">&#x27;@all&#x27;</span>		<span class="comment"># 所有人就是@all，或者是指定人</span></span><br><span class="line">    agent_id: <span class="string">&#x27;1000003&#x27;</span> 	<span class="comment"># 企业微信(&quot;企业应用&quot;--&gt;&quot;自定应用&quot;[Prometheus]--&gt; &quot;AgentId&quot;)</span></span><br><span class="line">    api_secret: <span class="string">&#x27;E8DR55yEDwp0E3d0mpjsdWdt0pFNF9i7kQPzFfsQVbI&#x27;</span>	<span class="comment"># 企业微信(&quot;企业应用&quot;--&gt;&quot;自定应用&quot;[Prometheus]--&gt; &quot;Secret&quot;) </span></span><br><span class="line">    send_resolved: true		<span class="comment">#问题解决了要发信息</span></span><br><span class="line">    message: <span class="string">&#x27;&#123;&#123; template &quot;wechat.html&quot; . &#125;&#125;&#x27;</span>		<span class="comment"># 指定模板</span></span><br><span class="line"></span><br><span class="line">inhibit_rules:</span><br><span class="line">  - source_match:</span><br><span class="line">      severity: <span class="string">&#x27;critical&#x27;</span></span><br><span class="line">    target_match:</span><br><span class="line">      severity: <span class="string">&#x27;warning&#x27;</span></span><br><span class="line">    equal: [<span class="string">&#x27;alertname&#x27;</span>, <span class="string">&#x27;dev&#x27;</span>, <span class="string">&#x27;instance&#x27;</span>]</span><br></pre></td></tr></table></figure></p>
<p>然后来到当前目录的<code>/template/</code>里创建<code>wechat.tmpl</code>，如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123; define <span class="string">&quot;wechat.html&quot;</span> &#125;&#125;</span><br><span class="line">    &#123;&#123; <span class="built_in">range</span> .Alerts &#125;&#125;</span><br><span class="line">    ========start==========</span><br><span class="line">    告警程序: prometheus_alert</span><br><span class="line">    告警级别: &#123;&#123; .Labels.severity &#125;&#125;</span><br><span class="line">    告警类型: &#123;&#123; .Labels.alertname &#125;&#125;</span><br><span class="line">    故障主机: &#123;&#123; .Labels.instance &#125;&#125;</span><br><span class="line">    告警主题: &#123;&#123; .Annotations.summary &#125;&#125;</span><br><span class="line">    告警详情: &#123;&#123; .Annotations.description &#125;&#125;</span><br><span class="line">    触发时间: &#123;&#123; .StartsAt.Format <span class="string">&quot;2019-01-01 01:01:01&quot;</span> &#125;&#125;</span><br><span class="line">    ========end==========</span><br><span class="line">    &#123;&#123; end &#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>启动alertmanager，不就就可以在微信上看到信息了：<br><img data-src="/images/prometheus17.png" alt="akb48"></p>
<h2 id="配置钉钉告警"><a href="#配置钉钉告警" class="headerlink" title="配置钉钉告警"></a>配置钉钉告警</h2><p>首先先创建钉钉机器人并且获取对应的token:<br><img data-src="/images/prometheus18.png" alt="akb48"></p>
<p>然后检查一下自己的golang版本，网络上流行的timonwong的webhook是不能用于1.13版本的，所以要安装1.11版本的golang。安装方法golang 1.11方法如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">wget https://studygolang.com/dl/golang/go1<span class="number">.11</span>.linux-amd64.tar.gz</span><br><span class="line">tar zxvf go1<span class="number">.11</span>.linux-amd64.tar.gz -C /usr/local</span><br></pre></td></tr></table></figure></p>
<p>修改<code>/etc/profile</code>,在文件末尾添加如下内容:<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#go setting</span></span><br><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export GOPATH=/usr/local/gopath</span><br><span class="line">export PATH=$PATH:$GOROOT/<span class="built_in">bin</span></span><br></pre></td></tr></table></figure></p>
<p>执行<code>source /etc/profile</code>配置文件的环境变量立刻生效，此时在<code>/usr/local/go/src</code>路径下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mkdir -pv github.com/timonwong</span><br><span class="line">cd github.com/timonwong</span><br><span class="line">git clone https://github.com/timonwong/prometheus-webhook-dingtalk.git</span><br><span class="line">cd  prometheus-webhook-dingtalk/</span><br><span class="line">make</span><br></pre></td></tr></table></figure></p>
<p>然后执行效果如下，同时<code>/usr/local/go/src/github.com/timonwong/prometheus-webhook-dingtalk</code>路径下多了一个<code>prometheus-webhook-dingtalk</code>：<br><img data-src="/images/prometheus21.png" alt="akb48"></p>
<p>然后在后台执行这个<code>prometheus-webhook-dingtalk</code>：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nohup ./prometheus-webhook-dingtalk --ding.profile=<span class="string">&quot;chen_dingding=https://oapi.dingtalk.com/robot/send?access_token=XXXXX&quot;</span>   <span class="number">2</span>&gt;&amp;<span class="number">1</span> <span class="number">1</span>&gt;dingding.log &amp;		<span class="comment">#创建一个频道chen_dingding</span></span><br></pre></td></tr></table></figure></p>
<p>然后在<code>alertmanager.yaml</code>增加钉钉报警相关的信息：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">- receiver: <span class="string">&#x27;dingding&#x27;</span></span><br><span class="line">  group_wait: 30s</span><br><span class="line">  <span class="keyword">match</span>:</span><br><span class="line">    go: gothreads</span><br><span class="line"></span><br><span class="line">- name: <span class="string">&#x27;dingding&#x27;</span></span><br><span class="line">  webhook_configs:</span><br><span class="line">  - send_resolved: true</span><br><span class="line">    url: http://localhost:<span class="number">8060</span>/dingtalk/chens_dingding/send		<span class="comment">#这里频道要一致</span></span><br></pre></td></tr></table></figure></p>
<p>然后重启Alarmmanager即可，一会就能收到报警：<br><img data-src="/images/prometheus22.png" alt="akb48"></p>
<p>至于这个钉钉与alertmanager的webhook勾连的细节，可以去看<a href="http://ylzheng.com/2018/03/01/alertmanager-webhook-dingtalk/">http://ylzheng.com/2018/03/01/alertmanager-webhook-dingtalk/</a> 。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/xzkzzz/p/10211394.html">https://www.cnblogs.com/xzkzzz/p/10211394.html</a><br><a href="https://github.com/prometheus/alertmanager/issues/1385">https://github.com/prometheus/alertmanager/issues/1385</a><br><a href="https://blog.rj-bai.com/post/158.html">https://blog.rj-bai.com/post/158.html</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>监控</tag>
        <tag>Prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>Ansible-playbook如何获取ip</title>
    <url>/2018/01/31/Ansible-playbook%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96ip/</url>
    <content><![CDATA[<p>公司的模块都新加了加密算法，现在就是需要把约100台机器的<code>/etc/hosts</code>文件里的zookeeper server的ip调整成新的ip 地址，目前在ansible控制机上已经写好了带有新的zookeeper server的ip的<code>/etc/hosts</code>文件，然后计划是把这个新文件下发到大约100台具体模块的服务器里，然后这100台机器的文件中把他们各自的ip和hostname添加到这个新的<code>/etc/hosts</code>文件上。</p>
<p>于是就写了一个ansible-playbook:<br>	 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">- <span class="attr">hosts</span>: all</span><br><span class="line">  <span class="attr">tasks</span>:</span><br><span class="line">        - <span class="attr">name</span>: 将原有的hosts文件备份</span><br><span class="line">          <span class="attr">shell</span>: mv /etc/hosts /etc/hosts_bak</span><br><span class="line"></span><br><span class="line">        - <span class="attr">name</span>: 将ansible端的hosts复制到各自机器上</span><br><span class="line">          <span class="attr">copy</span>: src=<span class="regexp">/root/</span>hosts dest=<span class="regexp">/etc/</span> owner=root group=root mode=<span class="number">0544</span></span><br><span class="line"></span><br><span class="line">        - <span class="attr">name</span>: 在新的hosts文件后面追加各自机器内网ip和hostname</span><br><span class="line">          <span class="attr">lineinfile</span>: dest=<span class="regexp">/etc/</span>hosts line=<span class="string">&quot;`ansible_all_ipv4_addresses`  `ansible_hostname`&quot;</span></span><br></pre></td></tr></table></figure><br>但是写完之后执行出来，却是这样的效果：<br><img data-src="/images/ansibleip.png" alt="akb48"></p>
<p>而我想要的是这样的效果：<br><img data-src="/images/ansibleip2.png" alt="akb48"></p>
<p>遇到这种情况怎么办？</p>
<p>后来调整了一下，变量用<code>IP</code>: ““，而不是<code>ansible_all_ipv4_addresses</code>。</p>
<p>修改了之后的playbook 如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">- <span class="attr">hosts</span>: all</span><br><span class="line">  <span class="attr">vars</span>:</span><br><span class="line">        <span class="attr">IP</span>: <span class="string">&quot;&#123;&#123; ansible_eth0[&#x27;ipv4&#x27;][&#x27;address&#x27;] &#125;&#125;&quot;</span></span><br><span class="line">  <span class="attr">tasks</span>:</span><br><span class="line">        - <span class="attr">name</span>: 将原有的hosts文件备份</span><br><span class="line">          <span class="attr">shell</span>: mv /etc/hosts /etc/hosts_bak</span><br><span class="line">	</span><br><span class="line">   	    - <span class="attr">name</span>: 将ansible端的hosts复制到各自机器上</span><br><span class="line">   	      <span class="attr">copy</span>: src=<span class="regexp">/root/</span>hosts dest=<span class="regexp">/etc/</span> owner=root group=root mode=<span class="number">0644</span></span><br><span class="line"></span><br><span class="line">        - <span class="attr">name</span>: 在新的hosts文件后面追加各自机器内网ip和hostname</span><br><span class="line">          <span class="attr">lineinfile</span>: dest=<span class="regexp">/etc/</span>hosts line=<span class="string">&quot;`IP`  `ansible_hostname`&quot;</span></span><br></pre></td></tr></table></figure><br>这样就达到目的了。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>AWS数据迁移到阿里云的一些坑</title>
    <url>/2019/11/07/AWS%E9%85%8D%E7%BD%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>最近在忙AWS迁移阿里云的事情，在这之中发现了也解决了很多坑，这里记录一下。</p>
<h2 id="只读RDS修改配置组无效果"><a href="#只读RDS修改配置组无效果" class="headerlink" title="只读RDS修改配置组无效果"></a>只读RDS修改配置组无效果</h2><p>我们这一次数据库的迁移是重点任务，考虑到AWS的源库都是无公网访问权限的，于是就创建一个有公网权限的只读库（read replica），然后在阿里云是用DTS，以这个只读库作为源库，然后进行数据的<code>增量同步</code>。这里有一点：“源库”的binlog必须是ROW模式，而默认的AWS创建的源库是MIX模式，于是就需要修改一下参数组（parameter group），将其改成ROW：<br><img data-src="/images/aws1.png" alt="akb48"></p>
<p>然后配置只读实例引用这个参数组，但是要等待参数组状态是（pending reboot），重启。</p>
<p>但是这里有一个大坑！那么就是<code>read replica</code>的<code>Backup retention period</code>值不可以是0，不然参数组即使重启了是不会生效的！<br><img data-src="/images/aws2.png" alt="akb48"></p>
<p>当然直接使用DTS并不是一个好方案，因为即使是同一个可用区，比如都在法兰克福，但是不同厂商还是会有网络影响，所以更加推荐就是搭一个专线，然后走专线同步。而且DTS的时候，切忌目标库发生与源库不同的操作造成数据错乱，那样就前功尽弃了。</p>
<p>DTS的原理就是不断的读取binlog然后执行binlog，但是row模式的binlog特别巨大，再加上网络有波动或者源库有跟主库名称一样但是内容不一致的数据导致所有唯一主键都要报错一遍，那么延迟可能就是一辈子的事儿…</p>
<h2 id="无公网ec2访问外网"><a href="#无公网ec2访问外网" class="headerlink" title="无公网ec2访问外网"></a>无公网ec2访问外网</h2><p>本次迁移数据除了mysql还有redis，但是AWS的redis也都是内网服务器，于是这样我们就做了外网NLB，在阿里云的redis上做主从配置，并且在阿里云的redis.conf里把主写成了NLB的域名，这里如果担心NLB域名后面的IP发生变化而故障，那么可以事先在aws里购买弹性IP，然后将域名绑定死对应的IP就不怕了。</p>
<p>但是如果想要返回来，让阿里云的redis做主，AWS这个无公网的ec2 redis做从的话，用外网NLB就不行了。不过AWS比较好，就是ec2虽然表面没有公网IP，但是它有一个<code>隐藏的公网</code>，比如我这个ec2:<br><img data-src="/images/aws3.png" alt="akb48"></p>
<p>可见它没有公网IP，但是在服务器里使用<code>curl myip.ipip.net</code>可以获取到它的公网出口IP：<br><img data-src="/images/aws4.png" alt="akb48"></p>
<p>将这个IP写到阿里云的安全组就可以在ec2这边访问到阿里云的公网了！</p>
<h2 id="DMS白名单问题"><a href="#DMS白名单问题" class="headerlink" title="DMS白名单问题"></a>DMS白名单问题</h2><p>AWS的数据迁移叫DMS，这个地方也有一个坑，就是<code>Replication instances</code>的公网IP可能是不对的，如图：<br><img data-src="/images/aws5.png" alt="akb48"></p>
<p>我把图中的<code>Public IP address</code>填写到了阿里云对应数据库的白名单里但是test无法成功，后来改成<code>0.0.0.0/0</code>之后登陆上去一看，连接的IP并不是图中的IP，这真的是一个大坑！</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>aws</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>Atlas的几种常见故障解决方法</title>
    <url>/2018/02/23/Atlas%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="使用atlas却发现“读库闲置，框架还是去主库读写数据”"><a href="#使用atlas却发现“读库闲置，框架还是去主库读写数据”" class="headerlink" title="使用atlas却发现“读库闲置，框架还是去主库读写数据”"></a>使用atlas却发现“读库闲置，框架还是去主库读写数据”</h2><p>配置完atlas之后，发现使用<code>jdbc</code>框架的话，读库和写库各司其职，但是使用<code>mybatis</code>框架之后，就发现框架的读写都去了主库，把读库放置一边，那么这种情况是因为<code>有事务存在的话，atlas就会强制走主库</code>，遇到这种情况就检查一下是否有事务的存在，比如<code>@Transactional</code>，如果要解决的话，就加上<code>@Transactional(propagation=Propagation.NOT_SUPPORTED)</code>即可。<br><img data-src="/images/atlas13.png" alt="paradin"></p>
<h2 id="自动读写分离挺好，但有时候我写完马上就想读，万一主从同步延迟怎么办"><a href="#自动读写分离挺好，但有时候我写完马上就想读，万一主从同步延迟怎么办" class="headerlink" title="自动读写分离挺好，但有时候我写完马上就想读，万一主从同步延迟怎么办?"></a>自动读写分离挺好，但有时候我写完马上就想读，万一主从同步延迟怎么办?</h2><p>SQL语句前增加 <code>/*master*/</code> 就可以将读请求强制发往主库。在mysql命令行测试该功能时，需要加<code>-c</code>选项，以防mysql客户端过滤掉注释信息。不过这不能从本质上解决问题，使用Atlas需要考虑到这点，提高主机的IO性能，加大memory可以缓解延迟症状，但依旧不能避免延迟的出现，尤其是读多写少的应用。</p>
<h2 id="resource-limit的问题"><a href="#resource-limit的问题" class="headerlink" title="resource limit的问题"></a>resource limit的问题</h2><p>atlas有自己的连接池，会吃掉很多CPU, <code>php</code>应用端改用短链接来连接atlas, 这时候atlas对<code>php</code>发送来的sql只负责验证和转发的操作，后端DB的连接由atlas自己管理,未使用的连接线程进行剔除操作(DB的<code>wait_timeout</code>和<code>interactive_timeout</code>设置为300s,超时亦退出)。<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">2014</span>-<span class="number">04</span>-<span class="number">12</span> <span class="number">20</span>:<span class="number">56</span>:<span class="number">29</span>: (warning) (libevent) <span class="attr">event_del</span>: event has no event_base set.</span><br><span class="line"><span class="number">2014</span>-<span class="number">04</span>-<span class="number">12</span> <span class="number">20</span>:<span class="number">56</span>:<span class="number">29</span>: (critical) last message repeated <span class="number">5</span> times</span><br><span class="line"><span class="number">2014</span>-<span class="number">04</span>-<span class="number">12</span> <span class="number">20</span>:<span class="number">56</span>:<span class="number">29</span>: (critical) network-conn-pool-lua.<span class="property">c</span><span class="number">.144</span>: <span class="title function_">socket</span>() <span class="attr">failed</span>: <span class="title class_">Too</span> many open <span class="title function_">files</span> (<span class="number">24</span>)</span><br><span class="line"><span class="number">2014</span>-<span class="number">04</span>-<span class="number">12</span> <span class="number">20</span>:<span class="number">56</span>:<span class="number">29</span>: (warning) (libevent) <span class="attr">event_del</span>: event has no event_base set.</span><br><span class="line"><span class="number">2014</span>-<span class="number">04</span>-<span class="number">12</span> <span class="number">20</span>:<span class="number">56</span>:<span class="number">30</span>: (debug) chassis-unix-daemon.<span class="property">c</span>:<span class="number">168</span>: <span class="number">12951</span> <span class="attr">returned</span>: <span class="number">12951</span></span><br><span class="line"><span class="number">2014</span>-<span class="number">04</span>-<span class="number">12</span> <span class="number">20</span>:<span class="number">56</span>:<span class="number">30</span>: (critical) chassis-unix-daemon.<span class="property">c</span>:<span class="number">196</span>: [angel] <span class="variable constant_">PID</span>=<span class="number">12951</span> died on signal=<span class="number">11</span> (it used <span class="number">16</span> kBytes max) ... waiting 3min before restart</span><br></pre></td></tr></table></figure></p>
<p>如果MySQL后端的连接数也满了可能会报以下错误:<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">2014</span>-<span class="number">11</span>-<span class="number">13</span> <span class="number">12</span>:<span class="number">21</span>:<span class="number">07</span>: (critical) <span class="attr">network_mysqld_proto_password_scramble</span>: assertion <span class="string">`20 == challenge_len&#x27; failed</span></span><br><span class="line"><span class="string">2014-11-13 12:21:07: (warning) (libevent) event_del: event has no event_base set.</span></span><br><span class="line"><span class="string">2014-11-13 12:21:07: (critical)</span></span><br></pre></td></tr></table></figure></p>
<p>可以临时增加<code>MySQL connection</code>数量:<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">echo -n “<span class="title class_">Max</span> processes=<span class="attr">SOFT_LIMIT</span>:<span class="variable constant_">HARD_LIMIT</span>” &gt; <span class="regexp">/proc/</span><span class="string">`pidof mysqld`</span>/limits</span><br></pre></td></tr></table></figure></p>
<h2 id="出现Too-many-open-files的错误，怎么办？"><a href="#出现Too-many-open-files的错误，怎么办？" class="headerlink" title="出现Too many open files的错误，怎么办？&gt;"></a>出现<code>Too many open files</code>的错误，怎么办？&gt;</h2><p>关于<code>Too many open files</code>错误，可能由两种情况引起:<br>一、php长连接连接到atlas后，每个线程占用一个FD,直到超出系统资源限制而出现too many错误;<br>二、php应用端发送到atlas的sql过多，大量并发的情况下，linevent维护的队列过多，每个event吃一个FD，超出系统资源限制引起<code>Too many open files</code>错误;</p>
<p>避免<code>Too many open files</code>错误,增加用户的ulimit值加大<code>FD</code>的使用量,可增加系统ulimit资源到 <code>~/.bash_profile</code>文件或<code>/etc/security/limits.conf</code>文件:<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># cat .<span class="property">bash_profile</span> </span><br><span class="line"># .<span class="property">bash_profile</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">export</span> <span class="variable constant_">PATH</span></span><br><span class="line">ulimit -n <span class="number">16384</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>atlas</tag>
        <tag>读写分离</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7安装zabbix3.4全过程</title>
    <url>/2018/06/04/Centos7%E5%AE%89%E8%A3%85zabbix3-4%E5%85%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="安装zabbix-server-3-4"><a href="#安装zabbix-server-3-4" class="headerlink" title="安装zabbix-server 3.4"></a>安装zabbix-server 3.4</h2><p>本文以<code>centos 7</code>为例。<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld.service	#关闭防火墙</span><br><span class="line">systemctl disable firewalld.service #开机不启动防火墙</span><br><span class="line">setenforce 0 #清空selinux的配置	</span><br><span class="line">yum install mariadb-server mariadb –y</span><br><span class="line">systemctl enable mariadb	#设置开机启动</span><br><span class="line">systemctl start mariadb		#启动MariaDB</span><br><span class="line">rpm -Uvh http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/zabbix-agent-3.4.5-1.el7.x86_64.rpm</span><br><span class="line">yum install zabbix-server-mysql zabbix-web-mysql -y</span><br><span class="line">zcat /usr/share/doc/zabbix-server-mysql-3.4.9/create.sql.gz  |mysql -uzabbix -pzabbix zabbix		#这里是设定zabbix数据库账号密码和database的地方，create.sql.gz这个文件位置要根据实际情况来</span><br><span class="line">vim /etc/httpd/conf.d/zabbix.conf	#这里要修改文件里的时区，改成Asia/Shanghai</span><br><span class="line">systemctl start zabbix-server</span><br><span class="line">systemctl enable zabbix-server	</span><br><span class="line">setsebool -P httpd_can_connect_zabbix on</span><br><span class="line">setsebool -P httpd_can_cetwork_connect_db on</span><br><span class="line">systemctl start httpd </span><br><span class="line">systemctl enable httpd</span><br><span class="line">chkconfig zabbix_agent on</span><br><span class="line">systemctl start zabbix-agent</span><br></pre></td></tr></table></figure></p>
<p>然后就是在浏览器输入<code>外网IP/zabbix/</code>进行页面安装了，剩下的就不多写了。</p>
<p>如果打开WEB网页是如下的样子：<br><img data-src="/images/zabbix3.png" alt="akb48"></p>
<p>请检查php-fpm的版本。</p>
<h2 id="安装zabbix-agent-4-0"><a href="#安装zabbix-agent-4-0" class="headerlink" title="安装zabbix-agent 4.0"></a>安装zabbix-agent 4.0</h2><p>如果是<code>centos 6</code>:<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rpm -<span class="title class_">Uvh</span> <span class="attr">https</span>:<span class="comment">//repo.zabbix.com/zabbix/4.0/rhel/6/x86_64/zabbix-release-4.0-2.el6.noarch.rpm</span></span><br><span class="line">yum install -y zabbix-agent</span><br><span class="line">chkconfig zabbix-agent on;service zabbix-agent start	#如果不对就使使zabbix_agent</span><br></pre></td></tr></table></figure></p>
<p>如果是<code>centos 7</code>:<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rpm -<span class="title class_">Uvh</span> <span class="attr">https</span>:<span class="comment">//repo.zabbix.com/zabbix/4.0/rhel/7/x86_64/zabbix-release-4.0-2.el7.noarch.rpm</span></span><br><span class="line">yum install -y zabbix-agent</span><br><span class="line">chkconfig zabbix-agent on;service zabbix-agent start	#如果不对就使使zabbix_agent</span><br></pre></td></tr></table></figure></p>
<h2 id="安装Graphtree"><a href="#安装Graphtree" class="headerlink" title="安装Graphtree"></a>安装Graphtree</h2><p>虽然官方说Graphtree只维护到3.2版本，但是经过我测试3.4依旧可用。安装方法如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">首先进入到zabbix的html页面的文件夹</span><br><span class="line">yum install patch -y</span><br><span class="line">wget https://raw.githubusercontent.com/OneOaaS/graphtrees/master/graphtree3<span class="number">.0</span><span class="number">.4</span>.patch</span><br><span class="line">patch  -Np0 &lt;graphtree3<span class="number">.0</span><span class="number">.4</span>.patch</span><br><span class="line">chown -R apache.apache oneoaas	<span class="comment">#如果是nginx，那就是www.www</span></span><br></pre></td></tr></table></figure></p>
<p>刷新一下zabbix-server即可发现Monitoring下面多了一个Graphtree，如图：<br><img data-src="/images/zabbix6.png" alt="akb48"></p>
<p>点击即可查看。</p>
<h2 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h2><p><a href="https://www.kaijia.me/2014/11/zabbix-report-lack-of-free-swap-space-issue-on-server-without-swap-solved/">https://www.kaijia.me/2014/11/zabbix-report-lack-of-free-swap-space-issue-on-server-without-swap-solved/</a><br><a href="https://blog.csdn.net/sinat_15955423/article/details/76685878">https://blog.csdn.net/sinat_15955423/article/details/76685878</a> (centos6.x安装php5.6+gd库+bcmath库)<br><a href="https://www.sundayle.com/zabbix-monitor/">https://www.sundayle.com/zabbix-monitor/</a><br><img data-src="/images/curry3p3.gif" alt="akb48"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title>Crontab里解决脚本时间重叠的问题</title>
    <url>/2018/01/24/Crontab%E9%87%8C%E8%A7%A3%E5%86%B3%E8%84%9A%E6%9C%AC%E6%97%B6%E9%97%B4%E9%87%8D%E5%8F%A0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>Linux里的Crontab是一个好东西，但是它的默认最小执行频率是1分钟，但是我们在实际生产环境里有的时候遇到的脚本执行时间是大于1分钟的，这样就会出现一个很尴尬的情况，就是在1分钟过后，系统进程会出现多个脚本，neck and neck式的在后台运行，比如这样：<br><img data-src="/images/log499.png" alt="akb48"></p>
<p>从上面的图可以看到，10点36分<code>log499.sh</code>没有执行完毕，10点37又开始了执行了一个新的<code>log499.sh</code>脚本。这种脚本冲突肯定不是我们所希望的，那么如何才能保证后台只是在一段时间里只执行一个脚本呢？</p>
<p>这个时候我们就要使用文件锁，<code>flock</code>，这种方法要比判断pid高大上的多。</p>
<p>首先假设我们的脚本名字叫abc.sh，这个脚本文件的执行时间是要大于1分钟的，同时我们再设定一个锁文件，位置就叫<code>/tmp/abc.lock</code>,这个文件可以是空的，然后<code>crontab -e</code>，添加一句命令如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">* * * * * flock -xn /tmp/abc.<span class="property">lock</span> -c <span class="string">&#x27;sh /路径/abc.sh &gt;&gt; /记录日志的路径 2&gt;&amp;1&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>这个时候静候crontab启动abc.sh，通过<code>ps -ef|grep abc</code>，发现在后台始终只有一个abc进程。</p>
<p>但是有的时候会有这样的一个问题，就是abc执行一次之后，在下一次该执行的时候却没有执行，好像crontab失效了一样，对于这样的情况，就需要添加下面的语句到abc.sh末尾：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rm -rf /tmp/abc.<span class="property">lock</span>      #删除掉原有的锁文件</span><br><span class="line">sleep n                      #睡n秒</span><br><span class="line">touch /tmp/abc.<span class="property">lock</span>     #再新建一个锁文件</span><br></pre></td></tr></table></figure></p>
<p>这样不断地更新lock锁文件，就会保证crontab每次都会按期执行。</p>
<p>这里要注意一下，里面我加了一句<code>sleep n</code>，这里的n是为了跨分钟的存在，这是为了防止没有走到下一个分钟又会生成一个新的lock锁文件，这样还是会出现重复启动脚本的情况。</p>
<p>这里就涉及到flock的一个原理：<strong>在每一次执行任务的时候都会先去尝试取到锁文件，如果取到了锁文件，那么就会下一步，反之就会放弃执行</strong>。A任务在运行的时候已经占据了lock文件，那么B任务来了，发现没有lock了，就不会执行任务。</p>
<p>这里我们使用了flock的三个参数：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">-x, --<span class="attr">exclusive</span>: 获得一个独占锁</span><br><span class="line">-n, --<span class="attr">nonblock</span>:  如果没有立即获得锁，直接失败而不是等待</span><br><span class="line">-c, --<span class="attr">command</span>:   在shell中运行一个单独的命令</span><br></pre></td></tr></table></figure></p>
<p>当然，flock还是有很多丰富的参数可以供各位使用，大家就各自去google一下吧。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.csdn.net/fdipzone/article/details/38284009">http://blog.csdn.net/fdipzone/article/details/38284009</a><br><a href="http://chuansong.me/n/285635151949">http://chuansong.me/n/285635151949</a><br><a href="https://segmentfault.com/q/1010000008039907">https://segmentfault.com/q/1010000008039907</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>crontab</tag>
        <tag>运维技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Django+Ajax实现局部刷新</title>
    <url>/2022/03/20/Django-Ajax%E5%AE%9E%E7%8E%B0%E5%B1%80%E9%83%A8%E5%88%B7%E6%96%B0/</url>
    <content><![CDATA[<h2 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h2><p>Django &#x3D;&#x3D; 3.2.12<br>Python &#x3D;&#x3D; 3.8.1</p>
<p>这次的目标就是:在页面输入一个应用名，然后不用提交按钮，直接就动态刷新出来这个应用在数据库的情况。同时可以通过下拉单<code>select</code>和<code>checkbox</code>来调整该应用的状态，这样达到界面化查询和修改数据的目的：<br><img data-src="/images/ajax%E5%88%B7%E6%96%B03.png"></p>
<p>关键html代码如下：<br>	<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card-body&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;form-control form-control-lg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入应用名&quot;</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group row&quot;</span> <span class="attr">id</span>=<span class="string">&quot;get-status&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>	</span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>应用等级<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">id</span>=<span class="string">&quot;app_level&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span>&gt;</span>核心<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span>&gt;</span>非核心<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>是否接入测试平台<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">id</span>=<span class="string">&quot;test_platform&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span>&gt;</span>True<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span>&gt;</span>False<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-check&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;form-check-input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;fuwuhua&quot;</span> <span class="attr">id</span>=<span class="string">&quot;fuwuhua&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hangye&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;form-check-label&quot;</span>&gt;</span>服务化<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-check&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;form-check-input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;guojihangye&quot;</span> <span class="attr">id</span>=<span class="string">&quot;guojihangye&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hangye&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;form-check-label&quot;</span>&gt;</span>国际行业<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-check&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;form-check-input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;maochaohangye&quot;</span> <span class="attr">id</span>=<span class="string">&quot;maochaohangye&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hangye&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;form-check-label&quot;</span>&gt;</span>猫超行业<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-check&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;form-check-input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;fchangye&quot;</span> <span class="attr">id</span>=<span class="string">&quot;fchangye&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hangye&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;form-check-label&quot;</span>&gt;</span>FC行业<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-check&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;form-check-input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;pingtaihangye&quot;</span> <span class="attr">id</span>=<span class="string">&quot;pingtaihangye&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hangye&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;form-check-label&quot;</span>&gt;</span>平台行业<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span>       </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card-footer&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-danger float-right&quot;</span> <span class="attr">id</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这个<code>get-status</code>标签是用来ajax动态展示数据库查询结果的，而提交<code>button</code>会再提交一次ajax把数据给后台<code>views.py</code>。</p>
<h2 id="失去焦点"><a href="#失去焦点" class="headerlink" title="失去焦点"></a>失去焦点</h2><p>要实现”输入应用名后，实时刷新后台数据”，那么就需要判断<code>失去焦点</code>，这个方法在ajax的方法如下：<br>	<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 失去焦点</span></span></span><br><span class="line"><span class="language-javascript">$(<span class="string">&quot;#app&quot;</span>).<span class="title function_">blur</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> app = $(<span class="string">&quot;#app&quot;</span>).<span class="title function_">val</span>();</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;BYEBYE Russia!&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(app);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这里就是判断<code>app</code>标签一旦鼠标离开，那就会触发这个方法—-在控制台里输入字符串。效果如下：<br><img data-src="/images/ajax%E5%88%B7%E6%96%B01.png"></p>
<h2 id="checkbox传值"><a href="#checkbox传值" class="headerlink" title="checkbox传值"></a>checkbox传值</h2><p>组件<code>checkbox</code>的传值跟input不太一样，它不是想象中的“打勾了就是true,不打勾就是false”这样的判断逻辑。在这个case里，我先给每一个<code>checkbox</code>统一的<code>name</code>，然后轮询来得到他们各自的<code>value</code>。方法如下：<br>	<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">$(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">  $(<span class="string">&#x27;#submit&#x27;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> app = $(<span class="string">&quot;#app&quot;</span>).<span class="title function_">val</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> app_level = $(<span class="string">&quot;#app_level&quot;</span>).<span class="title function_">val</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> test_platform = $(<span class="string">&quot;#test_platform&quot;</span>).<span class="title function_">val</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> hangye = $(<span class="string">&quot;input[name=&#x27;hangye&#x27;]:checked&quot;</span>).<span class="title function_">serialize</span>();	<span class="comment">//这里获取所有的name是hangye的标签</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">cache</span>: <span class="literal">false</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">type</span>: <span class="string">&quot;POST&quot;</span>, <span class="comment">//方法类型</span></span></span><br><span class="line"><span class="language-javascript">      <span class="attr">dataType</span>: <span class="string">&quot;json&quot;</span>, <span class="comment">//预期服务器返回的数据类型</span></span></span><br><span class="line"><span class="language-javascript">      <span class="attr">url</span>: <span class="string">&#x27;&#123;% url &quot;change_app_level_ajax&quot; %&#125;&#x27;</span> ,  <span class="comment">//传给后面的url</span></span></span><br><span class="line"><span class="language-javascript">      <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">app</span>: app,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">app_level</span>: app_level,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">test_platform</span>: test_platform,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">hangye</span>: hangye   <span class="comment">//这里将以上的值传给后端views.py的值</span></span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">traditional</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">async</span>: <span class="literal">false</span>,  </span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">	<span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span>(data.<span class="property">status</span> == <span class="string">&quot;success&quot;</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">alert</span>(<span class="string">&quot;提交成功！&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">                location.<span class="title function_">reload</span>();  <span class="comment">// 直接刷新当前页面</span></span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">	<span class="attr">error</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">	        <span class="title function_">alert</span>(<span class="string">&quot;申请提交失败！&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">	        &#125;</span></span><br><span class="line"><span class="language-javascript">	  &#125;); </span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这里将<code>app</code>,<code>app_level</code>,<code>test_platform</code>和<code>hangye</code>作为一个json传给Django的<code>views.py</code>。那么在<code>views.py</code>里的<code>change_app_level_ajax</code>就这么写：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> parse_qs	<span class="comment"># 这里引入parse_qs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change_app_level_ajax</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">        app = request.POST.get(<span class="string">&quot;app&quot;</span>, <span class="literal">None</span>)  <span class="comment"># 从json里获取目标应用</span></span><br><span class="line">        app_level = request.POST.get(<span class="string">&quot;app_level&quot;</span>, <span class="literal">None</span>)</span><br><span class="line">        test_platform = request.POST.get(<span class="string">&quot;test_platform&quot;</span>, <span class="literal">False</span>)    </span><br><span class="line">        hangye = parse_qs(request.POST.get(<span class="string">&quot;hangye&quot;</span>, <span class="literal">False</span>))  <span class="comment"># 这里按照&amp;拆开，拆成了字典&#123;&#x27;hangye&#x27;: [&#x27;XXX&#x27;, &#x27;XXX&#x27;, &#x27;XXX&#x27;]&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(app, app_level, test_platform, hangye[<span class="string">&#x27;hangye&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;status&#x27;</span>: <span class="string">&#x27;success&#x27;</span>&#125;)  <span class="comment"># 返回成功信息给ajax</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;status&#x27;</span>: <span class="string">&#x27;error&#x27;</span>&#125;)  <span class="comment"># 失败</span></span><br></pre></td></tr></table></figure></p>
<p>为什么这里要有一个<code>parse_qs</code>?因为这里的<code>hangye</code>得到的样式是<code>hangye=AAA&amp;hangye=BBB&amp;hangye=CCC</code>的样子，那么通过<code>parse_qs</code>方法，可以给它优雅的拆成一个dict:<code>{&#39;hangye&#39;: [&#39;AAA&#39;, &#39;BBB&#39;, &#39;CCC&#39;]}</code>，然后就是可以对这个字典进一步的加工了。</p>
<h2 id="ajax局部刷新页面"><a href="#ajax局部刷新页面" class="headerlink" title="ajax局部刷新页面"></a>ajax局部刷新页面</h2><p>搭配submit或者上面的“失去焦点”，可以触发ajax，将获取到的前端数据给到后端，然后后端处理它。但是为了更加友好的交互，我们就要达到页面的局部刷新，这种刷新方法也很简单。</p>
<p>首先先需要在前端里确认一个标签，比如最上面代码的<code>&lt;div class=&quot;form-group row&quot; id=&quot;get-status&quot;&gt;&lt;/div&gt;</code>，这个标签就是将来刷新的地方。</p>
<p>然后就是在ajax的方法最后，说明在<code>get-status</code>进行替换：<br>	<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 失去焦点</span></span></span><br><span class="line"><span class="language-javascript">$(<span class="string">&quot;#app&quot;</span>).<span class="title function_">blur</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> app = $(<span class="string">&quot;#app&quot;</span>).<span class="title function_">val</span>();</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;BYEBYE Russia!&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(app);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">type</span>: <span class="string">&quot;POST&quot;</span>,  <span class="comment">//提交方式</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">dataType</span>: <span class="string">&quot;json&quot;</span>, <span class="comment">//数据类型</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">url</span>: <span class="string">&#x27;&#123;% url &quot;get_info_ajax&quot; %&#125;&#x27;</span>, <span class="comment">//请求url</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">app</span>: app <span class="comment">//这里将以上的值传给后端views.py的值</span></span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">         <span class="keyword">if</span>(data.<span class="property">status</span> == <span class="string">&quot;success&quot;</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">             $(<span class="string">&quot;#get-status&quot;</span>).<span class="title function_">html</span>(<span class="string">&quot;该应用目前的状态是:&quot;</span> + data.<span class="property">app_info</span>);   	<span class="comment">// 这个data是一个字典，传递的是data的app.info字段</span></span></span><br><span class="line"><span class="language-javascript">         &#125;</span></span><br><span class="line"><span class="language-javascript">         <span class="keyword">if</span>(data.<span class="property">status</span> == <span class="string">&quot;noexist&quot;</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">             $(<span class="string">&quot;#get-status&quot;</span>).<span class="title function_">html</span>(<span class="string">&quot;此应用不存在在数据库里！&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">         &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">   <span class="attr">error</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">         <span class="title function_">alert</span>(<span class="string">&quot;申请提交失败！请联系管理员查看问题。&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">     &#125;); </span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这样只要后台<code>views.py</code>返回的是success的话，<code>get-status</code>的标签变成<code>该应用目前的状态是:&quot; + data.app_info</code>。如果返回的是noexist，<code>get-status</code>的标签变成<code>此应用不存在在数据库里！</code>。效果如图：<br><img data-src="/images/ajax%E5%88%B7%E6%96%B02.png"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.chendacheng.com/content/?category=Django%E4%B8%93%E9%A2%98&article=Django_07.html">http://www.chendacheng.com/content/?category=Django%E4%B8%93%E9%A2%98&amp;article=Django_07.html</a><br><a href="https://blog.csdn.net/weixin_44144510/article/details/121995683">https://blog.csdn.net/weixin_44144510/article/details/121995683</a><br><a href="https://zhuanlan.zhihu.com/p/25016726">https://zhuanlan.zhihu.com/p/25016726</a><br><a href="https://blog.csdn.net/sinat_36553913/article/details/78418098">https://blog.csdn.net/sinat_36553913/article/details/78418098</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>django3</tag>
        <tag>ajax</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpu share和vpa</title>
    <url>/2022/12/23/Cpu-share-%E5%92%8Cvpa/</url>
    <content><![CDATA[<h2 id="什么是-CPU-Share"><a href="#什么是-CPU-Share" class="headerlink" title="什么是 CPU Share?"></a>什么是 CPU Share?</h2><p>CPU Share 是容器调度时进行 CPU 资源分配的一种方式，相对于集团之前使用的 CPU Set 而言。CPU Set 模式下会为一个 4C 的容器分配固定的“独占的” 4 个 CPU 核，容器中所有进程&#x2F;任务只能跑在这 4 个核上（因此算力上限就这 4 核），同时其它容器中的进程&#x2F;任务不能使用这 4 个核。</p>
<p>而 CPU Share 模式下一台 96 核的宿主机上一个 4C 容器绑定的 CPU 核数可能在 4 ~ 96 之间，取决这台宿主机上的资源分配情况及其它容器是否 CPU Share。目前一台宿主机上的所有 Share 容器都绑定相同的一批 CPU 核，容器中的进程&#x2F;任务可以跑在所有这些核上，每个容器可使用的 CPU 资源通过与容器规格相对应的权重来分配。<br><img data-src="/images/cpushare.webp" alt="paradin"></p>
<h2 id="为什么要做-CPU-Share"><a href="#为什么要做-CPU-Share" class="headerlink" title="为什么要做 CPU Share"></a>为什么要做 CPU Share</h2><p>优势：</p>
<ol>
<li>CPU 资源的分配可以更加精细化，原来 Set 模式下 CPU 资源的最小分配粒度是 1 核，而 Share 模式下可以做到 1&#x2F;1000 核；</li>
<li>宿主机上所有 Share 容器共享 CPU 核，每个容器不用的 CPU 资源可以被其它容器&#x2F;任务使用，有利于资源利用率提升；</li>
<li>可以更好的满足业务实时资源弹性需求，并且可能允许容器在短时间内使用超过容器规格的 CPU 资源来应对瞬间突发峰值；</li>
</ol>
<p>需要注意：</p>
<ol>
<li>因为 CPU Share 的资源共享特性，当宿主机整机 CPU 压力比较高时，请求达到时可能需要内核调度时间，可能对长尾延迟有影响。</li>
<li>CPU Share是不会导致ip发生变化的。</li>
</ol>
<p>由于 CPU Share 在资源利用率和弹性资源调度上的优势，后续在非重点应用上大规模推进应用 Share 化应该是业界主流趋势。除极个别延迟特别敏感业务（Latency sensitive critical）外，绝大多数的在线延迟敏感通用业务（Latency sensitive general）都将切换为 Share 模式。</p>
<p>最后简单总结：<br><img data-src="/images/cpushare2.png" alt="paradin" title="简单总结"></p>
<p>上图说cpuset也存在两种详细的绑核模式，分为<code>Spread</code>和<code>SameCoreFirst</code>。差异主要如下（举例4core Pod）：<br>● Spread：优先绑定每个core的1个HT，最多可以用到4个core的cpu算力，算力上限高，但确定性较差（对端HT会争抢），且存在L1&#x2F;L2层面的cache污染<br>● SameCoreFirst：优先占用每个core的两个HT，最多用满2个core的4个HT算力，算力上限低，但确定性高。</p>
<h2 id="如何查看应用的进程-线程数"><a href="#如何查看应用的进程-线程数" class="headerlink" title="如何查看应用的进程&#x2F;线程数"></a>如何查看应用的进程&#x2F;线程数</h2><p>绝大多数在线应用的启动脚本中通过读取容器内可见的 CPU 核数( grep -c ‘cpu[0-9][0-9]*’ &#x2F;proc&#x2F;stat )来设置应用进程&#x2F;线程数等，尤其是 Java 应用的 ParallelGCThreads 参数设置。由于 Share 容器绑定的 CPU 核可能远大于容器规格，因此需要读取容器内的 SIGMA_MAX_PROCESSORS_LIMIT 来作为相关设置的依据。</p>
<h2 id="什么是-VPA"><a href="#什么是-VPA" class="headerlink" title="什么是 VPA"></a>什么是 VPA</h2><p>VPA(Vertical Pod Autoscaler，垂直弹性伸缩) 相对于 HPA(Horizontal Pod Autoscaler，水平弹性伸缩) 而言，HPA 通过增减应用的运行容器实例来提升资源利用率&#x2F;应对峰值，而 VPA 则是通过增减单个容器实例所分得的资源(CPU&#x2F;MEM)多少来提升资源利用率&#x2F;应对峰值。由于 CPU Share 具备的共享和弹性特性，VPA 在 CPU Share 模式下更易实施且更安全。</p>
<p>VPA 根据应用资源画像调整容器 CPU 规格，同时保持 CPU 最大可用上限不变来弹性使用资源，容器将根据调整后规格进行计费，从而节省业务资源成本（后续随着应用水位的变化，也会自动往上调节，以寻找到最适合应用的资源配置）。当前阶段由于可用资源上限不变，并且平台设置了安全水位策略，风险较低，如有异常可在平台上执行一键回滚。</p>
<h2 id="为什么要做-VPA"><a href="#为什么要做-VPA" class="headerlink" title="为什么要做 VPA"></a>为什么要做 VPA</h2><p>HPA 扩缩容器的方式链路较长，涉及应用启停、中间件等运维配置的变动等，对线上的影响比较大，但是在资源节省上也更彻底。另外，由于业务容灾部署的需要，应用保有最小容器数量有一定限制，可能远超应用真实的资源需求。</p>
<p>VPA可以对应用容器进行原地秒级资源伸缩，链路短，风险更低，业务基本无感，从而更好的做到资源利用率的提升。CPU Share 容器资源分配由 request 和 limit 两个值决定，request 是强保障的资源，limit 是最大可用到的资源上限，默认情况下 容器规格 &#x3D;&#x3D; request &#x3D;&#x3D; limit，VPA 通过资源画像得到应用推荐的 request 值，同时保持 limit 不变，因此 CPU Share 模式的 VPA 风险较低。</p>
<p>不过这里要注意！应用升配（比如 2c-&gt;3c）在当前宿主机剩余资源不足时会发生驱逐，驱逐会导致更换宿主机，进而更换ip和重启应用。</p>
<h2 id="注意这里的坑"><a href="#注意这里的坑" class="headerlink" title="注意这里的坑"></a>注意这里的坑</h2><p>最近大促压测的时候，发现有一个应用同一个单元但是不同的机房cpu相差10%左右：<br><img data-src="/images/cpushare-1.png" alt="paradin" title="开始以为是有离线任务，但是后来发现离线任务压测时候已经压制掉了"></p>
<p>同样的应用肯定代码都是一样的，后来发现低cpu的是cpuset资源分配机制，而高cpu的是cpushare资源分配机制。后来查了一下原因：</p>
<ol>
<li>amd8代机(256core)&#x2F;intel机器8代机有两个numa，cpushare会导致跨numa，这样会导致较高的延迟和较低的带宽利用率，性能变差。</li>
<li>NUMA架构下，CPU近端节点和远端节点之间的访存延时存在较大差异（idle延时110+ns vs 80+ns），因此在对cpuset pod调度时，会优先分配同一个socket&#x2F;die上的cpu给pod，配合单机default的numa policy，所以会尽量做到同一个pod的cpu和内存在同一个numa节点上，容器性能会比较稳定。</li>
<li>amdl3 cache是Die共用，跨Die会导致性能变差。针对cpushare的pod，当前x86场景未做特殊处理，倚天场景会把单机划分成两个cpuSharePool（倚天跨Die的性能比较差）。</li>
</ol>
<p>所以如果是核心应用的话，还是建议尽量用cpuset来保障稳定性。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>cpu</tag>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Django前端输入变量通过内部脚本加工返回前端展示之五</title>
    <url>/2018/11/29/Django%E4%B8%8EJquery%E3%80%81Ajax%E7%9A%84%E8%81%94%E5%90%88%E8%BF%90%E7%94%A8/</url>
    <content><![CDATA[<h2 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h2><p>python：<code>3.6.5</code><br>Django：<code>2.1.1</code><br>Project：<code>Kubernetes</code>，文件夹路径就是<code>/django/Kubernetes/</code><br>App：<code>createyaml</code>，文件夹路径就是<code>/django/Kubernetes/createyaml</code><br>前文地址：<a href="https://rorschachchan.github.io/2018/11/24/Django%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%E5%8F%8D%E9%A6%88%E5%88%B0%E5%89%8D%E7%AB%AF%E8%BE%93%E5%87%BA/">https://rorschachchan.github.io/2018/11/24/Django%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%E5%8F%8D%E9%A6%88%E5%88%B0%E5%89%8D%E7%AB%AF%E8%BE%93%E5%87%BA/</a></p>
<h2 id="需求说明以及实现思路"><a href="#需求说明以及实现思路" class="headerlink" title="需求说明以及实现思路"></a>需求说明以及实现思路</h2><p>之前Django已经实现了点击按钮把值传入到后台脚本，同时把结果反馈到页面的效果了。但是那个逻辑太挫了:得把前端的变量存到本地去，然后后台的python脚本要去读取本地文件取的变量值执行任务。如果想用更加优雅的方法实现我们的目的那就要用<code>jQuery+Ajax</code>技术—-把目标反馈值包装成function调用，修改内置参数的方法，更容易上手，适合新手入门。</p>
<p>jQuery和Ajax的定义这里就不多说了，说直白点它们的作用就是不用离开当前的页面，而是在当前的页面加载出我们想要的结果，这就叫做<code>异步刷新</code>，这种刷新方法比较友好，而且可以少写一些html。</p>
<p>本次试验的目的就是在<code>test111.html</code>里随机输入内容，然后把数字“666”在当前页展示。效果如图：<br><img data-src="/images/django25.gif" alt="akb48"></p>
<p>这里我先使用<code>POST</code>方法，因为它无论是安全还是输入字符长度都要比<code>GET</code>方法优秀。但是要注意！如果代码中没有指明方法，那么默认就是<code>GET</code>方法。</p>
<h2 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h2><p>前端页面<code>test111.html</code>的内容如下：<br>	<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">title</span>&gt;</span>TEST PAGE<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">				// 这里引用jquery.min.js</span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                $(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;	<span class="comment">//元素加载完成之后，绑定事件</span></span></span><br><span class="line"><span class="language-javascript">                        $(<span class="string">&quot;#AJAX_post&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;	<span class="comment">//这里的AJAX_post与按钮的id一致，并且配置了点击click动作</span></span></span><br><span class="line"><span class="language-javascript">                                <span class="keyword">var</span> someth =  $(<span class="string">&quot;#someth&quot;</span>).<span class="title function_">val</span>();	<span class="comment">// 获取输入框的值</span></span></span><br><span class="line"><span class="language-javascript">                                <span class="keyword">var</span> data = &#123;<span class="string">&quot;someth&quot;</span>: someth&#125;;	<span class="comment">// 打包成get请求发送的数据</span></span></span><br><span class="line"><span class="language-javascript">								alert_text = <span class="string">&#x27;666即将出现！&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">                                <span class="title function_">alert</span>(alert_text);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                                $.<span class="title function_">post</span>(	<span class="comment">// post 方法请求服务器</span></span></span><br><span class="line"><span class="language-javascript">                                        <span class="string">&#x27;&#123;% url &#x27;</span>test111<span class="string">&#x27; %&#125;&#x27;</span>,	<span class="comment">// 请求的url</span></span></span><br><span class="line"><span class="language-javascript">                                data,	<span class="comment">// 这个data就是上面打包的数据</span></span></span><br><span class="line"><span class="language-javascript">                                <span class="keyword">function</span>(<span class="params">ret</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">										<span class="comment">// 回调函数，其中ret是返回的JSON </span></span></span><br><span class="line"><span class="language-javascript">                                        <span class="keyword">var</span> someth = ret[<span class="string">&#x27;someth&#x27;</span>];</span></span><br><span class="line"><span class="language-javascript">                                        <span class="keyword">var</span> num = ret[<span class="string">&#x27;num&#x27;</span>];</span></span><br><span class="line"><span class="language-javascript">                                        <span class="comment">// 这里把得到的两个值ret成查询结果</span></span></span><br><span class="line"><span class="language-javascript">                                        $(<span class="string">&quot;#result&quot;</span>).<span class="title function_">text</span>(num);</span></span><br><span class="line"><span class="language-javascript">										<span class="comment">// result就是输出到网页上的值，格式是text，如果是text(someth)，那么就会出现的是你随机输入的那段字符</span></span></span><br><span class="line"><span class="language-javascript">                                &#125;)</span></span><br><span class="line"><span class="language-javascript">                        &#125;)</span></span><br><span class="line"><span class="language-javascript">                &#125;);</span></span><br><span class="line"><span class="language-javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>请随便输入：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;someth&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>这里出现666：<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;result&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;AJAX_post&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span>&gt;</span>ajax post<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><br>ajax那部分虽然有注释，但是还是要多说一点：</p>
<ol>
<li><code>$(document).ready(function(){}</code>:等待{}中涉及到的元素全部加载完，就按照function具体内容给它们绑定特殊事件;</li>
<li><code>$(&quot;button&quot;).click(function(){}</code>:<code>$(&quot;AJAX_post&quot;)</code>是Jquery的选择器，表示页面的“按钮”，<code>.click(function(){}</code>为前面选中的元素，绑定一个鼠标点击的事件，具体事件是function()里面；</li>
<li><code>$.post</code>：表示调用了post方法，里面有三个元素，用逗号隔开，分别是<code>URL</code>,<code>data（可省略）</code>和<code>callback（可省略</code>，其中URL可以就是要局部刷新后展示的那个页面；</li>
<li>如果想把变量以字符串的形式输入，那么就是<code>var id=document.getElementById(&#39;name&#39;).value</code>，如果单独使用<code>request.GET.get</code>，得到的数据类型是<code>&#39;NoneType&#39;</code>;</li>
</ol>
<p>而对应的<code>views.py</code>那部分函数的内容如下：<br>	<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">from django.views.decorators.csrf import csrf_exempt</span><br><span class="line"></span><br><span class="line">@csrf_exempt	#取消CSRF保护，线上环境请不要这样</span><br><span class="line">def test(request):	</span><br><span class="line">    if request.method == &#x27;POST&#x27;:</span><br><span class="line">        someth = request.POST.get(&#x27;someth&#x27;)	#从前端获取name值</span><br><span class="line">        num = &quot;666&quot;		#已经定义好了666，然后会被ret得到</span><br><span class="line">        data = &#123;&#125;</span><br><span class="line">        data[&#x27;someth&#x27;] = someth</span><br><span class="line">        data[&#x27;num&#x27;] = num</span><br><span class="line">        print (data)</span><br><span class="line">        return JsonResponse(data)</span><br><span class="line">    else:</span><br><span class="line">        return render(request,&#x27;test111.html&#x27;)</span><br></pre></td></tr></table></figure></p>
<p>对应的<code>urls.py</code>内容如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">path</span>(r<span class="string">&#x27;test111&#x27;</span>,views.<span class="property">test</span>,name=<span class="string">&#x27;test111&#x27;</span>),</span><br></pre></td></tr></table></figure></p>
<p>保存之后，启动django，在<code>test111.html</code>页面即可达到效果。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.runoob.com/jquery/jquery-ajax-get-post.html">http://www.runoob.com/jquery/jquery-ajax-get-post.html</a><br><a href="https://zhuanlan.zhihu.com/p/27665172">https://zhuanlan.zhihu.com/p/27665172</a><br><a href="https://my.oschina.net/esdn/blog/814094">https://my.oschina.net/esdn/blog/814094</a><br><a href="https://www.jianshu.com/p/26cd9f442a13">https://www.jianshu.com/p/26cd9f442a13</a><br><a href="https://segmentfault.com/a/1190000009938183">https://segmentfault.com/a/1190000009938183</a> （rel&#x3D;noopener的问题）<br><img data-src="/images/Doncic.gif" alt="akb48"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>Jquery</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>Django前端输入变量通过内部脚本加工返回前端展示之三</title>
    <url>/2018/09/26/Django%E4%BD%BF%E7%94%A8form%E8%A1%A8%E5%8D%95%E5%88%A4%E6%96%AD%E8%BE%93%E5%85%A5%E5%80%BC%E6%98%AF%E5%90%A6%E5%90%88%E6%B3%95/</url>
    <content><![CDATA[<h2 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h2><p>python：<code>3.6.5</code><br>Django：<code>2.1.1</code><br>Project：<code>Kubernetes</code>，文件夹路径就是<code>/django/Kubernetes/</code><br>App：<code>createyaml</code>，文件夹路径就是<code>/django/Kubernetes/createyaml</code><br>前文地址：<a href="https://rorschachchan.github.io/2018/09/18/Django%E9%80%9A%E8%BF%87%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86%E7%AC%A6%E5%B0%86%E5%90%8E%E5%8F%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E5%BA%94%E8%BE%93%E5%87%BA/">https://rorschachchan.github.io/2018/09/18/Django%E9%80%9A%E8%BF%87%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86%E7%AC%A6%E5%B0%86%E5%90%8E%E5%8F%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E5%BA%94%E8%BE%93%E5%87%BA/</a></p>
<h2 id="需求与解决思路"><a href="#需求与解决思路" class="headerlink" title="需求与解决思路"></a>需求与解决思路</h2><p>对于表单而言，<strong>检查用户输入的信息是否合法</strong>是必然项。检查合法一般来说都是用<code>JavaScript</code>或<code>JQuery</code>。不过我是一个前端白痴，<code>JavaScript</code>对我来说就是天书。但是Django非常的贴心，在form表单里就准备了“验证输入内容”这个功能。</p>
<p>如果使用这个功能，首先先在app的<code>views.py</code>里导入form模块：<code>from django import forms</code>。</p>
<p>导入模块之后，设定一个类，这个类就是要在前端html页面中生成form表单中的<code>input</code>标签的，比如：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class YamlInfo(forms.Form):   #定义的django表单</span><br><span class="line">    name = forms.CharField(error_messages=&#123;&#x27;required&#x27;: u&#x27;此节点不能为空&#x27;&#125;,)	#自定义错误信息</span><br><span class="line">    replicas = forms.DecimalField(max_digits=2,error_messages=&#123;&#x27;required&#x27;: u&#x27;副本个数不能大于100&#x27;&#125;) #最大只有2位数</span><br><span class="line">    labels_app = forms.CharField(error_messages=&#123;&#x27;required&#x27;: u&#x27;此节点不能为空&#x27;&#125;)    </span><br><span class="line">	containers_name = forms.CharField(error_messages=&#123;&#x27;required&#x27;: u&#x27;此节点不能为空&#x27;&#125;)</span><br><span class="line">    containers_image = forms.CharField(error_messages=&#123;&#x27;required&#x27;: u&#x27;此节点不能为空&#x27;&#125;)</span><br></pre></td></tr></table></figure></p>
<p>表单上输入的东西可能会有很多，根据实际情况哪些字段不能为空就把那些字段写到这个class里，在上面那个<code>YamlInfo</code>里把这五项配置对应的Django表单字段，比如<code>replicas</code>，这个字节代表的是<code>容器副本个数</code>，所以它只能是数字，而且我们不要求它大于100，就设定max为2。</p>
<p>创建完类之后，需要在html页面里根据类的对象创建html标签，然后再提交的时候，需要后台<code>views.py</code>把前端页面提交的数据封装到一个对象里：<code>obj = YamlInfo(request.POST)</code>。由于每个Django表单的实例都有一个内置的<code>is_valid()</code>方法，用来验证接收的数据是否合法。如果所有数据都合法，那么该方法将返回<code>True</code>，并将所有的表单数据转存到它的一个叫做<code>cleaned_data</code>的属性中，该属性是以个字典类型数据，然后对这组数据进行展示或者保存到数据库就随你便了；如果有一个数据是非法的，就可以return一个别的结果。</p>
<h2 id="实际代码"><a href="#实际代码" class="headerlink" title="实际代码"></a>实际代码</h2><p>理论到此结束，先看<code>views.py</code>:<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.shortcuts import render,render_to_response</span><br><span class="line">from django.http import HttpResponse</span><br><span class="line">from .models import parameter		#引入数据库里的类</span><br><span class="line">from django import forms		#引入模块</span><br><span class="line"></span><br><span class="line">class YamlInfo(forms.Form):   #定义的django表单</span><br><span class="line">    name = forms.CharField(error_messages=&#123;&#x27;required&#x27;: u&#x27;此节点不能为空&#x27;&#125;,)</span><br><span class="line">    replicas = forms.DecimalField(max_digits=2,error_messages=&#123;&#x27;required&#x27;: u&#x27;副本个数不能大于100&#x27;&#125;) #最大只有2位数</span><br><span class="line">    labels_app = forms.CharField(error_messages=&#123;&#x27;required&#x27;: u&#x27;此节点不能为空&#x27;&#125;)   </span><br><span class="line">	containers_name = forms.CharField(error_messages=&#123;&#x27;required&#x27;: u&#x27;此节点不能为空&#x27;&#125;)</span><br><span class="line">    containers_image = forms.CharField(error_messages=&#123;&#x27;required&#x27;: u&#x27;此节点不能为空&#x27;&#125;)</span><br><span class="line"></span><br><span class="line">#create_yaml就是用来展示输入的页面而已</span><br><span class="line">def create_yaml(request):	</span><br><span class="line">    obj = YamlInfo()	#创建form的对象</span><br><span class="line">    return render(request,&#x27;create_yaml.html&#x27;,&#123;&#x27;obj&#x27;:obj&#125;)	#返回create_yaml这个模板，模板里的内容其实都是空的</span><br><span class="line"></span><br><span class="line">#yaml_list就是展示所有的输入情况</span><br><span class="line">def yaml_list(request):</span><br><span class="line">    obj = YamlInfo()	#创建form的对象</span><br><span class="line">    if request.method == &#x27;POST&#x27;:	</span><br><span class="line">        input_obj = YamlInfo(request.POST)		#request.POST为提交过来的所有数据</span><br><span class="line">        if input_obj.is_valid():</span><br><span class="line">            data = input_obj.clean()		#用clean()函数获取提交的数据</span><br><span class="line">            apiVersion = request.POST.get(&#x27;apiVersion&#x27;,&#x27;v1&#x27;)	#POST.get方法获取到非form的对象</span><br><span class="line">            kind = request.POST.get(&#x27;kind&#x27;,&#x27;RC&#x27;)</span><br><span class="line">            name = data[&#x27;name&#x27;]			#用data字典来获取form的对象</span><br><span class="line">            replicas = data[&#x27;replicas&#x27;]</span><br><span class="line">            labels_app = data[&#x27;labels_app&#x27;]</span><br><span class="line">            containers_name = data[&#x27;containers_name&#x27;]</span><br><span class="line">            containers_image = data[&#x27;containers_image&#x27;]</span><br><span class="line">            containerPort1 = request.POST.get(&#x27;containerPort1&#x27;,None)</span><br><span class="line">            containerPort2 = request.POST.get(&#x27;containerPort2&#x27;,None)</span><br><span class="line">            containers_name2 = request.POST.get(&#x27;containers_name2&#x27;,None)</span><br><span class="line">            containers_image2 = request.POST.get(&#x27;containers_image2&#x27;,None)</span><br><span class="line">            containerPort2_1 = request.POST.get(&#x27;containerPort2_1&#x27;,None)</span><br><span class="line">            containerPort2_2 = request.POST.get(&#x27;containerPort2_2&#x27;,None)</span><br><span class="line">            print (data)	#可以在后台看到整个data的内容</span><br><span class="line">        else:		#如果输入不合法，返回错误信息</span><br><span class="line">            error_msg = input_obj.errors	#errors为错误信息</span><br><span class="line">            return  render(request,&#x27;create_yaml.html&#x27;,&#123;&#x27;obj&#x27;:input_obj,&#x27;errors&#x27;:error_msg&#125;)		#将错误信息直接返回到前端页面去展示,刚刚输入的非法字段也保留</span><br><span class="line">    else:		#如果不是post提交，那么就是展示数据里的情况</span><br><span class="line">        yamls = parameter.objects.all().order_by(&#x27;-id&#x27;)		#以倒数展示，即新加的在上面</span><br><span class="line">        context = &#123;&#125;</span><br><span class="line">        context[&#x27;yamls&#x27;] = yamls</span><br><span class="line">		return render_to_response(&#x27;yaml_list.html&#x27;,context)	#返回yaml_list.html，里面有数据库的所有数据</span><br><span class="line"></span><br><span class="line">    Parameter = parameter()		#将数据库的类实例化</span><br><span class="line">    Parameter.apiVersion = apiVersion</span><br><span class="line">    Parameter.kind = kind</span><br><span class="line">    Parameter.name = name</span><br><span class="line">    Parameter.replicas = replicas</span><br><span class="line">    Parameter.labels_app = labels_app</span><br><span class="line">    Parameter.containers_name = containers_name</span><br><span class="line">    Parameter.containers_image = containers_image</span><br><span class="line">    Parameter.containerPort1 = containerPort1</span><br><span class="line">    Parameter.containerPort2 = containerPort2</span><br><span class="line">    Parameter.containers_name2 = containers_name2</span><br><span class="line">    Parameter.containers_image2 = containers_image2</span><br><span class="line">    Parameter.containerPort2_1 = containerPort2_1</span><br><span class="line">    Parameter.containerPort2_2 = containerPort2_2</span><br><span class="line">    Parameter.save()        #保存这些到数据库里</span><br><span class="line"></span><br><span class="line">    yamls = parameter.objects.all().order_by(&#x27;-id&#x27;)</span><br><span class="line">    context = &#123;&#125;</span><br><span class="line">    context[&#x27;yamls&#x27;] = yamls</span><br><span class="line">    return render_to_response(&#x27;yaml_list.html&#x27;,context)</span><br></pre></td></tr></table></figure></p>
<p>配置一下<code>urls.py</code>:<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from django.urls import path</span><br><span class="line">from createyaml import views	#将app的views.py文件引入</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;admin/&#x27;, admin.site.urls),	#每个页面对应各自在views.py里的函数</span><br><span class="line">    path(r&#x27;create_yaml/&#x27;, views.create_yaml),</span><br><span class="line">    path(r&#x27;yaml_list/&#x27;, views.yaml_list),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>配置一下用户输入的界面—<code>create_yaml.html</code>：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">        &lt;head&gt;</span><br><span class="line">                &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">                &lt;title&gt;生成K8S所用的YAML文件&lt;/title&gt;</span><br><span class="line">        &lt;/head&gt;</span><br><span class="line">        &lt;body&gt;</span><br><span class="line">                &lt;h1&gt;用户输入&lt;/h1&gt;</span><br><span class="line">                &lt;h2&gt;请注意！大小写敏感！！！&lt;/h2&gt;</span><br><span class="line">                &lt;form action=&quot;/yaml_list/&quot; method=&quot;post&quot; name=&#x27;yamllist&#x27;&gt;</span><br><span class="line">                &#123;% csrf_token %&#125;</span><br><span class="line">                API版本：</span><br><span class="line">                &lt;select name=&#x27;apiVersion&#x27;&gt;</span><br><span class="line">                        &lt;option value=&quot;v1&quot; selected&gt;v1&lt;/option&gt;</span><br><span class="line">                        &lt;option value=&quot;extensions/v1beta1&quot;&gt;beta1&lt;/option&gt;</span><br><span class="line">                &lt;/select&gt;&lt;br /&gt;</span><br><span class="line">                任务类型：</span><br><span class="line">                &lt;select name=&#x27;kind&#x27;&gt;</span><br><span class="line">                        &lt;option value=&quot;Pod&quot; selected&gt;Pod&lt;/option&gt;</span><br><span class="line">                        &lt;option value=&quot;Service&quot;&gt;Service&lt;/option&gt;</span><br><span class="line">                        &lt;option value=&quot;Deployment&quot;&gt;Deployment&lt;/option&gt;</span><br><span class="line">                        &lt;option value=&quot;ReplicationController&quot;&gt;ReplicationController&lt;/option&gt;</span><br><span class="line">                &lt;/select&gt;&lt;br /&gt;</span><br><span class="line">                &lt;p&gt;任务名称：&#123;&#123; obj.name &#125;&#125; &lt;span&gt;&#123;&#123; errors.name &#125;&#125;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;任务数量：&#123;&#123; obj.replicas &#125;&#125; &lt;span&gt;&#123;&#123; errors.replicas &#125;&#125;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;APP名称：&#123;&#123; obj.labels_app &#125;&#125; &lt;span&gt;&#123;&#123; errors.labels_app &#125;&#125;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;容器1名称：&#123;&#123; obj.containers_name &#125;&#125; &lt;span&gt;&#123;&#123; errors.containers_name &#125;&#125;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;容器1镜像：&#123;&#123; obj.containers_image &#125;&#125; &lt;span&gt;&#123;&#123; errors.containers_image &#125;&#125;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">                容器1开放端口1：&lt;input type=&quot;text&quot; placeholder=&quot;没有可以不填&quot; name=&quot;containerPort1&quot; /&gt;&lt;br /&gt;</span><br><span class="line">                容器1开放端口2：&lt;input type=&quot;text&quot; placeholder=&quot;没有可以不填&quot; name=&quot;containerPort2&quot; /&gt;&lt;br /&gt;</span><br><span class="line">                容器2名称：&lt;input type=&quot;text&quot; placeholder=&quot;没有可以不填&quot; name=&quot;containers_name2&quot; /&gt;&lt;br /&gt;</span><br><span class="line">                容器2镜像：&lt;input type=&quot;text&quot; placeholder=&quot;没有可以不填&quot; name=&quot;containers_image2&quot; /&gt;&lt;br /&gt;</span><br><span class="line">                容器2开放端口1：&lt;input type=&quot;text&quot; placeholder=&quot;没有可以不填&quot; name=&quot;containerPort2_1&quot; /&gt;&lt;br /&gt;</span><br><span class="line">                容器2开放端口2：&lt;input type=&quot;text&quot; placeholder=&quot;没有可以不填&quot; name=&quot;containerPort2_2&quot; /&gt;&lt;br /&gt;</span><br><span class="line">                &lt;input type=&quot;reset&quot; value=&quot;清除所有&quot; /&gt;</span><br><span class="line">                &lt;input type=&quot;submit&quot; value=&quot;生成yaml文件&quot; /&gt;</span><br><span class="line">                &lt;/form&gt;</span><br><span class="line">        &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>而跳转后的<code>yaml_list.html</code>就是这样：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">        &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;yaml文件展示&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">        &lt;body&gt;</span><br><span class="line">                &lt;h1&gt;数据库里的yaml数据展示&lt;/h1&gt;</span><br><span class="line">                &lt;table width=&quot;100%&quot; border=&quot;1&quot;&gt;</span><br><span class="line">                        &lt;thead&gt;</span><br><span class="line">                                &lt;a href=&quot;http://121.41.37.251:33664/create_yaml/&quot;&gt;&lt;button&gt;返回&lt;/button&gt;&lt;/a&gt;</span><br><span class="line">                                &lt;!--插入按钮 开始--&gt;</span><br><span class="line">                                &lt;input type=&quot;button&quot; value=&quot;执行&quot; onclick=&quot;MsgBox()&quot; /&gt;</span><br><span class="line">                                &lt;!--插入按钮 结束--&gt;</span><br><span class="line">                                &lt;!--引用JS代码以达到弹出对话框目的 开始--&gt;</span><br><span class="line">                                &lt;script language=&quot;javascript&quot;&gt;</span><br><span class="line">                                        function MsgBox() //声明标识符</span><br><span class="line">                                        &#123;</span><br><span class="line">                                        confirm(&quot;确定要执行后台脚本么？&quot;); //弹出对话框</span><br><span class="line">                                        &#125;</span><br><span class="line">                                &lt;/script&gt;</span><br><span class="line">                                &lt;!--引用JS代码以达到弹出对话框目的 结束--&gt;</span><br><span class="line">                                &lt;br&gt;</span><br><span class="line">                        &lt;form&gt;</span><br><span class="line">                                &lt;tr&gt;</span><br><span class="line">                                &lt;td align=&quot;center&quot;&gt;任务序号&lt;/td&gt;</span><br><span class="line">                                &lt;td align=&quot;center&quot;&gt;yaml名称&lt;/td&gt;</span><br><span class="line">                                &lt;td align=&quot;center&quot;&gt;api版本&lt;/td&gt;</span><br><span class="line">                                &lt;td align=&quot;center&quot;&gt;任务类型&lt;/td&gt;</span><br><span class="line">                                &lt;td align=&quot;center&quot;&gt;任务数量&lt;/td&gt;</span><br><span class="line">                                &lt;td align=&quot;center&quot;&gt;对应应用&lt;/td&gt;</span><br><span class="line">                                &lt;td align=&quot;center&quot;&gt;使用的第一个镜像名称&lt;/td&gt;</span><br><span class="line">                                &lt;td align=&quot;center&quot;&gt;镜像1的第一个端口&lt;/td&gt;</span><br><span class="line">                                &lt;td align=&quot;center&quot;&gt;镜像1的第二个端口&lt;/td&gt;</span><br><span class="line">                                &lt;td align=&quot;center&quot;&gt;使用的第二个镜像名称&lt;/td&gt;</span><br><span class="line">                                &lt;td align=&quot;center&quot;&gt;镜像2的第一个端口&lt;/td&gt;</span><br><span class="line">                                &lt;td align=&quot;center&quot;&gt;镜像2的第二个端口&lt;/td&gt;</span><br><span class="line">                                &lt;/tr&gt;</span><br><span class="line">                        &lt;/thead&gt;</span><br><span class="line">                        &lt;tbody&gt;</span><br><span class="line">                                &#123;% for yaml in yamls %&#125;</span><br><span class="line">                                &lt;tr&gt;</span><br><span class="line">                                        &lt;td&gt;&lt;input type=&quot;radio&quot; name=&quot;id&quot; checked=&quot;checked&quot;/&gt;&#123;&#123; yaml.id &#125;&#125; &lt;/td&gt;</span><br><span class="line">                                        &lt;td align=&quot;center&quot;&gt;&#123;&#123; yaml.name &#125;&#125; &lt;/td&gt;</span><br><span class="line">                                        &lt;td align=&quot;center&quot;&gt;&#123;&#123; yaml.apiVersion &#125;&#125;&lt;/td&gt;</span><br><span class="line">                                        &lt;td align=&quot;center&quot;&gt;&#123;&#123; yaml.kind &#125;&#125;&lt;/td&gt;</span><br><span class="line">                                        &lt;td align=&quot;center&quot;&gt;&#123;&#123; yaml.replicas &#125;&#125;&lt;/td&gt;</span><br><span class="line">                                        &lt;td align=&quot;center&quot;&gt;&#123;&#123; yaml.labels_app &#125;&#125;&lt;/td&gt;</span><br><span class="line">                                        &lt;td align=&quot;center&quot;&gt;&#123;&#123; yaml.containers_image &#125;&#125;&lt;/td&gt;</span><br><span class="line">                                        &lt;td align=&quot;center&quot;&gt;&#123;&#123; yaml.containerPort1 &#125;&#125;&lt;/td&gt;</span><br><span class="line">                                        &lt;td align=&quot;center&quot;&gt;&#123;&#123; yaml.containerPort2 &#125;&#125;&lt;/td&gt;</span><br><span class="line">                                        &lt;td align=&quot;center&quot;&gt;&#123;&#123; yaml.containers_image2 &#125;&#125;&lt;/td&gt;</span><br><span class="line">                                        &lt;td align=&quot;center&quot;&gt;&#123;&#123; yaml.containerPort2_1 &#125;&#125;&lt;/td&gt;</span><br><span class="line">                                        &lt;td align=&quot;center&quot;&gt;&#123;&#123; yaml.containerPort2_2 &#125;&#125;&lt;/td&gt;</span><br><span class="line">                                &lt;/tr&gt;</span><br><span class="line">                                &#123;% endfor %&#125;</span><br><span class="line">                        &lt;/tbody&gt;</span><br><span class="line">                &lt;/table&gt;</span><br><span class="line">        &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>启动django，我们来看一下效果！<br><img data-src="/images/django20.gif" alt="paradin" title="提示某些项目必须填写"></p>
<p><img data-src="/images/django21.gif" alt="paradin" title="如果副本数大于100的错误提示"><br>不过说实话，对于用户来说，肯定选择题的感觉要比填空题好。所以到时候我们可以把阿里云容器仓库里的所有的镜像做成一个数据库，到时候映射到这个页面，让用户去在里面做选择而不是填空。而且django的form检查相比较JavaScript而言还是很粗糙的，如果是处女座的话，还是要搞JavaScript，而且两者也并不冲突，一个是对前端用户而言，一个是后台检查录入数据库的。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://docs.djangoproject.com/en/2.1/topics/forms/">https://docs.djangoproject.com/en/2.1/topics/forms/</a>	（官方文档）<br><a href="http://www.liujiangblog.com/course/django/152">http://www.liujiangblog.com/course/django/152</a><br><a href="https://www.cnblogs.com/chenchao1990/p/5284237.html">https://www.cnblogs.com/chenchao1990/p/5284237.html</a><br><a href="http://dokelung-blog.logdown.com/posts/221431-django-notes-8-form-validation-and-modeling">http://dokelung-blog.logdown.com/posts/221431-django-notes-8-form-validation-and-modeling</a><br><a href="https://www.jb51.net/article/103135.htm">https://www.jb51.net/article/103135.htm</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django前端输入变量通过内部脚本加工返回前端展示之一</title>
    <url>/2018/09/13/Django%E5%88%B6%E4%BD%9C%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%94%9F%E6%88%90yaml%E6%96%87%E4%BB%B6%E4%B9%8B%E6%94%B9%E8%BF%9B%E7%89%88/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前搞了一个简易版的“通过前端页面生成yaml”的方法，地址在此：<a href="https://rorschachchan.github.io/2018/09/03/%E5%88%B6%E4%BD%9C%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%94%9F%E6%88%90yaml%E6%96%87%E4%BB%B6/">https://rorschachchan.github.io/2018/09/03/制作前端页面生成yaml文件/</a> 。但是这个方法实际上有很多的不足，比如说每一次生成记录就消失了，无法追溯，所以要引入数据库，把每一次的数据保存到数据库里。</p>
<p>整体的流程设计还是跟以前的一样：</p>
<ol>
<li>制作一个<code>create_yaml.html</code>网页让用户输入相关数值，并且有两个按钮，一个是重置，一个是生成yaml供K8s使用；</li>
<li>数值保存到django的数据库里；</li>
<li>做一个脚本，脚本从django数据库里取值然后执行；</li>
<li>脚本的结果返回到<code>get_yaml</code>网页，它也有两个按钮，一个是返回，一个是执行此yaml；</li>
</ol>
<p><strong>本篇文章的内容是第一步和第二步</strong>，Django的project名是<code>Kubernetes</code>，app名是<code>createyaml</code>。</p>
<h2 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h2><p>由于这个小系统保存的数据量不多，所以我就直接使用django默认的<code>db.sqlite3</code>数据库。跑到<code>Kubernetes/createyaml</code>的<code>models.py</code>里，根据yaml的实际情况编写一下数据库各字段：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.<span class="property">db</span> <span class="keyword">import</span> models</span><br><span class="line"> </span><br><span class="line"># <span class="title class_">Create</span> your models here.</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">parameter</span>(models.<span class="property">Model</span>):</span><br><span class="line">       type = (</span><br><span class="line">               (U<span class="string">&#x27;Pod&#x27;</span>,<span class="string">&#x27;Pod&#x27;</span>),</span><br><span class="line">               (U<span class="string">&#x27;Service&#x27;</span>,<span class="string">&#x27;Service&#x27;</span>),</span><br><span class="line">               (U<span class="string">&#x27;Deployment&#x27;</span>,<span class="string">&#x27;Deployment&#x27;</span>),</span><br><span class="line">               (U<span class="string">&#x27;ReplicationController&#x27;</span>,<span class="string">&#x27;ReplicationController&#x27;</span>),</span><br><span class="line">                   )</span><br><span class="line">       api_type = (</span><br><span class="line">                    (U<span class="string">&#x27;v1&#x27;</span>,<span class="string">&#x27;v1&#x27;</span>),</span><br><span class="line">                    (U<span class="string">&#x27;extensions/v1beta1&#x27;</span>,<span class="string">&#x27;beta1&#x27;</span>),</span><br><span class="line">                   )</span><br><span class="line">       apiVersion = models.<span class="title class_">CharField</span>(verbose_name=<span class="string">&#x27;API版本&#x27;</span>,max_length=<span class="number">20</span>,choices=api_type)</span><br><span class="line">       kind = models.<span class="title class_">CharField</span>(verbose_name=<span class="string">&#x27;任务类型&#x27;</span>,max_length=<span class="number">50</span>,choices=type)</span><br><span class="line">       name = models.<span class="title class_">CharField</span>(verbose_name=<span class="string">&#x27;任务名称&#x27;</span>,max_length=<span class="number">100</span>)</span><br><span class="line">       replicas = models.<span class="title class_">CharField</span>(verbose_name=<span class="string">&#x27;任务数量&#x27;</span>,max_length=<span class="number">50</span>,<span class="keyword">default</span>=<span class="string">&#x27;1&#x27;</span>)	#默认情况下副本数是<span class="number">1</span></span><br><span class="line">       labels_app = models.<span class="title class_">CharField</span>(verbose_name=<span class="string">&#x27;APP名称&#x27;</span>,max_length=<span class="number">100</span>)</span><br><span class="line">       containers_name = models.<span class="title class_">CharField</span>(verbose_name=<span class="string">&#x27;容器1名称&#x27;</span>,max_length=<span class="number">100</span>)</span><br><span class="line">       containers_image = models.<span class="title class_">CharField</span>(verbose_name=<span class="string">&#x27;容器1镜像&#x27;</span>,max_length=<span class="number">100</span>)</span><br><span class="line">       containerPort1 = models.<span class="title class_">CharField</span>(verbose_name=<span class="string">&#x27;容器1开放端口1&#x27;</span>,max_length=<span class="number">25</span>,blank=<span class="title class_">True</span>)		#可以为空，下同</span><br><span class="line">       containerPort2 = models.<span class="title class_">CharField</span>(verbose_name=<span class="string">&#x27;容器1开放端口2&#x27;</span>,max_length=<span class="number">25</span>,blank=<span class="title class_">True</span>)</span><br><span class="line">       containers_name2 = models.<span class="title class_">CharField</span>(verbose_name=<span class="string">&#x27;容器2名称&#x27;</span>,max_length=<span class="number">100</span>,blank=<span class="title class_">True</span>)</span><br><span class="line">       containers_image2 = models.<span class="title class_">CharField</span>(verbose_name=<span class="string">&#x27;容器2镜像&#x27;</span>,max_length=<span class="number">100</span>,blank=<span class="title class_">True</span>)</span><br><span class="line">       containerPort2_1 = models.<span class="title class_">CharField</span>(verbose_name=<span class="string">&#x27;容器2开放端口1&#x27;</span>,max_length=<span class="number">25</span>,blank=<span class="title class_">True</span>)</span><br><span class="line">       containerPort2_2 = models.<span class="title class_">CharField</span>(verbose_name=<span class="string">&#x27;容器2开放端口2&#x27;</span>,max_length=<span class="number">25</span>,blank=<span class="title class_">True</span>)</span><br><span class="line">       signer = models.<span class="title class_">CharField</span>(verbose_name=<span class="string">&#x27;登记人&#x27;</span>,max_length=<span class="number">50</span>, <span class="keyword">default</span>=<span class="string">&#x27;system&#x27;</span>)		</span><br><span class="line">       signtime = models.<span class="title class_">DateField</span>(auto_now_add= <span class="title class_">True</span>)		#默认添加当前时间</span><br><span class="line"></span><br><span class="line">#返回相应的值</span><br><span class="line">def <span class="title function_">__unicode__</span>(self):</span><br><span class="line">	<span class="keyword">return</span> self.<span class="property">name</span></span><br></pre></td></tr></table></figure></p>
<p>保存之后，<code>python manage.py makemigrations</code>和<code>python manage.py migrate</code>，就会看到<code>db.sqlite3</code>文件在<code>Kubernetes</code>这个project文件夹里诞生了。</p>
<h2 id="配置URL路由"><a href="#配置URL路由" class="headerlink" title="配置URL路由"></a>配置URL路由</h2><p>根据整体的流程设计所说，url.py就新增了如下几个路由：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    <span class="title function_">path</span>(r<span class="string">&#x27;create_yaml/&#x27;</span>, views.<span class="property">create_yaml</span>),	#create_yaml网页里的内容就是views.<span class="property">py</span>里的create_yaml函数，下同</span><br><span class="line">    <span class="title function_">path</span>(r<span class="string">&#x27;get_yaml/&#x27;</span>, views.<span class="property">get_yaml</span>),</span><br><span class="line">    <span class="title function_">path</span>(r<span class="string">&#x27;addok/&#x27;</span>, views.<span class="property">addok</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>在admin后台界面也要体现出每一次数据输入，于是就配置一下<code>Kubernetes/createyaml/admin.py</code>:<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.<span class="property">contrib</span> <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> .<span class="property">models</span> <span class="keyword">import</span> parameter		#把parameter这个<span class="keyword">class</span>引入</span><br><span class="line"># <span class="title class_">Register</span> your models here.</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">parameterAdmin</span>(admin.<span class="property">ModelAdmin</span>):</span><br><span class="line">    list_display = (<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;apiVersion&#x27;</span>,<span class="string">&#x27;kind&#x27;</span>,<span class="string">&#x27;replicas&#x27;</span>,<span class="string">&#x27;labels_app&#x27;</span>,<span class="string">&#x27;containers_name&#x27;</span>,<span class="string">&#x27;containers_image&#x27;</span>,<span class="string">&#x27;containerPort1&#x27;</span>,<span class="string">&#x27;containers_name2&#x27;</span>,<span class="string">&#x27;containers_image2&#x27;</span>,<span class="string">&#x27;containerPort2_1&#x27;</span>,<span class="string">&#x27;signer&#x27;</span>,<span class="string">&#x27;signtime&#x27;</span>)		#把models.<span class="property">py</span>里的字段都添加进去</span><br><span class="line">    exclude = [<span class="string">&#x27;signer&#x27;</span>]						#signer字段不要添加</span><br><span class="line">    def <span class="title function_">save_model</span>(self, request, obj, form, change):</span><br><span class="line">        obj.<span class="property">signer</span> = <span class="title function_">str</span>(request.<span class="property">user</span>)</span><br><span class="line">        obj.<span class="title function_">save</span>()</span><br><span class="line"></span><br><span class="line">admin.<span class="property">site</span>.<span class="title function_">register</span>(parameter,parameterAdmin)</span><br></pre></td></tr></table></figure></p>
<p>准备工作完事，开始搞前端页面。</p>
<h2 id="配置前端"><a href="#配置前端" class="headerlink" title="配置前端"></a>配置前端</h2><p>在<code>createyaml</code>文件夹下建立一个<code>template</code>文件夹，里面先写一个<code>create_yaml.html</code>：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">        &lt;head&gt;</span><br><span class="line">                &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">                &lt;title&gt;生成K8S所用的YAML文件&lt;/title&gt;</span><br><span class="line">        &lt;/head&gt;</span><br><span class="line">        &lt;body&gt;</span><br><span class="line">                &lt;h1&gt;用户输入：&lt;/h1&gt;</span><br><span class="line">                &lt;h2&gt;请注意！大小写敏感！！！&lt;/h2&gt;</span><br><span class="line">                &lt;form action=&quot;/get_yaml/&quot; method=&quot;post&quot; name=&#x27;addyaml&#x27;&gt;</span><br><span class="line">				&lt;!-- form action的意思就是，submit的指向就是/get_yaml/，以post形式传递 --&gt;</span><br><span class="line">                &#123;% csrf_token %&#125;</span><br><span class="line">                API版本：</span><br><span class="line">                &lt;select name=&#x27;apiVersion&#x27;&gt;</span><br><span class="line">                        &lt;option value=&quot;v1&quot; selected&gt;v1&lt;/option&gt;</span><br><span class="line">                        &lt;option value=&quot;extensions/v1beta1&quot;&gt;beta1&lt;/option&gt;</span><br><span class="line">                &lt;/select&gt;&lt;br /&gt;</span><br><span class="line">                任务类型：</span><br><span class="line">                &lt;select name=&#x27;kind&#x27;&gt;</span><br><span class="line">                        &lt;option value=&quot;Pod&quot; selected&gt;Pod&lt;/option&gt;</span><br><span class="line">                        &lt;option value=&quot;Service&quot;&gt;Service&lt;/option&gt;</span><br><span class="line">                        &lt;option value=&quot;Deployment&quot;&gt;Deployment&lt;/option&gt;</span><br><span class="line">                        &lt;option value=&quot;ReplicationController&quot;&gt;ReplicationController&lt;/option&gt;</span><br><span class="line">                &lt;/select&gt;&lt;br /&gt;</span><br><span class="line">                任务名称：&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;&lt;br /&gt;</span><br><span class="line">                任务数量：&lt;input type=&quot;text&quot; placeholder=&quot;请输入阿拉伯数字&quot; name=&quot;replicas&quot; /&gt;&lt;br /&gt;</span><br><span class="line">                APP名称：&lt;input type=&quot;text&quot; placeholder=&quot;对应的APP&quot; name=&quot;labels_app&quot; /&gt;&lt;br /&gt;</span><br><span class="line">                容器1名称：&lt;input type=&quot;text&quot; name=&quot;containers_name&quot; /&gt;&lt;br /&gt;</span><br><span class="line">                容器1镜像：&lt;input type=&quot;text&quot; name=&quot;containers_image&quot; /&gt;&lt;br /&gt;</span><br><span class="line">                容器1开放端口1：&lt;input type=&quot;text&quot; placeholder=&quot;没有可以不填&quot; name=&quot;containerPort1&quot; /&gt;&lt;br /&gt;</span><br><span class="line">                容器1开放端口2：&lt;input type=&quot;text&quot; placeholder=&quot;没有可以不填&quot; name=&quot;containerPort2&quot; /&gt;&lt;br /&gt;</span><br><span class="line">                容器2名称：&lt;input type=&quot;text&quot; placeholder=&quot;没有可以不填&quot; name=&quot;containers_name2&quot; /&gt;&lt;br /&gt;</span><br><span class="line">                容器2镜像：&lt;input type=&quot;text&quot; placeholder=&quot;没有可以不填&quot; name=&quot;containers_image2&quot; /&gt;&lt;br /&gt;</span><br><span class="line">                容器2开放端口1：&lt;input type=&quot;text&quot; placeholder=&quot;没有可以不填&quot; name=&quot;containerPort2_1&quot; /&gt;&lt;br /&gt;</span><br><span class="line">                容器2开放端口2：&lt;input type=&quot;text&quot; placeholder=&quot;没有可以不填&quot; name=&quot;containerPort2_2&quot; /&gt;&lt;br /&gt;</span><br><span class="line">                &lt;input type=&quot;reset&quot; value=&quot;清除所有&quot; /&gt;</span><br><span class="line">                &lt;input type=&quot;submit&quot; value=&quot;生成yaml文件&quot; /&gt;</span><br><span class="line">                &lt;/form&gt;</span><br><span class="line">        &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>写完了之后，再来一个<code>addok.html</code>：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;添加成功&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        * &#123;</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        a&#123;</span><br><span class="line">            text-decoration:none;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;添加成功&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>前端准备完毕。</p>
<h2 id="配置views-py"><a href="#配置views-py" class="headerlink" title="配置views.py"></a>配置views.py</h2><p>views.py里的具体函数是整个django的主心骨，内容如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.<span class="property">shortcuts</span> <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> django.<span class="property">http</span> <span class="keyword">import</span> <span class="title class_">HttpResponse</span>,<span class="title class_">HttpResponseRedirect</span></span><br><span class="line"></span><br><span class="line">def <span class="title function_">create_yaml</span>(request):</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">render</span>(request,<span class="string">&#x27;create_yaml.html&#x27;</span>)	#只是展现一个页面而已</span><br><span class="line"></span><br><span class="line">def <span class="title function_">get_yaml</span>(request):</span><br><span class="line">    <span class="keyword">if</span> request.<span class="property">method</span> == <span class="string">&#x27;POST&#x27;</span>:	#如果是<span class="variable constant_">POST</span>就获取前端传入的值</span><br><span class="line">        apiVersion = request.<span class="property">POST</span>.<span class="title function_">get</span>(<span class="string">&#x27;apiVersion&#x27;</span>,<span class="string">&#x27;v1&#x27;</span>)</span><br><span class="line">        kind = request.<span class="property">POST</span>.<span class="title function_">get</span>(<span class="string">&#x27;kind&#x27;</span>,<span class="string">&#x27;RC&#x27;</span>)</span><br><span class="line">        name = request.<span class="property">POST</span>.<span class="title function_">get</span>(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">        replicas = request.<span class="property">POST</span>.<span class="title function_">get</span>(<span class="string">&#x27;replicas&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        labels_app = request.<span class="property">POST</span>.<span class="title function_">get</span>(<span class="string">&#x27;labels_app&#x27;</span>,<span class="title class_">None</span>)</span><br><span class="line">        containers_name = request.<span class="property">POST</span>.<span class="title function_">get</span>(<span class="string">&#x27;containers_name&#x27;</span>,<span class="title class_">None</span>)</span><br><span class="line">        containers_image = request.<span class="property">POST</span>.<span class="title function_">get</span>(<span class="string">&#x27;containers_image&#x27;</span>,<span class="title class_">None</span>)</span><br><span class="line">        containerPort1 = request.<span class="property">POST</span>.<span class="title function_">get</span>(<span class="string">&#x27;containerPort1&#x27;</span>,<span class="title class_">None</span>)</span><br><span class="line">        containerPort2 = request.<span class="property">POST</span>.<span class="title function_">get</span>(<span class="string">&#x27;containerPort2&#x27;</span>,<span class="title class_">None</span>)</span><br><span class="line">        containers_name2 = request.<span class="property">POST</span>.<span class="title function_">get</span>(<span class="string">&#x27;containers_name2&#x27;</span>,<span class="title class_">None</span>)</span><br><span class="line">        containers_image2 = request.<span class="property">POST</span>.<span class="title function_">get</span>(<span class="string">&#x27;containers_image2&#x27;</span>,<span class="title class_">None</span>)</span><br><span class="line">        containerPort2_1 = request.<span class="property">POST</span>.<span class="title function_">get</span>(<span class="string">&#x27;containerPort2_1&#x27;</span>,<span class="title class_">None</span>)</span><br><span class="line">        containerPort2_2 = request.<span class="property">POST</span>.<span class="title function_">get</span>(<span class="string">&#x27;containerPort2_2&#x27;</span>,<span class="title class_">None</span>)</span><br><span class="line">        signer = request.<span class="property">POST</span>.<span class="title function_">get</span>(<span class="string">&#x27;signer&#x27;</span>, <span class="string">&#x27;Micheal Jackson&#x27;</span>)</span><br><span class="line">    <span class="attr">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">HttpResponse</span>(<span class="string">&#x27;404&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> createyaml.<span class="property">models</span> <span class="keyword">import</span> parameter	#数据库对应项进行赋值</span><br><span class="line">    <span class="title class_">Parameter</span> = <span class="title function_">parameter</span>()</span><br><span class="line">    <span class="title class_">Parameter</span>.<span class="property">apiVersion</span> = apiVersion</span><br><span class="line">    <span class="title class_">Parameter</span>.<span class="property">kind</span> = kind</span><br><span class="line">    <span class="title class_">Parameter</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="title class_">Parameter</span>.<span class="property">replicas</span> = replicas</span><br><span class="line">    <span class="title class_">Parameter</span>.<span class="property">labels_app</span> = labels_app</span><br><span class="line">    <span class="title class_">Parameter</span>.<span class="property">containers_name</span> = containers_name</span><br><span class="line">    <span class="title class_">Parameter</span>.<span class="property">containers_image</span> = containers_image</span><br><span class="line">    <span class="title class_">Parameter</span>.<span class="property">containerPort1</span> = containerPort1</span><br><span class="line">    <span class="title class_">Parameter</span>.<span class="property">containerPort2</span> = containerPort2</span><br><span class="line">    <span class="title class_">Parameter</span>.<span class="property">containers_name2</span> = containers_name2</span><br><span class="line">    <span class="title class_">Parameter</span>.<span class="property">containers_image2</span> = containers_image2</span><br><span class="line">    <span class="title class_">Parameter</span>.<span class="property">containerPort2_1</span> = containerPort2_1</span><br><span class="line">    <span class="title class_">Parameter</span>.<span class="property">containerPort2_2</span> = containerPort2_2</span><br><span class="line">    <span class="title class_">Parameter</span>.<span class="title function_">save</span>()        #保存到数据库里</span><br><span class="line"></span><br><span class="line">    # 重定向到添加成功页面</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">HttpResponseRedirect</span>(<span class="string">&#x27;/addok/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">def <span class="title function_">addok</span>(request):</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">render</span>(request,<span class="string">&#x27;addok.html&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="效果验证"><a href="#效果验证" class="headerlink" title="效果验证"></a>效果验证</h2><p>启动django之后，首先先去admin后台看一下当前的情况，如图：<br><img data-src="/images/django9.png" alt="paradin"></p>
<p>可以看到里面是有几个记录的，那么我们现在登录<code>外网地址:端口/create_yaml</code>，输入一些字段看一下效果：<br><img data-src="/images/django10.gif" alt="paradin"></p>
<p>再返回到admin后台刷新，发现刚才新加的任务已经体现出来了：<br><img data-src="/images/django11.png" alt="paradin"></p>
<p>至此，就达到了“前端html传入数据，后端数据库记录”的效果。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django前端输入变量通过内部脚本加工返回前端展示之七</title>
    <url>/2018/12/04/Django%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E5%AF%86%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<h2 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h2><p>python：<code>3.6.5</code><br>Django：<code>2.1.1</code><br>Project：<code>Kubernetes</code>，文件夹路径就是<code>/django/Kubernetes/</code><br>App：<code>createyaml</code>，文件夹路径就是<code>/django/Kubernetes/createyaml</code><br>前文地址：<a href="https://rorschachchan.github.io/2018/12/03/%E9%A1%B5%E9%9D%A2%E5%B1%80%E9%83%A8%E5%88%B7%E6%96%B0%E5%BE%97%E5%88%B0AES%E5%8A%A0%E5%AF%86%E5%80%BC/">https://rorschachchan.github.io/2018/12/03/%E9%A1%B5%E9%9D%A2%E5%B1%80%E9%83%A8%E5%88%B7%E6%96%B0%E5%BE%97%E5%88%B0AES%E5%8A%A0%E5%AF%86%E5%80%BC/</a></p>
<h2 id="secrets模块"><a href="#secrets模块" class="headerlink" title="secrets模块"></a>secrets模块</h2><p>这个<code>secrets</code>模块是<code>Python 3.6</code>才有的模块，在说它之前，先看一下<code>string.ascii_letters</code>和<code>string.digits</code>，其中<code>ascii_letters</code>是生成所有字母，即a-z和A-Z,而<code>digits</code>是生成所有数字，即0-9,如下：<br><img data-src="/images/django28.png" alt="akb48"></p>
<p>那么他俩搭配<code>secrets</code>模块就可以生成密码，代码如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> secrets,string</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>characters = string.ascii_letters + string.digits + <span class="string">&quot;!@#$%^&amp;*()&#123;&#125;[]~&quot;</span>     <span class="comment">#加入特殊符号</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>password = <span class="string">&#x27;&#x27;</span>.join(secrets.choice(characters) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>))    <span class="comment">#生成一个20位的随机字符串</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>password</span><br><span class="line"><span class="string">&#x27;a%45BW5bxFlN3ylr!!IE&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>password = <span class="string">&#x27;&#x27;</span>.join(secrets.choice(characters) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))     <span class="comment">#生成一个10位的随机字符串</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>password</span><br><span class="line"><span class="string">&#x27;)vqRWYxgxs&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>看上去<code>secrets.choice</code>和<code>random.choice</code>的效果差不多，但是还是有差别的。因为<code>random</code>模块的官方文档清楚的写着<code>该模块完全不适合用作数据加密</code>，而<code>secrets</code>模块不但可以生成安全随机数还可以生成一个笃定长度的随机字符串—-可用作令牌和安全URL。</p>
<p>所以与<code>random</code>模块中的默认伪随机数生成器相比，我们应该优先使用<code>secrets</code>模块！</p>
<h2 id="后台检验输入值合法"><a href="#后台检验输入值合法" class="headerlink" title="后台检验输入值合法"></a>后台检验输入值合法</h2><p>之前的文章，曾经写过在django的<code>views.py</code>里判断输入值是否为空的方法，地址是<a href="https://rorschachchan.github.io/2018/09/26/Django%E4%BD%BF%E7%94%A8form%E8%A1%A8%E5%8D%95%E5%88%A4%E6%96%AD%E8%BE%93%E5%85%A5%E5%80%BC%E6%98%AF%E5%90%A6%E5%90%88%E6%B3%95/">https://rorschachchan.github.io/2018/09/26/Django%E4%BD%BF%E7%94%A8form%E8%A1%A8%E5%8D%95%E5%88%A4%E6%96%AD%E8%BE%93%E5%85%A5%E5%80%BC%E6%98%AF%E5%90%A6%E5%90%88%E6%B3%95/</a> ，但是那套方法毕竟还太粗糙。这一次我们可以通过<code>jQuery+Ajax</code>获取到值，然后进行一个具体的判断，看一下这个值是否是数字，如果不是数字就直接在页面提示“输入非法”，如果是数字，就不会提示。</p>
<p>思路就是先获取到前端传来的值，然后在<code>views.py</code>里增加一个定义，如果值满足定义，就不会有动静，如果值不满足，那么就局部刷新一个页面。</p>
<h2 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h2><p>路由文件<code>urls.py</code>部分如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">开头略</span><br><span class="line">   <span class="title function_">path</span>(r<span class="string">&#x27;mkpasswd/&#x27;</span>,views.<span class="property">make_passwd</span>,name=<span class="string">&#x27;mkpasswd&#x27;</span>),</span><br><span class="line">   <span class="title function_">path</span>(r<span class="string">&#x27;get_mkpasswd/&#x27;</span>,views.<span class="property">get_passwd</span>,name=<span class="string">&#x27;get_passwd&#x27;</span>),</span><br></pre></td></tr></table></figure></p>
<p>配置文件<code>views.py</code>相关部分如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">开头略</span><br><span class="line"><span class="keyword">from</span> django.<span class="property">views</span>.<span class="property">decorators</span>.<span class="property">csrf</span> <span class="keyword">import</span> csrf_exempt</span><br><span class="line"><span class="keyword">import</span> secrets,string</span><br><span class="line"></span><br><span class="line">def <span class="title function_">make_passwd</span>(request):</span><br><span class="line">   <span class="keyword">return</span> <span class="title function_">render</span>(request,<span class="string">&#x27;mkpasswd.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line">@csrf_exempt</span><br><span class="line">def <span class="title function_">get_passwd</span>(request):</span><br><span class="line">	characters = string.<span class="property">ascii_letters</span> + string.<span class="property">digits</span> + <span class="string">&quot;!@#$%^&amp;*()~[]&#123;&#125;=+&quot;</span></span><br><span class="line">   	<span class="keyword">if</span> request.<span class="property">method</span> == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">       	num = request.<span class="property">POST</span>.<span class="title function_">get</span>(<span class="string">&#x27;number&#x27;</span>,<span class="number">20</span>)		#这里得到的是str格式</span><br><span class="line">       	<span class="keyword">if</span> str.<span class="title function_">isdigit</span>(num) is <span class="title class_">False</span>:	#判断是否是数字</span><br><span class="line">       	    <span class="keyword">return</span>  <span class="title class_">HttpResponse</span>(<span class="string">&quot;输入值不合法！必须是数字！&quot;</span>)</span><br><span class="line">       	<span class="attr">else</span>:</span><br><span class="line">       	    result = <span class="string">&#x27;&#x27;</span>.<span class="title function_">join</span>(secrets.<span class="title function_">choice</span>(characters) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="title function_">range</span>(<span class="title function_">int</span>(num)))</span><br><span class="line">       	    <span class="keyword">return</span> <span class="title class_">HttpResponse</span>(result)</span><br><span class="line">   	<span class="attr">else</span>:</span><br><span class="line">       	pass</span><br></pre></td></tr></table></figure></p>
<p>前端页面<code>mkpasswd.html</code>如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">extends</span> <span class="string">&#x27;base.html&#x27;</span> %&#125;</span><br><span class="line">&#123;% block title %&#125;</span><br><span class="line">        创建密码</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">                &#123;% csrf_token %&#125;</span><br><span class="line">                &lt;h2&gt;创建密码&lt;/h2&gt;</span><br><span class="line">                <span class="language-xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>默认密码是20位，并且带有特殊符号<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line">                密码长度：&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;number&quot;</span> /&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line">                <span class="language-xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>生成密码<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">                <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;ask&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">                <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                        $(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                                $(<span class="string">&quot;button&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;  </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                                <span class="keyword">var</span> word=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;number&#x27;</span>).<span class="property">value</span> <span class="comment">//获取输入框的值</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                                        $.<span class="title function_">ajax</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                                        <span class="attr">type</span>:<span class="string">&quot;POST&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                                        <span class="attr">url</span>:<span class="string">&quot;&#123;% url &quot;</span>get_passwd<span class="string">&quot; %&#125;&quot;</span>,              </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                                        <span class="attr">data</span>:&#123;<span class="attr">number</span>:word&#125;,         <span class="comment">//传递参数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                                        <span class="attr">success</span>:<span class="keyword">function</span>(<span class="params">result</span>)&#123;$(<span class="string">&quot;#ask&quot;</span>).<span class="title function_">html</span>(result);&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                                        &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                                &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                        &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后整个的过程执行效果如下：<br><img data-src="/images/django29.gif" alt="akb48"></p>
<h2 id="前端检验输入值合法"><a href="#前端检验输入值合法" class="headerlink" title="前端检验输入值合法"></a>前端检验输入值合法</h2><p>俗话说得好，人生不折腾不舒服斯基。为了更好的体验，现在改一下方略：在用户输入的时候，页面要随时的判断输入值，有错误就直接提醒，这样就不用在提交的时候才告诉用户“输入值非法”了，但是这样的需求就需要更改判断逻辑—-把判断的任务交给<code>jQuery</code>而不是后台，<code>jQuery</code>判断成功了，再把值提交到后台。</p>
<p>要在输入的时候随时判断，那么就要使用<code>jQuery</code>的<code>keydown</code>功能，然后再配上<code>each</code>功能进行遍历。<code>each</code>的用法是<code>$(selector).each(function(index,element))</code>，这里<code>index</code>是选择器的<code>index</code>位置,而<code>element</code>是当前的元素，这两个元素都是必须的！</p>
<p>那么只需要更改的是<code>mkpasswd.html</code>，内容如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;% block content %&#125;</span><br><span class="line">                &#123;% csrf_token %&#125;</span><br><span class="line">                &lt;h2 style=<span class="string">&quot;text-align:center;&quot;</span>&gt;创建密码&lt;/h2&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">                &#123;% csrf_token %&#125;</span><br><span class="line">				&lt;div style=<span class="string">&quot;text-align:center;&quot;</span>&gt;</span><br><span class="line">                <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>创建密码<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>		<span class="comment">//增加了居中效果</span></span><br><span class="line">                <span class="language-xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>默认密码是20位，并且带有特殊符号<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line">                <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>密码长度：<span class="tag">&lt;<span class="name">input</span> <span class="attr">style</span>=<span class="string">&quot;margin: 5px; padding: 10px;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;number&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span>	//调整输入框的长宽</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: red&quot;</span> <span class="attr">id</span>=<span class="string">&quot;error&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span>	//这里是警告出现的位置</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> &gt;</span>生成密码<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;ask&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>	//这里是结果出现的位置</span></span><br><span class="line"><span class="language-xml">				<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">                <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                        $(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                                $(<span class="string">&quot;#number&quot;</span>).<span class="title function_">bind</span>(<span class="string">&#x27;keydown&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;		<span class="comment">//输入就开始检查</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                                $(<span class="string">&#x27;input&#x27;</span>).<span class="title function_">each</span>(<span class="keyword">function</span>(<span class="params">i,n</span>)&#123;	<span class="comment">//进行遍历</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                                        <span class="keyword">var</span> isnum = n.<span class="property">value</span>.<span class="title function_">match</span>(<span class="regexp">/^\d+$/g</span>);	<span class="comment">//匹配正则表达式，是否是数字</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                                        <span class="keyword">if</span>(<span class="literal">null</span> != isnum)&#123;                                                </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">												$(n).<span class="title function_">css</span>(<span class="string">&#x27;border&#x27;</span>,<span class="string">&#x27;2px solid green&#x27;</span>);   <span class="comment">//是数字，边框变为绿色</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                                                <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;error&quot;</span>).<span class="property">innerText</span>=<span class="string">&quot;&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                                                &#125;<span class="keyword">else</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                                                $(n).<span class="title function_">css</span>(<span class="string">&#x27;border&#x27;</span>,<span class="string">&#x27;2px solid red&#x27;</span>);     <span class="comment">//不是数字，边框变为红色作为警告                                           </span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">												<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;error&quot;</span>).<span class="property">innerText</span>=<span class="string">&quot;输入值必须是数字！&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                                                &#125; </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                                                &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                                               &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                                $(<span class="string">&quot;button&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;  		<span class="comment">//配置点击动作</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                                <span class="keyword">var</span> word=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;number&#x27;</span>).<span class="property">value</span>	 <span class="comment">//获取输入框的值</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                                        $.<span class="title function_">ajax</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                                        <span class="attr">type</span>:<span class="string">&quot;POST&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                                        <span class="attr">url</span>:<span class="string">&quot;&#123;% url &quot;</span>get_passwd<span class="string">&quot; %&#125;&quot;</span>,              </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                                        <span class="attr">data</span>:&#123;<span class="attr">number</span>:word&#125;,         <span class="comment">//传递参数！！！！ </span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                                        <span class="attr">success</span>:<span class="keyword">function</span>(<span class="params">result</span>)&#123;$(<span class="string">&quot;#ask&quot;</span>).<span class="title function_">html</span>(result);&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                                        &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                                &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                        &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p>
<p>整改之后的效果如下：<br><img data-src="/images/django30.gif" alt="akb48"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.blog.pythonlibrary.org/2017/02/16/pythons-new-secrets-module/">http://www.blog.pythonlibrary.org/2017/02/16/pythons-new-secrets-module/</a><br><a href="https://www.cnblogs.com/yyds/p/7072492.html">https://www.cnblogs.com/yyds/p/7072492.html</a><br><a href="http://qindongliang.iteye.com/blog/2147336">http://qindongliang.iteye.com/blog/2147336</a><br><a href="https://segmentfault.com/q/1010000002760528">https://segmentfault.com/q/1010000002760528</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>Jquery</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>Django前端输入变量通过内部脚本加工返回前端展示之四</title>
    <url>/2018/11/24/Django%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%E5%8F%8D%E9%A6%88%E5%88%B0%E5%89%8D%E7%AB%AF%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<h2 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h2><p>python：<code>3.6.5</code><br>Django：<code>2.1.1</code><br>Project：<code>Kubernetes</code>，文件夹路径就是<code>/django/Kubernetes/</code><br>App：<code>createyaml</code>，文件夹路径就是<code>/django/Kubernetes/createyaml</code><br>前文地址：<a href="https://rorschachchan.github.io/2018/09/26/Django%E4%BD%BF%E7%94%A8form%E8%A1%A8%E5%8D%95%E5%88%A4%E6%96%AD%E8%BE%93%E5%85%A5%E5%80%BC%E6%98%AF%E5%90%A6%E5%90%88%E6%B3%95/">https://rorschachchan.github.io/2018/09/26/Django%E4%BD%BF%E7%94%A8form%E8%A1%A8%E5%8D%95%E5%88%A4%E6%96%AD%E8%BE%93%E5%85%A5%E5%80%BC%E6%98%AF%E5%90%A6%E5%90%88%E6%B3%95/</a></p>
<h2 id="需求说明"><a href="#需求说明" class="headerlink" title="需求说明"></a>需求说明</h2><p>之前我们已经达到了“页面判断输入值是否合法”，“页面输入值录入数据库”这两个目的，现在就到了重头戏–网页上点击按钮，然后调用后台python脚本，并且把脚本的结果反馈到网页端。</p>
<p>我们本次使用一个加密的python脚本<code>encrypt.py</code>，它主要得作用是输入某个字段，然后进行AES256加密，然后把加密结果返回给界面，整个脚本内容如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/usr/</span>bin/env python</span><br><span class="line">#coding=utf-<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="title class_">AESWord</span> = <span class="title function_">input</span>(<span class="string">&quot;输入字段：&quot;</span>)</span><br><span class="line">result = <span class="title function_">list</span>(subprocess.<span class="title function_">getstatusoutput</span>(<span class="string">&quot;java -jar /yunwei/AES/aesEncrpt.jar &quot;</span>+<span class="title class_">AESWord</span>))[<span class="number">1</span>].<span class="title function_">split</span>(<span class="string">&quot;=&quot;</span>)[<span class="number">1</span>]</span><br><span class="line"><span class="title function_">print</span> (<span class="title class_">AESWord</span>+ <span class="string">&quot;的加密结果是：&quot;</span>+(result))</span><br></pre></td></tr></table></figure></p>
<p>脚本执行效果如下：<br><img data-src="/images/django23.png" alt="akb48"></p>
<h2 id="笨方法解决"><a href="#笨方法解决" class="headerlink" title="笨方法解决"></a>笨方法解决</h2><p>前端的页面内容如下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% extends &#x27;base.html&#x27; %&#125;	#这部分是引入base.html这个模板</span><br><span class="line">&#123;% block title %&#125;</span><br><span class="line">        AES加密</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">                &lt;form action=&quot;/k8s/encrypt/&quot; method=&quot;post&quot; name=&#x27;encrypt&#x27;&gt;	</span><br><span class="line">                &#123;% csrf_token %&#125;</span><br><span class="line">                要加密的字段：&lt;input type=&quot;text&quot; name=&quot;AESWord&quot; /&gt;&lt;br /&gt;</span><br><span class="line">                &lt;input type=&quot;reset&quot; value=&quot;清除所有&quot; /&gt;</span><br><span class="line">                &lt;input type=&quot;submit&quot; value=&quot;查询解析&quot; /&gt;</span><br><span class="line">                &lt;/form&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p>
<p>目前已知<code>views.py</code>里使用<code>request.POST.get()</code>方法是可以捕获到前端输入值，但是这个输入值怎么传递给<code>encrypt.py</code>呢？这一点非常的复杂。</p>
<p>可能这个时候很多人会想使用“外部脚本引入django系统”的方法，但是那个方法可以引用到数据库，但是无法引用<code>views.py</code>里的函数的变量。于是只能用一个笨招：<strong>先把前端输入值记录到本地某个文件里，然后<code>encrypt.py</code>去读取这个文件，这样达到获取变量的方法。</strong></p>
<p>于是<code>views.py</code>里的相关部分就是这样：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">前面略</span><br><span class="line">def <span class="title function_">encrypt</span>(request):</span><br><span class="line">    <span class="keyword">if</span> request.<span class="property">method</span> == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        <span class="title class_">AESWord</span> = request.<span class="property">POST</span>.<span class="title function_">get</span>(<span class="string">&#x27;AESWord&#x27;</span>)</span><br><span class="line">        <span class="keyword">with</span> <span class="title function_">open</span>(<span class="string">&#x27;/yunwei/AES/AESWord.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> <span class="attr">f</span>:		#把前端获取到的值记录到本地的<span class="title class_">AESWord</span>.<span class="property">txt</span>文件里</span><br><span class="line">            f.<span class="title function_">write</span>(<span class="title class_">AESWord</span>+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        child = subprocess.<span class="title class_">Popen</span>(<span class="string">&#x27;python /yunwei/AES/Encrypt.py&#x27;</span>,stdout=subprocess.<span class="property">PIPE</span>, stderr=subprocess.<span class="property">PIPE</span>,shell=<span class="title class_">True</span>)	</span><br><span class="line">        stdout, stderr = child.<span class="title function_">communicate</span>()</span><br><span class="line">        result = <span class="title function_">str</span>(stdout,encoding=<span class="string">&#x27;utf-8&#x27;</span>)	#将脚本反馈的结果输入result</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">HttpResponse</span>(result)			#页面展示result</span><br><span class="line">    <span class="attr">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">render</span>(request,<span class="string">&#x27;encrypt.html&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>而<code>encrypt.py</code>内容改成如下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">#coding=utf-8</span><br><span class="line"></span><br><span class="line">import linecache,subprocess</span><br><span class="line">AESWord = linecache.getline(&#x27;/yunwei/AES/AESWord.txt&#x27;,1).strip(&#x27;\n&#x27;)	#在这里读取前端的变量</span><br><span class="line">result = list(subprocess.getstatusoutput(&quot;java -jar /yunwei/AES/aesEncrpt.jar &quot;+AESWord))[1].split(&quot;=&quot;)[1]</span><br><span class="line">print (AESWord+ &quot;的加密结果是：&quot;+(result))</span><br></pre></td></tr></table></figure></p>
<p>执行效果如下：<br><img data-src="/images/django24.gif" alt="akb48"></p>
<p>这样的操作达到了目的！后期就是把<code>result</code>使用<code>render</code>加工映射到某个网页，页面就好看很多了。</p>
<h2 id="js-ajax方法解决"><a href="#js-ajax方法解决" class="headerlink" title="js+ajax方法解决"></a>js+ajax方法解决</h2><p>上面的方法虽然可以达到我们想要的目的，但是其实是十分不推荐的：一是因为网页调用本地程序的权限正在被取消，二是因为真不如JS写直接，三是只能在自己本地调用。</p>
<p>所以还是用前端来解决更专业更优雅，那么就要使用js+ajax。</p>
<p>具体内容下次补充…</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>在外部脚本引入django系统的方法就是在外部脚本的开头加上下面的内容：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/usr/</span>bin/env python</span><br><span class="line">#coding=utf-<span class="number">8</span></span><br><span class="line"><span class="keyword">import</span> os,sys,django</span><br><span class="line">sys.<span class="property">path</span>.<span class="title function_">append</span>(<span class="string">&#x27;/django/Kubernetes/&#x27;</span>) # 将项目路径添加到系统搜寻路径当中</span><br><span class="line">os.<span class="property">environ</span>[<span class="string">&#x27;DJANGO_SETTINGS_MODULE&#x27;</span>] = <span class="string">&#x27;Kubernetes.settings&#x27;</span> # 设置项目的配置文件</span><br><span class="line"></span><br><span class="line">django.<span class="title function_">setup</span>()</span><br><span class="line"><span class="keyword">from</span> createyaml.<span class="property">models</span> <span class="keyword">import</span> parameter		#这样就可以引入models.<span class="property">py</span>文件里的parameter这个类</span><br></pre></td></tr></table></figure><br>但是上面说过，这个方法可以引入数据库<code>models.py</code>文件，并不能引入<code>views.py</code>文件。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://stackoverflow.com/questions/15151133/execute-a-python-script-on-button-click">https://stackoverflow.com/questions/15151133/execute-a-python-script-on-button-click</a><br><a href="https://blog.csdn.net/yzy_1996/article/details/80223053">https://blog.csdn.net/yzy_1996/article/details/80223053</a><br><a href="https://simpleisbetterthancomplex.com/tutorial/2016/08/29/how-to-work-with-ajax-request-with-django.html">https://simpleisbetterthancomplex.com/tutorial/2016/08/29/how-to-work-with-ajax-request-with-django.html</a><br><a href="https://www.candypapi.com/2017/11/02/Python-external-script-calls-the-Django-project-model-table/">https://www.candypapi.com/2017/11/02/Python-external-script-calls-the-Django-project-model-table/</a><br><a href="https://segmentfault.com/q/1010000005096919">https://segmentfault.com/q/1010000005096919</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django前端传入excel表格并将表格数据记录到MySQL里</title>
    <url>/2020/04/26/Django%E5%89%8D%E7%AB%AF%E4%BC%A0%E5%85%A5excel%E5%B9%B6%E5%B0%86%E5%AD%97%E6%AE%B5%E4%BF%9D%E5%AD%98MySQL/</url>
    <content><![CDATA[<h2 id="背景交代"><a href="#背景交代" class="headerlink" title="背景交代"></a>背景交代</h2><p>Django最简单的用途，就是在前台页面展示mysql的数据。为了提高录入效率，我们使用Excel上传文件的形式，这样事前在Excel里先按照格式准备好数据，然后前端做一个“上传”的功能，就可以进行解析各数据并且保存到Mysql里了。</p>
<p>先交代软件版本:<code>Django 2.1.8</code>和<code>Python 3.6</code>,project的名字是<code>naxx</code>，App名称是<code>naxxramas</code>，整个目录结构如下：<br><img data-src="/images/excel-mysql2.png" alt="akb48"></p>
<h2 id="配置URL和view"><a href="#配置URL和view" class="headerlink" title="配置URL和view"></a>配置URL和view</h2><p>。然后需要安装一个插件：<code>pip install openpyxl==2.5.1</code></p>
<p>然后我们在Excel里先加上两组数据，如下：<br><img data-src="/images/excel-mysql1.png" alt="akb48" title="这里面记录的是攻防演习的数据"></p>
<p>先说明一下我这里的urls.py，我在project层的urls.py里给路径做了特别设置，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from django.urls import path, include</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;admin/&#x27;, admin.site.urls),    #后台</span><br><span class="line">    path(r&#x27;naxx/&#x27;, include(&#x27;naxxramas.urls&#x27;)),  #naxx的单独去naxxramas里的`urls.py`里配置</span><br><span class="line">    path(&#x27;&#x27;, views.portal, name=&#x27;portal&#x27;),  #主页</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>naxxramas里面的<code>urls.py</code>的配置是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.urls import path</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;excel-practice&#x27;, views.excelupdate, name=&quot;excel-practice&quot;),  #录入资损攻防数据页面</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>然后来写<code>naxxramas/views.py</code>里的<code>excelupdate</code>函数:<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.shortcuts import render_to_response, get_object_or_404</span><br><span class="line">from django.views.decorators.csrf import csrf_exempt</span><br><span class="line">from .models import BlueArmy, STAPractice, CAPPractice</span><br><span class="line">import openpyxl</span><br><span class="line"></span><br><span class="line"># excel上传文件录入</span><br><span class="line">@csrf_exempt</span><br><span class="line">def excelupdate(request):</span><br><span class="line">    if &quot;GET&quot; == request.method:</span><br><span class="line">        return render_to_response(&#x27;excel-practice.html&#x27;)</span><br><span class="line">    else:</span><br><span class="line">        excel_file = request.FILES[&quot;excel_file&quot;]</span><br><span class="line">        wb = openpyxl.load_workbook(excel_file)</span><br><span class="line">        worksheet = wb[&quot;Sheet1&quot;]</span><br><span class="line"></span><br><span class="line">        excel_data = list()  # 效果等同于 excel_data = []</span><br><span class="line">        for row in worksheet.iter_rows():</span><br><span class="line">            row_data = list()</span><br><span class="line">            for cell in row:</span><br><span class="line">                row_data.append(str(cell.value))</span><br><span class="line"></span><br><span class="line">            if str(excel_file).find(&quot;可用性攻防&quot;) &gt; 0:  # 如果上传的excel名称是带有“可用性攻防”的</span><br><span class="line">                practice_date, redarmy, practice_scene, app, reach1, reach5, reach10, scene_level, workdomain, bluearmy = row_data</span><br><span class="line">                STAPractice.objects.create(		# 这里就把Excel的值按列一一录入到models</span><br><span class="line">                    date=practice_date,</span><br><span class="line">                    practice_scene=practice_scene,</span><br><span class="line">                    oneok=reach1,</span><br><span class="line">                    fiveok=reach5,</span><br><span class="line">                    tenok=reach10,</span><br><span class="line">                    workdomain=workdomain,</span><br><span class="line">                    bluearmy=BlueArmy.objects.get(army_name=bluearmy),</span><br><span class="line">                    redarmy=redarmy,</span><br><span class="line">                    app=app,</span><br><span class="line">                    scene_level=scene_level</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">            elif str(excel_file).find(&quot;资损攻防&quot;) &gt; 0:	#如果上传的excel名称是带有“资损攻防”的</span><br><span class="line">                practice_date, redarmy, practice_scene, app, scene_level, blueok, redok, practice_time, workdomain, bluearmy = row_data</span><br><span class="line">                CAPPractice.objects.create(</span><br><span class="line">                    date=practice_date,</span><br><span class="line">                    practice_scene=practice_scene,</span><br><span class="line">                    redok=redok,</span><br><span class="line">                    blueok=blueok,</span><br><span class="line">                    scene_level=scene_level,</span><br><span class="line">                    workdomain=workdomain,</span><br><span class="line">                    bluearmy=BlueArmy.objects.get(army_name=bluearmy),  # 关联外键的写法，注意这里要跟外键默认的值匹配，不然会报错</span><br><span class="line">                    redarmy=redarmy,</span><br><span class="line">                    app=app,</span><br><span class="line">                    practice_time=practice_time</span><br><span class="line">                )</span><br><span class="line">            else:</span><br><span class="line">                pass</span><br><span class="line">            excel_data.append(row_data)</span><br><span class="line">    return render_to_response(&#x27;excel-practice.html&#x27;, &#123;&quot;excel_data&quot;: excel_data&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="写前端"><a href="#写前端" class="headerlink" title="写前端"></a>写前端</h2><p>上面的<code>views.py</code>里我们规定前端页面是<code>excel-practice.html</code>，我这个HTML页面是基于adminLTE上改造的：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% extends &#x27;naxx-base.html&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block title %&#125;</span><br><span class="line">  阿里供应链平台 | Excel批量数据录入</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">  &lt;!-- Content Wrapper. Contains page content --&gt;</span><br><span class="line">  &lt;div class=&quot;content-wrapper&quot;&gt;</span><br><span class="line">    &lt;!-- Content Header (Page header) --&gt;</span><br><span class="line">    &lt;section class=&quot;content-header&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;container-fluid&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;row mb-2&quot;&gt;</span><br><span class="line">          &lt;div class=&quot;col-sm-6&quot;&gt;</span><br><span class="line">            &lt;h1&gt;Excel录入攻防情况&lt;/h1&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">          &lt;div class=&quot;col-sm-6&quot;&gt;</span><br><span class="line">            &lt;ol class=&quot;breadcrumb float-sm-right&quot;&gt;</span><br><span class="line">              &lt;li class=&quot;breadcrumb-item&quot;&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">              &lt;li class=&quot;breadcrumb-item active&quot;&gt;Excel录入&lt;/li&gt;</span><br><span class="line">            &lt;/ol&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;&lt;!-- /.container-fluid --&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Main content --&gt;</span><br><span class="line">    &lt;section class=&quot;content&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;container-fluid&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;row&quot;&gt;</span><br><span class="line">          &lt;!-- left column --&gt;</span><br><span class="line">          &lt;div class=&quot;col-md-12&quot;&gt;</span><br><span class="line">            &lt;!-- general form elements --&gt;</span><br><span class="line">            &lt;div class=&quot;card card-primary&quot;&gt;</span><br><span class="line">              &lt;div class=&quot;card-header&quot;&gt;</span><br><span class="line">                &lt;h3 class=&quot;card-title&quot;&gt;上传对应表格文件&lt;/h3&gt;</span><br><span class="line">              &lt;/div&gt;</span><br><span class="line">              &lt;!-- /.card-header --&gt;</span><br><span class="line">              &lt;!-- form start --&gt;</span><br><span class="line">              &lt;form role=&quot;form&quot; enctype=&quot;multipart/form-data&quot; action=&quot;&#123;% url &quot;excel-practice&quot; %&#125;&quot; method=&quot;post&quot;&gt;</span><br><span class="line">                &lt;div class=&quot;card-body&quot;&gt;</span><br><span class="line">                  &lt;div class=&quot;form-group&quot;&gt;</span><br><span class="line">                    &lt;label for=&quot;exampleInputFile&quot;&gt;File input&lt;/label&gt;</span><br><span class="line">                    &lt;div class=&quot;input-group&quot;&gt;</span><br><span class="line">                      &lt;div class=&quot;custom-file&quot;&gt;</span><br><span class="line">                        &#123;% csrf_token %&#125;</span><br><span class="line">                        &lt;input type=&quot;file&quot; class=&quot;custom-file-input&quot; title=&quot;Upload excel file&quot; name=&quot;excel_file&quot; required=&quot;required&quot;&gt;</span><br><span class="line">                        &lt;label class=&quot;custom-file-label&quot; for=&quot;exampleInputFile&quot;&gt;Choose file&lt;/label&gt;</span><br><span class="line">                      &lt;/div&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                  &lt;/div&gt;</span><br><span class="line">                 &lt;h&gt; 注意！上传的Excel是有格式的，具体格式请去咨询桃熙&lt;/h&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">                &lt;!-- /.card-body --&gt;</span><br><span class="line"></span><br><span class="line">                &lt;div class=&quot;card-footer&quot;&gt;</span><br><span class="line">                  &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;确认提交&lt;/button&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">              &lt;/form&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;!-- /.card --&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">          &lt;!-- /.card-body --&gt;</span><br><span class="line">          &lt;table border=&quot;1&quot;&gt;</span><br><span class="line">           &lt;tr&gt;</span><br><span class="line">            &#123;% for row in excel_data %&#125;</span><br><span class="line">              &#123;% for cell in row %&#125;</span><br><span class="line">                &lt;table border=&quot;1&quot;&gt;</span><br><span class="line">                &lt;tr&gt;               </span><br><span class="line">               &lt;td&gt; &#123;&#123; cell &#125;&#125;&amp;nbsp;&amp;nbsp; &lt;/td&gt;</span><br><span class="line">              &#123;% endfor %&#125;</span><br><span class="line">            &#123;% endfor %&#125;</span><br><span class="line">           &lt;/tr&gt;</span><br><span class="line">          &lt;/table&gt;</span><br><span class="line">         &lt;br&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;!-- /.card --&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;!--/.col (right) --&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">    &lt;!-- /.content --&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;!-- /.content-wrapper --&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p>
<p>整个效果如下：<br><img data-src="/images/excel-mysql3.png" alt="akb48"></p>
<p>到时候直接传入Excel然后上传就好了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.pythoncircle.com/post/591/how-to-upload-and-process-the-excel-file-in-django/">https://www.pythoncircle.com/post/591/how-to-upload-and-process-the-excel-file-in-django/</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>Django</tag>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title>Django如何将timestamp时间戳在template改成时间</title>
    <url>/2020/08/25/Django%E5%A6%82%E4%BD%95%E5%B0%86timestamp%E6%97%B6%E9%97%B4%E6%88%B3%E5%9C%A8template%E6%94%B9%E6%88%90%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<p>先说一下配置：<br>Django:<code>2.1.8</code><br>Python:<code>3.6.4</code><br>project的名称是:<code>naxx</code><br>APP的名称是:<code>naxxramas</code></p>
<h2 id="template的除法与as"><a href="#template的除法与as" class="headerlink" title="template的除法与as"></a>template的除法与as</h2><p>我们在用Django搭配平台API的时候，经常会得到各种各样形式的数据。那么<code>views.py</code>获取到这些数据之后，需要通过<code>template</code>向前端展示。但是往往由于API数据的格式多种多样，比如API提供的是时间戳timestamp，而前端需要展示的是可读的时间，这种变化怎么办？</p>
<p>比如我们公司的一个监控系统，对外暴露的API格式如下：<br>	<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;attends&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="attr">&quot;metadata&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="attr">&quot;result&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span><span class="number">1598369220000</span><span class="punctuation">,</span><span class="attr">&quot;avg_cpu&quot;</span><span class="punctuation">:</span><span class="number">1.6593</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span><span class="number">1598369280000</span><span class="punctuation">,</span><span class="attr">&quot;avg_cpu&quot;</span><span class="punctuation">:</span><span class="number">1.6854</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span><span class="number">1598369340000</span><span class="punctuation">,</span><span class="attr">&quot;avg_cpu&quot;</span><span class="punctuation">:</span><span class="number">1.6552</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span><span class="number">1598369400000</span><span class="punctuation">,</span><span class="attr">&quot;avg_cpu&quot;</span><span class="punctuation">:</span><span class="number">1.7705</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;success&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span><span class="attr">&quot;totalCount&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>可以看出返回的是某个应用最近5分钟的CPU情况。那么如果要展示到前端，就需要对<code>timestamp</code>进行二次加工。原来的代码是：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">for</span> app <span class="keyword">in</span> data %&#125;</span><br><span class="line">	&#123;&#123; app.timestamp &#125;&#125;</span><br><span class="line">	&#123;&#123; app.avg_cpu &#125;&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先第一步，<code>timestamp</code>这个值并不是一个正确的时间戳，如图：<br><img data-src="/images/%E9%94%99%E8%AF%AF%E7%9A%84%E6%97%B6%E9%97%B4%E6%88%B3.png" alt="akb48" title="这都5万多年了..."></p>
<p>可见它是真实时间戳的1000倍，所以我们要先将其除以1000。那么更改代码如下：<br><img data-src="/images/widthratio.png" alt="akb48" title="hexo识别widthratio报错，只能用图片了"></p>
<p>这里就达到了将原来<code>app.timestamp</code>除以1000的效果。但是要注意，这样就不能继续加工了，即在后面加上<code>|date:&quot;D d M Y&quot; %}</code>这个过滤器是会报错的，因为<code>widthratio</code>只能接受int类型。</p>
<p>既然这样，我们就中转一下使用<code>as</code>，改成这样:<br><img data-src="/images/widthratio2.png" alt="akb48" title="hexo识别widthratio报错，只能用图片了"></p>
<p>这里通过<code>as</code>来解决问题，先用除法将结果赋予<code>timestamp</code>，然后再对<code>timestamp</code>进行<code>print_timestamp</code>的加工展示。</p>
<h2 id="自定义template过滤器"><a href="#自定义template过滤器" class="headerlink" title="自定义template过滤器"></a>自定义template过滤器</h2><p>在上面那个例子里，我用了<code>print_timestamp</code>这个模板过滤器，这是一个自定义的过滤器，因为Django2目前没有官方的时间戳转时间的过滤器。所以就要手写一个，手写的过程如下：</p>
<p>首先现在你的App文件夹里，创建一个空文件夹<code>templatetags</code>，里面先创建一个空文件<code>__init__.py</code>。这个空文件的作用就是相当于把自身整个文件夹当作一个包来管理，每当有外部import的时候，就会自动执行里面的函数。</p>
<p>然后再创建一个叫<code>timetages.py</code>的文件，内容如下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django import template</span><br><span class="line">import datetime</span><br><span class="line">register = template.Library()</span><br><span class="line"></span><br><span class="line">def print_timestamp(timestamp):</span><br><span class="line">       try:</span><br><span class="line">           #assume, that timestamp is given in seconds with decimal point</span><br><span class="line">           ts = float(timestamp)</span><br><span class="line">       except ValueError:</span><br><span class="line">           return None</span><br><span class="line">       return datetime.datetime.fromtimestamp(ts)</span><br><span class="line"></span><br><span class="line">register.filter(print_timestamp)</span><br></pre></td></tr></table></figure></p>
<p>如果你要精确到小时分秒这个级别的话，上面的代码就要对应补充和修改一下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line">def print_timestamp(timestamp):</span><br><span class="line">       ...</span><br><span class="line">       #specify format here</span><br><span class="line">       return time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.gmtime(ts))</span><br></pre></td></tr></table></figure></p>
<p>然后在对应的html文件里，添加<code>load 文件名</code>，注意是文件名不是文件里的函数名，如图：<br><img data-src="/images/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%87%E6%BB%A4%E5%99%A8.png" alt="akb48" title="加到这里就可以了"></p>
<p>此时我们自定义的<code>print_timestamp</code>函数就OK了，重启一下django，一定要重启，看看效果吧！<br><img data-src="/images/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%87%E6%BB%A4%E5%99%A82.png" alt="akb48" title="还有很多功能没完成呢..."></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/u011181633/article/details/79337369">https://blog.csdn.net/u011181633/article/details/79337369</a><br><a href="https://stackoverflow.com/questions/10715253/display-timestamp-in-django-template">https://stackoverflow.com/questions/10715253/display-timestamp-in-django-template</a><br><img data-src="/images/tifa.gif" alt="akb48" title="这个蒂法做的很棒"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>平台搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Django前端实现数据库删除修改操作</title>
    <url>/2020/07/13/Django%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%A0%E9%99%A4%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>Django读取数据库信息并且展示出来的时候，往往都需要一个“编辑”和“删除”按钮来通过前台修改数据。那么这里面就涉及几个点：<br>1.通过点击“编辑”button，会出来一个新的页面或者是在原有的页面出一个弹窗；<br>2.获取到要修改的数据的主键；<br>3.在修改页面上要在input里直接有要修改的数值，这样方便直接修改；</p>
<h2 id="编辑功能"><a href="#编辑功能" class="headerlink" title="编辑功能"></a>编辑功能</h2><p>首先我们先确定，要通过点击“修改”这个button会跳到一个新的页面上。那么这个页面的地址就在button里的<code>href</code>属性里写明，这里用了<code>?id=数据库主键</code>这样的url，表格相关html内容如下：<br>	<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 给这个表格起ID叫project-table --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">&quot;project-table&quot;</span> <span class="attr">class</span>=<span class="string">&quot;table table-bordered table-striped&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>大促名称<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>供应链PM<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>集团压测负责人<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>操作<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    &#123;% for activity in activities %&#125;	//这一部分是views.py里传过来的</span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; activity.promotionname &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span>	//这些也是models.py里指定的</span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; activity.pm &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; activity.modelbuilder &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/naxx/update_activity/?id=&#123;&#123; activity.id &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">button</span> <span class="attr">id</span>=<span class="string">&quot;updateBtn&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-danger&quot;</span> <span class="attr">value</span>=<span class="string">&quot;修改&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这里需要把herf里url添加到后台里，那么就在<code>urls.py</code>里添加一条对应的记录：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">	...	<span class="comment"># 默认略</span></span><br><span class="line">    path(<span class="string">&#x27;naxx/update_activity/&#x27;</span>, views.update_activity, name=<span class="string">&#x27;update_activity&#x27;</span>) <span class="comment"># 修改大促数据</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>这里注意，<code>urls.py</code>还是按照普通的样式配置的，因为在<code>views.py</code>里我们会通过<code>request.GET.get(&#39;id&#39;)</code>获取到<code>?=</code>的<code>id</code>，那么这个<code>id</code>也就是数据库的主键。同时还要注意，这个后面是有<code>/</code>的，如果没有就会报路由错误。</p>
<p>然后就写一个<code>/naxx/update_activity</code>的界面吧，相关展示的地方如下：<br>	<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">role</span>=<span class="string">&quot;form&quot;</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card-body&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;form-inline&quot;</span>&gt;</span>大促名称：<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;project_name&quot;</span> <span class="attr">id</span>=<span class="string">&quot;project_name&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123; obj.promotionname &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;form-inline&quot;</span>&gt;</span>大促总PM：<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;ascppm&quot;</span> <span class="attr">id</span>=<span class="string">&quot;ascppm&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123; obj.pm &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;form-inline&quot;</span>&gt;</span>集团压测负责人：<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;stressman&quot;</span> <span class="attr">id</span>=<span class="string">&quot;stressman&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123; obj.modelbuilder &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- /.card-body --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card-footer&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span>&gt;</span>提交到数据库<span class="tag">&lt;/<span class="name">button</span>&gt;</span> &#123;&#123; error &#125;&#125;</span><br><span class="line">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>对应的<code>views.py</code>如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render_to_response, redirect</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Promotion  <span class="comment">#这个是对应的models.py的数据class</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改信息</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update_activity</span>(<span class="params">request</span>):</span><br><span class="line">    error = <span class="string">&#x27;&#x27;</span>  <span class="comment"># 错误提示</span></span><br><span class="line">    activity_pk = request.GET.get(<span class="string">&#x27;id&#x27;</span>)		<span class="comment">#因为url上是?id=XXX，所以这里要写id</span></span><br><span class="line">    activity_list = Promotion.objects.<span class="built_in">filter</span>(pk=activity_pk)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> activity_list:</span><br><span class="line">        <span class="keyword">return</span> render_to_response(<span class="string">&#x27;404.html&#x27;</span>)   <span class="comment"># 如果ID找不到就返回404页面</span></span><br><span class="line">    obj = activity_list[<span class="number">0</span>]      <span class="comment"># 获取到ID号</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        obj.promotionname = request.POST.get(<span class="string">&quot;project_name&quot;</span>, <span class="literal">None</span>)		<span class="comment">#这里的.字段是models.py里配置好的</span></span><br><span class="line">        obj.pm = request.POST.get(<span class="string">&quot;ascppm&quot;</span>, <span class="literal">None</span>)</span><br><span class="line">        obj.modelbuilder = request.POST.get(<span class="string">&quot;stressman&quot;</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">all</span>([obj.promotionname, obj.pm, obj.modelbuilder]):     <span class="comment"># 判断获取到的值同时不为空</span></span><br><span class="line">            obj.save()  <span class="comment"># 保存到数据库里</span></span><br><span class="line">            <span class="keyword">return</span> redirect(<span class="string">&#x27;/naxx/activity&#x27;</span>)       <span class="comment"># 使用redirect如果后面直接加.html就是在原有路径上加，所以这直接写路径，注意后面没有/</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            error = <span class="string">&quot;有数据为空，请重新检查&quot;</span></span><br><span class="line">    <span class="keyword">return</span> render_to_response(<span class="string">&#x27;update_activity.html&#x27;</span>,&#123;<span class="string">&#x27;obj&#x27;</span>: obj, <span class="string">&#x27;error&#x27;</span>:error&#125;)</span><br></pre></td></tr></table></figure></p>
<p>看一下<code>views.py</code>里已经写得很明白了，首先先从url里通过<code>request.GET.get</code>获取到id，那么通过<code>objects.filter</code>去查到对应的数据信息，然后将这些信息反映到<code>/naxx/update_activity</code>的界面，直接作为<code>value</code>展示。如果post，那么就获取到对应新的合法信息，重新save到数据库里，同时页面跳转回数据展示页面。如果有发现为空的信息，那么就在<code>/naxx/update_activity</code>的界面里的<code>error</code>提示“有数据为空，请重新检查”。整体的效果如下：<br><img data-src="/images/%E5%89%8D%E5%8F%B0%E6%9B%B4%E6%94%B9%E6%95%B0%E6%8D%AE.gif" alt="akb48" title="更改“韩当”保存到数据库"></p>
<h2 id="删除功能"><a href="#删除功能" class="headerlink" title="删除功能"></a>删除功能</h2><p>如果编辑功能搞定了，那删除就很简单了:拿到<code>id</code>之后，调用<code>objects.filter(id=activity_pk).delete()</code>就删除掉了，然后跳转回数据展示页面即可。</p>
<p>说详细点，比如你在HTML里的删除button是这么写的：<br>	<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-danger btn-sm&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/naxx/delete_event/?id=&#123;&#123; event.id &#125;&#125;&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fas fa-trash&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">         删除</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>那么在<code>views.py</code>里对应的方法就是：<br>	 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">del_event</span>(<span class="params">request</span>):</span><br><span class="line">	event_pk = request.GET.get(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">	Event.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=event_pk).delete()  <span class="comment"># 在Event这个表里执行删除操作</span></span><br><span class="line">	<span class="keyword">return</span> render_to_response(<span class="string">&#x27;XXX.html&#x27;</span>)	<span class="comment"># 返回某某页面</span></span><br></pre></td></tr></table></figure></p>
<p>至此，编辑和删除都搞定了！</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/Panda_Murong/article/details/78894388">https://blog.csdn.net/Panda_Murong/article/details/78894388</a><br><a href="https://www.cnblogs.com/machangwei-8/p/11016524.html">https://www.cnblogs.com/machangwei-8/p/11016524.html</a><br><a href="https://blog.csdn.net/zimu_2080/article/details/89470030">https://blog.csdn.net/zimu_2080/article/details/89470030</a><br><a href="https://www.cnblogs.com/gcgc/p/11176389.html">https://www.cnblogs.com/gcgc/p/11176389.html</a><br><a href="https://blog.csdn.net/cf313995/article/details/83105037">https://blog.csdn.net/cf313995/article/details/83105037</a> （路由传递参数的文章）</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>平台搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Django实现文件上传功能</title>
    <url>/2018/12/19/Django%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>python：<code>3.6.5</code><br>Django：<code>2.1.1</code><br>执行<code>pip install pillow</code>，安装python图片处理库pillow</p>
<h2 id="图片单张上传"><a href="#图片单张上传" class="headerlink" title="图片单张上传"></a>图片单张上传</h2><p>首先先修改一下<code>setting.py</code>，添加如下两行代码：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MEDIA_URL = <span class="string">&#x27;/media/&#x27;</span></span><br><span class="line">MEDIA_ROOT = os.path.join(BASE_DIR, <span class="string">&#x27;media&#x27;</span>).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)    <span class="comment">#media即为图片上传的根路径</span></span><br></pre></td></tr></table></figure></p>
<p>保存之后，在项目根目录即<code>manage.py</code>同级目录里创建<code>media</code>这个文件夹。然后编辑<code>models.py</code>，内容如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Img</span>(models.Model):</span><br><span class="line">    img_url = models.ImageField(upload_to=<span class="string">&#x27;photos/&#x27;</span>,blank=<span class="literal">True</span>,null=<span class="literal">True</span>) <span class="comment">#指定图片上传路径，即media/photos/</span></span><br></pre></td></tr></table></figure></p>
<p>保存之后执行一下<code>python manage.py makemigrations</code>和<code>python manage.py migrate</code>，建立项目与数据库之间的关系。</p>
<p>增加<code>urls.py</code>的内容如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">	path(<span class="string">r&#x27;uploadImg/&#x27;</span>,views.uploadImg,name=<span class="string">&#x27;uploadImg&#x27;</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>增加<code>views.py</code>的内容如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">其他内容略</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Img</span><br><span class="line"></span><br><span class="line"><span class="comment">#图片上传</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">uploadImg</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        img = Img(img_url=request.FILES.get(<span class="string">&#x27;img&#x27;</span>))</span><br><span class="line">        img.save()</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;imgUpload.html&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>最后就是写一个前端页面<code>imgUpload.html</code>:<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;图片上传&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=&quot;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">        &#123;% csrf_token %&#125;</span><br><span class="line">        &lt;input type=&quot;file&quot; name=&quot;img&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>启动django，打开<code>imgUpload.html</code>就可以看到界面，并且上传图片了，效果如图（我这个前端是加工过的，不是上面的代码）：<br><img data-src="/images/django34.gif" alt="akb48"></p>
<p>然后在<code>django项目目录里的media/photos</code>路径里找到我们刚刚上传的test333.png，而且在数据库里也能看到这条记录，如下：<br><img data-src="/images/django35.png" alt="akb48"></p>
<h2 id="图片批量上传"><a href="#图片批量上传" class="headerlink" title="图片批量上传"></a>图片批量上传</h2><p>不过在现实工作中，图片批量上传的应用场景更为普遍，如果是批量上传的话，我们尝试一个全新而且更简单粗暴的方法。</p>
<p>首先先修改前端页面<code>imgUpload.html</code>，把<code>&lt;input type=&quot;file&quot; name=&quot;img&quot;&gt;</code>改成<code>&lt;input type=&quot;file&quot; name=&quot;img&quot; multiple=&quot;&quot;&gt;</code>，就这一处而已，其他都不动。</p>
<p>然后就是修改<code>views.py</code>，如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">	<span class="comment">#图片上传</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">uploadImg</span>(<span class="params">request</span>):</span><br><span class="line">    files = request.FILES.getlist(<span class="string">&#x27;img&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> files:</span><br><span class="line">        destination = <span class="built_in">open</span>(<span class="string">&#x27;/tmp/&#x27;</span> + f.name,<span class="string">&#x27;wb+&#x27;</span>)		<span class="comment">#上传的文件都放到/tmp文件夹里</span></span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> f.chunks(): </span><br><span class="line">            destination.write(chunk)</span><br><span class="line">            destination.close()</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;imgUpload.html&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>可以看出，这次<code>views.py</code>在执行<code>uploadImg</code>已经完全脱离img数据库和media路径了，就是一个非常单纯的图片上传功能。效果如图：<br><img data-src="/images/django36.gif" alt="akb48"></p>
<p>此时去&#x2F;tmp里检查文件是否成功传上来：<br><img data-src="/images/django37.png" alt="akb48"></p>
<p>可见已经成功的一次性传上来三个文件到目标文件夹了。</p>
<h2 id="使用阿里云云存储的API上传文件"><a href="#使用阿里云云存储的API上传文件" class="headerlink" title="使用阿里云云存储的API上传文件"></a>使用阿里云云存储的API上传文件</h2><p>阿里云云存储上传文件的脚本如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#需要先执行pip install oss2</span></span><br><span class="line"><span class="keyword">import</span> oss2,os</span><br><span class="line">path = <span class="string">&quot;图片所在文件夹的绝对路径&quot;</span></span><br><span class="line">files = os.listdir(path)     <span class="comment">#得到文件夹下的所有文件名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#鉴权</span></span><br><span class="line">auth = oss2.Auth(<span class="string">&#x27;这里是AK&#x27;</span>, <span class="string">&#x27;这里是SK&#x27;</span>)</span><br><span class="line">bucket = oss2.Bucket(auth, <span class="string">&#x27;http://oss-cn-hangzhou.aliyuncs.com&#x27;</span>, <span class="string">&#x27;目标BUCKET名称&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> files:  </span><br><span class="line">    bucket.put_object_from_file(<span class="string">&#x27;路径/&#x27;</span>+i, path+i)</span><br><span class="line">	<span class="built_in">print</span> (<span class="string">&quot;上传成功！&quot;</span>+i+<span class="string">&quot;的url地址是：https://lechangebbs.oss-cn-hangzhou.aliyuncs.com/jjfjj/&quot;</span>+i)</span><br><span class="line">   	<span class="built_in">print</span> (<span class="string">&quot;\n&quot;</span> * <span class="number">2</span>)	<span class="comment">#空两行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>执行效果如下：<br><img data-src="/images/django33.png" alt="akb48" title="图片是中文名称也不怕"></p>
<p>通过搭配这个脚本写到<code>views.py</code>里就可以把上传上来的图片转到阿里云云存储里去了！</p>
<p>PS，阿里云OSS有官方支持django的模块：<code>django-aliyun-oss2-storage </code>（果然够牛逼！），直接pip安装即可，如何使用待我研究一番先。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://jinfagang.gitlab.io/2017/11/27/Django%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0%E5%A4%9A%E5%BC%A0%E5%9B%BE%E7%89%87%E6%88%96%E6%96%87%E4%BB%B6/">https://jinfagang.gitlab.io/2017/11/27/Django%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0%E5%A4%9A%E5%BC%A0%E5%9B%BE%E7%89%87%E6%88%96%E6%96%87%E4%BB%B6/</a><br><a href="https://blog.csdn.net/c_beautiful/article/details/79755368">https://blog.csdn.net/c_beautiful/article/details/79755368</a><br><a href="https://www.jianshu.com/p/3c79b19849f5">https://www.jianshu.com/p/3c79b19849f5</a><br><a href="https://blog.csdn.net/u014633966/article/details/78727034">https://blog.csdn.net/u014633966/article/details/78727034</a><br><a href="https://abersheeran.com/articles/Django-MutliImageFormSet/">https://abersheeran.com/articles/Django-MutliImageFormSet/</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django搭配anymail去发送邮件</title>
    <url>/2019/03/22/Django%E6%90%AD%E9%85%8Danymail%E5%8E%BB%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="注册mailgun账号"><a href="#注册mailgun账号" class="headerlink" title="注册mailgun账号"></a>注册mailgun账号</h2><p>首先登陆<a href="https://app.mailgun.com/sessions/new">https://app.mailgun.com/sessions/new</a> 里注册一个账号，填写邮件和密码点击注册，会出现这样的页面：<br><img data-src="/images/anymail1.png" alt="akb48"></p>
<p>然后在注册的邮件会接到两个邮件，一个是API的邮件，另一个是激活账号邮件，如下：<br><img data-src="/images/anymail2.png" alt="akb48"></p>
<p>点击激活之后，就要添加可信任邮箱，mailgun只能对这些可信任邮箱发送邮件，其他邮件就会失败，在<code>Account</code>里选择<code>Authorized Recipients</code>，然后<code>Invite new Recipients</code>创建新的守信邮箱，创建完毕之后，邮箱应该是<code>Unverified</code>的状态，如下：<br><img data-src="/images/anymail3.png" alt="akb48"></p>
<p>点击那个<code>Unverified</code>的状态的邮箱，如果你的机器有装foxmail或者outlook的话，就会自动弹出来，你就可以发送一个邮件到指定的邮箱里，不久邮箱就会收到一个确认信，如下：<br><img data-src="/images/anymail4.png" alt="akb48"></p>
<p>点击<code>I agree</code>即完成授信，邮箱状态也变成了绿色的<code>Verified</code>。</p>
<p>点击Domains就可以看到账号的<code>api</code>和<code>domain</code>了，如图：<br><img data-src="/images/anymail5.png" alt="akb48"></p>
<p>至此，邮箱账号申请部分完成。</p>
<h2 id="开始配置"><a href="#开始配置" class="headerlink" title="开始配置"></a>开始配置</h2><p>首先安装<code>pip install django-anymail</code>组件，并且在<code>setting.py</code>里添加如下内容：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&quot;anymail&quot;</span>,</span><br><span class="line">    ...</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">ANYMAIL = &#123;</span><br><span class="line">    <span class="string">&quot;MAILGUN_API_KEY&quot;</span>: <span class="string">&quot;这里填写API&quot;</span>,	</span><br><span class="line">    <span class="string">&quot;MAILGUN_SENDER_DOMAIN&quot;</span>: <span class="string">&#x27;这里填写domain&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line">EMAIL_BACKEND = <span class="string">&quot;anymail.backends.mailgun.EmailBackend&quot;</span></span><br><span class="line"><span class="comment"># DEFAULT_FROM_EMAIL = &quot;you@example.com&quot;  # if you don&#x27;t already have this in settings</span></span><br><span class="line"><span class="comment"># SERVER_EMAIL = &quot;your-server@example.com&quot;  # ditto (default from-email for Django errors)</span></span><br></pre></td></tr></table></figure></p>
<p>保存退出之后，在<code>views.py</code>里添加如下信息：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> send_mail</span><br><span class="line"></span><br><span class="line"><span class="comment">#只需一个send_mail 函数，便能发送邮件</span></span><br><span class="line">send_mail(<span class="string">&quot;It works!这里是标题&quot;</span>, <span class="string">&quot;This will get sent through Mailgun，这里是内容&quot;</span>,<span class="string">&quot;domian的内容，即上面图片里那个mailgun.org结尾的东西&quot;</span>, [<span class="string">&quot;授信的邮箱地址&quot;</span>])</span><br></pre></td></tr></table></figure></p>
<p>保存之后，django会自动重启，就会看到邮件顺利发出去了！<br><img data-src="/images/anymail6.png" alt="akb48"></p>
<p>可以看出只需要一个<code>send_mail</code>就能发送邮件，的确比SMTP方便多了。在实际运用中，就把<code>send_mail</code>放到对应的函数里，然后灵活搭配标题和内容就能使用了！</p>
<h2 id="故障排错"><a href="#故障排错" class="headerlink" title="故障排错"></a>故障排错</h2><ol>
<li>如果出现<code>Please activate your Mailgun account. Check your inbox or log in to your control panel to resend the activation email.</code>，即账号没激活；</li>
<li>如果出现<code>Sandbox subdomains are for test purposes only. Please add your own domain or add the address to authorized recipients in Account Settings.</code>，即目标邮箱不是授信邮箱，需要添加到授信名单里。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/anymail/django-anymail">https://github.com/anymail/django-anymail</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>anymail</tag>
      </tags>
  </entry>
  <entry>
    <title>Django前端输入变量通过内部脚本加工返回前端展示之二</title>
    <url>/2018/09/18/Django%E9%80%9A%E8%BF%87%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86%E7%AC%A6%E5%B0%86%E5%90%8E%E5%8F%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E5%BA%94%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<h2 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h2><p>python：<code>3.6.5</code><br>Django：<code>2.1.1</code><br>Project：<code>Kubernetes</code>，文件夹路径就是<code>/django/Kubernetes/</code><br>App：<code>createyaml</code>，文件夹路径就是<code>/django/Kubernetes/createyaml</code><br>前文地址：<a href="https://rorschachchan.github.io/2018/09/13/Django%E5%88%B6%E4%BD%9C%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%94%9F%E6%88%90yaml%E6%96%87%E4%BB%B6%E4%B9%8B%E6%94%B9%E8%BF%9B%E7%89%88/">https://rorschachchan.github.io/2018/09/13/Django%E5%88%B6%E4%BD%9C%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%94%9F%E6%88%90yaml%E6%96%87%E4%BB%B6%E4%B9%8B%E6%94%B9%E8%BF%9B%E7%89%88/</a></p>
<h2 id="sqlite3的用法"><a href="#sqlite3的用法" class="headerlink" title="sqlite3的用法"></a>sqlite3的用法</h2><p><code>sqlite</code>是django默认的数据库，如果只是存一点简单的数据，那么它是足够胜任的。如果在django的APP文件夹里配置了<code>models.py</code>而且执行了<code>python manage.py makemigrations</code>和<code>python manage.py migrate</code>的话，那么在project的文件夹里是会生成<code>db.sqlite3</code>这个文件的。至于如何命令行操作sqlite和python调用sqlite，请去看：<a href="http://blog.51cto.com/zengestudy/1904680">http://blog.51cto.com/zengestudy/1904680</a> ，里面说的已经很清楚了。</p>
<p>不过要注意的是<code>execute</code>方法得到的是一个对象，是看不到具体的sql结果。还需要<code>fetchall</code>方法进一步的解析，这样得到的是一个列表，然后取其中的具体元素，如图：<br><img data-src="/images/django12.png" alt="paradin"></p>
<h2 id="使用唯一标识符"><a href="#使用唯一标识符" class="headerlink" title="使用唯一标识符"></a>使用唯一标识符</h2><p>由于yaml的参数是从前端传入的，如果同时有多个人传入数据，那么后端脚本在取参数就会出现错误：<strong>多个人在传入不同的数据之后得到的结果却是一样的，即服务器接收到的最后那个数据返回的结果</strong>。为了不出现这样的混乱，所以我们就要引入唯一标识符保证每个人得到都是他们的结果。</p>
<p>在数据库里是有一个主键的也就是<code>id</code>，它是django生成数据库的时候自带的<code>private key</code>，每一个id都是唯一的，既然唯一那肯定就是我们选做唯一标识符的首选。至于怎么用它，其实就是在原有的<code>views.py</code>上做一点小手脚。如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.<span class="property">shortcuts</span> <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> django.<span class="property">http</span> <span class="keyword">import</span> <span class="title class_">HttpResponse</span></span><br><span class="line"><span class="keyword">from</span> .<span class="property">models</span> <span class="keyword">import</span> parameter		#引入同级的modes.<span class="property">py</span>里的parameter类</span><br><span class="line"></span><br><span class="line">def <span class="title function_">create_yaml</span>(request):</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">render</span>(request,<span class="string">&#x27;create_yaml.html&#x27;</span>)	#这个页面是用来输入各值</span><br><span class="line"></span><br><span class="line">def <span class="title function_">get_yaml</span>(request):</span><br><span class="line">    <span class="keyword">if</span> request.<span class="property">method</span> == <span class="string">&#x27;POST&#x27;</span>:		#如果是post传参，那么就记录下来</span><br><span class="line">        apiVersion = request.<span class="property">POST</span>.<span class="title function_">get</span>(<span class="string">&#x27;apiVersion&#x27;</span>,<span class="string">&#x27;v1&#x27;</span>)</span><br><span class="line">        kind = request.<span class="property">POST</span>.<span class="title function_">get</span>(<span class="string">&#x27;kind&#x27;</span>,<span class="string">&#x27;RC&#x27;</span>)</span><br><span class="line">        name = request.<span class="property">POST</span>.<span class="title function_">get</span>(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">        replicas = request.<span class="property">POST</span>.<span class="title function_">get</span>(<span class="string">&#x27;replicas&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        labels_app = request.<span class="property">POST</span>.<span class="title function_">get</span>(<span class="string">&#x27;labels_app&#x27;</span>,<span class="title class_">None</span>)</span><br><span class="line">		containers_name = request.<span class="property">POST</span>.<span class="title function_">get</span>(<span class="string">&#x27;containers_name&#x27;</span>,<span class="title class_">None</span>)</span><br><span class="line">		containers_image = request.<span class="property">POST</span>.<span class="title function_">get</span>(<span class="string">&#x27;containers_image&#x27;</span>,<span class="title class_">None</span>)</span><br><span class="line">		containerPort1 = request.<span class="property">POST</span>.<span class="title function_">get</span>(<span class="string">&#x27;containerPort1&#x27;</span>,<span class="title class_">None</span>)</span><br><span class="line">		containerPort2 = request.<span class="property">POST</span>.<span class="title function_">get</span>(<span class="string">&#x27;containerPort2&#x27;</span>,<span class="title class_">None</span>)</span><br><span class="line">       	containers_name2 = request.<span class="property">POST</span>.<span class="title function_">get</span>(<span class="string">&#x27;containers_name2&#x27;</span>,<span class="title class_">None</span>)</span><br><span class="line">       	containers_image2 = request.<span class="property">POST</span>.<span class="title function_">get</span>(<span class="string">&#x27;containers_image2&#x27;</span>,<span class="title class_">None</span>)</span><br><span class="line">       	containerPort2_1 = request.<span class="property">POST</span>.<span class="title function_">get</span>(<span class="string">&#x27;containerPort2_1&#x27;</span>,<span class="title class_">None</span>)</span><br><span class="line">       	containerPort2_2 = request.<span class="property">POST</span>.<span class="title function_">get</span>(<span class="string">&#x27;containerPort2_2&#x27;</span>,<span class="title class_">None</span>)</span><br><span class="line">       	signer = request.<span class="property">POST</span>.<span class="title function_">get</span>(<span class="string">&#x27;signer&#x27;</span>, <span class="string">&#x27;Micheal Jackson&#x27;</span>)</span><br><span class="line">   	<span class="attr">else</span>:</span><br><span class="line">       	<span class="keyword">return</span> <span class="title class_">HttpResponse</span>(<span class="string">&#x27;404&#x27;</span>)</span><br><span class="line"></span><br><span class="line">   	<span class="title class_">Parameter</span> = <span class="title function_">parameter</span>()		#将parameter实例化</span><br><span class="line">   	<span class="title class_">Parameter</span>.<span class="property">apiVersion</span> = apiVersion	#把刚刚从前端得到的值对应赋值</span><br><span class="line">   	<span class="title class_">Parameter</span>.<span class="property">kind</span> = kind</span><br><span class="line">   	<span class="title class_">Parameter</span>.<span class="property">name</span> = name</span><br><span class="line">   	<span class="title class_">Parameter</span>.<span class="property">replicas</span> = replicas</span><br><span class="line">   	<span class="title class_">Parameter</span>.<span class="property">labels_app</span> = labels_app</span><br><span class="line">   	<span class="title class_">Parameter</span>.<span class="property">containers_name</span> = containers_name</span><br><span class="line">   	<span class="title class_">Parameter</span>.<span class="property">containers_image</span> = containers_image</span><br><span class="line">   	<span class="title class_">Parameter</span>.<span class="property">containerPort1</span> = containerPort1</span><br><span class="line">   	<span class="title class_">Parameter</span>.<span class="property">containerPort2</span> = containerPort2</span><br><span class="line">   	<span class="title class_">Parameter</span>.<span class="property">containers_name2</span> = containers_name2</span><br><span class="line">   	<span class="title class_">Parameter</span>.<span class="property">containers_image2</span> = containers_image2</span><br><span class="line">   	<span class="title class_">Parameter</span>.<span class="property">containerPort2_1</span> = containerPort2_1</span><br><span class="line">   	<span class="title class_">Parameter</span>.<span class="property">containerPort2_2</span> = containerPort2_2</span><br><span class="line">   	<span class="title class_">Parameter</span>.<span class="title function_">save</span>()        #保存修改</span><br><span class="line"></span><br><span class="line">   	yaml = parameter.<span class="property">objects</span>.<span class="title function_">get</span>(id=<span class="title class_">Parameter</span>.<span class="property">id</span>)	#通过object.<span class="property">get</span>方法是得到保存的所有值，但是我们只要本次的值，也就是id与private key一致的</span><br><span class="line">   	<span class="keyword">return</span> <span class="title class_">HttpResponse</span>(<span class="string">&#x27;api版本:%s yaml类型:%s yaml名称:%s 副本数量:%s yaml所属APP:%s 容器名称:%s 容器镜像名:%s&#x27;</span>  % (yaml.<span class="property">apiVersion</span>,yaml.<span class="property">kind</span>,yaml.<span class="property">name</span>,yaml.<span class="property">replicas</span>,yaml.<span class="property">labels_app</span>,yaml.<span class="property">containers_name</span>,yaml.<span class="property">containers_image</span>)))		#输出部分刚输入的值到页面，检查一下是否正确</span><br></pre></td></tr></table></figure></p>
<p><code>urls.py</code>如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.<span class="property">contrib</span> <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.<span class="property">urls</span> <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> createyaml <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="title function_">path</span>(<span class="string">&#x27;admin/&#x27;</span>, admin.<span class="property">site</span>.<span class="property">urls</span>),</span><br><span class="line">    <span class="title function_">path</span>(r<span class="string">&#x27;create_yaml/&#x27;</span>, views.<span class="property">create_yaml</span>),</span><br><span class="line">    <span class="title function_">path</span>(r<span class="string">&#x27;get_yaml/&#x27;</span>, views.<span class="property">get_yaml</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>启动django，在前端页面测试一下看看是否得到的结果就是本次输入的结果，如图：<br><img data-src="/images/django13.gif" alt="paradin"></p>
<p>可以看到，返回的页面正确的输出了本次各个参数！剩下还有三部分：</p>
<ol>
<li>做一个python脚本，把脚本加工的结果返回到前端；</li>
<li>用css&#x2F;js把界面加工一下；</li>
<li>加入javascript，在前端输入的时候判断输入值是否合法；</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.51cto.com/lannyma/1735751">http://blog.51cto.com/lannyma/1735751</a><br><a href="http://www.liujiangblog.com/course/django/152">http://www.liujiangblog.com/course/django/152</a><br><a href="https://www.jianshu.com/p/46188b39eae5">https://www.jianshu.com/p/46188b39eae5</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>python</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>DockerFile创建一个nginx容器的全过程</title>
    <url>/2018/02/25/DockerFile%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAnginx%E5%AE%B9%E5%99%A8%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2><p>首先，随便建立一个文件夹，比如先<code>mkdir sample</code>，然后我在这个sample文件夹里建立一个<code>Dockerfile</code>，内容如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">FROM</span> <span class="attr">ubuntu</span>:<span class="number">14.04</span></span><br><span class="line"><span class="variable constant_">MAINTAINER</span> <span class="title class_">Chris</span> <span class="title class_">Chan</span> <span class="string">&quot;chenx1242@163.com&quot;</span></span><br><span class="line"><span class="variable constant_">ENV</span> <span class="variable constant_">REFRESHED_AT</span> <span class="number">2016</span>-<span class="number">12</span>-<span class="number">05</span></span><br><span class="line"><span class="variable constant_">RUN</span> apt-get -y update &amp;&amp; apt-get install -y nginx</span><br><span class="line"><span class="variable constant_">RUN</span> mkdir -p /<span class="keyword">var</span>/www/html/website</span><br><span class="line"><span class="variable constant_">ADD</span> nginx/<span class="variable language_">global</span>.<span class="property">conf</span> /etc/nginx/conf.<span class="property">d</span>/</span><br><span class="line"><span class="variable constant_">ADD</span> nginx/nginx.<span class="property">conf</span> /etc/nginx/nginx.<span class="property">conf</span></span><br><span class="line"><span class="variable constant_">EXPOSE</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></p>
<p>从这个Dockfile里面看出：我们使用了ubuntu的基础镜像，然后下载了nginx，同时建立一个<code>/var/www/html/website</code>文件夹，然后又拷贝了宿主机上的两个文件，一个是<code>global.conf</code>，另一个是<code>nginx.conf</code>，这两个文件需要我们自己写。于是我们就要在sample下再建立一个叫nginx的文件夹，里面写上这两个文件，其中<code>global.conf</code>的内容如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">       listen   <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">80</span>;</span><br><span class="line">       server_name     _;</span><br><span class="line">       root    /<span class="keyword">var</span>/www/html/website;</span><br><span class="line">       index   index.<span class="property">html</span> index.<span class="property">htm</span>;</span><br><span class="line">       access_log      /<span class="keyword">var</span>/log/nginx/default_access.<span class="property">log</span>;</span><br><span class="line">       error_log       /<span class="keyword">var</span>/log/nginx/default_error.<span class="property">log</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而<code>nginx.conf</code>的内容如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">user www-data;</span><br><span class="line">worker_processes <span class="number">4</span>;</span><br><span class="line">pid /run/nginx.<span class="property">pid</span>;</span><br><span class="line">events &#123; &#125;</span><br><span class="line">http &#123;</span><br><span class="line"> sendfile on;</span><br><span class="line"> tcp_nopush on;</span><br><span class="line"> tcp_nodelay on;</span><br><span class="line"> keepalive_timeout <span class="number">65</span>;</span><br><span class="line"> types_hash_max_size <span class="number">2048</span>;</span><br><span class="line"> include /etc/nginx/mime.<span class="property">types</span>;</span><br><span class="line"> default_type application/octet-stream;</span><br><span class="line"> access_log /<span class="keyword">var</span>/log/nginx/access.<span class="property">log</span>;	</span><br><span class="line"> error_log /<span class="keyword">var</span>/log/nginx/error.<span class="property">log</span>;</span><br><span class="line"> gzip on;</span><br><span class="line"> gzip_disable <span class="string">&quot;msie6&quot;</span>;</span><br><span class="line"> include /etc/nginx/conf.<span class="property">d</span><span class="comment">/*.conf;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>全部搞定之后，我们就来build这个镜像，比如这个镜像名叫做<code>chentest/nginx001</code>，在sample文件夹里使用的命令语句就是：<code>docker build -t=&#39;chentest/nginx001&#39; .</code>。</p>
<p>一顿七七八八之后，显示OK，<code>docker ps -a</code>就会显示我们新建的镜像，如图：<br><img data-src="/images/dockernginx1.png" alt="paradin"></p>
<p>有了镜像，再在sample文件夹里新增一个文件夹，比如就叫<code>webiste</code>，里面有一个文件叫<code>index.html</code>。而<code>index.html</code>的内容如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span> is a nginxtest page.</span><br></pre></td></tr></table></figure></p>
<p>保存退出之后，返回到sample目录。</p>
<p>现在我们可以制作一个容器了，制作容器命令是<code>docker run -d -p 8080:80 --name test02 -v $PWD/website:/var/www/html/website chentest/nginx001 nginx -g &quot;daemon off;&quot;</code>,这句话里规定容器的8080端口映射到宿主机的80端口，同时引入了当前目录的website目录到容器的<code>/var/www/html/website</code>目录，nginx也默认在前台进程进行。执行之后，<code>docker ps -a</code>看一下：<br><img data-src="/images/dockernginx2.png" alt="paradin"></p>
<p>看见port这一栏已经显示8080与80端口的相勾结成功，于是我们可以登录这台机器的80端口看一下。<br><img data-src="/images/dockernginx3.png" alt="paradin"></p>
<p>而如果现在我更改一下上面的<code>index.html</code>，改成另外一句话。比如说改成“why so serious??”,保存文件之后，直接刷新网页，就会看到网页的内容已经发生了变化，如图：<br><img data-src="/images/dockernginx4.png" alt="paradin"></p>
<p>可见引入<code>-v</code>这个命令在容器里，可以随时调试内容，而不是每次都要重新打包生成镜像。这一点再调试阶段为我们提供了很大的方便。</p>
<h2 id="docker端口映射的问题"><a href="#docker端口映射的问题" class="headerlink" title="docker端口映射的问题"></a>docker端口映射的问题</h2><p><code>docker run</code>命令里指定端口的格式是<code>-p 容器端口:宿主机端口</code>。如果想要随机指定就是大写的<code>P</code>。如图：<br><img data-src="/images/dockernginx5.png" alt="paradin"></p>
<p>这里就是随机分配了一个32775端口给宿主机，访问的时候也是要访问这个32775端口。</p>
<p>有时候port这里却不显示端口映射的情况，如图：<br><img data-src="/images/dockernginx6.png" alt="paradin"></p>
<p>这个情况是因为这个容器的status是<code>exited</code>，docker会在容器主进程结束后自动终止容器运行，而<code>nginx</code>启动后就会在后台运行，docker以为<code>nginx</code>已经结束运行了，所以就会停止容器。</p>
<h2 id="源码安装nginx如何开机自启动"><a href="#源码安装nginx如何开机自启动" class="headerlink" title="源码安装nginx如何开机自启动"></a>源码安装nginx如何开机自启动</h2><p>切换到<code>/lib/systemd/system/</code>目录，创建<code>nginx.service</code>文件,文件内容如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="title class_">Unit</span>]</span><br><span class="line"><span class="title class_">Description</span>=nginx </span><br><span class="line"><span class="title class_">After</span>=network.<span class="property">target</span> </span><br><span class="line">   </span><br><span class="line">[<span class="title class_">Service</span>] </span><br><span class="line"><span class="title class_">Type</span>=forking </span><br><span class="line"><span class="title class_">ExecStart</span>=<span class="regexp">/usr/</span>local/nginx/sbin/nginx</span><br><span class="line"><span class="title class_">ExecReload</span>=<span class="regexp">/usr/</span>local/nginx/sbin/nginx reload</span><br><span class="line"><span class="title class_">ExecStop</span>=<span class="regexp">/usr/</span>local/nginx/sbin/nginx quit</span><br><span class="line"><span class="title class_">PrivateTmp</span>=<span class="literal">true</span> </span><br><span class="line">   </span><br><span class="line">[<span class="title class_">Install</span>] </span><br><span class="line"><span class="title class_">WantedBy</span>=multi-user.<span class="property">target</span></span><br></pre></td></tr></table></figure></p>
<p>退出并保存文件，执行<code>systemctl enable nginx.service</code>使nginx开机启动，<code>systemctl restart nginx.service</code>重启nginx。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Django将某个数据库字段给多个app使用</title>
    <url>/2018/09/25/Django%E5%B0%86%E6%9F%90%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%97%E6%AE%B5%E7%BB%99%E5%A4%9A%E4%B8%AAapp%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Django里经常会有这样的一个需求—-同样的一组数据要给很多个app使用。比如一个运维系统，运维人员的名单就既要给“项目部署”这个APP用又要给“责任负责人”这个APP用。如果每次都要去跨应用去<code>from XXX.models import xxx</code>的话，代码感觉很不友好。那么要解决这个问题，就要用到django自带的<code>ContentTypes</code>框架。以下是所用软件版本：<br>Django:<code>2.1.1</code><br>Python:<code>3.6.4</code><br>old app:<code>Articles</code><br>new app:<code>read_stats</code></p>
<h2 id="原始状态与前期配置"><a href="#原始状态与前期配置" class="headerlink" title="原始状态与前期配置"></a>原始状态与前期配置</h2><p>目前在django的控制台页面的情况是这样的：<br><img data-src="/images/django14.png" alt="paradin"></p>
<p>可见里面就一个叫<code>Articles</code>的app，点开之后，发现对应的项目也很简单，只有<code>id</code>和<code>title</code>这两个字段而已：<br><img data-src="/images/django15.png" alt="paradin"></p>
<p>本次试验的目的就是<strong>新建立一个文章统计计数的app，在里面配置数据库，然后让原来的blog这个app能够使用得到新app的数据项</strong>。</p>
<p>首先先建立一个专门用来计数的app，比如就叫<code>read_stat</code>。那么就在django项目路径下<code>python manage.py startapp read_stats</code>，再把这个新的app名称添加到<code>settings.py</code>里：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    &#x27;django.contrib.admin&#x27;,</span><br><span class="line">    &#x27;django.contrib.auth&#x27;,</span><br><span class="line">    &#x27;django.contrib.contenttypes&#x27;,</span><br><span class="line">    &#x27;django.contrib.sessions&#x27;,</span><br><span class="line">    &#x27;django.contrib.messages&#x27;,</span><br><span class="line">    &#x27;django.contrib.staticfiles&#x27;,</span><br><span class="line">    &#x27;article&#x27;,			#先加载django自身的app，然后是第三方app，最后是自己开发的app</span><br><span class="line">    &#x27;read_stats&#x27;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>编辑一下<code>read_stats</code>里的<code>models.py</code>，创建模型先：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line">from django.contrib.contenttypes.fields import GenericForeignKey		#这句话是固定的，引用类型</span><br><span class="line">from django.contrib.contenttypes.models import ContentType		#这句话是固定的，引用类型</span><br><span class="line"># Create your models here.</span><br><span class="line"></span><br><span class="line">class ReadNum(models.Model):</span><br><span class="line">    read_num = models.IntegerField(default=0)	#设定read_num就是一个普通的数字</span><br><span class="line">    content_type = models.ForeignKey(ContentType,on_delete=models.DO_NOTHING)	#说明这是一个外键，即关联的模型，加上后面的话的意思是：即使删除了这个字段也不会影响其他数据</span><br><span class="line">    object_id = models.PositiveIntegerField()		#这里是一个主键，即pk</span><br><span class="line">    content_object = GenericForeignKey(&quot;content_type&quot;,&quot;object_id&quot;)	#通过上面两个变量，配置成一个通用的外键</span><br></pre></td></tr></table></figure></p>
<p>通过使用一个<code>content_type</code>属性代替了实际的<code>model</code>（如Post，Picture），而<code>object_id</code>则代表了实际model中的一个实例的主键，其中，<code>content_type</code>和<code>object_id</code>的字段命名都是作为字符串参数传进<code>content_object</code>的。</p>
<p>配置了数据库，肯定需要<code>python manage.py makemigrations</code>和<code>python manage.py migrate</code>：<br><img data-src="/images/django16.png" alt="paradin"></p>
<p>数据更新完毕之后，修改一下负责后台展示的<code>admin.py</code>：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from .models import ReadNum		#引用ReadNum这个模型</span><br><span class="line"># Register your models here.</span><br><span class="line"></span><br><span class="line">@admin.register(ReadNum)   #装饰器</span><br><span class="line">class ReadNumAdmin(admin.ModelAdmin):</span><br><span class="line">        list_display = (&#x27;read_num&#x27;,&#x27;content_object&#x27;)</span><br></pre></td></tr></table></figure></p>
<p>此时刷新一下django页面就看到read_stats这个app已经注册成功了：<br><img data-src="/images/django17.png" alt="paradin"></p>
<p>由于是新的，所以里面空空如也，点击一下<code>ADD</code>，就可以输入值了：<code>Read num</code>就是设定的“阅读次数”，<code>Content type</code>这个数据是一个选择项，选择需要对应的数据库模型，即Article这个app里的<code>models.py</code>的类—<code>Article</code>，而<code>Object id</code>就<code>Articles</code>对应的文章编号：<br><img data-src="/images/django18.png" alt="paradin"></p>
<p>这样达到了后台配置“将Article应用里的第2篇文章的阅读次数上调到了99次”。</p>
<h2 id="数据库的跨app配置"><a href="#数据库的跨app配置" class="headerlink" title="数据库的跨app配置"></a>数据库的跨app配置</h2><p>刚才手动在后台配置完毕，但是目前这个<code>read_num</code>数据只能是在<code>read_stats</code>这个app里自嗨。要给让<code>Article</code>能够得到这个<code>read_num</code>的话，就需要通过模型获取到具体数值，这里要用到<code>ContentType.objects.get_for_model</code>方法。首先要配置<code>Article</code>下的<code>models.py</code>：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line">from django.db.models.fields import exceptions	#引入错误给try...except使用</span><br><span class="line">from django.contrib.contenttypes.models import ContentType		#引入ContentType</span><br><span class="line">from read_stats.models import ReadNum      #从另一个app里引入类</span><br><span class="line"></span><br><span class="line"># Create your models here.</span><br><span class="line">class Article(models.Model):	</span><br><span class="line">    title = models.CharField(max_length=30)</span><br><span class="line">    content = models.TextField()			#这是它原来的数据库内容</span><br><span class="line">   	 </span><br><span class="line">    #添加一个方法给admin.py使用，如果有就直接返回值（字符串），如果没有object就返回一个0</span><br><span class="line">    def get_read_num(self):</span><br><span class="line">        try:</span><br><span class="line">            ct = ContentType.objects.get_for_model(self)	#确定ContentType</span><br><span class="line">            readnum = ReadNum.objects.get(content_type=ct,object_id=self.pk)	#每个readnum都是content_type和object_id对应的QuerySet</span><br><span class="line">            return readnum.read_num		#这样返回就是一个具体的值，不然只是一个数据</span><br><span class="line">        except exceptions.ObjectDoesNotExist:</span><br><span class="line">            return 0</span><br></pre></td></tr></table></figure></p>
<p>再修改<code>Article</code>下的<code>admin.py</code>，让后台可以体现出来<code>read_num</code>：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from .models import Article</span><br><span class="line"># Register your models here.</span><br><span class="line"></span><br><span class="line">@admin.register(Article)</span><br><span class="line">class Article(admin.ModelAdmin):</span><br><span class="line">        list_display = (&#x27;id&#x27;,&#x27;title&#x27;,&#x27;get_read_num&#x27;)	#这里新加上刚才的那个方法</span><br></pre></td></tr></table></figure></p>
<p>由于<code>admin.py</code>里返回的必须是字段，所以我们才在<code>models.py</code>里添加了一个方法去生成字段。</p>
<p>刷新一下Django后台页面，就看到效果了：<br><img data-src="/images/django19.png" alt="paradin"></p>
<p>至此，这个<code>read_num</code>数据就同时被两个APP关联分享了。至于再把<code>read_num</code>通过一定的处理方法之后映射到html前端就很简单了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://docs.djangoproject.com/en/2.1/ref/contrib/contenttypes/">https://docs.djangoproject.com/en/2.1/ref/contrib/contenttypes/</a>	（官方文档）</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django搭配钉钉机器人做催办效果</title>
    <url>/2020/08/18/Django%E6%90%AD%E9%85%8D%E9%92%89%E9%92%89%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%81%9A%E5%82%AC%E5%8A%9E%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<p>在“任务管理”里，催办是一个很常见的功能：点击“催办”按钮，钉钉机器人会去发信息，提醒任务负责人。</p>
<p>Django:<code>2.1.8</code><br>Python:<code>3.6.4</code><br>project的名称是:<code>naxx</code><br>APP的名称是:<code>naxxramas</code></p>
<p>首先，在钉钉群里申请一个自定义机器人，并且获取到对应的webhook，如图：<br><img data-src="/images/%E9%92%89%E9%92%89%E6%9C%BA%E5%99%A8%E4%BA%BA.png" alt="akb48" title="红箭头就是webhook"></p>
<p>然后设计一下任务数据库的<code>models.py</code>：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 大促任务表，给日历用的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Events</span>(models.Model):</span><br><span class="line">    event_name = models.CharField(max_length=<span class="number">255</span>, null=<span class="literal">True</span>, blank=<span class="literal">True</span>)  <span class="comment"># 大促任务名称</span></span><br><span class="line">    promotion_name = models.ForeignKey(Promotion, on_delete=models.CASCADE)     <span class="comment"># 大促名称，是从大促表里取外键，这里做了联级删除，即大促表里的大促删除了，这里的事件也会删除</span></span><br><span class="line">    principal = models.CharField(max_length=<span class="number">20</span>, null=<span class="literal">True</span>, blank=<span class="literal">True</span>)  <span class="comment"># 责任人</span></span><br></pre></td></tr></table></figure></p>
<p>由于一次大促会有很多个任务，是一个一对多的关系，所以引入了foreignkey，那么大促的<code>models.py</code>如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 大促名单记录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Promotion</span>(models.Model):</span><br><span class="line">    promotionname = models.CharField(max_length=<span class="number">50</span>)     <span class="comment"># 大促名称</span></span><br><span class="line">    dingding = models.CharField(max_length=<span class="number">50</span>)  <span class="comment"># 群钉钉机器人</span></span><br><span class="line">    description = models.CharField(max_length=<span class="number">2000</span>, null=<span class="literal">True</span>, blank=<span class="literal">True</span>)   <span class="comment"># 大促描述</span></span><br></pre></td></tr></table></figure></p>
<p>保证这两个表里都有对应数据之后，就可以写前端和后台了。</p>
<p>对应的前端按钮的设计如下：<br>	<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;project-actions text-right&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary btn-sm swalDefaultSuccess&quot;</span> <span class="attr">id</span>=<span class="string">&quot;AJAX_dingding&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- swalDefaultSuccess 这个是给alerts用的--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fas fa-bell&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      催办</span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-info btn-sm&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/naxx/update_event/?id=&#123;&#123; event.id &#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fas fa-pencil-alt&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      编辑</span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-danger btn-sm toastrDefaultError&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/naxx/delete_event/?id=&#123;&#123; event.id &#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fas fa-trash&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      删除</span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>按钮的样式如图：<br><img data-src="/images/%E5%82%AC%E5%8A%9E%E6%8C%89%E9%92%AE.png" alt="akb48" title="催办按钮的样式"></p>
<p>对应的<code>script</code>如下：<br>	<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 请求服务器，返回JSON</span></span></span><br><span class="line"><span class="language-javascript">    $(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      $(<span class="string">&quot;#AJAX_dingding&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;		<span class="comment">// 点击事件</span></span></span><br><span class="line"><span class="language-javascript">        &#123;% <span class="keyword">for</span> event <span class="keyword">in</span> events_list %&#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> id =  &#123;&#123; event.<span class="property">id</span> &#125;&#125;; 	<span class="comment">// 获取到活动的id值</span></span></span><br><span class="line"><span class="language-javascript">        &#123;% endfor %&#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> data = &#123;<span class="string">&quot;id&quot;</span>: id&#125;;  <span class="comment">// 打包成get请求发送的数据到view.py</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        $.<span class="title function_">get</span>(</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 请求的url</span></span></span><br><span class="line"><span class="language-javascript">            <span class="string">&quot;&#123;% url &#x27;dingding_event&#x27; %&#125;&quot;</span>, </span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 发送的数据</span></span></span><br><span class="line"><span class="language-javascript">            data,</span></span><br><span class="line"><span class="language-javascript">          )</span></span><br><span class="line"><span class="language-javascript">      &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>对应的<code>views.py</code>内容如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Promotion, Events</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 钉钉催办大促任务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dingding_event</span>(<span class="params">request</span>):</span><br><span class="line">	event_pk = request.GET.get(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">	promotion_id = Events.objects.<span class="built_in">filter</span>(pk=event_pk).values_list(<span class="string">&quot;promotion_name_id&quot;</span>)[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">	responsible_person = Events.objects.<span class="built_in">filter</span>(pk=event_pk).values_list(<span class="string">&quot;principal&quot;</span>)[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">	the_event = Events.objects.<span class="built_in">filter</span>(pk=event_pk).values_list(<span class="string">&quot;event_name&quot;</span>)[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">	dingding_bot = Promotion.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=promotion_id).values_list(<span class="string">&quot;dingding&quot;</span>)[<span class="number">0</span>][<span class="number">0</span>]  <span class="comment"># 获取对应的机器人编号</span></span><br><span class="line"></span><br><span class="line">webhook = <span class="string">&quot;https://oapi.dingtalk.com/robot/send?access_token=&quot;</span> + dingding_bot</span><br><span class="line"></span><br><span class="line">header = &#123;</span><br><span class="line">   <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">   <span class="string">&quot;Charset&quot;</span>: <span class="string">&quot;UTF-8&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">text = <span class="string">&quot;大促任务提醒！&quot;</span> + <span class="string">&#x27;\n&#x27;</span> + <span class="string">&quot;@&quot;</span> + <span class="built_in">str</span>(responsible_person) + <span class="string">&quot;,您负责的【&quot;</span> + <span class="built_in">str</span>(the_event) + <span class="string">&quot;】任务，请尽快处理~&quot;</span></span><br><span class="line">message = &#123;</span><br><span class="line">   <span class="string">&quot;msgtype&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">   <span class="string">&quot;text&quot;</span>: &#123;<span class="string">&quot;content&quot;</span>: text&#125;,</span><br><span class="line">   <span class="string">&quot;at&quot;</span>: &#123;<span class="string">&quot;isAtAll&quot;</span>: <span class="literal">True</span>&#125;		<span class="comment"># 这里是@所有人</span></span><br><span class="line">&#125;       <span class="comment"># 对请求的数据进行json封装</span></span><br><span class="line">message_json = json.dumps(message)</span><br><span class="line">info = requests.post(url=webhook, data=message_json, headers=header)       <span class="comment"># 发送post请求</span></span><br><span class="line">data = <span class="built_in">dict</span>()</span><br><span class="line">data[<span class="string">&#x27;info&#x27;</span>] = info.text</span><br><span class="line">    <span class="keyword">return</span> JsonResponse(data)</span><br></pre></td></tr></table></figure></p>
<p>在<code>urls.py</code>里新增一条记录：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path(<span class="string">&#x27;dingding_event/&#x27;</span>, views.dingding_event, name=<span class="string">&#x27;dingding_event&#x27;</span>),  <span class="comment"># 钉钉催办大促任务</span></span><br></pre></td></tr></table></figure></p>
<p>启动之后，整个的效果如下：<br><img data-src="/images/%E5%AE%9E%E7%8E%B0%E9%92%89%E9%92%89%E5%82%AC%E5%8A%9E.gif" alt="akb48" title="点击就发送信息了！"></p>
<p>我这个效果是@所有人，这样肯定会打扰到其他人。其实如果你有成员的钉钉注册手机号就可以在<code>&quot;at&quot;: {&quot;isAtAll&quot;: True}</code>改成 @对应的人。</p>
<p><img data-src="/images/%E5%BC%80%E6%8B%93%E8%80%85%E5%9B%B4%E5%89%BF%E8%A9%B9%E5%A7%86%E6%96%AF.gif" alt="akb48" title="久违的季后赛终于开始了..."></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>平台搭建</tag>
        <tag>钉钉</tag>
      </tags>
  </entry>
  <entry>
    <title>Django执行超长SQL语句的方式</title>
    <url>/2021/08/03/Django%E6%89%A7%E8%A1%8C%E8%B6%85%E9%95%BFSQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>在实际工作SQL语句中，使用到<code>LEFT JOIN</code>、<code>INNER JOIN</code>这种拼接语句是一个很常见的事儿，往往这种语句也很长，我昨天就写了一个80多行的一个语句。但是要知道Django的ORM语法跟Mysql的不一样，但是要在views.py里转用Django的写法来改写一个有join而且超长的语句就很麻烦，而且后期维护起来也很难。</p>
<p>那么遇到这种问题，一般有两种方式解决。</p>
<h2 id="RAW方式"><a href="#RAW方式" class="headerlink" title="RAW方式"></a>RAW方式</h2><p>Manager.raw()方式，也就是说:<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> naxxramas.models <span class="keyword">import</span> AAA	<span class="comment"># 假设有AAA这么一个models.py里的类做数据库结构</span></span><br><span class="line">context[<span class="string">&quot;domains&quot;</span>] = AAA.objects.raw(</span><br><span class="line">select * <span class="keyword">from</span> XXX</span><br><span class="line"><span class="comment">#你的SQL语句直接粘贴过来就行，长语句的话，请搭配三个单引号使用</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>但是要注意，这个方法要求查询的时候必须要带<code>primary key</code>，不然的话会报错<code>django.db.models.query_utils.InvalidQuery: Raw query must include the primary key</code>。但是比如我原表的主键是id，而现在要在原表的基础上求和求差肯定不会<code>select id...</code>，那么这里可以讨个巧，使用<code>SELECT 1 as id,...</code>这样把id带进去但是写死，而在前端的时候，就放弃掉id即可。</p>
<h2 id="使用DB-API方式"><a href="#使用DB-API方式" class="headerlink" title="使用DB-API方式"></a>使用DB-API方式</h2><p>这就完全脱离ORM的范围了，直接使用了MySQLbd的api，举个例子如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db <span class="keyword">import</span> connection</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cursor = connection.cursor()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cursor.execute(<span class="string">&#x27;&#x27;&#x27;SELECT count(*) FROM people_person&#x27;&#x27;&#x27;</span>)</span><br><span class="line"><span class="number">1L</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>row = cursor.fetchone()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> row</span><br><span class="line">(<span class="number">12L</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Person.objects.<span class="built_in">all</span>().count()</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure></p>
<p>其实我不推荐使用这种方式，代码看起来不伦不类的。</p>
<p>最后补充一下，如果要看一下ORM写法对应的sql写法是啥，就用<code>query</code>，举个例子:<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>qs = Department.objects.<span class="built_in">filter</span>(departmentvolunteer__isnull=<span class="literal">True</span>).values_list(<span class="string">&#x27;name&#x27;</span>, flat=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(qs.query)</span><br><span class="line">SELECT <span class="string">&quot;app_department&quot;</span>.<span class="string">&quot;name&quot;</span> FROM <span class="string">&quot;app_department&quot;</span> LEFT OUTER JOIN</span><br><span class="line"><span class="string">&quot;app_departmentvolunteer&quot;</span> ON ( <span class="string">&quot;app_department&quot;</span>.<span class="string">&quot;id&quot;</span> = <span class="string">&quot;app_departmentvolunteer&quot;</span>.<span class="string">&quot;department_id&quot;</span> ) WHERE <span class="string">&quot;app_epartmentvolunteer&quot;</span>.<span class="string">&quot;id&quot;</span> IS NULL</span><br></pre></td></tr></table></figure></p>
<p>这样可以帮你排查sql的问题。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://docs.djangoproject.com/zh-hans/3.2/topics/db/sql/">https://docs.djangoproject.com/zh-hans/3.2/topics/db/sql/</a><br><a href="https://www.cnblogs.com/fmgao-technology/p/10119671.html">https://www.cnblogs.com/fmgao-technology/p/10119671.html</a></p>
<p><img data-src="/images/%E8%87%B4%E5%91%BD%E5%A5%B3%E4%BA%BA.jpg"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>Django</tag>
        <tag>ORM</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Django发送邮件</title>
    <url>/2020/09/24/Django%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>一般时候，我们需要在界面上有一键发送邮件的功能，那么首先先创建一个按钮，如下：<br>	<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;user-block&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 以下这种写法可以直接召唤邮件系统，但是没有内容 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">strong</span>&gt;</span> 点击按钮就会以taoxi.cs@alibaba-inc.com发送邮件到对应的邮件组 <span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-danger&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;AjaxSubmit();&quot;</span>&gt;</span>发送邮件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>由于点击按钮发送邮件，页面并不发生跳转，所以我们用ajax来绑定点击这个任务，同时需要新增一个script：<br>	<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">AjaxSubmit</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> status = <span class="string">&#x27;邮件已经发送成功！&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">        $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">url</span>:<span class="string">&#x27;/naxx/send_mail/&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">type</span>:<span class="string">&#x27;POST&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">data</span>:&#123;<span class="attr">status</span>:status&#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">success</span>:<span class="keyword">function</span> (<span class="params">arg</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>保存后，效果如下：<br><img data-src="/images/%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E6%8C%89%E9%92%AE.png" alt="akb48" title="这里面只写按钮相关的，其他的内容太多就省略了"></p>
<p>这里面由于新增了一个路由<code>send_mail</code>，于是就去<code>urls.py</code>里增加对应的函数：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path(<span class="string">&#x27;send_mail/&#x27;</span>, views.send_mail, name=<span class="string">&#x27;send_mail&#x27;</span>),  <span class="comment"># ajax发送邮件功能</span></span><br></pre></td></tr></table></figure></p>
<p>然后去Django的<code>settings.py</code>里添加对应的邮箱信息：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">EMAIL_BACKEND = <span class="string">&#x27;django.core.mail.backends.smtp.EmailBackend&#x27;</span></span><br><span class="line">EMAIL_HOST = <span class="string">&#x27;smtp.XXX.com&#x27;</span>		<span class="comment"># 这里是邮箱服务器</span></span><br><span class="line">EMAIL_USE_SSL = <span class="literal">True</span></span><br><span class="line">EMAIL_USE_TLS = <span class="keyword">not</span> EMAIL_USE_SSL	<span class="comment"># 这里跟EMAIL_USE_SSL是互斥的，只有一个是True</span></span><br><span class="line">EMAIL_PORT = <span class="number">465</span>		<span class="comment"># 如果是SSL发送就是465，不然大概率是25接口</span></span><br><span class="line">EMAIL_HOST_USER = <span class="string">&quot;发送者的邮箱&quot;</span>	</span><br><span class="line">EMAIL_HOST_PASSWORD = <span class="string">&quot;发送者的密码&quot;</span></span><br><span class="line">DEFAULT_FROM_EMAIL = EMAIL_HOST_USER</span><br></pre></td></tr></table></figure></p>
<p>返回到<code>views.py</code>里，新增如下内容：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings	<span class="comment"># 将settings的内容引进</span></span><br><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> EmailMultiAlternatives		<span class="comment"># 这样可以发送HTML格式的内容了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在大促压测详情页发送邮件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_mail</span>(<span class="params">request</span>):</span><br><span class="line">    subject = <span class="string">&#x27;2020年9月25日XXX次压测报告&#x27;</span></span><br><span class="line">    text_content = <span class="string">&#x27;这是一封veryveryvery重要的邮件.&#x27;</span></span><br><span class="line">    html_content = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    &lt;p&gt;这是一封&lt;strong&gt;重要的&lt;/strong&gt;邮件.&lt;br&gt;好好学习天天向上&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;table border=&quot;1&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;tr&gt;</span></span><br><span class="line"><span class="string">            &lt;th&gt;Header 1&lt;/th&gt;</span></span><br><span class="line"><span class="string">            &lt;th&gt;Header 2&lt;/th&gt;</span></span><br><span class="line"><span class="string">        &lt;/tr&gt;</span></span><br><span class="line"><span class="string">        &lt;tr&gt;</span></span><br><span class="line"><span class="string">            &lt;td&gt;row 1, cell 1&lt;/td&gt;</span></span><br><span class="line"><span class="string">            &lt;td&gt;row 1, cell 2&lt;/td&gt;</span></span><br><span class="line"><span class="string">        &lt;/tr&gt;</span></span><br><span class="line"><span class="string">        &lt;tr&gt;</span></span><br><span class="line"><span class="string">            &lt;td&gt;row 2, cell 1&lt;/td&gt;</span></span><br><span class="line"><span class="string">            &lt;td&gt;row 2, cell 2&lt;/td&gt;</span></span><br><span class="line"><span class="string">        &lt;/tr&gt;</span></span><br><span class="line"><span class="string">    &lt;/table&gt;</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    from_email = settings.DEFAULT_FROM_EMAIL</span><br><span class="line">    msg = EmailMultiAlternatives(subject, text_content, from_email, [<span class="string">&#x27;接收人的邮箱地址&#x27;</span>])</span><br><span class="line">    msg.attach_alternative(html_content, <span class="string">&quot;text/html&quot;</span>)</span><br><span class="line"></span><br><span class="line">    msg.send()</span><br><span class="line">    <span class="built_in">print</span>(request.POST)</span><br><span class="line">    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;status&#x27;</span>: <span class="string">&#x27;邮件已经发送成功！&#x27;</span>&#125;)   <span class="comment"># 这个信息返回给AJAX</span></span><br></pre></td></tr></table></figure></p>
<p>保存之后，在页面上尝试一下点击“发送邮件”按钮试试，效果如下：<br><img data-src="/images/Django%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6.png" alt="akb48" title="这一下就可以一键直接发送压测报告了"></p>
<p>如果你想在HTML里直接调用系统默认电邮程序发送邮件，就把HTML这么写：<br>	<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mailto:XXX@126.com&quot;</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>到时候点击<code>Email</code>链接就会弹出程序了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/yifchan/p/python-1-34.html">https://www.cnblogs.com/yifchan/p/python-1-34.html</a><br><a href="https://blog.csdn.net/qq_35695253/article/details/80145634">https://blog.csdn.net/qq_35695253/article/details/80145634</a>  《Django获取该数据的上一条和下一条》</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>平台搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>DockerFile创建一个redis容器的全过程</title>
    <url>/2018/02/25/DockerFile%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAredis%E5%AE%B9%E5%99%A8%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本次目标是用<code>Centos 7</code>的基础镜像做一个redis容器供开发人员在开发环境里蹂躏。</p>
<p>首先，创建一个叫<code>redis-test</code>的文件夹，在这个<code>redis-test</code>文件夹里建立一个<code>Dockerfile</code>，内容如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">FROM</span> <span class="attr">centos</span>:latest</span><br><span class="line"><span class="variable constant_">MAINTAINER</span> <span class="title class_">Chris</span> <span class="title class_">Chan</span> <span class="string">&quot;chenx1242@163.com&quot;</span></span><br><span class="line"><span class="variable constant_">ENV</span> <span class="variable constant_">REFRESHED_AT</span> <span class="number">2017</span>-<span class="number">02</span>-<span class="number">16</span></span><br><span class="line"><span class="variable constant_">RUN</span> yum -y update &amp;&amp;  yum -y install epel-release &amp;&amp; yum -y install redis &amp;&amp; yum -y install net-tools</span><br><span class="line"><span class="variable constant_">EXPOSE</span> <span class="number">6379</span></span><br><span class="line"><span class="variable constant_">ENTRYPOINT</span> [ <span class="string">&quot;/usr/bin/redis-server&quot;</span> ]</span><br><span class="line"><span class="variable constant_">CMD</span> []</span><br></pre></td></tr></table></figure></p>
<p>这里我们简单说一下整个<code>Dockerfile</code>的内容：</p>
<p>首先选择了基础镜像是centos的最新版，即<code>centos 7</code>，然后填写作者信息；</p>
<p>在yum这一块要注意，如果没有安装<code>epel-release</code>的话，是无法正常安装redis的，这是centos与ubuntu不一样的地方。至于后面又补充安装了<code>net-tools</code>是因为<code>centos 7</code>里不自带<code>ifconfig</code>命令，所以需要安装一下<code>net-tools</code>，这样就有了<code>ifconfig</code>了；</p>
<p>随即我们又开放了<code>6379</code>端口；</p>
<p>然后就是<code>entrypoint</code>和<code>cmd</code>，这两个命令的区别很重要，具体区别请看：<a href="http://cloud.51cto.com/art/201411/457338.htm">http://cloud.51cto.com/art/201411/457338.htm</a> 这篇文章。</p>
<p>然后我们就可以依照这个Dockfile去建立一个镜像，因为目的是要在“centos环境下建立一个redis”，那么我们这个镜像的名字就叫作<code>lccentos/redis</code>，具体操作就是在<code>redis-test</code>文件夹下执行<code>docker build -t lccentos/redis .</code>。</p>
<p>然后根据这个镜像需要制作一个容器，容器的名字就叫<code>redisforcentos</code>，那么命令就是：<code>docker run -d -p 6379 --name redisforcentos lccentos/redis</code>。</p>
<p>然后我们<code>docker ps -a</code>看一下效果，如下：<br><img data-src="/images/redisinfo2.png" alt="paradin"></p>
<p>可见宿主机的32774端口和容器的6379端口“融为一体”，这个时候，我们测试一下这个<code>redisforcento</code>s的容器是否已经正常启动了redis，如图：<br><img data-src="/images/redisinfo3.png" alt="paradin"></p>
<p>而且对于Docker来说，可以多个docker对应宿主机的同一个端口，比如我这台机器搞了两个redis，两个容器都可以指向6379的端口，如图：<br><img data-src="/images/redisinfo4.png" alt="paradin"></p>
<h2 id="Dockerfile的优化原则"><a href="#Dockerfile的优化原则" class="headerlink" title="Dockerfile的优化原则"></a>Dockerfile的优化原则</h2><p>1）ADD和VOLUME应该放在Dockerfile底部，因为它们相对比yum安装那些变化的更勤；<br>2）EXPOSE可以一口气对应多个端口，比如<code>EXPOSE 80 2003 2004 7002</code>的效果跟下面的效果一样；<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">EXPOSE</span> <span class="number">80</span> </span><br><span class="line"><span class="variable constant_">EXPOSE</span> <span class="number">2003</span> </span><br><span class="line"><span class="variable constant_">EXPOSE</span> <span class="number">2004</span> </span><br><span class="line"><span class="variable constant_">EXPOSE</span> <span class="number">7002</span></span><br></pre></td></tr></table></figure></p>
<p>3）<code>ADD</code>的操作应该放在<code>Dockerfile</code>的最下面；</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://dockone.io/article/255?spm=5176.100239.blogcont40494.25.8RXqDX">http://dockone.io/article/255?spm=5176.100239.blogcont40494.25.8RXqDX</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker出现客户端与服务端有差的错误...</title>
    <url>/2018/01/16/Docker%E5%87%BA%E7%8E%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%9C%89%E5%B7%AE%E7%9A%84%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>今天用docker搞redis镜像的的时候，出现了这样的错误提示：<code>Error response from daemon: client is newer than server (client API version: 1.24, server API version: 1.22)</code>，如图：<br><img data-src="/images/docker1.png" alt="akb48"></p>
<p>可见使用了<code>docker version</code>的时候也有提示：当前docker客户端比服务端版本更新。这样是无法创建镜像的，遇到这个问题很简单，那就是重启一下docker，命令如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">systemctl stop docker</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure></p>
<p>然后我们再<code>docker version</code>看一下效果：<br><img data-src="/images/docker2.png" alt="akb48"></p>
<p>我做这个的时候，docker升级了也一样可以读到原先的镜像，但是出于保险起见我们也应该学会如何保存和导入镜像，比如现在我现在有这个叫<code>docker.io/ubuntu</code>的镜像，如图：<br><img data-src="/images/docker3.png" alt="akb48"></p>
<p>如果要备份它的话，语句就是：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">docker save docker.<span class="property">io</span>/ubuntu &gt; <span class="regexp">/root/u</span>buntu.<span class="property">image</span></span><br></pre></td></tr></table></figure></p>
<p>这里备份后的文件名就是ubuntu.image。</p>
<p>如果要导入的话，语句就是：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">docker load &lt; <span class="regexp">/root/u</span>buntu.<span class="property">image</span></span><br></pre></td></tr></table></figure></p>
<p>这样导入的话，images create时间是不变的。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>Excel根据相同的列合并两个sheet的内容</title>
    <url>/2021/05/24/Excel%E6%A0%B9%E6%8D%AE%E7%9B%B8%E5%90%8C%E7%9A%84%E5%88%97%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AAsheet/</url>
    <content><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>假设我有个excel，想从两个不同的sheet里，根据相同的列合并这两部分的内容，怎么办？办法就是<code>vlookup</code>。</p>
<p>比如我第一个sheet的内容如下：<br><img data-src="/images/Excel%E5%90%88%E5%B9%B61.png" title="这个就叫sheet1"></p>
<p>而第二个sheet的内容如下<br><img data-src="/images/Excel%E5%90%88%E5%B9%B62.png" title="这个就叫sheet2"></p>
<p>现在需要根据相同的<code>应用名</code>这一列，合并两个sheet，这样可以在一个表里看到应用对应的owner、git库和是否开源。遇到这种情况时，我们可以使用Excel内置的<code>VLOOKUP</code> 功能来实现数据的查找与引用。</p>
<p><code>VLOOKUP</code>的语法很简单，翻译成一眼就能看明白的话就是——<code>VLOOKUP</code>函数需要有 4 个部分：「需要以那个列为共同列、在哪个区域或者那个sheet的哪个区域查、查的列是第几列、是否返回近似值」。</p>
<p>这个式子中的最后一个值是选填的，0（False）是精确，1（True）是近似。</p>
<p>实际使用时只要记住最简单的 <code>=VLOOKUP(共同列,查的区域,返回第几列,0)</code>这样一个式子，就能顺利地使用<code>VLOOKUP</code>函数了。这里要注意，先把<code>共同列</code>放在两个sheet的第一列！</p>
<p>说回上面这个例子，如何合并这两个sheet呢？</p>
<p>先把<code>共同列</code>放在两个sheet的第一列，这里就是<code>应用名</code>这一列。然后把光标定位在需要展示数据的单元格中，也就是sheet1的D列，如图：<br><img data-src="/images/Excel%E5%90%88%E5%B9%B63.png"></p>
<p>在单元格中输入”&#x3D;vl”，然后会自动提示出VLOOKUP函数，双击蓝色的函数部分，就可以看到单元格中显示出的完整的VLOOKUP函数。选择第一列中需要匹配数据的单元格，只选中<code>应用名</code>这一列就可以，然后再英文状态下输入逗号”,”，如图：<br><img data-src="/images/Excel%E5%90%88%E5%B9%B64.png"></p>
<p>因为我们要返回的信息是sheet2中第2列的“代码库”信息，所以在公式中再输入”,2,”（因为第2列），这时Excel提示信息让我们选择<code>TRUE</code>或<code>FLASE</code>，选不选都行，默认是<code>TRUE</code>，直接回车即可。</p>
<p>可以看到，我们的公式就是<code>=VLOOKUP(A:A,Sheet2!A:C,2,FALSE)</code>,这个公式解读一下就是<code>以A列的全部作为公共列，在sheet2的A列到C列里查，返回A列到C列的第二列，精确查找</code>此时这个函数已经得到了值，如图：<br><img data-src="/images/Excel%E5%90%88%E5%B9%B66.png"></p>
<p>然后“是否开源”这一列也是一样的方法，公式是<code>=VLOOKUP(A:A,Sheet2!A:C,3,)</code> 直接拉下来就把剩下的值都获取到了，如图：<br><img data-src="/images/Excel%E5%90%88%E5%B9%B67.png" title="WDK在sheet2里就是没有对应的行，所以N&#x2F;A"></p>
<p>这里要注意！我们获取到的列内容是函数，如果sheet2的内容发生了变化，那么sheet1也要变更的，这个时候，我们只需要获取到对应的值就行，“值”选择的方法如下：<br><img data-src="/images/Excel%E5%90%88%E5%B9%B68.png" title="新开一列来复制值"></p>
<p>vlookup里还有几个地方需要注意，首先<code>需要查的内容</code>必须是<code>查哪个区域</code>第一列。很多时候查不出数据，就是因为没有遵守这个规则，这里一定要切记切记！。</p>
<p>第二条，选择寻找的区域的时候，不要点击左上角的三角来获取全部，一定要像例子写的那样，选择对应的列来作为目标范围，不然会有<code>#ERF</code>的错误。</p>
<h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><p><a href="https://www.zhihu.com/question/38606861">https://www.zhihu.com/question/38606861</a><br><a href="https://sspai.com/post/53242">https://sspai.com/post/53242</a><br><a href="https://blog.csdn.net/laobai1015/article/details/85248125">https://blog.csdn.net/laobai1015/article/details/85248125</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Excel</tag>
        <tag>Office</tag>
      </tags>
  </entry>
  <entry>
    <title>ES对应Kafka的topic生成不同的Index</title>
    <url>/2019/01/30/ES%E5%AF%B9%E5%BA%94kafka%E7%9A%84topic%E7%94%9F%E6%88%90index/</url>
    <content><![CDATA[<p>假设有两个模块分别叫shopauth和shoporder，日志文件也对应分别是<code>shopauth.log</code>和<code>shoporder.log</code>，现在需要把日志对应放到同个kafka里不同的topic里。</p>
<p>shopauth的<code>filebeat.yml</code>内容如下：<br>	<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">filebeat.prospectors<span class="punctuation">:</span></span><br><span class="line">- type<span class="punctuation">:</span> log</span><br><span class="line">  enabled<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  paths<span class="punctuation">:</span></span><br><span class="line">    - /mnt/shopauth/logs/shopauth.log	#日志路径</span><br><span class="line">  tags<span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;logmessages&quot;</span><span class="punctuation">]</span></span><br><span class="line">  encoding<span class="punctuation">:</span> utf<span class="number">-8</span></span><br><span class="line">  scan_frequency<span class="punctuation">:</span> <span class="number">10</span>s</span><br><span class="line">  harvester_buffer_size<span class="punctuation">:</span> <span class="number">15000</span></span><br><span class="line">  tail_files<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  fields<span class="punctuation">:</span></span><br><span class="line">    alilogtype<span class="punctuation">:</span> app_log</span><br><span class="line">    serverip<span class="punctuation">:</span> <span class="number">172.16</span><span class="number">.0</span><span class="number">.201</span>	#本地IP地址</span><br><span class="line">	log_topics<span class="punctuation">:</span> ecnode-log</span><br><span class="line"></span><br><span class="line">output.kafka<span class="punctuation">:</span></span><br><span class="line">  enabled<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  hosts<span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;172.31.0.84:9092&quot;</span><span class="punctuation">]</span>	#指定kafka的地址信息</span><br><span class="line">  topic<span class="punctuation">:</span> &#x27;%<span class="punctuation">&#123;</span><span class="punctuation">[</span>fields<span class="punctuation">]</span><span class="punctuation">[</span>log_topics<span class="punctuation">]</span><span class="punctuation">&#125;</span>&#x27;	#自动识别topic</span><br></pre></td></tr></table></figure></p>
<p>如果只有一个log源输入日志（不是指paths只有一个路径，paths可以同时指定多个路径），那么<code>output.kafka</code>的topic当然可以写死。如果是多个log源写入日志，而且又要对应输入到kafka的topic里，可以使用<code>&#39;%{[fields][log_topics]}&#39;</code>，达到自动识别的目的。</p>
<p><font color=red>但是要注意！</font>如果加上了<code>fields_under_root: true</code>，那么<code>&#39;%{[fields][log_topics]}&#39;</code>是错误的，要改成<code>topic: &quot;%{[log_topic]}&quot;</code>才可以。</p>
<p>shoporder的<code>filebeat.yml</code>内容如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">filebeat.<span class="property">prospectors</span>:</span><br><span class="line">- <span class="attr">type</span>: log</span><br><span class="line">  <span class="attr">enabled</span>: <span class="literal">true</span></span><br><span class="line">  <span class="attr">paths</span>:</span><br><span class="line">    - <span class="regexp">/mnt/</span>shoporder/logs/shoporder.<span class="property">log</span>		#指定路径</span><br><span class="line">  <span class="attr">tags</span>: [<span class="string">&quot;logmessages&quot;</span>]</span><br><span class="line">  <span class="attr">encoding</span>: utf-<span class="number">8</span></span><br><span class="line">  <span class="attr">scan_frequency</span>: 10s</span><br><span class="line">  <span class="attr">harvester_buffer_size</span>: <span class="number">15000</span></span><br><span class="line">  <span class="attr">tail_files</span>: <span class="literal">true</span></span><br><span class="line">  <span class="attr">fields</span>:</span><br><span class="line">    <span class="attr">alilogtype</span>: app_log</span><br><span class="line">    <span class="attr">serverip</span>: <span class="number">172.16</span><span class="number">.0</span><span class="number">.207</span>	#本地<span class="variable constant_">IP</span>地址</span><br><span class="line"></span><br><span class="line">output.<span class="property">kafka</span>:</span><br><span class="line">  <span class="attr">enabled</span>: <span class="literal">true</span></span><br><span class="line">  <span class="attr">hosts</span>: [<span class="string">&quot;172.31.0.84:9092&quot;</span>]	#指定kafka的地址信息</span><br><span class="line">  <span class="attr">topic</span>: <span class="string">&#x27;shoporder-log&#x27;</span>	#指定topic</span><br></pre></td></tr></table></figure></p>
<p>启动filebeat和kafka，kafka的配置这里略过不表。在kafka里查看，发现已经生成对应的topic：<br><img data-src="/images/elk21.png" alt="akb48"></p>
<p>而<code>logstash.yml</code>内容如下：<br>	<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">input <span class="punctuation">&#123;</span></span><br><span class="line">        kafka<span class="punctuation">&#123;</span></span><br><span class="line">                bootstrap_servers=&gt;<span class="string">&quot;172.31.0.84:9092&quot;</span>	#指定kafka的IP和端口</span><br><span class="line">                topics=&gt;<span class="punctuation">[</span><span class="string">&quot;shoporder-log&quot;</span><span class="punctuation">,</span><span class="string">&quot;shopauth-log&quot;</span><span class="punctuation">]</span>	#说明从这两个topic里消费</span><br><span class="line">                decorate_events=&gt;<span class="string">&quot;true&quot;</span>	#这个很重要，等会细说</span><br><span class="line">                codec=&gt;plain</span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">filter <span class="punctuation">&#123;</span>	#利用kafka域的内容构建自定义的域</span><br><span class="line">   if <span class="punctuation">[</span>@metadata<span class="punctuation">]</span><span class="punctuation">[</span>kafka<span class="punctuation">]</span><span class="punctuation">[</span>topic<span class="punctuation">]</span> == <span class="string">&quot;shopauth-log&quot;</span> <span class="punctuation">&#123;</span>	</span><br><span class="line">      mutate <span class="punctuation">&#123;</span></span><br><span class="line">         add_field =&gt; <span class="punctuation">&#123;</span><span class="string">&quot;[@metadata][index]&quot;</span> =&gt; <span class="string">&quot;shopauth-log-%&#123;+YYYY-MM&#125;&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">   <span class="punctuation">&#125;</span> else if <span class="punctuation">[</span>@metadata<span class="punctuation">]</span><span class="punctuation">[</span>kafka<span class="punctuation">]</span><span class="punctuation">[</span>topic<span class="punctuation">]</span> == <span class="string">&quot;shoporder-log&quot;</span> <span class="punctuation">&#123;</span></span><br><span class="line">      mutate <span class="punctuation">&#123;</span></span><br><span class="line">         add_field =&gt; <span class="punctuation">&#123;</span><span class="string">&quot;[@metadata][index]&quot;</span> =&gt; <span class="string">&quot;shoporder-log-%&#123;+YYYY-MM&#125;&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">   <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">output <span class="punctuation">&#123;</span></span><br><span class="line">        elasticsearch <span class="punctuation">&#123;</span></span><br><span class="line">                hosts=&gt;<span class="punctuation">[</span><span class="string">&quot;172.31.0.76:9200&quot;</span><span class="punctuation">]</span>	#指定es的IP和端口</span><br><span class="line">                index=&gt;<span class="string">&quot;%&#123;[@metadata][index]&#125;&quot;</span>	#对应生成各自的index</span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>说一下<code>decorate_events</code>，如果只用了单个logstash，订阅了多个主题，你肯定希望在es中为不同主题创建不同的索引，那么<code>decorate_events</code>就是你想要的配置项。这个值默认是<code>false</code>，当指定这个选项为<code>true</code>时，会附加kafka的一些信息到<code>logstash event</code>的一个名为kafka的域（<code>Metadata fields</code>）中，然后再通过filter进行判断，如果是从<code>shopauth-log</code>这个topic得到信息，就把index设定成<code>shopauth-log-%{+YYYY-MM}&quot;</code>。</p>
<p>启动logstash，待其正常之后，在es的控制台查看日志，发现index索引已经成功生成：<br><img data-src="/images/elk22.png" alt="akb48"></p>
<p>现在在kibana里就可以创建索引然后查找了！</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>elk</tag>
        <tag>logstash</tag>
      </tags>
  </entry>
  <entry>
    <title>EXCEL如何去掉科学记数法</title>
    <url>/2023/01/09/EXCEL%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E5%8E%BB%E6%8E%89%E7%A7%91%E5%AD%A6%E8%AE%B0%E6%95%B0%E6%B3%95/</url>
    <content><![CDATA[<h2 id="在复制粘贴时去掉科学记数法"><a href="#在复制粘贴时去掉科学记数法" class="headerlink" title="在复制粘贴时去掉科学记数法"></a>在复制粘贴时去掉科学记数法</h2><p>excel里的默认将长串数字以科学记数法的功能简直就是反人类，而且最坑的是，复制粘贴之后，再将科学记数法的数字通过“单元格格式-通用-0”是无法还原的，因为末尾数都是0。</p>
<p>那么这种复制粘贴大量数据，避免科学计数法的方法如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>在目标的Sheet里面全选，然后右键==&gt;设置单元格格式==&gt;数字==&gt;文本.</span><br><span class="line"><span class="number">2.</span>先复制好源数据，然后鼠标右键点击第一步的设置好的Sheet表，粘贴选项==&gt;匹配目标格式即可</span><br></pre></td></tr></table></figure></p>
<p>匹配目标格式的地方在这里：<br><img data-src="/images/excel%E7%B2%98%E8%B4%B4.png"></p>
<p>这样粘出来的长串数字就是原汁原味的了。</p>
<h2 id="在数据分列时去掉科学记数法"><a href="#在数据分列时去掉科学记数法" class="headerlink" title="在数据分列时去掉科学记数法"></a>在数据分列时去掉科学记数法</h2><p>如果数据列里有多个数据，一旦分列时，那么数据就会默认成为了科学记数法，如图：<br><img data-src="/images/%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%951.png"></p>
<p><img data-src="/images/%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%953.png" title="默认就会生成这么一个鬼样子"><br>这里又是一个蛋疼的地方，要解决这个问题，就要在分列的“第三步”里，把“列数据格式”改成文本，注意，这里有多少列，就要手动的把对应的列都改成“文本”才行，如图：</p>
<p><img data-src="/images/%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%952.png" title="这里很恶心，要一个一个手动点过去"></p>
<p><img data-src="/images/%E7%BA%A2%E8%BE%A3%E6%A4%92%E8%B7%B3%E6%A5%BC.gif" alt="&quot;足够荒诞的现实&quot;" title="It is showtime!"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>数据处理</tag>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title>Excel合并同一列相同行对应的行值</title>
    <url>/2021/05/19/Excel%E5%90%88%E5%B9%B6%E5%90%8C%E4%B8%80%E5%88%97%E7%9B%B8%E5%90%8C%E8%A1%8C%E5%AF%B9%E5%BA%94%E7%9A%84%E8%A1%8C%E5%80%BC/</url>
    <content><![CDATA[<p>在处理Excel的时候，有时候会遇到这样的情况：有几行的列是一样的，那么想把后面对应的行也合并到一行里，如下图：<br><img data-src="/images/Excel%E5%90%88%E5%B9%B64.png" title="将三行abc合并成a,b,c"></p>
<p>首先在D列复制整个A列过来，然后点击“数据”，选择“删除重复项”，如图：<br><img data-src="/images/Excel%E5%90%88%E5%B9%B65.png" title="这样只剩下“张三，李四，王五"></p>
<p>然后在E1单元格输入<code>=mid(SUBSTITUTE(PHONETIC(offset(INDIRECT(&quot;A&quot;&amp;match(D1,A:A,)),,,countif(A:A,D1),2)),D1,&quot;,&quot;),2,99)</code>，这里D1是因为我们的新的标准列是在D列。如图：<br><img data-src="/images/Excel%E5%90%88%E5%B9%B69.png" title="此时A应该是红色"></p>
<p>然后回车就看到效果了，最后就是拉下来即可：<br><img data-src="/images/Excel%E5%90%88%E5%B9%B610.png"></p>
<p>如果是要获取相同内容行对应行的和，使用透视表即可。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Excel</tag>
        <tag>Office</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker部署的几个tips</title>
    <url>/2018/10/10/Docker%E9%83%A8%E7%BD%B2%E7%9A%84%E5%87%A0%E4%B8%AAtips/</url>
    <content><![CDATA[<p>公司的电商平台使用的是阿里云VPC网络，整个交换机和云服务器都是部署在D区。今天在部署测试环境的时候，发现无法购买服务器，在钉钉上与阿里云售后交涉后，接到噩耗—D区已经不再出售服务器了，如图：<br><img data-src="/images/docker14.png" alt="akb48"></p>
<p>没办法，只能把现有的服务器调高配置，在里面安装docker，尽可能的让各进程的环境彼此之间不受干扰。由于事发仓促，整个架构都要重新调整，镜像就先选用<code>centos：latest</code>，生成容器后在里面装环境以及<code>git  pull</code>代码，把容器当做虚拟机来用了。</p>
<h2 id="几个小提示"><a href="#几个小提示" class="headerlink" title="几个小提示"></a>几个小提示</h2><ol>
<li><p>如果要<code>pecl install swoole</code>的话，要先<code>yum install -y glibc-headers gcc-c++ kernel-headers gcc openssl pcre-devel</code>和<code>yum install -y openssl-devel</code>；</p>
</li>
<li><p><code>centos:latest</code>镜像目前是7.5版本，如果要查看的话需要先安装lsb命令：<code>yum install redhat-lsb -y</code>；</p>
</li>
<li><p>如果容器里使用yum下载爆’Operation too slow. Less than 1000 bytes&#x2F;sec transferred the last 30 seconds’，用<code>yum -y install wget</code>解决；</p>
</li>
<li><p>容器需要php7.2的环境的话，就要用最新的源：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yum install epel-release -y</span><br><span class="line">rpm -<span class="title class_">Uvh</span> <span class="attr">https</span>:<span class="comment">//mirror.webtatic.com/yum/el7/webtatic-release.rpm</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>别忘了开机自启动docker进程：<code>systemctl enable docker</code>；</p>
</li>
<li><p><code>yum install node npm</code>之前要</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yum install -y epel-release</span><br><span class="line">curl --silent --location <span class="attr">https</span>:<span class="comment">//rpm.nodesource.com/setup_8.x | bash -</span></span><br><span class="line">yum install -y nodejs		#这样版本是<span class="number">8.12</span>,npm的版本是<span class="number">6.4</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在容器里查看端口情况就要安装netstat命令：<code>yum install -y net-tools</code>；</p>
</li>
<li><p>将一个运行中的容器做成镜像的命令：<code>docker commit 容器ID号 镜像名称</code>；</p>
</li>
<li><p>进入容器最好不要用<code>docker attach 容器ID</code>的方式，而是用<code>docker exec -it 容器ID /bin/bash</code>，离开容器的时候也不要用<code>exit</code>或者<code>ctrl + D</code>，这样会将容器停止，而是用<code>ctrl + P</code>、<code>ctrl + Q</code> 或者<code>ctrl + Q + P</code>组合键退出，这样就不会终止容器运行；</p>
</li>
<li><p>容器默认的时间与宿主机的时间相差8个小时，可以在<code>docker run</code>的时候使用-v挂载的方法挂载宿主机的时间文件，比如：<code>docker run --name 容器名 -v /etc/localtime:/etc/localtime:ro ...</code>，或者在dockerfile里添加“设定时区”的语句：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#设置时区</span><br><span class="line"><span class="variable constant_">RUN</span> /bin/cp /usr/share/zoneinfo/<span class="title class_">Asia</span>/<span class="title class_">Shanghai</span> /etc/localtime \</span><br><span class="line">    &amp;&amp; echo <span class="string">&#x27;Asia/Shanghai&#x27;</span> &gt;<span class="regexp">/etc/</span>timezone \</span><br></pre></td></tr></table></figure>
</li>
<li><p>容器映射默认情况下是tcp6的，这是正常的现象，如果telnet不通，请先去检查容器内的服务是否正常，比如在容器里<code>curl 127.0.0.1 端口号</code>；</p>
</li>
<li><p>使用<code>docker top 容器id</code>命令能获取的PID是容器内进程在宿主机上的pid，ppid是容器内进程在宿主机上的父进程pid；</p>
</li>
<li><p>如果多个容器要挂载一样的数据就是用<code>-volumes-from </code>，比如<code>docker run --volume-from 容器ID号</code>； </p>
</li>
<li><p>在容器外启动容器内部进程的方法是：<code>docker exec 容器ID /bin/bash -c &quot;对应的命令&quot; </code>，在zabbix监控docker发现进程死了后，就可以用这个方法拉起来；<br><img data-src="/images/docker17.png" alt="akb48" title="在容器外面启动并且关闭apache"></p>
</li>
<li><p>接上一条的说，docker跟虚拟机不同，它启动的时候是不会运行<code>/etc/rc.d/rc.local</code>的，如果想要Docker在启动后就自动运行<code>/etc/rc.d/rc.local</code>，请看<a href="https://github.com/johnnian/Blog/issues/13">https://github.com/johnnian/Blog/issues/13</a> 里面说的方法；</p>
</li>
<li><p>容器内的进程是会映射到宿主机上的，举个例子，比如容器里运行了swoole，如图：<br><img data-src="/images/docker15.png" alt="akb48"></p>
</li>
</ol>
<p>在宿主机上看也是能看到这个进程的：<br><img data-src="/images/docker16.png" alt="akb48" title="容器与宿主机时差相差8小时"></p>
<ol start="17">
<li>有时候是需要用一个脚本来启动镜像进程的，但是要知道容器只能管理一个主进程，当脚本执行完毕了，容器也会EXIT，所以我们需要在启动脚本后面添加<code>tail -f /dev/null</code>让这个启动脚本永远执行不结束。举个例子：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --name XXX -dit -v /data/httpd/yii_ecadmin/:/var/www -w /var/www --restart=always registry.cn-hangzhou.aliyuncs.com/lechangeshop/ecadmin:20190520 ./start.sh</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.sina.com.cn/s/blog_5ff8e0a00102wmti.html">http://blog.sina.com.cn/s/blog_5ff8e0a00102wmti.html</a><br><a href="https://outmanzzq.github.io/2018/01/11/docker-exit-without-stop/">https://outmanzzq.github.io/2018/01/11/docker-exit-without-stop/</a><br><a href="http://dockone.io/article/128">http://dockone.io/article/128</a><br><a href="https://blog.csdn.net/halcyonbaby/article/details/46884605">https://blog.csdn.net/halcyonbaby/article/details/46884605</a><br><a href="https://stackoverflow.com/questions/30960686/difference-between-docker-attach-and-docker-exec">https://stackoverflow.com/questions/30960686/difference-between-docker-attach-and-docker-exec</a><br><a href="https://www.binss.me/blog/learn-docker-with-me-about-volume/">https://www.binss.me/blog/learn-docker-with-me-about-volume/</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>Git clone的几个错误</title>
    <url>/2018/11/12/Git-clone%E7%9A%84%E5%87%A0%E4%B8%AA%E5%B0%8F%E6%95%85%E9%9A%9C/</url>
    <content><![CDATA[<p>Git clone的时候可能会出现<code>fatal: HTTP request failed</code>的错误，如图：<br><img data-src="/images/ksyunsdk.png" alt="akb48"></p>
<p>一般来说这样的情况多半就是git版本太低，&lt;&#x3D;1.7的版本经常出现这样的错误，解决问题的办法就是使用最新的git，安装git 1.9的方法在这里：<a href="https://rorschachchan.github.io/2018/06/13/Centos6%E5%AE%89%E8%A3%85git1-9%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/">https://rorschachchan.github.io/2018/06/13/Centos6%E5%AE%89%E8%A3%85git1-9%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/</a> 。</p>
<p>更新到1.9之后重新去git clone，这一次换成了<code>SSL connect error</code>错误：<br><img data-src="/images/ksyunsdk2.png" alt="akb48"></p>
<p>此时就需要执行一下<code>yum update -y nss curl libcurl</code>，这样才能顺利的git clone。</p>
<p>如果出现了<code>easy_install command not found</code>，可以使用<code>wget https://bootstrap.pypa.io/ez_setup.py -O - | python</code> 解决，有了easy_install就可以安装pip了。</p>
<p>以上的操作是在python2.7下进行的。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>Python 2.7</tag>
      </tags>
  </entry>
  <entry>
    <title>Gitlab+Jenkins搭建持续集成系统</title>
    <url>/2018/05/25/Gitlab-Jenkins%E6%90%AD%E5%BB%BA%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>gitlab是一个应用很广泛的版本控制工具，他也有自带的持续集成工具—<code>gitlab cli</code>，但是这个工具不如jenkins那么好用。本文的目的要把gitlab和jenkins进行结合，当我们更新了代码并且把代码push到gitlab的时候，gitlab会把代码的变化通知到jenkins，然后jenkins就会自动构建project。</p>
<p>说一下实验环境：<br>Jenkins所在服务器IP：121.41.37.251(10.168.173.181)，版本是<code>2.124</code>(查看jenkins的版本语句<code>java -jar /usr/lib/jenkins/jenkins.war --version</code>);<br>Gitlab所在服务器IP：114.55.224.158(10.25.85.175)，使用容器安装，版本是<code>10.7.3</code>;</p>
<h2 id="jenkins添加gitlab插件"><a href="#jenkins添加gitlab插件" class="headerlink" title="jenkins添加gitlab插件"></a>jenkins添加gitlab插件</h2><p>通过浏览器登陆jenkins界面，然后在<code>系统管理</code>里面选择<code>管理插件</code>，如图：<br><img data-src="/images/gitlabjenkins1.png" alt="akb48"></p>
<p>然后在<code>可选择插件</code>里搜索<code>gitlab hook</code>插件，但是没想到我这个版本提示”目前的1.4.2版本的<code>gitlab hook</code>目前存在安全隐患”，如图：<br><img data-src="/images/gitlabjenkins2.png" alt="akb48"></p>
<p>具体的安全隐患细节是这样的：<br><img data-src="/images/gitlabjenkins3.png" alt="akb48"></p>
<p>这个风险请自己把握，然后我选择了继续安装，如图：<br><img data-src="/images/gitlabjenkins4.png" alt="akb48"></p>
<p>安装完了<code>gitlab hook</code>插件后，还要安装<code>GitLab Plugin</code>和<code>Gitlab Authentication plugin</code>这两个插件，方法跟上面的一样。</p>
<h2 id="创建测试工程"><a href="#创建测试工程" class="headerlink" title="创建测试工程"></a>创建测试工程</h2><p>在jenkins上建立一个新的任务，比如叫<code>jicheng-test</code>，这是一个<code>自由风格的软件项目</code>：<br><img data-src="/images/gitlabjenkins6.png" alt="akb48"></p>
<p>然后在源码管理里面选择git，然后输入gitlab里面仓库的地址，比如我在gitlab上新建了一个project叫<code>jenkinstest</code>，那么就复制这个仓库的地址填到jenkins的<code>Repositories</code>里，如图：<br><img data-src="/images/gitlabjenkins8.png" alt="akb48"></p>
<p>还要在<code>Credentials</code>这里面写上gitlab的用户和密码，然后保存即可：<br><img data-src="/images/gitlabjenkins9.png" alt="akb48"></p>
<h2 id="配置-GitLab-用户"><a href="#配置-GitLab-用户" class="headerlink" title="配置 GitLab 用户"></a>配置 GitLab 用户</h2><p>浏览器切换到gitlab界面，在用户头像点击，<code>User settings</code> —&gt; <code>Access Tokens</code>，这里的<code>Personal Access Tokens</code>写入一个账号，这个账号是用来让Jenkins和GitLab API交互。这个用户将需要是全局的管理员或添加进每个组／工程，并作为成员。需要开发者权限来报告构建状态。如图：<br><img data-src="/images/gitlabjenkins5.png" alt="akb48"></p>
<p>输入账号和账号有效时期之后，会生成一个Private token，如图：<br><img data-src="/images/gitlabjenkins7.png" alt="akb48"></p>
<p>拷贝它，稍后在配置Jenkins服务器时会用到。</p>
<h2 id="配置-Jenkins-服务器"><a href="#配置-Jenkins-服务器" class="headerlink" title="配置 Jenkins 服务器"></a>配置 Jenkins 服务器</h2><p>需要配置 Jenkins 服务器来与 GitLab 服务器通信。</p>
<p>在 Jenkins 中，选择<code>系统管理</code> -&gt;<code>系统设置</code>，在系统设置中找到GitLab的部分：<br><img data-src="/images/gitlabjenkins10.png" alt="akb48"></p>
<p>在<code>Connection name</code>后的输入框中输入连接名称，在<code>Gitlab host URL</code>后的输入框中输入GitLab服务器的URL地址。点击<code>Credentials</code>行最后面的<code>Add -&gt; Jenkins</code>按钮，弹出如下对话框，在Kind 后的下拉列表中选择<code>GitLab API token</code>，并把上一步拷贝的<code>Private token</code>粘贴到<code>API token</code>后面的输入框中。<br><img data-src="/images/gitlabjenkins11.png" alt="akb48"></p>
<p>随后在<code>Credentials</code>的下拉框中选择<code>GitLab API token</code>。</p>
<h2 id="配置-Jenkins-工程"><a href="#配置-Jenkins-工程" class="headerlink" title="配置 Jenkins 工程"></a>配置 Jenkins 工程</h2><p>来到刚刚建立的那个工程<code>jicheng-test</code>，点击<code>构建触发器</code>，先勾选<code>Build when a change is pushed to GitLab</code>，点击<code>高级</code>，然后再点击一下<code>Generate</code>就会生成一个<code>Secret Token</code>，如下：<br><img data-src="/images/gitlabjenkins12.png" alt="akb48"></p>
<p>点击左下角的<code>保存</code>按钮，保存前面所做的配置。这个时候要记录两个东西，一个是<code>Build when a change is pushed to GitLab</code>那一行中，<code>GitLab CI Service URL: </code>后面的 URL；还有一个就是刚刚生成的<code>Secret Token</code>，这俩在后面配置GitLab工程时需要用到。</p>
<h2 id="配置-GitLab-工程"><a href="#配置-GitLab-工程" class="headerlink" title="配置 GitLab 工程"></a>配置 GitLab 工程</h2><p>在gitlab进入那个叫<code>jenkinstest</code>的project，然后在<code>settings---&gt;Integrations</code>，在<code>URL</code>里填写刚刚记下来的<code>URL</code>，在<code>Secret Token</code>里填写刚刚记下来的<code>Secret Token</code>，如图：<br><img data-src="/images/gitlabjenkins13.png" alt="akb48"></p>
<p>然后点击下面绿色的<code>add webhook</code>，就会生成一个<code>Webhooks</code>，如图：<br><img data-src="/images/gitlabjenkins14.png" alt="akb48"></p>
<p>去代码服务器上提交一个commit，然后push到gitlab里，再返回到<code>Integrations</code>，对刚刚生成的<code>webhooks</code>点击<code>test</code>，选择<code>push events</code>，如图：<br><img data-src="/images/gitlabjenkins16.png" alt="akb48"></p>
<p>然后就会出现200的成功字样，如图：<br><img data-src="/images/gitlabjenkins15.png" alt="akb48"></p>
<p>如果你再点击一下test上面的edit，就会看到webhook最近调用情况，再点击view details的话，就会看到具体的调用细节，如图：<br><img data-src="/images/gitlabjenkins17.png" alt="akb48"></p>
<h2 id="验证测试"><a href="#验证测试" class="headerlink" title="验证测试"></a>验证测试</h2><p>此时我在代码服务器上做了一些简单的改动，然后重新把代码push到gitlab服务器上，在jenkins里的相关project里，就会看到已经自动开始build了，如图：<br><img data-src="/images/gitlabjenkins18.png" alt="akb48"></p>
<p>再在具体的某次build里选择<code>控制台输出</code>，就会看到构建的详细过程，如图：<br><img data-src="/images/gitlabjenkins19.png" alt="akb48"></p>
<h2 id="横向扩展"><a href="#横向扩展" class="headerlink" title="横向扩展"></a>横向扩展</h2><p>如果是多个gitlab的project去对应同一个jenkins，那么需要在jenkins创建任务的时候就选择是<code>根据一个已经存在的任务创建</code>，如图：<br><img data-src="/images/gitlabjenkins21.png" alt="akb48"></p>
<p>在这里写上作为模板的任务的名称，然后在新生成的任务<code>配置</code>的<code>源码管理</code>里添加一个新的<code>Repositories</code>，如图：<br><img data-src="/images/gitlabjenkins20.png" alt="akb48"></p>
<p>如果想要限制分支的话，就要更改<code>Branches to build</code>，现在默认是“只要master分支有push就会触发jenkins构建”。然后再回到gitlab的新project里，进入<code>Integrations</code>，输入<code>配置 Jenkins 工程</code>那个环节里的<code>URL</code>就OK了，<code>Secret Token</code>不用单独填写，因为在复制任务那一步的时候直接把<code>Secret Token</code>全部拷贝过来了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.cnblogs.com/bugsbunny/p/7919993.html">http://www.cnblogs.com/bugsbunny/p/7919993.html</a><br><a href="https://www.wolfcstech.com/2018/03/26/gitlab_trigger_jenkins_build/">https://www.wolfcstech.com/2018/03/26/gitlab_trigger_jenkins_build/</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>Gitlab搭配Gitlab-runner实现流水线自动化部署</title>
    <url>/2019/08/21/Gitlab%E6%90%AD%E9%85%8DGitlab-runner%E5%AE%9E%E7%8E%B0%E6%B5%81%E6%B0%B4%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>最近跟开发研究给新业务搞一套完整的CI&#x2F;CD流程，据说drone很猛，在github上势头很高。不过缺点也很明显：文档不全+错误提示不到位，于是还是选择了Gitlab，这次不同于以往的Gitlab+jenkins，而是采用了Gitlab+runner。</p>
<p>名词解释，我这里就不多说了，可以去看<a href="https://segmentfault.com/a/1190000007180257">https://segmentfault.com/a/1190000007180257</a> ，讲解的很全。</p>
<p>环境介绍：阿里云Centos7 + Docker + Gitlab,gitlab里准备了一个测试用的project。</p>
<h2 id="配置gitlab-runner"><a href="#配置gitlab-runner" class="headerlink" title="配置gitlab-runner"></a>配置gitlab-runner</h2><p>很多地方都说<code>gitlab-runner</code>是一个比较吃内存的进程，而且处于安全角度考虑都很不推荐它跟gitlab装在一起，不过本文是展示测试而已，我手头也没有其他的服务器了，于是就先装在同一台服务器上。</p>
<p>用容器装<code>gitlab-runner</code>很简单，语句如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">docker run -d --name gitlab-runner --restart always \</span><br><span class="line">  -v /srv/gitlab-runner/config:/etc/gitlab-runner \</span><br><span class="line">  -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">  gitlab/gitlab-runner:latest</span><br></pre></td></tr></table></figure></p>
<p>如果你想玩骚的，可以通过一个存储卷容器来保存<code>gitlab-runner</code>的数据，语句如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">docker run -d --name gitlab-runner-config \</span><br><span class="line">   -v /etc/gitlab-runner \</span><br><span class="line">   busybox:latest \</span><br><span class="line">   /<span class="built_in">bin</span>/true</span><br><span class="line"></span><br><span class="line">docker run -d --name gitlab-runner --restart always \</span><br><span class="line">   -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">   --volumes-<span class="keyword">from</span> gitlab-runner-config \</span><br><span class="line">   gitlab/gitlab-runner:latest</span><br></pre></td></tr></table></figure></p>
<p>此时<code>docker ps -a</code>情况如下:<br><img data-src="/images/gitlab36.png" alt="抱光妹"></p>
<p>来到gitlab的WEB页面，进入测试用的project，然后左侧栏里选择<code>settings</code>—-<code>CI/CD</code>—点击<code>runner</code>，就会看到配置的相关信息，如图：<br><img data-src="/images/gitlab37.png" alt="抱光妹"></p>
<p>保持这个界面不要动，我们返回命令行进入<code>gitlab-runner</code>容器里，需要把runner注册到我们的gitlab上，执行命令<code>gitlab-runner register</code>，然后就是如下交互对话：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">root@4512a92c8cb2:/<span class="comment"># gitlab-runner register</span></span><br><span class="line">Runtime platform                                    arch=amd64 os=linux pid=<span class="number">26</span> revision=de7731dd version=<span class="number">12.1</span><span class="number">.0</span></span><br><span class="line">Running <span class="keyword">in</span> system-mode.                            </span><br><span class="line">                                                   </span><br><span class="line">Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/):	<span class="comment">#这里输入gitlab的域名，如果不是域名就http://IP的形式</span></span><br><span class="line">http://GITLAB的IP</span><br><span class="line">Please enter the gitlab-ci token <span class="keyword">for</span> this runner:</span><br><span class="line">刚刚页面里的token</span><br><span class="line">Please enter the gitlab-ci description <span class="keyword">for</span> this runner:		<span class="comment">#这里写一个注释</span></span><br><span class="line">[4512a92c8cb2]: test</span><br><span class="line">Please enter the gitlab-ci tags <span class="keyword">for</span> this runner (comma separated):</span><br><span class="line">my-tag			<span class="comment">#打一个标签，注意这个标签不能乱写，下面会细说</span></span><br><span class="line">Registering runner... succeeded                     runner=fvyoASC8</span><br><span class="line">Please enter the executor: docker, parallels, virtualbox, kubernetes, custom, shell, ssh, docker+machine, docker-ssh+machine, docker-ssh:</span><br><span class="line">shell			<span class="comment">#选择执行方式，我写了shell，如果你写的是docker，那么会让你填写一个镜像地址，然后默认就会去拉这个镜像地址</span></span><br><span class="line">Runner registered successfully. Feel free to start it, but <span class="keyword">if</span> it<span class="string">&#x27;s running already the config should be automatically reloaded! </span></span><br></pre></td></tr></table></figure></p>
<p>返回gitlab的web页面刷新一下，就看到刚刚填写的<code>runner</code>已经成功注册上了，如图：<br><img data-src="/images/gitlab38.png" alt="抱光妹"></p>
<p>可以看到注释和tag，如果点击小锁头旁边的编辑按钮，就可以编辑刚才命令行里的配置，所以tag啥的写错了请放心。</p>
<p>如果说想要看到runner的一个概览，那么就点击gitlab上的小扳手，然后<code>overview</code>–<code>runners</code>即可，如图：<br><img data-src="/images/gitlab39.png" alt="抱光妹"></p>
<p>至此<code>gitlab-runner</code>已经配置完成！</p>
<h2 id="搭配GItLab-CI"><a href="#搭配GItLab-CI" class="headerlink" title="搭配GItLab CI"></a>搭配GItLab CI</h2><p>要想在合并请求或者push的时候出发CI流水线，那么就在项目仓库的根目录添加<code>.gitlab-ci.yml</code>文件，for instance:<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stages:</span><br><span class="line">  - test</span><br><span class="line">  - build</span><br><span class="line">  - deploy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加名为test-check的任务</span></span><br><span class="line">test-check:</span><br><span class="line">  stage: test</span><br><span class="line">  tags: <span class="comment"># 指定使用有 my-tag 标签的runner运行该任务</span></span><br><span class="line">    - my-tag</span><br><span class="line">  <span class="comment"># 开始运行之前的操作</span></span><br><span class="line">  before_script:</span><br><span class="line">    - echo <span class="string">&#x27;runner begin...&#x27;</span></span><br><span class="line">  script:</span><br><span class="line">    - hostname &amp;&amp; date</span><br><span class="line">    - whoami</span><br><span class="line">  allow_failure: true	<span class="comment">#job失败了，pipline将会置绿或者置成功显示，可以继续往下走，但是commit页面或者job页面看到一条“CI build passed with warnings”的警告信息</span></span><br><span class="line"></span><br><span class="line">test-check2:</span><br><span class="line">  stage: test</span><br><span class="line">  tags:</span><br><span class="line">    - my-tag2</span><br><span class="line">  script:</span><br><span class="line">    - echo <span class="string">&quot;嘎嘎&quot;</span></span><br><span class="line">    - echo <span class="string">&quot;哈哈哈哈哈&quot;</span></span><br><span class="line">    - echo <span class="string">&quot;--------job2----------&quot;</span></span><br><span class="line">  after_script:</span><br><span class="line">    - echo <span class="string">&quot;FINISH!&quot;</span></span><br><span class="line"></span><br><span class="line">test-deploy:</span><br><span class="line">  stage: deploy</span><br><span class="line">  tags:</span><br><span class="line">    - deploy</span><br><span class="line">  environment:			<span class="comment">#这个环境设定主要是回滚的时候用得到</span></span><br><span class="line">    name: chentest</span><br><span class="line">    url: https://test.example.com</span><br><span class="line">  script:</span><br><span class="line">    - echo <span class="string">&quot;部署啦！！&quot;</span></span><br><span class="line">    - echo <span class="string">&quot;啦啦啦啦！&quot;</span></span><br><span class="line">    - echo <span class="string">&quot;--------job3----------&quot;</span></span><br><span class="line">    - echo <span class="string">&quot;finish&quot;</span> &gt;&gt; /tmp/test.txt</span><br></pre></td></tr></table></figure></p>
<p>然后触发一下<code>git push</code>，就会在gitlab的页面里看到<code>commit:passed</code>的绿色小勾，如图：<br><img data-src="/images/gitlab40.png" alt="抱光妹"></p>
<p>点击这个绿色小勾就能看到status下面的状态是<code>passed</code>，然后可以在<code>pipiline</code>里看到具体的流水线情况：<br><img data-src="/images/gitlab43.png" alt="抱光妹" title="在相同stage下的job将会被并行的执行"></p>
<p>然后点击对应的job，就能看到了执行的详情，如图：<br><img data-src="/images/gitlab41.png" alt="抱光妹"></p>
<p>可以看到整个过程是在<code>gitlab-runner</code>这个容器里操作的，如果失败了也可以在这里查看具体的原因。<font color=red>注意！.gitlab-ci.yml的任何对文件操作都是在gitlab-runner这个容器内部进行的，而不是它所在的宿主机！</font>也就是说在上面例子里job3最后的<code>/tmp/test.txt</code>是容器里的而不是宿主机的。</p>
<p>还有一个地方要注意，stage判断结果成功与否的标志是最后一个命令是否返回非零结果<code>($?)</code>，也就是说你的script内容是执行一个shell脚本，假如这个shell脚本中间有某些命令执行失败，但最后一个命令执行成功，stage最终结果也会是成功的。所以推荐shell命令行后面都加上<code>|| { exit 1; }</code>，这样可以避免坑。</p>
<p><code>.gitlab-ci.yml</code>的语法非常丰富，详情可见官方文档<a href="https://docs.gitlab.com/ce/ci/yaml/README.html">https://docs.gitlab.com/ce/ci/yaml/README.html</a> 或者是<a href="https://segmentfault.com/a/1190000010442764">https://segmentfault.com/a/1190000010442764</a> ，已经总结的非常全面了。</p>
<h2 id="高阶玩法"><a href="#高阶玩法" class="headerlink" title="高阶玩法"></a>高阶玩法</h2><p>上面只是gitlab-runner搭配cli的一个小小demo而已。在现实工作中，我们会创建很多个runner，然后给不同的runner分配各自的tag:编译、测试、打包和发布，然后在配合<code>.gitlab-ci.yml</code>文件操作。</p>
<p>如果想要jobs并发，先进入<code>gitlab-runner</code>容器里，将<code>/etc/gitlab-runner/config.toml</code>文件里的<code>concurrent = 1</code>酌情调大，重启容器生效。</p>
<p>如果说不想<code>push</code>都触发所有的jobs，而想要某个jobs在<code>merge</code>的时候才执行，可以在<code>.gitlab-ci.yml</code>里对应的job段落改成如下的格式：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stage: build</span><br><span class="line">script:</span><br><span class="line">  - xxxxx</span><br><span class="line">artifacts:</span><br><span class="line">  paths:</span><br><span class="line">    - xxxxx</span><br><span class="line">tags:</span><br><span class="line">  - xxxx</span><br><span class="line">only:			<span class="comment">#only后面可以跟分支或者标签</span></span><br><span class="line">     - /^issue-.*$/			<span class="comment"># 该job将会只在issue-开头的refs下执行</span></span><br><span class="line">  - merge_requests			<span class="comment"># 只有merge才会触发！</span></span><br></pre></td></tr></table></figure></p>
<p>如果在触发流水线执行job的时候被提示：<code>job is stuck check runners</code>，那么请检查一下gitlab-ci.yml里是不是没有写明tag。</p>
<p>除了上面<code>push/merge</code>人为触发之外，gitlab还支持定时触发流水线作业。可以在web界面里的<code>CI/CD</code>—<code>Schedules</code>看到，如图：<br><img data-src="/images/gitlab42.png" alt="抱光妹"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://triplecc.github.io/2018/06/23/2018-06-23-ji-gitlabcide-ci-shi-jian/">https://triplecc.github.io/2018/06/23/2018-06-23-ji-gitlabcide-ci-shi-jian/</a><br><a href="http://jiangbai333.github.io/2018/10/30/gitlab-runner%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/">http://jiangbai333.github.io/2018/10/30/gitlab-runner%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</a><br><a href="http://walterinsh.github.io/2016/04/18/using-gitlab-ci.html">http://walterinsh.github.io/2016/04/18/using-gitlab-ci.html</a><br><a href="https://www.chenshaowen.com/blog/gitlab-ci-configuring-runner.html">https://www.chenshaowen.com/blog/gitlab-ci-configuring-runner.html</a><br><a href="https://zhuanlan.zhihu.com/p/33633217">https://zhuanlan.zhihu.com/p/33633217</a><br><a href="https://segmentfault.com/a/1190000011890710">https://segmentfault.com/a/1190000011890710</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>自动化部署</tag>
        <tag>gitlab</tag>
        <tag>ci/cd</tag>
      </tags>
  </entry>
  <entry>
    <title>Gitlab的汉化过程</title>
    <url>/2018/05/15/Gitlab%E7%9A%84%E6%B1%89%E5%8C%96%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="gitlab的容器安装方法"><a href="#gitlab的容器安装方法" class="headerlink" title="gitlab的容器安装方法"></a>gitlab的容器安装方法</h2><p>部署前的第一句话，gitlab是不支持32位系统的！</p>
<p>gitlab用容器部署的话非常的简单，首先<code>docker pull gitlab/gitlab-ce:latest</code>下载镜像，然后<code>docker run --detach --hostname 本机外网IP --publish 443:443 --publish 80:80 --publish 2222:22 --name gitlab --restart always gitlab/gitlab-ce:latest</code>建立一个容器，如图：<br><img data-src="/images/gitlab10.png" alt="paradin"></p>
<p>然后在浏览器的地址栏里输入服务器的外网IP地址，就到了一个更换密码的页面(如果打开页面是Whoops, GitLab is taking too much time to respond.请检查内存是否小于2G)，这个密码就是root的密码，如图：<br><img data-src="/images/gitlab13.png" alt="paradin"></p>
<p>设定密码之后，就可以通过root账号登陆gitlab了，如图：<br><img data-src="/images/gitlab11.png" alt="paradin"></p>
<p>至于“使用ldap方式登录”、“配置域名”和“关闭注册功能”请移步去看：<a href="https://rorschachchan.github.io/2018/05/10/%E5%9C%A8%E5%B7%B2%E7%BB%8F%E8%BF%90%E8%A1%8C%E7%9A%84docker%E5%AE%B9%E5%99%A8%E9%87%8C%E9%9D%A2%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%87/">https://rorschachchan.github.io/2018/05/10/在已经运行的docker容器里面使用中文/</a> 。</p>
<h2 id="gitlab的汉化方法"><a href="#gitlab的汉化方法" class="headerlink" title="gitlab的汉化方法"></a>gitlab的汉化方法</h2><p>汉化之前，要确定gitlab的版本，先<code>docker exec -it 容器ID env LANG=C.UTF-8 /bin/bash</code>登陆到容器里，执行<code>cat /opt/gitlab/embedded/service/gitlab-rails/VERSION</code>，由于当时镜像是最新的，所以gitlab的版本是<code>10.7.3</code>。</p>
<p>还是在容器里，执行<code>git clone https://gitlab.com/xhang/gitlab.git</code>，克隆获取汉化版本库(这里要感谢辛苦的汉化工作者，向你们致敬！)，默认是获取最新的。如果需要下载老版本的汉化包，则要加上老版本的分支，如：<code>git clone https://gitlab.com/xhang/gitlab.git -b v10.2.5-zh</code>。</p>
<p>然后<code>gitlab-ctl stop</code>先停止gitlab服务，<code>cd gitlab/</code>进入到刚刚下载的那个git包里，执行如下代码：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@10 gitlab]# git fetch</span><br><span class="line">root@10 gitlab]# git diff v10.7.3 v10.7.3-zh &gt; ../10.7.3-zh.diff</span><br><span class="line">root@10 gitlab]# cd ..</span><br><span class="line">root@10 ~]# patch -d /opt/gitlab/embedded/service/gitlab-rails -p1 &lt; 10.7.3-zh.diff</span><br><span class="line">root@10 ~]# #如果提示没有patch，请执行apt-get update &amp;&amp; apt-get install patch</span><br><span class="line">root@10 ~]# gitlab-ctl start</span><br></pre></td></tr></table></figure></p>
<p>重新返回到浏览器里，就能看到汉化后的gitlab了，大功告成！<br><img data-src="/images/gitlab12.png" alt="paradin"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://xuanwo.org/2016/04/13/gitlab-install-intro/">https://xuanwo.org/2016/04/13/gitlab-install-intro/</a><br><a href="https://www.jianshu.com/p/6606aed59a56">https://www.jianshu.com/p/6606aed59a56</a><br><a href="http://adairjun.github.io/2016/12/20/gitlab/">http://adairjun.github.io/2016/12/20/gitlab/</a><br><a href="https://github.com/marbleqi/gitlab-ce-zh/blob/v10.5.1-zh-patch/Nginx.md">https://github.com/marbleqi/gitlab-ce-zh/blob/v10.5.1-zh-patch/Nginx.md</a><br><img data-src="/images/kdshotharden.gif" alt="paradin"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>Github如何删除掉一个commit</title>
    <url>/2018/12/06/Github%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E6%8E%89%E4%B8%80%E4%B8%AAcommit/</url>
    <content><![CDATA[<p>写完了一个脚本，里面使用了阿里云的api，那自然也有公司的阿里云ak\sk，在调试的时候发现没问题，于是就上传到github上。传完之后一看，发现脚本里忘了删除敏感字段，连通公司的ak\sk一起被提交上去了…<br><img data-src="/images/github10.png" alt="akb48"></p>
<p>卧槽，这还得了？要是这个commit被人发现并且拷贝走了，岂不是得到了公司的ak\sk，后果不堪设想啊。但是如何在github远端删除掉一个commit呢？</p>
<p>先记录下这次commit之前一次正常的版本号，查询版本号也可以通过命令<code>git log -5</code>（查询最近5次提交历史）：<br><img data-src="/images/github11.png" alt="akb48"></p>
<p>得到上一次的版本号是<code>051ebceaedd6b64801aada354f921d6ea7ef0622</code>，然后<code>git reset --hard  051ebceaedd6b64801aada354f921d6ea7ef0622</code>。</p>
<p>然后再<code>git push origin HEAD --force</code>即可。整个过程如下：<br><img data-src="/images/github12.png" alt="akb48"></p>
<p>此时再去github上刷新commit的历史页面，发现记录已经回滚到051ebce（版本号前面7位）了，如图：<br><img data-src="/images/github13.png" alt="akb48"></p>
<p><font color=red>但是要注意！</font>如果你的代码是两个地方在上传github，比如含敏感词汇的文件是通过windows客户端上传的，但是你在某个linux服务器上进行了删除commit的操作，那么如果windows继续commit的话，是会再次提交所有的commit的(含带有机密字段的commit)，所以要把源头也就是windows里的commit也要用这个方法干掉，这样才算彻底删除。</p>
<p><img data-src="/images/unnatural.gif" alt="akb48"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>Gitlab给分支设定权限</title>
    <url>/2018/06/06/Gitlab%E7%BB%99%E5%88%86%E6%94%AF%E8%AE%BE%E5%AE%9A%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<p>给gitlab的各位开发设置权限是很重要的，不然他们就可能会偷偷的把执行分支合并甚至<code>git pull</code>来破坏线上环境。</p>
<p>首先先确定在project下各位人员的身份，在<code>设置（setting）</code>–<code>成员(members)</code>里面，可以看到projects现有的用户和用户组，如图：<br><img data-src="/images/gitlab29.png" alt="akb48"></p>
<p>由于我这个gitlab已经是汉化版的了，这里做一个简单的中英对比：<code>Master</code>是“主程序员”、<code>Developer</code>是“开发人员”、<code>Reporter</code>是“报告者”，这个身份只有读权限可以创建代码片段，一般来说都给测试人员，而<code>Guest</code>就是“访客”了，它只能提交问题和评论。</p>
<p>然后再到<code>版本库（Repository）</code>里选择<code>保护分支（Protected Branches）</code>，如图：<br><img data-src="/images/gitlab31.png" alt="akb48"></p>
<p><code>Allowed to merge</code>就是分支合并权限，<code>Allowed to push</code>就是推送权限，这两个可以根据不同人的身份进行控制。如果受保护，除了master权限的人员，其余人都不可以push、delete等操作。默认情况下<code>master</code>分支是处于被保护状态下的，<code>developer</code>角色的人是无法提交到<code>master</code>分支的。</p>
<p>如果是docker的话，那么gitlab权限问题修复会用到如下命令：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it gitlab update-permissions</span><br><span class="line">docker restart gitlab容器的ID</span><br></pre></td></tr></table></figure></p>
<p><img data-src="/images/curry3p4.gif" alt="akb48"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Gitlab-runner实现跨服务器部署</title>
    <url>/2019/08/26/Gitlab-runner%E5%AE%9E%E7%8E%B0%E8%B7%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="环境描述"><a href="#环境描述" class="headerlink" title="环境描述"></a>环境描述</h2><p>本次试验的目的就是：业务模块服务器提交代码，触发流水线，gitlab-runner远程到该服务器进行操作。</p>
<p>gitlab-runner：172.16.194.01，容器安装，宿主机生成<code>id_rsa</code>；<br>业务模块服务器：172.16.194.02；<br>两个服务器相关端口已经打通。</p>
<h2 id="配置变量"><a href="#配置变量" class="headerlink" title="配置变量"></a>配置变量</h2><p><code>.gitlab-ci.yml</code>虽然是一个yaml格式的一个文件，但是script的内容其实就是一个shell脚本。既然是脚本，不可避免的要涉及到一些环境变量，而一些敏感的环境变量我们不推荐把它直接写进到<code>gitlab-ci.yml</code>里，比较好的方案是存储到gitlab里。</p>
<p>打开gitlab的web页面，点开对应的<code>project</code>—<code>Settings</code>—<code>CI/CD</code>—<code>Variables</code>，如图：<br><img data-src="/images/gitlab44.png" alt="抱光妹"></p>
<p>这里面存储的值比如<code>DEPLOY_SERVER</code>，对应的value就是<code>172.16.194.02</code>，即模块服务器的IP，保存之后，这样的环境变量不用在<code>.gitlab-ci.yml</code>里声明就可以直接通过<code>$变量名</code>的形式使用。</p>
<p>这里注意一下，<code>SSH_PRIVATE_KEY</code>对应的就是我们刚刚生成的那个宿主机的<code>id_rsa</code>内容，不是路径啊是整个文件的内容，我知道这个框很小，但是请放心，塞的进去。</p>
<h2 id="完整gitlab-ci-yml"><a href="#完整gitlab-ci-yml" class="headerlink" title="完整gitlab-ci.yml"></a>完整gitlab-ci.yml</h2><p>现在在模块服务器的代码根目录做一个gitlab-ci.yml，主要目的就是让<code>gitlab-runner</code>在模块服务器的<code>/tmp/test</code>目录下生成一个<code>111.txt</code>文件：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义 stages</span></span><br><span class="line">stages:</span><br><span class="line">  - build</span><br><span class="line">  - test</span><br><span class="line"></span><br><span class="line">before_script:</span><br><span class="line">  - <span class="string">&#x27;which ssh-agent || ( apt-get update -y &amp;&amp; apt-get install openssh-client -y )&#x27;</span></span><br><span class="line">  - <span class="built_in">eval</span> $(ssh-agent -s)</span><br><span class="line">  <span class="comment"># 清除一些系统中复制出现的换行符\r，并重定向到/dev/null防止泄露</span></span><br><span class="line">  - echo <span class="string">&quot;$SSH_PRIVATE_KEY&quot;</span> | tr -d <span class="string">&#x27;\r&#x27;</span> | ssh-add - &gt; /dev/null</span><br><span class="line">  <span class="comment"># 创建~/.ssh目录，并配置权限(非root运行的runner)</span></span><br><span class="line">  - mkdir -p ~/.ssh</span><br><span class="line">  - chmod <span class="number">700</span> ~/.ssh</span><br><span class="line">  - <span class="string">&#x27;[[ -f /.dockerenv ]] &amp;&amp; echo -e &quot;Host *\n\tStrictHostKeyChecking no\n\n&quot; &gt; ~/.ssh/config&#x27;</span></span><br><span class="line"></span><br><span class="line">after_script:</span><br><span class="line">     - echo <span class="string">&quot;FINISH!!!&quot;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment"># 也可以在这里指定环境变量，效果一样</span></span><br><span class="line">   variables:</span><br><span class="line">     - IMAGE: java:latest</span><br><span class="line">     - CONTAINER_NAME: daily_report_java</span><br><span class="line">     - VERSION: <span class="string">&quot;1.8&quot;</span>			<span class="comment"># 注意这里的双引号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义 job1</span></span><br><span class="line">job1:</span><br><span class="line">  stage: test</span><br><span class="line">  tags:</span><br><span class="line">    - my-tag</span><br><span class="line">  script:</span><br><span class="line">    - echo <span class="string">&quot;I am job1&quot;</span></span><br><span class="line">    - echo <span class="string">&quot;I am in test stage&quot;</span></span><br><span class="line">  environment:</span><br><span class="line">    name: production</span><br><span class="line">    url: http://$DEPLOY_SERVER</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义 job2</span></span><br><span class="line">job2:</span><br><span class="line">  stage: build</span><br><span class="line">  tags:</span><br><span class="line">    - my-tag</span><br><span class="line">  script:</span><br><span class="line">    - echo <span class="string">&quot;I am job2&quot;</span></span><br><span class="line">    - echo <span class="string">&quot;I am in build stage&quot;</span></span><br><span class="line">    - echo $IMAGE:$VERSION</span><br><span class="line">       - echo $CONTAINER_NAME</span><br><span class="line">    - ssh root@$DEPLOY_SERVER <span class="string">&quot;cd /tmp/test &amp;&amp; echo &#x27;123123&#x27;&gt; 111.txt&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>这里说一下<code>before_script</code>段：第一行代码判断ssh-agent是否存在，不存在则下载；第二行执行ssh-agent；第三行将server端的私钥加入到ssh-agent的管理下；四、五行创建.ssh文件夹，并给予正确的权限。</p>
<p>还有<code>before_script</code>不是<font color=red>before-script</font>，这样会被gitlab-runner当成一个job…</p>
<p>执行一下，来到web端可见job状态是OK：<br><img data-src="/images/gitlab46.png" alt="抱光妹"></p>
<p>点开build这个job，查看细节，可见文中的环境变量也被正确的读取了：<br><img data-src="/images/gitlab47.png" alt="抱光妹"></p>
<p>同时在模块服务器上的<code>111.txt</code>也生成了，实验成功！</p>
<p>如果要使用ansible搭配批量部署，可以考虑让gitlab-runner去操作ansible服务器，然后在gitlab-ci.yml去调用ansible的脚本。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://docs.gitlab.com/ee/ci/ssh_keys/">https://docs.gitlab.com/ee/ci/ssh_keys/</a><br><a href="https://wangjunming.com/Shi%20Yong%20gitlab%20CI%20CDJiang%20Cheng%20Xu%20Bu%20Shu%20Dao%20Yuan%20Cheng%20Fu%20Wu%20Qi.html">https://wangjunming.com/Shi%20Yong%20gitlab%20CI%20CDJiang%20Cheng%20Xu%20Bu%20Shu%20Dao%20Yuan%20Cheng%20Fu%20Wu%20Qi.html</a><br><a href="https://zhuanlan.zhihu.com/p/51163261">https://zhuanlan.zhihu.com/p/51163261</a><br><a href="https://blog.51cto.com/11750513/2422946">https://blog.51cto.com/11750513/2422946</a><br><a href="https://laogen.site/gitlab-ci/example-docker-ssh-deploy/">https://laogen.site/gitlab-ci/example-docker-ssh-deploy/</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>gitlab-runner</tag>
        <tag>CI/CD</tag>
      </tags>
  </entry>
  <entry>
    <title>Gitlab的简单应用</title>
    <url>/2018/05/16/Gitlab%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%94%A8/</url>
    <content><![CDATA[<p>gitlab跟svn的区别我就不多说了，这里直接说具体应用。</p>
<h2 id="建立一个project"><a href="#建立一个project" class="headerlink" title="建立一个project"></a>建立一个project</h2><p>先登陆到gitlab的网页，我这里使用了root用户，选择<code>create a project</code>，然后就是填写project的名称以及它所属的用户，这里由于只有root用户，所以这个叫<code>jjfjj</code>的project就是root自己的，如果建立了一个组的话，那么这里就填写那个组，如下：<br><img data-src="/images/gitlab14.png" alt="paradin"></p>
<p>下面这个<code>Visibility Level</code> ，就是权限等级，它分三种：</p>
<ol>
<li>Private：私有的，只有你自己或者组内的成员能访问</li>
<li>Internal：所有登录的用户</li>
<li>Public：公开的，所有人都可以访问</li>
</ol>
<p>这个东西和project的名称都是可以后期更改的。</p>
<p>然后就是<code>create project</code>，就创建了这个jjfjj。如图:<br><img data-src="/images/gitlab15.png" alt="paradin"></p>
<h2 id="将本地代码上传"><a href="#将本地代码上传" class="headerlink" title="将本地代码上传"></a>将本地代码上传</h2><p>建立好了gitlab，就要把开发的代码传进去，我在另外一个机器里，创建一个目录code，这个目录就是专门用来放置代码的，假设现在里面有一个文件叫<code>testcode.py</code>，如图：<br><img data-src="/images/gitlab16.png" alt="paradin"></p>
<p>具体操作如下：<br><img data-src="/images/gitlab17.png" alt="paradin"></p>
<p>注意！如果在创建project的时候勾选同时创建README.md的话，第一次提交本地代码需要是<code>git pull origin master</code>。</p>
<p>如果在两个不同的文件夹里执行上面的过程，会传输到两个不同的project里。说明一下上面几个命令的意思：<br><code>git init</code>：初始化git仓库<br><code>git add .</code>：添加整个目录里的所有文件到仓库<br><code>git rm --cached 某个文件名</code>：将某个文件从gitlab上撤除，如果想当前文件夹恢复成一个普通的文件夹，那就把文件夹路径下的.git文件删除掉即可	<br><code>git commit -m &#39;这里是要写的注释&#39;</code>：提交代码到仓库<br><code>git remote add origin +gitlab的地址(上上图里红色框的内容)</code>：链接到gitlab服务器<br><code>git push origin master</code>：push代码到服务器<br><code>git remote -v</code>：查看当前文件夹的目标project</p>
<p>此时刷新一下gitlab的project页面，就看到刚刚的那个<code>testcode.py</code>已经传上来了。如图：<br><img data-src="/images/gitlab18.png" alt="paradin"></p>
<p>如果代码有所更改或者出现<code>Everything up-to-date</code>，那么就按顺序执行<code>git add .</code>，<code>git commit -m &#39;这里是要写的注释&#39;</code>，<code>git push origin master</code>即可。</p>
<h2 id="免密码push代码"><a href="#免密码push代码" class="headerlink" title="免密码push代码"></a>免密码push代码</h2><p>在上面的<code>git push origin master</code>的时候需要输入gitlab的用户密码，如要需要免密码push，有两种方法。</p>
<p>第一种方法是ssh，请看 <a href="https://blog.whsir.com/post-1749.html/comment-page-1#comment-3425">https://blog.whsir.com/post-1749.html/comment-page-1#comment-3425</a> 。</p>
<p>第二种方法是用http的方式传送，先打开<code>.git/config</code>这个配置文件，修改<code>url = http://账号:密码@以.git结尾的项目地址</code>,保存之后重新去执行<code>git add .</code>，<code>git commit -m &#39;这里是注释&#39;</code>，<code>git push origin master</code>，就不再需要输入密码了。</p>
<h2 id="从gitlab上垃取代码"><a href="#从gitlab上垃取代码" class="headerlink" title="从gitlab上垃取代码"></a>从gitlab上垃取代码</h2><p>在要部署的机器上找到要部署的文件夹，我这里用&#x2F;gitlab为例，操作如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@pass-mixnumbus-<span class="number">001</span> /<span class="variable constant_">GITLAB</span>] # git init        	#将这个文件夹进行初始化                                             </span><br><span class="line"><span class="title class_">Initialized</span> empty <span class="title class_">Git</span> repository <span class="keyword">in</span> /<span class="variable constant_">GITLAB</span>/.<span class="property">git</span>/	#提示现在已经安装了.<span class="property">git</span>文件</span><br><span class="line">[root@pass-mixnumbus-<span class="number">001</span> /<span class="title function_">GITLAB</span>(master)] # git remote add origin <span class="attr">http</span>:<span class="comment">//114.55.224.158/root/JJFJJ.git		#确定库</span></span><br><span class="line">[root@pass-mixnumbus-<span class="number">001</span> /<span class="title function_">GITLAB</span>(master)] # git pull origin master 	#制定要把master分支的代码全拉取到这个文件夹里</span><br><span class="line"><span class="title class_">Username</span> <span class="keyword">for</span> <span class="string">&#x27;http://114.55.224.158&#x27;</span>: root		#输入账号和密码</span><br><span class="line"><span class="title class_">Password</span> <span class="keyword">for</span> <span class="string">&#x27;http://root@114.55.224.158&#x27;</span>: </span><br><span class="line"><span class="title class_">From</span> <span class="attr">http</span>:<span class="comment">//114.55.224.158/root/JJFJJ</span></span><br><span class="line"> * branch            master     -&gt; <span class="variable constant_">FETCH_HEAD</span></span><br><span class="line">[root@pass-mixnumbus-<span class="number">001</span> /<span class="title function_">GITLAB</span>(master)] # ls		#看一下效果</span><br><span class="line">admin.<span class="property">py</span>  looksql.<span class="property">py</span>  models.<span class="property">py</span>  syncECS.<span class="property">py</span>  testsyncECS.<span class="property">py</span></span><br></pre></td></tr></table></figure></p>
<p>再与gitlab界面的代码比较一下，果然都过来了！如图：<br><img data-src="/images/gitlab30.png" alt="paradin"></p>
<h2 id="在gitlab上建立分支"><a href="#在gitlab上建立分支" class="headerlink" title="在gitlab上建立分支"></a>在gitlab上建立分支</h2><p>gitlab上有很多个分支，主要的分支是master，它也是默认的分支，但是实际工作中是需要其他的开发去新建一些测试的分支，到时候可以先把这些测试的分支拿来部署，如果有问题就回滚回master分支。</p>
<p>分支相关的语句如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git branch	#查看本地分支</span><br><span class="line">git branch -r	#查看远程分支</span><br><span class="line">git branch -a 	#查看所有分支</span><br><span class="line">git branch develop	#本地创建新的分支，此时刷新gitlab的页面的话就会有这个叫develop的分支建立了</span><br><span class="line">git checkout develop	#切换到新的develop分支</span><br><span class="line">git checkout -b 	develop		#上面两步可以合成一个命令，这个的意思就是：创建+切换分支</span><br></pre></td></tr></table></figure></p>
<p>这个时候在代码机上新增或者改变文件，然后执行<code>git add .</code>，<code>git commit -m &#39;这里是要写的注释&#39;</code>，<code>git push origin develop</code>，就把新增的变化上传到了develop分支，如图：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@iZ23pg8sy5bZ ~/<span class="title function_">GITLAB</span>(develop)] # git push origin develop</span><br><span class="line"><span class="title class_">Counting</span> <span class="attr">objects</span>: <span class="number">4</span>, done.</span><br><span class="line"><span class="title class_">Compressing</span> <span class="attr">objects</span>: <span class="number">100</span>% (<span class="number">2</span>/<span class="number">2</span>), done.</span><br><span class="line"><span class="title class_">Writing</span> <span class="attr">objects</span>: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), <span class="number">325</span> bytes | <span class="number">0</span> bytes/s, done.</span><br><span class="line"><span class="title class_">Total</span> <span class="number">3</span> (delta <span class="number">1</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line"><span class="attr">remote</span>: </span><br><span class="line"><span class="attr">remote</span>: <span class="title class_">To</span> create a merge request <span class="keyword">for</span> develop, <span class="attr">visit</span>:</span><br><span class="line"><span class="attr">remote</span>:   <span class="attr">http</span>:<span class="comment">//114.55.224.158/root/JJFJJ/merge_requests/new?merge_request%5Bsource_branch%5D=develop</span></span><br><span class="line"><span class="attr">remote</span>: </span><br><span class="line"><span class="title class_">To</span> <span class="attr">http</span>:<span class="comment">//114.55.224.158/root/JJFJJ.git</span></span><br><span class="line">   fc8d456..8a97b58  develop -&gt; develop</span><br></pre></td></tr></table></figure></p>
<p>而在部署的机器上，直接执行<code>git pull origin develop</code>，输入账号密码之后，就会把develop分支的内容全部垃取下来了。</p>
<p>如果不想要这个develop分支了，就<code>git branch -d develop</code>，如果要删除远程的分支，就是<code>git push origin :develop</code>，注意这个冒号。</p>
<p>如果gitlab的地址发生了改变，那么在<code>git pull</code>之前需要<code>git remote set-url origin 新的git地址</code>，不过设定完毕之后，免输账号密码的效果会消失。</p>
<h2 id="在windows里使用gitlab"><a href="#在windows里使用gitlab" class="headerlink" title="在windows里使用gitlab"></a>在windows里使用gitlab</h2><p>首先先安装git，然后在目标文件夹里点击右键—<code>Git Bash Here</code>，在命令行里输入<code>git clone 远程目标.git</code>。同时在project页面里的develop分支（开发分支）里新开一个分支比如叫<code>feature/chenshuo</code>。待目标全部下载完毕之后，cd到代码文件夹里：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git branch -a		<span class="comment">#此时应该是master分支</span></span><br><span class="line">git checkout -b feature/chenshuo origin/feature/chenshuo		<span class="comment">#将本地的分支feature/chenshuo与远程的分支origin/feature/chenshuo关联</span></span><br><span class="line">git branch -a 		<span class="comment">#此时应该由master切换到了本地分支</span></span><br><span class="line">...修改代码...</span><br><span class="line">git add .</span><br><span class="line">   git commit -m <span class="string">&quot;提交信息&quot;</span>		<span class="comment">#将代码提交到本地分支</span></span><br><span class="line">   git push 		<span class="comment">#将本地分支push到远程</span></span><br></pre></td></tr></table></figure></p>
<p>如果在git clone那一步密码输入错误了，可以在<code>我的电脑</code>–<code>控制面板</code>–<code>用户账户</code>–<code>管理您的凭据</code> 里面修改。</p>
<h2 id="普通用户访问docker"><a href="#普通用户访问docker" class="headerlink" title="普通用户访问docker"></a>普通用户访问docker</h2><p>让普通用户访问docker的方法其实就是把该用户添加到docker组里即可。</p>
<p>先切换root用户给予普通用户（比如叫lcshop）免sudo权限：使用<code>sudoedit /etc/sudoers</code>添加这样的语句：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lcshop  ALL=(ALL)       ALL</span><br></pre></td></tr></table></figure></p>
<p>然后还是root状态下，执行<code>gpasswd -a lcshop docker</code>，将lcshop添加到docker组里，此时应该若反馈<code>Adding user lcshop to group docker</code>则添加成功。</p>
<p>然后就是重启一下docker进程，同时lcshop也重新连接ssh，此时lcshop就可以正常使用<code>docker ps -a</code>等命令了。若要查看某个用户组下有哪些用户，可以通过<code>grep &#39;组名&#39; /etc/group</code>获取。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.cnbluebox.com/blog/2014/04/15/gitlabde-shi-yong/">https://blog.cnbluebox.com/blog/2014/04/15/gitlabde-shi-yong/</a><br><a href="https://zhang759740844.github.io/2016/08/27/git%E6%8A%80%E5%B7%A7/">https://zhang759740844.github.io/2016/08/27/git%E6%8A%80%E5%B7%A7/</a><br><a href="https://www.restran.net/2016/02/23/git-and-gitlab-guide/">https://www.restran.net/2016/02/23/git-and-gitlab-guide/</a><br><a href="https://www.jianshu.com/p/f54053afecf2">https://www.jianshu.com/p/f54053afecf2</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>Goaccess---良心nginx日志分析工具</title>
    <url>/2018/01/30/Goaccess-%E8%89%AF%E5%BF%83nginx%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>Goaccess是一个非常良心的开源软件，它的良心之处体现在如下方面：</p>
<ul>
<li>安装简单；</li>
<li>操作容易；</li>
<li>界面酷炫；</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装<code>Goaccess</code>十分的简单，在centos里直接<code>yum install goaccess</code>，如果yum源里没有<code>goaccess</code>，可以先安装<code>epel</code>。安装<code>epel</code>的方法如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wget <span class="attr">http</span>:<span class="comment">//dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm</span></span><br><span class="line">wget <span class="attr">http</span>:<span class="comment">//rpms.famillecollet.com/enterprise/remi-release-6.rpm</span></span><br><span class="line">rpm -<span class="title class_">Uvh</span> remi-release-<span class="number">6</span>*.<span class="property">rpm</span> epel-release-<span class="number">6</span>*.<span class="property">rpm</span></span><br></pre></td></tr></table></figure></p>
<h2 id="配置和使用"><a href="#配置和使用" class="headerlink" title="配置和使用"></a>配置和使用</h2><p>安装完<code>goaccess</code>之后，我们需要在<code>/etc/goaccess.conf</code>里添加如下几句话：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">time-format %T</span><br><span class="line">date-format %d/%b/%Y</span><br><span class="line">log-format %h %^[%<span class="attr">d</span>:%t %^] “%r” %s %b “%R” “%u”</span><br></pre></td></tr></table></figure></p>
<p>保存退出之后，我们就可以通过<code>goaccess</code>来分析<code>nginx</code>日志了，语句格式也很简单：<code>goaccess -f nginx日志的绝对路径</code>。比如我的nginx日志是<code>access-chen.log</code>，查看一下里面的内容：<br><img data-src="/images/goaccess1.png" alt="goaccess"></p>
<p>虽然有规律，但是看上去很乱，需要在分析日志之前喝两瓶静心口服液。</p>
<p>然后我就<code>goaccess -f access-chen.log</code>，就会看到如下的界面：<br><img data-src="/images/goaccess2.png" alt="goaccess"></p>
<p>这一下，整个日志看起来更加友好，更加直白，更加高大上。足以吸引周围人的羡慕目光。</p>
<p>但是这里面还是有一个注意点：<code>goaccess</code>默认支持的日志格式是<code>nginx</code>默认的日志格式，也就是nginx.conf里的如下格式：<br><img data-src="/images/goaccess3.png" alt="goaccess"></p>
<p>如果你的日志格式是有过更改的，而且还不想改回来，那么就需要去<code>/etc/goaccess.conf</code>里对应的<code>log-format</code>进行更改。</p>
<p>这还没有完，goaccess还可以生成html，这里<code>goaccess -f access-chen.log  -a &gt; /nginx安装路径/html/chen.html</code>。然后在浏览器里登陆到这个服务器的chen.html，就会看到整个日志情况的网页排版，如图：<br><img data-src="/images/goaccess4.png" alt="goaccess"></p>
<p>这样的话，我们可以每一天都发一份当天的日志html去运维人员的信箱里，这样更加方便我们分析日志。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>虽然前面说了那么多goaccess的优点，但是缺点也是有的，比如<code>goaccess</code>的粒度太粗，只能按天分割，如果要按小时分割，需要先<code>grep</code>出来，这个做法比较挫我懂…</p>
<p>还有一个缺点，就是访问人的来源只能定位到国家，无法具体定位到省市县村屯…<br><img data-src="/images/goaccess5.png" alt="goaccess"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.maxhemby.se/determine-the-apache-traffic-load/#respond">http://blog.maxhemby.se/determine-the-apache-traffic-load/#respond</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>日志统计</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache配置Https</title>
    <url>/2019/04/04/Gitlab%E9%85%8D%E7%BD%AEHttps/</url>
    <content><![CDATA[<h2 id="Httpd配置https"><a href="#Httpd配置https" class="headerlink" title="Httpd配置https"></a>Httpd配置https</h2><p>事前说明，我的Httpd版本是：<code>Server version: Apache/2.4.6 (CentOS)</code></p>
<p>首先先准备https证书文件，把他们传递到apache服务器的<code>/etc/httpd/ssl</code>文件夹里，然后安装<code>yum install -y mod_ssl openssl</code>，安装完毕之后，发现<code>/etc/httpd/conf.d</code>文件夹下多了一个<code>ssl.conf</code>，出于安全先备份一份，然后修改<code>ssl.conf</code>的如下几个地方：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">未涉及的字段保留原样</span><br><span class="line">DocumentRoot <span class="string">&quot;/var/www/html&quot;</span>	<span class="comment">#网站的目录</span></span><br><span class="line">ServerName 自己的域名</span><br><span class="line">SSLCertificateFile /etc/httpd/ssl/imoulife.crt		<span class="comment">#秘钥crt文件及路径</span></span><br><span class="line">SSLCertificateKeyFile /etc/httpd/ssl/imoulife.key	<span class="comment">#秘钥key文件及路径</span></span><br></pre></td></tr></table></figure></p>
<p>保存退出，重启httpd即可生效。注意！因为一个ip只能绑一个SSL，因此这里就算在写了两份<code>&lt;VirtualHost *:443&gt;...&lt;/VirtualHost&gt;</code>，也还是会读取第一个SSL。</p>
<h2 id="Httpd配置http跳转https"><a href="#Httpd配置http跳转https" class="headerlink" title="Httpd配置http跳转https"></a>Httpd配置http跳转https</h2><p>如果想要达到http跳转https的话，还是在ssl文件里的最下面追加这段内容：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;VirtualHost  *:<span class="number">80</span>&gt;</span><br><span class="line">        RewriteEngine on</span><br><span class="line">        RewriteCond %&#123;SERVER_PORT&#125; !^<span class="number">443</span>$</span><br><span class="line">        RewriteRule ^/?(.*)$ https://%&#123;SERVER_NAME&#125;%&#123;REQUEST_URI&#125; [L,R]</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure></p>
<p>如果只是单url跳转，比如<code>http://test.imoulife.com/login</code>跳转到<code>https://test.imoulife.com/login</code>，其他的域名依旧是http。那么就把最后一句改成:<code>RewriteRule ^/logon.do$ https://%{SERVER_NAME}%{REQUEST_URI} [L,R]</code>，重启httpd就生效。</p>
<h2 id="httpd配置ip白名单"><a href="#httpd配置ip白名单" class="headerlink" title="httpd配置ip白名单"></a>httpd配置ip白名单</h2><p>设置了https不能说很安全，我们还需要设置IP白名单才能让WEB界面更加放心。由于我这个httpd主要是给zabbix使用的，所以就拿访问zabbix的IP白名单为例。</p>
<p>首先打开<code>/etc/httpd/conf.d/zabbix.conf</code>，修改如下地方：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Alias /zabbix /usr/share/zabbix</span><br><span class="line"></span><br><span class="line">&lt;Directory <span class="string">&quot;/usr/share/zabbix&quot;</span>&gt;</span><br><span class="line">   Options FollowSymLinks</span><br><span class="line">   AllowOverride <span class="literal">None</span></span><br><span class="line">   <span class="comment">#Require all granted	#这句话是任何人都可以访问的意思</span></span><br><span class="line">&lt;RequireAll&gt;</span><br><span class="line">       Require ip <span class="number">192.168</span><span class="number">.1</span>	<span class="comment">#准许192.168.1开头的IP地址的访问</span></span><br><span class="line">	Require ip <span class="number">192.168</span><span class="number">.1</span><span class="number">.104</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.205</span>	<span class="comment">#准许固定IP地址访问</span></span><br><span class="line">	Require ip <span class="number">10.1</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">16</span>	<span class="comment">#网络/子网掩码的访问</span></span><br><span class="line">   &lt;/RequireAll&gt;</span><br></pre></td></tr></table></figure></p>
<p>保存退出，重启httpd即可。</p>
<h2 id="Gitlab配置Https"><a href="#Gitlab配置Https" class="headerlink" title="Gitlab配置Https"></a>Gitlab配置Https</h2><p>我的gitlab是容器做的，其实无论容器还是非容器其实配置都是一样的。</p>
<p>首先先开放443端口给相应的IP，然后进入容器，在<code>/etc/gitlab/</code>下先创建一个ssl文件夹，里面放入https证书，如图：<br><img data-src="/images/https1.png" alt="akb48"></p>
<p>放好证书文件之后，返回上一级目录，修改一下<code>gitlab.rb</code>文件：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">external_url <span class="string">&#x27;https的域名&#x27;</span></span><br><span class="line">nginx[<span class="string">&#x27;redirect_http_to_https&#x27;</span>] = true</span><br><span class="line">nginx[<span class="string">&#x27;redirect_http_to_https_port&#x27;</span>] = <span class="number">80</span></span><br><span class="line">nginx[<span class="string">&#x27;ssl_certificate&#x27;</span>] = <span class="string">&quot;上面https证书的路径/crt文件名称&quot;</span></span><br><span class="line">nginx[<span class="string">&#x27;ssl_certificate_key&#x27;</span>] = <span class="string">&quot;上面https证书的路径/key文件名称&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>然后执行<code>gitlab-ctl reconfigure</code>更新配置，完事之后找到nginx的gitlab配置文件<code>gitlab-http.conf</code>，发现由于更新了配置，所以里面已经生成好了一份新的配置文件，如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen *:<span class="number">443</span> ssl http2;</span><br><span class="line">  server_name https的域名;</span><br><span class="line">  server_tokens off; </span><br><span class="line">  client_max_body_size <span class="number">0</span>;</span><br><span class="line">  ssl on;</span><br><span class="line">  ssl_certificate 上面https证书的路径/crt文件名称;</span><br><span class="line">  ssl_certificate_key 上面https证书的路径/key文件名称;</span><br><span class="line">  .............................  <span class="comment">#剩余的信息省略了</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">server&#123;</span><br><span class="line">listen*:<span class="number">80</span>;</span><br><span class="line">server_name https的域名;</span><br><span class="line">rewrite^(.*)$https://$host$1permanent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>确认各个信息无误之后，退出执行<code>gitlab-ctl restart</code>即可。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://tonylit.me/2016/02/29/apache_http%E8%B7%B3%E8%BD%AC/">http://tonylit.me/2016/02/29/apache_http%E8%B7%B3%E8%BD%AC/</a><br><a href="http://zhizhi.tangliangdong.me/2017/10/12/2017-10-12-http-to-https/">http://zhizhi.tangliangdong.me/2017/10/12/2017-10-12-http-to-https/</a><br><a href="https://blog.mallux.me/2017/02/27/gitlab/">https://blog.mallux.me/2017/02/27/gitlab/</a><br><a href="https://blog.csdn.net/leshami/article/details/78521031">https://blog.csdn.net/leshami/article/details/78521031</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Gitlab</tag>
        <tag>httpd</tag>
        <tag>白名单</tag>
      </tags>
  </entry>
  <entry>
    <title>Gitlab的配置备份</title>
    <url>/2018/05/16/Gitlab%E9%85%8D%E7%BD%AE%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<h2 id="备份正文"><a href="#备份正文" class="headerlink" title="备份正文"></a>备份正文</h2><p>我这个gitlab是容器安装的，直接使用最新的gitlab镜像，gitlab版本是<code>10.7.3</code>。</p>
<p>要备份数据的话，就要进入容器里，执行<code>gitlab-rake gitlab:backup:create</code>，效果如下：<br><img data-src="/images/gitlab19.png" alt="paradin"></p>
<p>执行完毕之后，在<code>/var/opt/gitlab/backups</code>文件夹里就会生成一个备份文件，我这里生成的文件叫：1526454102_2018_05_16_10.7.3_gitlab_backup.tar，这个就是备份的文件。</p>
<p>如果要还原的话，命令如下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 先关闭连接数据库的进程</span><br><span class="line">sudo gitlab-ctl stop</span><br><span class="line"></span><br><span class="line"># 通过指定时间戳来执行restore操作，这个操作会复写gitlab的数据库</span><br><span class="line">sudo gitlab-rake gitlab:backup:restore BACKUP=1526454102 	#BACKUP后面的是备份文件开头的那串数字</span><br><span class="line"></span><br><span class="line"># 再次启动gitlab</span><br><span class="line">sudo gitlab-ctl start</span><br><span class="line"></span><br><span class="line"># 通过下面命令检查gitlab</span><br><span class="line">sudo gitlab-rake gitlab:check SANITIZE=true</span><br></pre></td></tr></table></figure></p>
<p>注意！利用backup机制进行备份的话，对gitlab的版本是要求严格一致的。例如用8.6版的gitlab生成的备份文件，拿到8.7版的gitlab上进行恢复，是会报错的。</p>
<p>同时除了要导入备份文件之外，还要备份以下几个文件：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/etc/gitlab/gitlab.<span class="property">rb</span> 	配置文件须备份</span><br><span class="line">/<span class="keyword">var</span>/opt/gitlab/nginx/conf 	nginx配置文件</span><br><span class="line">/etc/postfix/main.<span class="property">cfpostfix</span> 	邮件配置备份</span><br></pre></td></tr></table></figure></p>
<p>如果要设置这个备份文件的生命周期和备份文件存储的位置，编辑<code>/etc/gitlab/gitlab.rb</code>，修改如下的地方：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gitlab_rails[&#x27;backup_path&#x27;] = &quot;/var/opt/gitlab/backups&quot;		#这里改新路径</span><br><span class="line">gitlab_rails[&#x27;backup_archive_permissions&#x27;] = 0644			#这里可以设定文件的权限</span><br><span class="line"># limit backup lifetime to 7 days - 604800 seconds</span><br><span class="line">gitlab_rails[&#x27;backup_keep_time&#x27;] = 604800		#文件存储时间一周</span><br></pre></td></tr></table></figure></p>
<p>然后重启一下gitlab即可。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://eimsteim.github.io/2017/12/12/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9D%91%E7%88%B9%E7%9A%84Gitlab%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E4%B9%8B%E6%97%85/">http://eimsteim.github.io/2017/12/12/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9D%91%E7%88%B9%E7%9A%84Gitlab%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E4%B9%8B%E6%97%85/</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang的切片学习笔记</title>
    <url>/2019/07/03/Golang%E7%9A%84%E5%88%87%E7%89%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="与python对比"><a href="#与python对比" class="headerlink" title="与python对比"></a>与python对比</h2><p>初开始接触golang的slice，感觉跟python的slice有点像，但也有几个比较明显的区别：</p>
<ol>
<li>python中的slice是在原有基础上拷贝一份。go中的slice则是指向生成它的数组&#x2F;切片(切片和数组共用同一片内存)，切最长长度不会超限；</li>
<li>go的切片，其成员是相同类型的，python的列表和元组则不限制类型；</li>
<li>对于[a:b]这种切片操作，go的a、b两个参数不能是负数，python可以是负数，此时就相当于从末尾往前数；</li>
<li>对于[a:b:c]这种切片操作，go的c表示的是容量；而python的c表示的是步长。</li>
</ol>
<h2 id="先来点俗气的"><a href="#先来点俗气的" class="headerlink" title="先来点俗气的"></a>先来点俗气的</h2><p>切片使用<code>s =s[0:]</code>可以清空。</p>
<p>如果要查看获取到的东东究竟是数组还是切片，可以使用<code>fmt.Printf(&quot;%s&quot;,reflect.TypeOf(获取到的东西).Kind())</code>。</p>
<p>如果想要数组转切片很简单，[:]就可以。</p>
<h2 id="判断切片相等"><a href="#判断切片相等" class="headerlink" title="判断切片相等"></a>判断切片相等</h2><p>比较两个切片是否相等，除了循环遍历还有一个<code>reflect</code>方法：<br>	<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bijiao</span><span class="params">(b,c []<span class="type">int</span>)</span></span> <span class="type">bool</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> reflect.DeepEqual(b,c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	b := []<span class="type">int</span>&#123;&#125;		<span class="comment">//他俩是一回事</span></span><br><span class="line">	c :=<span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">var</span> d []<span class="type">int</span>			<span class="comment">//d跟b、c不是一回事</span></span><br><span class="line">	fmt.Println(bijiao(b,c))</span><br><span class="line">	fmt.Println(bijiao(d,c))</span><br><span class="line">	fmt.Println(d)</span><br><span class="line">	fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>reflect.DeepRqual()</code>除了可以比较数组和切片，还可以比较map和srtucts，不过据说 <a href="https://github.com/google/go-cmp">https://github.com/google/go-cmp</a> 这个方法更牛逼。</p>
<h2 id="copy的问题"><a href="#copy的问题" class="headerlink" title="copy的问题"></a>copy的问题</h2><p>go的copy是拷贝对应的位置，而不是全拷贝，也就是说如果是让一个空切片作为目的切片，那得到了新切片就是空切片，如果是让一个空切片做源切片，那么得到的新切片与目的切片一致。</p>
<h2 id="判断字符串的几种情况"><a href="#判断字符串的几种情况" class="headerlink" title="判断字符串的几种情况"></a>判断字符串的几种情况</h2><p>用一个例子说明：<br>	<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> str <span class="type">string</span> = <span class="string">&quot;This is an example of a string.&quot;</span>		<span class="comment">//定义变量</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;T/F? Does the string \&quot;%s\&quot; have prefix %s? &quot;</span>, str, <span class="string">&quot;Th&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%t\n&quot;</span>, strings.HasPrefix(str, <span class="string">&quot;Th&quot;</span>))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%t\n&quot;</span>, strings.HasSuffix(str,<span class="string">&quot;ing&quot;</span>))</span><br><span class="line">	fmt.Println(strings.Contains(str,<span class="string">&quot;an&quot;</span>))			<span class="comment">//目标变量是否含有an</span></span><br><span class="line">	fmt.Println(strings.ContainsAny(str,<span class="string">&quot;axwq&quot;</span>))	<span class="comment">//目标变量是否含有“axwq”里的任意一个</span></span><br><span class="line">	fmt.Println(strings.Count(str, <span class="string">&quot;s&quot;</span>))			<span class="comment">//目标变量里有多少个s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果要获取汉字字符串的汉字数，可以使用<code>utf8.RuneCountInString(s)</code>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://studygolang.com/articles/12944">https://studygolang.com/articles/12944</a> （判断相等的deepequal）<br><a href="https://studygolang.com/articles/5769">https://studygolang.com/articles/5769</a>  （golang中strings包用法）</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>一个Go语言按行读取文件的脚本</title>
    <url>/2019/07/02/Go%E8%AF%AD%E8%A8%80flag%E5%8C%85%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="脚本内容"><a href="#脚本内容" class="headerlink" title="脚本内容"></a>脚本内容</h2><p>假设我有一个文件111.txt，内容如下：<br><img data-src="/images/go3.png" alt="akb48"></p>
<p>现在需要读取这个111.txt，并将文件里的数值，然后组合成一个数列，再写入到222.txt里。写了一个go脚本flagtest.go，内容如下：<br>	<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> infile *<span class="type">string</span> = flag.String(<span class="string">&quot;i&quot;</span>,<span class="string">&quot;infile&quot;</span>,<span class="string">&quot;file contains vales for sorting&quot;</span>)	<span class="comment">//flag 包中，定义的指令以指针类型返回</span></span><br><span class="line"><span class="keyword">var</span> outfile *<span class="type">string</span> = flag.String(<span class="string">&quot;o&quot;</span>,<span class="string">&quot;outfile&quot;</span>,<span class="string">&quot;file to receive sorted values&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readValues</span><span class="params">(infile <span class="type">string</span>)</span></span>(values []<span class="type">int</span>,err <span class="type">error</span>)&#123;</span><br><span class="line">	file, err := os.Open(infile)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;failed to open this file:&quot;</span>,infile)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> file.Close()		<span class="comment">//资源释放,关闭文件句柄</span></span><br><span class="line">	<span class="comment">//file.Close()不会触发panic，会先判断file == nil</span></span><br><span class="line">	<span class="comment">//defer 除了最后执行之外还有一个重要的特性：即便函数抛出了异常，也会被执行的。 这样就不会因程序出现了错误，而导致资源不会释放了</span></span><br><span class="line"></span><br><span class="line">	br := bufio.NewReader(file)		<span class="comment">//读缓冲区</span></span><br><span class="line"></span><br><span class="line">	values = <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>)		<span class="comment">//空切片</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		line,isPrefix,err1 := br.ReadLine()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err1 != <span class="literal">nil</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> err1 != io.EOF &#123;</span><br><span class="line">				err = err1</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> isPrefix &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;A too long line,seems unexpected.&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		str := <span class="type">string</span>(line)  <span class="comment">//转换字符数组成字符串</span></span><br><span class="line"></span><br><span class="line">		value,err1 := strconv.Atoi(str)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">			err = err1</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		values = <span class="built_in">append</span>(values,value)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(values)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeVaules</span><span class="params">(values []<span class="type">int</span>, outfile <span class="type">string</span>)</span></span> <span class="type">error</span>&#123;</span><br><span class="line">	file, err := os.Create(outfile)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;创建文件失败！&quot;</span>,outfile)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _,value := <span class="keyword">range</span> values &#123;		<span class="comment">//第一个是下标，第二个是元素</span></span><br><span class="line">		str := strconv.Itoa(value)		<span class="comment">//int到string</span></span><br><span class="line">		file.WriteString(str + <span class="string">&quot;\n&quot;</span>)	<span class="comment">//如果是windows文件，那就是\r\n</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	flag.Parse()</span><br><span class="line">	<span class="keyword">if</span> infile != <span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;infile =&quot;</span>,*infile,<span class="string">&quot;outfile =&quot;</span>,*outfile)</span><br><span class="line">	&#125;</span><br><span class="line">	values,err := readValues(*infile)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;原文件的内容是:&quot;</span>, values)</span><br><span class="line">		fmt.Println(<span class="string">&quot;现在开始录入到新文件里...&quot;</span>)</span><br><span class="line">		writeVaules(values, *outfile)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行效果如下：<br><img data-src="/images/go2.png" alt="akb48"></p>
<h2 id="新的知识点！"><a href="#新的知识点！" class="headerlink" title="新的知识点！"></a>新的知识点！</h2><ol>
<li><code>bufio.NewReader</code>的返回值里<code>line</code>和<code>err</code>不可能同时<code>非nil</code>。</li>
<li><code>string</code>方法会自动识别\n和\t等通配符。</li>
<li><code>reader.ReadBytes（&quot;\n&quot;)</code>这个方法可以将字符串按\n分割，然后取第一部分。</li>
<li>读取一行，通常会选择<code>ReadBytes</code>或<code>ReadString</code>。不过，正常人的思维，应该用<code>ReadLine</code>，只是不明白为啥ReadLine的实现不是通过ReadBytes，然后清除掉行尾的<code>\n</code>（或<code>\r\n</code>），它现在的实现，用不好会出现意想不到的问题，比如丢数据。个人建议可以这么实现读取一行： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">line, err := reader.ReadBytes(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">line := bytes.TrimRight(line, <span class="string">&quot;\r\n&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这样既读取了一行，也去掉了行尾结束符（当然，如果你希望留下行尾结束符，只用ReadBytes即可）。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://segmentfault.com/a/1190000014935402">https://segmentfault.com/a/1190000014935402</a><br><a href="http://qefee.com/2014/02/02/go%E8%AF%AD%E8%A8%80%E7%9A%84flag%E5%8C%85%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/">http://qefee.com/2014/02/02/go%E8%AF%AD%E8%A8%80%E7%9A%84flag%E5%8C%85%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</a> (flag各种用法集合）<br><a href="http://fuxiaohei.me/2015/12/9/mistake-in-bufio-reader.html">http://fuxiaohei.me/2015/12/9/mistake-in-bufio-reader.html</a> （bufio.reader的坑）<br><a href="https://github.com/ma6174/blog/issues/10">https://github.com/ma6174/blog/issues/10</a> （bufio.reader的坑2）<br><a href="https://studygolang.com/articles/5932">https://studygolang.com/articles/5932</a> （go使用Defer的几个场景）</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Gitlab配置ssh，实现秘钥上传下载代码</title>
    <url>/2019/05/21/Gitlab%E9%85%8D%E7%BD%AEssh%EF%BC%8C%E5%AE%9E%E7%8E%B0%E7%A7%98%E9%92%A5%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h2 id="常规配置"><a href="#常规配置" class="headerlink" title="常规配置"></a>常规配置</h2><p>gitlab配置ssh比较简单，在代码机上使用<code>ssh-keygen -t rsa -C &quot;你的邮箱&quot;</code>制作<code>id_rsa</code>和<code>id_rsa.pub</code>，然后来到gitlab的web页面，settings—ssh keys,把<code>id_rsa.pub</code>拷贝进去，然后点击<code>Add key</code>:<br><img data-src="/images/gitlab32.png" alt="akb48"></p>
<p>然后返回到代码机器上，再对应的代码目录里使用<code>git remote -v</code>查看一下当前的方式，如果不是git的话，通过<code>git remote set-url origin git@你的project地址</code>修改，然后再试一下 <code>ssh -T git@&quot;你的gitlab服务器地址&quot;</code>是否会出现welcome，如果可以的话，那么就可以通过ssh的方式下载上传代码以及<code>git clone 对应的project</code>了。</p>
<h2 id="容器配置"><a href="#容器配置" class="headerlink" title="容器配置"></a>容器配置</h2><p>但是现在很多人都用容器部署gitlab，而且在部署的时候除了指定80，443端口的映射，还制定了22端口的映射。比如我的这个gitlab容器的启动命令就是：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">docker run --detach --hostname 外网IP --publish <span class="number">443</span>:<span class="number">443</span> --publish <span class="number">80</span>:<span class="number">80</span> --publish <span class="number">2222</span>:<span class="number">22</span> --name gitlab --restart always gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure></p>
<p>可见我把宿主机的2222端口对应给了gitlab容器。那么像上面的方法肯定不会成功，这里就需要我们修改一处地方。</p>
<p>首先进入容器，然后修改<code>gitlab.rb</code>文件，这个文件在容器里有很多，我这个镜像里的gitlab.rb是<code>/etc/gitlab/gitlab.rb</code>，然后把<code>gitlab_rails[&#39;gitlab_shell_ssh_port&#39;]</code>改成2222并且去掉注释，如图：<br><img data-src="/images/gitlab33.png" alt="akb48"></p>
<p>然后<code>gitlab-ctl restart</code>重启之，重启完毕之后，在代码机上测试一下ssh：<br><img data-src="/images/gitlab34.png" alt="akb48"></p>
<p>可以已经连通，修改一下remote master地址之后，就可以直接上传了：<br><img data-src="/images/gitlab35.png" alt="akb48"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>容器</tag>
        <tag>gitlab</tag>
        <tag>ssh keys</tag>
      </tags>
  </entry>
  <entry>
    <title>Grafana配置smtp邮件</title>
    <url>/2018/06/06/Grafana%E9%85%8D%E7%BD%AEsmtp%E9%82%AE%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="配置smtp"><a href="#配置smtp" class="headerlink" title="配置smtp"></a>配置smtp</h2><p>如果要通过grafana接收告警邮件，都需要配置邮箱。而相关配置文件就是<code>grafana.ini</code>，分别要修改如下几个地方：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#################################### <span class="variable constant_">SMTP</span> / <span class="title class_">Emailing</span> ##########################</span><br><span class="line">[smtp]</span><br><span class="line">enabled = <span class="literal">true</span></span><br><span class="line">host = smtp<span class="number">.163</span>.<span class="property">com</span>:<span class="number">465</span></span><br><span class="line">user = 邮箱前缀@<span class="number">163.</span>com</span><br><span class="line"># <span class="title class_">If</span> the password contains # or ; you have to wrap it <span class="keyword">with</span> trippel quotes. <span class="title class_">Ex</span> <span class="string">&quot;&quot;</span><span class="string">&quot;#password;&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">password = 客户端授权密码</span><br><span class="line">;cert_file =</span><br><span class="line">;key_file =</span><br><span class="line">skip_verify = <span class="literal">true</span></span><br><span class="line">from_address = 邮箱前缀@<span class="number">163.</span>com</span><br><span class="line">from_name = <span class="title class_">Grafana</span>	</span><br><span class="line"># <span class="variable constant_">EHLO</span> identity <span class="keyword">in</span> <span class="variable constant_">SMTP</span> <span class="title function_">dialog</span> (defaults to instance_name)</span><br><span class="line">;ehlo_identity = dashboard.<span class="property">example</span>.<span class="property">com</span></span><br><span class="line">#################################### <span class="title class_">Alerting</span> ############################</span><br><span class="line">[alerting]</span><br><span class="line"># <span class="title class_">Disable</span> alerting engine &amp; <span class="variable constant_">UI</span> features</span><br><span class="line">;enabled = <span class="literal">true</span></span><br><span class="line"># <span class="title class_">Makes</span> it possible to turn off alert rule execution but alerting <span class="variable constant_">UI</span> is visible</span><br><span class="line">execute_alerts = <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>我采用了网易邮箱，把文件保存退出之后，重启一下<code>grafana-server</code>。然后在页面的alatm页面里配置<code>Notification channels</code>，如图：<br><img data-src="/images/grafanasmtp3.png" alt="paradin"></p>
<p>如果发送不成功，去查看一下日志，日志地址是<code>/var/log/grafana/grafana.log</code>。如果发送成功了，那么邮箱会收到这样的一个邮件：<br><img data-src="/images/grafanasmtp4.png" alt="paradin"></p>
<h2 id="邮箱密码问题问题"><a href="#邮箱密码问题问题" class="headerlink" title="邮箱密码问题问题"></a>邮箱密码问题问题</h2><p>这里要注意几个问题！<br>1.	阿里云的服务器出于安全考虑默认是不会开放25端口的，如果你非要用阿里云的服务器去打开25端口，请移步<a href="https://www.alibabacloud.com/help/zh/doc-detail/56130.htm">https://www.alibabacloud.com/help/zh/doc-detail/56130.htm</a> ；<br>2.	如果不想麻烦阿里云那么就要使用其他端口，比如我配置文件里面写的加密的465端口，这个端口不能使用登陆邮箱的普通密码，而是需要填写“授权码”；<br>3.	以网易邮箱为例，首先先要打开<code>POP3/SMTP服务</code>，如图：<br><img data-src="/images/grafanasmtp1.png" alt="paradin"></p>
<p>其次然后在<code>客户端授权密码</code>里设置一个新的密码，如图：<br><img data-src="/images/grafanasmtp2.png" alt="paradin"></p>
<p>然后把这个授权码填写到<code>grafana.ini</code>里，填邮箱的登录密码是错误的。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.kubiops.com/blog/2017/02/27/Grafana%E5%91%8A%E8%AD%A6%E9%85%8D%E7%BD%AE.html">http://www.kubiops.com/blog/2017/02/27/Grafana%E5%91%8A%E8%AD%A6%E9%85%8D%E7%BD%AE.html</a></p>
<p><img data-src="/images/%E9%A9%AC%E5%A4%8F%E5%B0%941.gif" alt="akb48" title="马夏尔在底线的标准操作"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>grafana</tag>
      </tags>
  </entry>
  <entry>
    <title>Html制作progress进度条</title>
    <url>/2019/01/07/Html%E5%88%B6%E4%BD%9Cprogress%E8%BF%9B%E5%BA%A6%E6%9D%A1/</url>
    <content><![CDATA[<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>无论是下载还是上传，亦或者是执行脚本。进度条都是必不可少的环节，它能让人清晰直观的看到事情发展的进度。现在生成进度条有很多种方法，我选择的是<code>progress</code>，它的用法很简单：<br>	<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">progress</span> <span class="attr">value</span>=<span class="string">&#x27;70&#x27;</span> <span class="attr">max</span>=<span class="string">&#x27;100&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">progress</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><code>value</code>属性表示进度条已经完成的进度值，范围为<code>0~max</code>之间。如果没有设置<code>max</code>属性，那么<code>value</code>属性值的范围要在0~1之间。如果没有<code>value</code>值，那么完成进度是不确定的。那么整个进度条就是一个动态效果，就像一个加载中loading，中间的进度块来回游荡。如下图：<br><img data-src="/images/django42.gif" alt="akb48"></p>
<h2 id="动态进度条"><a href="#动态进度条" class="headerlink" title="动态进度条"></a>动态进度条</h2><p>有些时候，我们无法正常获取到后台脚本运行的进度，因为某些脚本无法反馈给前端一个值来衡量目前运行到什么阶段，于是这种情况我们只能预估一下这个脚本大约用多少时间，做一个假的进度条来展示进度。如果想做一个逐渐进行的进度条，比如2秒钟跑满的进度条，那么代码如下：<br>	<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>进度条：<span class="tag">&lt;<span class="name">progress</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span> <span class="attr">max</span>=<span class="string">&quot;100&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">progress</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;开始&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;goprogress()&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">goprogress</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> pro=<span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;progress&quot;</span>)[<span class="number">0</span>];	<span class="comment">//获取progress的第一行</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">gotoend</span>(pro,<span class="number">0</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">gotoend</span>(<span class="params">pro,value</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> value=value+<span class="number">1</span>;</span></span><br><span class="line"><span class="language-javascript">        pro.<span class="property">value</span>=value;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(value&lt;<span class="number">100</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="title function_">gotoend</span>(pro, value);&#125;,<span class="number">20</span>)		<span class="comment">//这里是时间，20的意思是2秒完成</span></span></span><br><span class="line"><span class="language-javascript">        &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="title function_">alert</span>(<span class="string">&quot;任务完成&quot;</span>)&#125;,<span class="number">20</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>整个动态效果如下：<br><img data-src="/images/django41.gif" alt="akb48"></p>
<h2 id="如何页面自动执行函数"><a href="#如何页面自动执行函数" class="headerlink" title="如何页面自动执行函数"></a>如何页面自动执行函数</h2><p>上面的例子，需要手动点击button，如果不想把函数绑定点击按钮事件上，而是要页面加载出来后自动执行函数就出现此效果，那么有两种办法：</p>
<ol>
<li><p>直接把函数写到html的body标签里面</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;myfunction()&quot;</span>&gt;</span></span><br><span class="line">	//具体函数</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在JS语句里调用</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">　　	<span class="keyword">function</span> <span class="title function_">myfun</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="language-javascript">　　	&#123;</span></span><br><span class="line"><span class="language-javascript">　	　 <span class="title function_">alert</span>(<span class="string">&quot;this window.onload&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">　　	&#125;</span></span><br><span class="line"><span class="language-javascript">　　	<span class="comment">/*用window.onload调用myfun()*/</span></span></span><br><span class="line"><span class="language-javascript">　　	<span class="variable language_">window</span>.<span class="property">onload</span> = myfun;	<span class="comment">//不要括号</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>或者在JS语句里按以下方法调用：</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">onload</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="title function_">func1</span>();</span></span><br><span class="line"><span class="language-javascript">           <span class="title function_">func2</span>();</span></span><br><span class="line"><span class="language-javascript">           <span class="title function_">func3</span>();</span></span><br><span class="line"><span class="language-javascript">   &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="a-href页面不刷新方法"><a href="#a-href页面不刷新方法" class="headerlink" title="a href页面不刷新方法"></a>a href页面不刷新方法</h2><p>使用<code>&lt;a href=&quot;#&quot;&gt;</code>页面是会原地刷新的，那么如何不让页面刷新呢？使用<code>&lt;a href=&#39;javascript:&#39;&gt;</code> 。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/qq965194745/article/details/80034993">https://blog.csdn.net/qq965194745/article/details/80034993</a><br><a href="https://frontenddev.org/article/how-to-use-javascript-to-do-a-high-force-the-progress-bar.html">https://frontenddev.org/article/how-to-use-javascript-to-do-a-high-force-the-progress-bar.html</a><br><a href="http://www.voidcn.com/article/p-crqmibur-a.html">http://www.voidcn.com/article/p-crqmibur-a.html</a><br><a href="https://blog.csdn.net/Zhaky/article/details/50922613">https://blog.csdn.net/Zhaky/article/details/50922613</a><br><a href="http://www.webfront-js.com/articaldetail/47.html">http://www.webfront-js.com/articaldetail/47.html</a><br><a href="https://www.cnblogs.com/witchgogogo/p/5547258.html">https://www.cnblogs.com/witchgogogo/p/5547258.html</a> （这个用bootstrap做的进度条更牛逼）
	</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>html</tag>
        <tag>进度条</tag>
      </tags>
  </entry>
  <entry>
    <title>Google SRE读后感</title>
    <url>/2020/02/03/Google-SRE%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
    <content><![CDATA[<h2 id="职业定义"><a href="#职业定义" class="headerlink" title="职业定义"></a>职业定义</h2><p>SRE是<code>站点可靠性工程师</code>，与运维不同之处是，运维更多是在别人开发好的系统上当流水线工人，而SRE需要自己开发系统，所以SRE需要有更加强的脚本开发技能，同时也要具备强有力的沟通能力、领导能力和丰富的排错经验。开发技能表现在需要开发一些工具帮助我们监控、事故追踪和压测。而沟通能力是因为我们需要经常与开发人员和产品经理交流，无论是优化环节还是故障排查环节。领导能力是建立在排错经验基础上的，当出现了线上故障，我们要第一时间的迅速定位故障点，同时领导整个团队高效解决故障。</p>
<p>注意！SRE并不负责部署，但是要负责发布！这里发布的概念要比部署大多了，虽然不负责机械化的部署操作，但是SRE更着眼于整个流程，而且更要有流程化思维。</p>
<p>SRE，我个人认为它是与用户站在同一个角度思考问题的，开发人员关注的是<code>功能是否会实现</code>，实现了那就OK了。而SRE关注的是<code>用户用的爽不爽</code>，若用户使用的时候出现了错误，那么SRE就要出场解决问题。</p>
<p>SRE也要注意推动问题解决，SRE不是<code>server reboot engineering</code>…重启大法虽然好，但是治标不治本。</p>
<h2 id="平台稳定与SLO"><a href="#平台稳定与SLO" class="headerlink" title="平台稳定与SLO"></a>平台稳定与SLO</h2><p>谷歌对系统稳定性有一个比较人性的看法：天底下没有100%不出故障的系统，出故障是正常情况，而如果判断一个系统的健康程度，主要看它是否满足预期的SLO。</p>
<p>SLO是一个重要概念,它中文意思是服务质量目标.服务的故障由于种种原因是无法避免的，每个服务的级别不同，不可能所有服务都是99.999999%，要针对业务的不通特性制定不同的SLO。如果是稳定性要求很高,即与客户有高强度的赔偿协议的服务,那么SLO的级别必须很高，那么付出的代价就是发布变动频率不高或者每一次发布都要严谨评审；而如果是相对冷门涟源的服务，那么SLO可以适度放低。</p>
<p>SLO的制定通常是产品经理、开发团队、SRE一起协商完成，大家根据业务的规模，产品特性，产品处于的阶段制定。当出现了“稳定”与“创新”的矛盾的时候，那么就要产品经理、开发团队、SRE再一次坐到一起修正SLO。</p>
<p>而年度总结的时候，是否满足SLO也是判断SRE的工作业绩的一个考核标准。</p>
<h2 id="值班问题"><a href="#值班问题" class="headerlink" title="值班问题"></a>值班问题</h2><p>SRE有on-call制度的，即值班制度。这里的值班并不是广义的值班，而是在某个周期，某个成员会成为故障的第一接口人。这段时间里，这位同学保证内网VPN和工作电脑时刻在身边。值班范围可以先从一个小系统开始，然后随着对业务的熟悉而逐渐扩大。</p>
<p>值班同学切记不要搞“个人英雄主义”，该汇报汇报，该求助求助，同时其他同学也不可以“事不关己”的态度，同是一个团队的战友，“解决问题”是大家的共同责任。但是辩证法的看，如果平台太稳定，会导致on-call人员产生惰性，所以有些时候需要“人为制造麻烦”—-不断的演习；</p>
<p>但是总而言之，值班是一个很苦逼的工作，如何让值班变得轻松且成功，也是一个制度改进的问题。</p>
<h2 id="故障排查"><a href="#故障排查" class="headerlink" title="故障排查"></a>故障排查</h2><p>不要一天到晚盯着“大屏”，而是编写合适的监控与报警规则，让我们能快速找到故障根源；</p>
<p>出故障第一时间先快速恢复（回滚、部分服务降级限流或者是其他方法），可以将流量转移到其他节点去，保留一台服务器作为事故现场，用于事后分析（这里可以看出虽然SRE不用实际手动去部署，但是有权利直接回滚）</p>
<p>故障排查不是一门玄学，平时经验积累是很重要的一环，经验的积累有助于在模糊不清的旁人描述中提高判断力，但是也要注意结合实际环境和最后一次改动，怀疑的范围逐渐缩小最后得到“真凶”。</p>
<p>事后总结要遵循“对事不对人”的原则，这样大家就不惧怕写事后总结了，而且会让事后总结质量提高，可以对新入职的同学有帮助；</p>
<h2 id="结合实际的工作目标"><a href="#结合实际的工作目标" class="headerlink" title="结合实际的工作目标"></a>结合实际的工作目标</h2><p>首要任务：有效性和覆盖率<br>具体工作内容（☆越多代表优先级越高）：<br>1.对现有的系统二次开发或者利用开源软件搭建环境，得到符合自己业务需要的监控系统（分布式，高可用），监控是SRE的眼睛；<font color='red'>☆☆</font><br> 1.1 监控系统要从更高的服务质量和链路通讯层面告警，通过API或者是CURL等技术获取整体细节，但是也要能快速定位到具体的颗粒；<br>1.2 告警分级系统，兼顾覆盖率的前提下要突出重点；<br>1.3 准备一个文档，可以给开发或者其他同事讲述如何应对各种告警；<br>1.4 即可以tcp又可以udp的探测系统；<br>1.5 事故根源被跟踪恢复，可能还需要一个基线式的事故跟踪系统；<br>2.需求预测与规划容量，一些大型促销时需要正确计算出扩容的规模；<font color='red'>☆☆</font><br>3.保障大促期间平台的正常运行，处理紧急运维事件，注意满足“1510法则”；<font color='red'>☆☆☆</font><br>4.建立一套完整的on-call值班机制；<font color='red'>☆</font><br>5.当熟悉了系统以及与开发人员交流增多的前提下，参与延迟优化和性能优化等工作；<font color='red'>☆</font><br>6.学习并参与全链路压测；<font color='red'>☆☆</font><br>7.参与各种演习，如故障演习，攻防演习等等，将平时演习得分提升上去；<font color='red'>☆☆☆</font></p>
<h2 id="书中金句分享"><a href="#书中金句分享" class="headerlink" title="书中金句分享"></a>书中金句分享</h2><p>1.备份就像纳税一样，是一个服务需要持久而付出的代价，来保障其数据的可用性；<br>2.失败是正常现象，没有100%正常的系统，但是要主动的去寻找失败的可能性；<br>3.用排除法定位故障不是不可以，但是要快速定位，就要平时有对比环境是否一致性的习惯，这就是推动容器化的主要原因；<br>4.SRE通过创造流程、实践以及工具，来提高软件的可靠性；<br>5.一个需要人工阅读邮件和分析报警来决定目前是否需要采取某种行动的系统从本质上是错误的，没有不需要采取行动的警报，如果您遇到一个自己认为不需要执行操作的警报，您需要采用自动化的手段来修复该警报；<br>6.不应该盲目的追求高可用性，从99.99% –&gt;99.999%付出的成本是巨大的，但是收益仅仅是0.009%而已。<br><img data-src="/images/%E5%88%A9%E6%8B%89%E5%BE%B71.gif" alt="akb48" title="利拉德踩中场logo超远距离三分"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>运维技术</tag>
        <tag>SRE</tag>
      </tags>
  </entry>
  <entry>
    <title>Intellij Idea配置GO调用本地包</title>
    <url>/2019/07/05/Intellij-Idea%E9%85%8D%E7%BD%AEGO%E8%B0%83%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%8C%85/</url>
    <content><![CDATA[<p>go代码里使用import去导入包文件，比如常见的<code>import fmt</code>，这个命令实际上导入的就是<code>GOROOT\src\fmt</code>。但是当遇到需要导入本地包的时候，就需要配置一下。</p>
<p>我windows里的go脚本文件夹是<code>E:\github\GoeveryDay</code>，现在在这个文件夹里创建<code>src\chentest\</code>，然后在<code>src\</code>下面创建一个<code>chenchen.go</code>，在<code>chentest\</code>下创建<code>testtest.go</code>，如图：<br><img data-src="/images/go4.png" alt="抱光妹"></p>
<p>而<code>chenchen.go</code>的内容如下：<br>	<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;chentest&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	chentest.XXX()</span><br><span class="line">	<span class="keyword">var</span> s1 chentest.Player</span><br><span class="line">	s1.Name = <span class="string">&quot;iverson&quot;</span></span><br><span class="line">	s1.Number = <span class="number">3</span></span><br><span class="line">	s1.Team = <span class="string">&quot;76ers&quot;</span></span><br><span class="line">	fmt.Println(s1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在需要让<code>chenchen.go</code>能成功调用到<code>chentest.go</code>里的<code>XXX</code>函数，如果此时在<code>chenchen.go</code>里直接<code>import testtest.go所在文件夹</code>是会报错的，错误提示是<code>Cannot resolve file ‘testtest.go所在文件夹’</code>，这是因为程序在运行时先去GOROOT去搜索导入包，然后去GOPATH寻找导入包，最后在当前项目模块下寻找导入包，如果三个都找不到就会报错。</p>
<p>可见在idea中默认不支持直接导入本地Golang包，那么解决该问题的关键是明白GOROOT和GOPATH的作用，根据官方文档的解释GOPATH的主要作用是存放文件以便Golang程序编译时可以进行搜索引用，GOPATH可以设置一个值或多个值，多个值之间以分号隔开。很明显只要我们将本地Golang加入到GOPATH中即可在IDEA中正常运行该程序。</p>
<p>那么先<code>File--Settings--Languages &amp; Frameworks--Go--GOPATH</code>，在project GOPATH里添加<code>E:\github\GoeveryDay</code>这个总的文件路径，如图：<br><img data-src="/images/go5.png" alt="抱光妹"></p>
<p>apply保存即可，记住这里不能填<code>E:\github\GoeveryDay\src</code>，因为系统会自带src目录，如图：<br><img data-src="/images/go6.png" alt="抱光妹"></p>
<p>此时再执行就得到正确结果了！如图：<br><img data-src="/images/go7.png" alt="抱光妹"></p>
<p>但是要注意，<font color=red>要使用本地包函数、结构体、结构体的成员，首字母必须是大写！</font>如果首字母是小写是私有的，即不可见的，只能在同一个包里使用。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>intellij idea</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins与钉钉机器人实现手机端获取当前服务日志</title>
    <url>/2018/02/06/Jenkins%E4%B8%8E%E9%92%89%E9%92%89%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%90%AD%E9%85%8D%E6%89%8B%E6%9C%BA%E7%AB%AF%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>马上要过年了，各位运维们除了因为买不到回家的火车票而嚎嚎大哭之外也开始扩容服务器和提前调整监控值，目的就是为了过一个消停的春节。可是这毕竟十天左右不在公司，要是模块真出了什么意外肯定没法第一找到日志分析问题，毕竟这几天都在串门拜年和醉生梦死中度过，走到哪都要再背一个笔记本实在太不方便了。</p>
<p>那么这个时候，我就琢磨使用手机端来启动服务器里脚本，让这个脚本可以去获取当前的日志，然后再把结果返回到手机端。这样就不用到哪里都带那个一看就很扫兴的公司笔记本电脑了。</p>
<p>使用手机端启动服务器里脚本？我又不会开发android和ios，那么肯定就要使用第三方工具，我条件反射的想到了jenkins，因为jenkins是用手机可以登录的，那么在手机端得到结果用什么呢？在微信公众号和钉钉机器人里，我选择了钉钉机器人。</p>
<h2 id="创造钉钉机器人"><a href="#创造钉钉机器人" class="headerlink" title="创造钉钉机器人"></a>创造钉钉机器人</h2><p>我的钉钉版本是4.2.6.37，首先在左上角头像的三角菜单有一个<code>机器人管理</code>，如图：<br><img data-src="/images/dingding1.png" alt="paradin"></p>
<p>然后选择自定义机器人，给它起个名又换一个图标之后，添加到一个群聊里，如图：<br><img data-src="/images/dingding2.png" alt="paradin"></p>
<p>添加的时候，这个机器人会生成一个<code>webhook</code>，它的结构应该是：<code>https://oapi.dingtalk.com/robot/send?access_token=XXX</code>，后面的XXX是标识符，不同的标识符代表不同的机器人，这个标识符如果丢了，可以在机器人头像点击一下然后选择<code>机器人设置</code>重新看到。</p>
<h2 id="编写机器人脚本"><a href="#编写机器人脚本" class="headerlink" title="编写机器人脚本"></a>编写机器人脚本</h2><p>机器人的官方说明网址就是<code>https://open-doc.dingtalk.com/docs/doc.htm?spm=a219a.7629140.0.0.zZIvnt&amp;treeId=257&amp;articleId=105735&amp;docType=1</code>，这里面已经把使用方法写的够清楚了。我这里的这个python脚本是用json的格式，如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/bin/</span>python</span><br><span class="line">#<span class="attr">coding</span>: utf-<span class="number">8</span></span><br><span class="line"><span class="keyword">import</span> json,urllib2</span><br><span class="line"></span><br><span class="line">#这里是机器人对应的<span class="title class_">Webhook</span>地址</span><br><span class="line">url = <span class="string">&quot;https://oapi.dingtalk.com/robot/send?access_token=这里输入你机器人的标识符</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#这里是头，原样复制就好</span></span><br><span class="line"><span class="string">header = &#123;</span></span><br><span class="line"><span class="string">    &quot;</span><span class="title class_">Content</span>-<span class="title class_">Type</span><span class="string">&quot;: &quot;</span>application/json<span class="string">&quot;,</span></span><br><span class="line"><span class="string">    &quot;</span>charset<span class="string">&quot;: &quot;</span>utf-<span class="number">8</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#这里是传送的消息</span></span><br><span class="line"><span class="string">data = &#123;</span></span><br><span class="line"><span class="string">   	 &quot;</span>msgtype<span class="string">&quot;: &quot;</span>text<span class="string">&quot;,</span></span><br><span class="line"><span class="string">   	    &quot;</span>text<span class="string">&quot;: &#123;</span></span><br><span class="line"><span class="string">   	        &quot;</span>content<span class="string">&quot;: &quot;</span>这里是消息正文！<span class="string">&quot;</span></span><br><span class="line"><span class="string">  		    &#125;,</span></span><br><span class="line"><span class="string">  		 &quot;</span>at<span class="string">&quot;: &#123;</span></span><br><span class="line"><span class="string">		 &quot;</span>atMobiles<span class="string">&quot;: [</span></span><br><span class="line"><span class="string">           &quot;</span>A的手机号<span class="string">&quot;,</span></span><br><span class="line"><span class="string">		&quot;</span>B的手机号<span class="string">&quot;</span></span><br><span class="line"><span class="string">		]， </span></span><br><span class="line"><span class="string">  	         &quot;</span>isAtAll<span class="string">&quot;:False   #这里True代表要发给所有人，False的话，要代表消息只发给A和B这两个人</span></span><br><span class="line"><span class="string">  	      &#125;</span></span><br><span class="line"><span class="string">  	 &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">sendData = json.dumps(data)</span></span><br><span class="line"><span class="string">request = urllib2.Request(url,data = sendData,headers = header)</span></span><br><span class="line"><span class="string">urlopen = urllib2.urlopen(request)</span></span><br><span class="line"><span class="string">print urlopen.read()</span></span><br></pre></td></tr></table></figure></p>
<p>直接执行这个脚本，就会看到我刚新建的钉钉机器人在群聊里说话了。<br><img data-src="/images/dingding3.png" alt="paradin"></p>
<h2 id="机器人搭配nginx"><a href="#机器人搭配nginx" class="headerlink" title="机器人搭配nginx"></a>机器人搭配nginx</h2><p>上面那个脚本已经可以初步实现我们的目的，但是有一个缺点，就是正文内容不能过长。但是我想多打印一点日志，至少50行，怎么办？我想了想，可以把日志放进nginx的一个网页里，然后用钉钉机器人反馈这个网页地址啊，这样内容想写多少就可以写多少了。</p>
<p>假设我现在获取到的日志的文件写进一个叫<code>chairmanmao.html</code>里，在浏览器打开看是这样的：<br><img data-src="/images/dingding4.png" alt="paradin"></p>
<p>那么上面那个机器人的python脚本就要改成这样：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/bin/</span>python</span><br><span class="line">#<span class="attr">coding</span>: utf-<span class="number">8</span></span><br><span class="line"><span class="keyword">import</span> json,urllib2,commands</span><br><span class="line"></span><br><span class="line">commands.<span class="title function_">getstatusoutput</span>(<span class="string">&#x27;echo -e &quot;THIS IS TEST MESSAGE！ \n&quot; &gt; /路径/chairmantail.html&#x27;</span>)	#这里可以给网页加一个标题</span><br><span class="line">commands.<span class="title function_">getstatusoutput</span>(<span class="string">&#x27;cat /路径/chairmanmao.txt &gt;&gt;  /路径/chairmanmao.html&#x27;</span>)		#这里就是把诗词写进html文件里</span><br><span class="line"></span><br><span class="line">#这里是机器人的webhook地址</span><br><span class="line">url = <span class="string">&quot;https://oapi.dingtalk.com/robot/send?access_token=这里输入你机器人的标识符&quot;</span></span><br><span class="line"></span><br><span class="line">header = &#123;</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">    <span class="string">&quot;charset&quot;</span>: <span class="string">&quot;utf-8&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">     <span class="string">&quot;msgtype&quot;</span>: <span class="string">&quot;link&quot;</span>,</span><br><span class="line">        <span class="string">&quot;link&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;text&quot;</span>: <span class="string">&quot;点击网址就可获取到本次日志查询的结果&quot;</span>,</span><br><span class="line">                <span class="string">&quot;title&quot;</span>: <span class="string">&quot;日志查询结果已经生成！&quot;</span>,</span><br><span class="line">                <span class="string">&quot;picUrl&quot;</span>: <span class="string">&quot;http://p1x3hd2at.bkt.clouddn.com/nanshen.jpg&quot;</span>,	#这里可以加一个缩略图片</span><br><span class="line">                <span class="string">&quot;messageUrl&quot;</span>: <span class="string">&quot;http://服务器外网IP地址/chairmanmao.html&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">     <span class="string">&quot;at&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;isAtAll&quot;</span>:<span class="title class_">True</span>   # at为非必须</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">sendData = json.<span class="title function_">dumps</span>(data)</span><br><span class="line">request = urllib2.<span class="title class_">Request</span>(url,data = sendData,headers = header)</span><br><span class="line">urlopen = urllib2.<span class="title function_">urlopen</span>(request)</span><br><span class="line">print urlopen.<span class="title function_">read</span>()</span><br></pre></td></tr></table></figure></p>
<p>执行这个脚本可以看到机器人发送的信息如下：<br><img data-src="/images/dingding5.png" alt="paradin"></p>
<p>然后打开这个网址，就看到完整的网页信息：<br><img data-src="/images/dingding6.png" alt="paradin"></p>
<p>到时候把毛主席诗词换成实际的日志文件就好了，不用一口气打印所有的日志出来，<code>tail -n 50 日志文件名</code>，50行足够用了。</p>
<h2 id="配置Jenkins"><a href="#配置Jenkins" class="headerlink" title="配置Jenkins"></a>配置Jenkins</h2><p>脚本写完了，机器人也写完了，这个时候就要添加“启动端”。安装Jenkins的步骤我这里就不写了，直接可以去看<code>https://rorschachchan.github.io/2018/02/05/Jenkins安装与创建简单任务/</code>。现在去登录Jenkins的网页，去添加一个新的Job，比如我这个Job就叫“获取模块日志”，如图：<br><img data-src="/images/dingding7.png" alt="paradin"></p>
<p>如果是要在Jenkins上去读取其他服务器的日志，就可以在<code>构建project</code>的时候选择<code>参数化构建过程</code>，然后配置参数ip，到时候把这些ip传递给目标脚本。如果觉得这样hold不住，可以不用jenkins的这个功能，把ip写到脚本里去，一了百了：<br><img data-src="/images/dingding8.png" alt="paradin"></p>
<p>在<code>构建</code>那一步，选择<code>Execute Shell</code>，然后里面写上具体的shell命令，如果在上面使用了参数，那么参数就可以在这里使用，我的脚本里是没有ip这个参数的，在图里写<code>$ip</code>就是做一个例子讲解一下用法而已：<br><img data-src="/images/dingding9.png" alt="paradin"></p>
<p>在<code>构建后操作</code>这一步可以选择<code>E-mail Notification</code>，这样如果失败了会发送邮件通知。如果用不着就什么都不用选。然后就是保存好这个project，点击左侧菜单栏的<code>立即构建</code>，就会看到下面<code>Build History</code>会多一个<code>#1</code>出来，同时钉钉机器人也在群里发消息，这个<code>#1</code>就是构建的记录，这个纪录多了的话，新纪录会覆盖掉老的记录。<br><img data-src="/images/dingding10.png" alt="paradin"></p>
<p>点击这个<code>#1</code>，选择<code>控制台输出</code>，就能看到具体的操作结果了，跟在shell界面里执行的效果差不多的。可见操作成功，目的已经达到了！<br><img data-src="/images/dingding11.png" alt="paradin"></p>
<p>以后需要调用脚本，就在手机端浏览器里登陆jenkins，然后构建一下这个project，同时就可以看到钉钉里机器人有反馈了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://xu3352.github.io/linux/2017/05/01/jenkins-restart-remote-server-tomcat">https://xu3352.github.io/linux/2017/05/01/jenkins-restart-remote-server-tomcat</a><br><a href="https://github.com/typ431127/zabbix_dingding">https://github.com/typ431127/zabbix_dingding</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>钉钉</tag>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins与Github组合成持续集合环境</title>
    <url>/2018/02/05/Jenkins%E4%B8%8EGithub%E7%BB%84%E5%90%88%E6%88%90%E6%8C%81%E7%BB%AD%E9%9B%86%E5%90%88%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h2 id="生成Token码"><a href="#生成Token码" class="headerlink" title="生成Token码"></a>生成Token码</h2><p>首先登录github，在首页选择<code>settings</code>，如图：<br><img data-src="/images/jenkins12.png" alt="paradin"></p>
<p>然后点击最下面的<code>Developer settings</code>，点击<code>Personal access tokens</code>，最后点击<code>Generate new token</code>，如图：<br><img data-src="/images/jenkins13.png" alt="paradin"></p>
<p>输入名称和权限，权限选择<code>repo</code>和<code>admin:repo_hook</code>这俩，如图：<br><img data-src="/images/jenkins14.png" alt="paradin"></p>
<p>然后就会生成一个<code>token密码</code>，这个<code>token密码</code>请妥善保存，丢失或者删除就GG了。<br><img data-src="/images/jenkins15.png" alt="paradin"></p>
<h2 id="将Token码配置到Jenkins"><a href="#将Token码配置到Jenkins" class="headerlink" title="将Token码配置到Jenkins"></a>将Token码配置到Jenkins</h2><p>浏览器返回到Jenkins界面，在首页里点击<code>系统管理</code>，然后选择<code>系统配置</code>，在系统配置里面添加一个<code>GitHub Servers</code>，在<code>Add Credentials</code>这一步的时候，要把<code>kind</code>改成<code>Secret text</code>，如图：<br><img data-src="/images/jenkins17.png" alt="paradin"></p>
<p>这里<code>Secret</code>的地方就是填写刚刚生成的Token码。</p>
<p>保存之后，点击一下<code>test connection</code>，如果出现<code>Credentials verified for user xxx, rate limit: xxx</code>的字样就是成功了，如图：<br><img data-src="/images/jenkins19.png" alt="paradin"></p>
<h2 id="设置webhooks"><a href="#设置webhooks" class="headerlink" title="设置webhooks"></a>设置webhooks</h2><p>在github里找一个源码库，选择<code>settings</code>，然后点击小菜单栏里的<code>Webhooks</code>，再点击右边的<code>Add Webhook</code>即可，如图：<br><img data-src="/images/jenkins16.png" alt="paradin"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>持续集成</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins的安装与创建简单任务</title>
    <url>/2018/02/05/Jenkins%E5%AE%89%E8%A3%85%E4%B8%8E%E5%88%9B%E5%BB%BA%E7%AE%80%E5%8D%95%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="安装与启动"><a href="#安装与启动" class="headerlink" title="安装与启动"></a>安装与启动</h2><p>环境：<code>CentOS 7.0</code> + <code>java 1.8</code></p>
<p>安装方式：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yum install yum-fastestmirror -y  #安装自动选择最快源的插件</span><br><span class="line">#添加<span class="title class_">Jenkins</span>源:</span><br><span class="line">sudo wget -O /etc/yum.<span class="property">repos</span>.<span class="property">d</span>/jenkins.<span class="property">repo</span> <span class="attr">http</span>:<span class="comment">//jenkins-ci.org/redhat/jenkins.repo</span></span><br><span class="line">sudo rpm --<span class="keyword">import</span> <span class="attr">http</span>:<span class="comment">//pkg.jenkins-ci.org/redhat/jenkins-ci.org.key</span></span><br><span class="line">yum install jenkins               #安装jenkins</span><br></pre></td></tr></table></figure></p>
<p>启动方式：<code>sudo service jenkins start</code>，如果没有java是无法启动的。</p>
<p>Jenkins默认端口是<code>8080</code>，如果要更改端口，需要先<code>vim /etc/sysconfig/jenkins</code>，然后修改<code>JENKINS_PORT=&quot;8080&quot;</code>为自己想要的端口号即可。</p>
<p>访问方式：浏览器输入<code>http://your server ip:8080/</code>，然后会看到这样的一个界面，打开这个文件，输入里面的key就可以访问jenkins了。<br><img data-src="/images/jenkins1.png" alt="paradin"></p>
<p>然后就是让你安装插件，如果是新手的话，可以安装系统推荐的插件，如果插件安装失败不要怕，可以日后手动补上。<br><img data-src="/images/jenkins2.png" alt="paradin"></p>
<p>插件安装完毕之后，就是自己创建一个管理员账号和密码，输入之后，点击右下角<code>保存并完成</code>。<br><img data-src="/images/jenkins3.png" alt="paradin"></p>
<p>然后就可以看到Jenkins初始化的首页。<br><img data-src="/images/jenkins4.png" alt="paradin"></p>
<h2 id="镜像安装"><a href="#镜像安装" class="headerlink" title="镜像安装"></a>镜像安装</h2><p>docker安装jenkins也很简单粗暴，但是官方的jenkins镜像可能拉取比较慢，推荐先去加速，国内docker加速的方法在此：<a href="https://rorschachchan.github.io/2018/04/20/%E5%9B%BD%E5%86%85Docker%E7%9A%84%E5%8A%A0%E9%80%9F%E6%96%B9%E6%B3%95/">https://rorschachchan.github.io/2018/04/20/%E5%9B%BD%E5%86%85Docker%E7%9A%84%E5%8A%A0%E9%80%9F%E6%96%B9%E6%B3%95/</a> 。</p>
<p>安装步骤如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">docker pull jenkins		</span><br><span class="line">cd /data/</span><br><span class="line">docker run -d --name jenkins -p <span class="number">8080</span>:<span class="number">8080</span> -v /data/<span class="attr">jenkins</span>:<span class="regexp">/var/</span>jenkins_home jenkins	#做了一个挂载</span><br><span class="line">chown -R <span class="number">1000</span> /data/jenkins		#将权限打开，不然的话jenkins无法正常启动</span><br><span class="line">docker start jenkins</span><br><span class="line">cat /data/jenkins/secrets/initialAdminPassword		#网页需要的验证码</span><br></pre></td></tr></table></figure></p>
<p>此时登录<code>http://your server ip:8080/</code>就会正常访问了，其余的步骤跟上面的一致。不过镜像安装有点瑕疵，就是tag是V2.60.3，有点老，有些插件已经不支持了。</p>
<h2 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h2><p>假设现在要创建一个Job(任务)，这个任务就是输出当前服务器的外网IP地址，那么就点击首页里的<code>新建任务</code>，然后输入任务名，补充一句，生产环境里的Job名最好不用中文，不做死就不会死，然后选择<code>构建一个自由风格的软件项目</code>，如图：<br><img data-src="/images/jenkins5.png" alt="paradin"></p>
<p>在<code>源码管理</code>的地方，我们暂时选择<code>None</code>，待日后把jenkins与github相关联之后，就可以通过github来配置源码了。在<code>构建触发器</code>的地方，我们选择<code>Poll SCM</code>，这里说一下这几个触发器选项的意思：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Build</span> after other projects are built：	</span><br><span class="line"><span class="title class_">Build</span> periodically ： 周期进行项目构建（它不关心源码是否发生变化），可以配置如下：<span class="number">0</span> <span class="number">2</span> * * *（每天<span class="number">2</span>:<span class="number">00</span> 必须build一次源码）</span><br><span class="line"><span class="title class_">Build</span> when a change is pushed to <span class="title class_">GitHub</span>： 只要github上有提交了，jenkins没有自动检测到并构建，这设置之后在github中也需要设置才能生效</span><br><span class="line"><span class="title class_">Poll</span> <span class="variable constant_">SCM</span>：定时检查源码变更（根据<span class="variable constant_">SCM</span>软件的版本号），如果有更新就checkout最新code下来，然后执行构建动作。可以配置如下：*/<span class="number">10</span> * * * *  （每<span class="number">5</span>分钟检查一次源码变化）</span><br></pre></td></tr></table></figure><br><img data-src="/images/jenkins6.png" alt="paradin"></p>
<p><code>构建步骤</code>这里有很多的选项，我们选择<code>Execute Shell</code>，里面可以写shell命令也可以写shell脚本，这里我就写入一个很简单的ifconfig命令去查看一下IP地址，如图：<br><img data-src="/images/jenkins7.png" alt="paradin"></p>
<p><code>构建后操作</code>这里也有很多的选项，这里我选择<code>E-mail Notification</code>，然后输入自己的邮箱地址，这样如果构建失败了，就可以发邮件提醒。如图：<br><img data-src="/images/jenkins8.png" alt="paradin"></p>
<p>配置完毕之后，点击左下角<code>保存</code>即可。</p>
<h2 id="查看任务效果"><a href="#查看任务效果" class="headerlink" title="查看任务效果"></a>查看任务效果</h2><p>返回到Jenkins的首页，我们看到多了那个刚才新建的任务，然后点击任务名旁边的小三角，选择<code>立即构建</code>，如图：<br><img data-src="/images/jenkins9.png" alt="paradin"></p>
<p>然后就会看到构建的历史，点击任意历史记录的<code>控制台输出</code>，就会看到效果，的确是操作了<code>ifconfig</code>命令的效果：<br><img data-src="/images/jenkins10.png" alt="paradin"><br><img data-src="/images/jenkins11.png" alt="paradin"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>持续集成</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins自动构建镜像并且发送钉钉通知</title>
    <url>/2018/08/30/Jenkins%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F%E5%B9%B6%E4%B8%94%E5%8F%91%E9%80%81%E9%92%89%E9%92%89%E9%80%9A%E7%9F%A5/</url>
    <content><![CDATA[<h2 id="部署流程图"><a href="#部署流程图" class="headerlink" title="部署流程图"></a>部署流程图</h2><p>把k8s引入到整个部署的自动化流程如下图：<br><img data-src="/images/jenkinsdingding2.png" alt="akb48" title="这是宋净超大神的图，侵权则删"></p>
<p>上图已经说的很明白了，但是结合到我公司的内部情况，再加一点文字的解释：</p>
<ol>
<li>运维做一个前端页面，上面提供一些关键词作为变量传入;</li>
<li>开发将代码上传到svn或者gitlab，进行jira通知，如果是svn的话，jenkins将新代码打包成zip文件，启动jenkins把windows的zip包上传到阿里云云存储上；如果是到gitlab，就不用打包成zip了，直接就把包传到云存储上；</li>
<li>Gitlab&#x2F;Svn通过webhook通知jenkins去挂载云存储bucket的文件夹里，并且根据对应的dockerfile进行build成镜像，然后再把镜像推送到云镜像仓库里，推送成功后，Jenkins发送一个钉钉成功的通知；</li>
<li>Jinkens针对本次镜像和实际部署内容再搭配上之前传递进来的变量，构建一个yaml文件；</li>
<li>通过create这个yaml文件，启动对应的services来达到用户访问的目的，此时Jenkins再发一条钉钉通知，整个部署流程结束。</li>
</ol>
<h2 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h2><p>Jenkins:<code>2.124</code>,jenkins与docker在同一台云服务器上，并且确定这个机器上可以顺利login到阿里云的私有仓库<br>云存储:阿里云OSS<br>Gitlab:<code>10.7.3</code><br>镜像仓库:阿里云容器镜像仓库<br>钉钉:<code>4.5.5</code></p>
<h2 id="Jinkens安装钉钉插件"><a href="#Jinkens安装钉钉插件" class="headerlink" title="Jinkens安装钉钉插件"></a>Jinkens安装钉钉插件</h2><p>既然要让jenkins调用钉钉发送成功消息，那么就需要把jenkins跟钉钉结合在一起。至于怎么配自定义钉钉机器人，请看钉钉的官方文档：<a href="https://open-doc.dingtalk.com/docs/doc.htm?spm=a219a.7629140.0.0.karFPe&treeId=257&articleId=105735&docType=1">https://open-doc.dingtalk.com/docs/doc.htm?spm=a219a.7629140.0.0.karFPe&amp;treeId=257&amp;articleId=105735&amp;docType=1</a> 。而jenkins里也是有官方的钉钉插件，界面<code>系统管理</code>–<code>管理插件</code>，然后搜索“dingding”，安装即可，如图：<br><img data-src="/images/jenkinsdingding1.png" alt="akb48"></p>
<p>插件安装完毕之后，重启jenkins即可。</p>
<h2 id="挂载阿里云存储"><a href="#挂载阿里云存储" class="headerlink" title="挂载阿里云存储"></a>挂载阿里云存储</h2><p>阿里云官方挂载云存储的方法是<code>ossfs</code>，登陆到jenkins所在的服务器(centos 7.4)里，步骤如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wget <span class="attr">https</span>:<span class="comment">//github.com/aliyun/ossfs/releases/download/v1.80.5/ossfs_1.80.5_centos7.0_x86_64.rpm</span></span><br><span class="line">yum localinstall ossfs_1<span class="number">.80</span>.5_centos7.0_x86_64.<span class="property">rpm</span> 		#这一步安装可能会比较慢</span><br><span class="line">echo 需要挂载的bucket名:云存储对应<span class="attr">ak</span>:云存储对应sk &gt; <span class="regexp">/etc/</span>passwd-ossfs	#将云存储的ak,sk写入到文件里</span><br><span class="line">chmod <span class="number">640</span> /etc/passwd-ossfs</span><br><span class="line">mkdir /tmp/ossfs	#创建挂载文件</span><br><span class="line">ossfs 需要挂载的bucket名 /tmp/ossfs -ourl=<span class="attr">http</span>:<span class="comment">//oss-cn-hangzhou-internal.aliyuncs.com	#如果不是阿里云就要用外网的endpoint</span></span><br></pre></td></tr></table></figure></p>
<p>操作的效果如下，我挂载的bucket叫<code>ligentest</code>，毕竟代码是高度机密，bucket属性设置是<code>私有</code>，256T的容量爽爽的：<br><img data-src="/images/jenkinsdingding3.png" alt="akb48"></p>
<h2 id="配置任务"><a href="#配置任务" class="headerlink" title="配置任务"></a>配置任务</h2><p>在jenkins里创建一个新的工程，取名叫“构建镜像并且上传到云仓库”。“gitlab更新就触发jenkins”的配置内容可以参考 <a href="https://rorschachchan.github.io/2018/05/25/Gitlab-Jenkins%E6%90%AD%E5%BB%BA%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E7%B3%BB%E7%BB%9F/">https://rorschachchan.github.io/2018/05/25/Gitlab-Jenkins搭建持续集成系统/</a> 一文进行操作。</p>
<p>配置正确jenkins与gitlab各自的webhook，测试提交能返回200之后。就要配置<code>构建</code>和<code>构建后操作</code>。</p>
<p><code>构建</code>选择<code>执行shell</code>，里面填写这样一个命令：<code>sudo sh /docker/pushimage.sh</code>，也就是运行一个脚本，脚本内容如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/bin/</span>bash</span><br><span class="line">#这个脚本用来推送最新的镜像去阿里云镜像仓库</span><br><span class="line"></span><br><span class="line">version=$(date +<span class="number">20</span>%y%m%d)			#用当前日期作为version</span><br><span class="line">docker build -f /docker/chenpyfile -t chentest/<span class="attr">python</span>:$version .		#先本地构建镜像</span><br><span class="line">image_id=$(docker images | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span> | sed -n <span class="string">&#x27;2p&#x27;</span>)		#获取image的id号</span><br><span class="line">docker tag $image_id registry.<span class="property">cn</span>-hangzhou.<span class="property">aliyuncs</span>.<span class="property">com</span>/lechangetest/<span class="attr">chentest</span>:$version	#给本地的镜像打一个tag</span><br><span class="line">docker push registry.<span class="property">cn</span>-hangzhou.<span class="property">aliyuncs</span>.<span class="property">com</span>/lechangetest/<span class="attr">chentest</span>:$version		#推送到阿里云对应的仓库去</span><br></pre></td></tr></table></figure></p>
<p><code>构建后操作</code>选择<code>钉钉通知器配置</code>，<code>jenkins URL</code>一栏应该默认填好的，即jenkins的网址；<code>钉钉access token</code>这一栏就是直接填机器人的那个<code>access token</code>，然后选择根据什么情景机器人触发通知，如图：<br><img data-src="/images/jenkinsdingding4.png" alt="akb48"></p>
<h2 id="触发验证"><a href="#触发验证" class="headerlink" title="触发验证"></a>触发验证</h2><p>首先要确认jenkins用户能否正常使用docker命令，方法就是修改一下<code>/etc/sudoers</code>添加<code>jenkins</code>这个用户即可。</p>
<p>这次测试，我们就不搞nginx那种静态页面了，换一个python在后台运行的例子。首先，准备一个叫<code>time.py</code>的脚本，这个脚本很简单，就是不断的输出当前时间的脚本：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/usr/</span>bin/env python</span><br><span class="line">#coding=utf-<span class="number">8</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">def <span class="title function_">get_time</span>():</span><br><span class="line">       localtime = time.<span class="title function_">asctime</span>( time.<span class="title function_">localtime</span>(time.<span class="title function_">time</span>()) )</span><br><span class="line">       <span class="title function_">print</span> (<span class="string">&quot;本地时间为 :&quot;</span>, localtime)		#python的dockerfile用的是latest，python3是要求有括号的</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">       <span class="keyword">while</span> <span class="title class_">True</span>:</span><br><span class="line">          <span class="title function_">get_time</span>()</span><br><span class="line">          time.<span class="title function_">sleep</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>对应的dockerfile叫<code>chenpyfile</code>，如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">############################################################</span><br><span class="line"># <span class="title class_">Dockerfile</span> to build A python container images			   #</span><br><span class="line"># <span class="title class_">Based</span> on <span class="title class_">Python</span>										   #</span><br><span class="line">############################################################</span><br><span class="line"><span class="variable constant_">FROM</span>    <span class="attr">python</span>:latest</span><br><span class="line"><span class="variable constant_">MAINTAINER</span>      <span class="title class_">ChrisChan</span> <span class="string">&quot;Chris@jjfjj.com&quot;</span></span><br><span class="line"><span class="variable constant_">RUN</span>     apt-get update &amp;&amp; \</span><br><span class="line">        apt-get install -y vim &amp;&amp; \</span><br><span class="line">        apt-get install -y procps</span><br><span class="line"><span class="variable constant_">RUN</span>     mkdir -p /root/app</span><br><span class="line"><span class="variable constant_">COPY</span>    /script/ <span class="regexp">/root/</span>script			#把上面那个脚本拷贝到容器里，当然挂载也可以</span><br><span class="line"><span class="variable constant_">CMD</span>     [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;/root/script/time.py&quot;</span>]		#这里不要写“python /root/script/time.<span class="property">py</span>”，注意前后台问题</span><br></pre></td></tr></table></figure></p>
<p>这个dockerfile在本地测试构建镜像是完全没问题的，然后触发一下<code>git push</code>，就会看到钉钉机器人启动了：<br><img data-src="/images/jenkinsdingding5.png" alt="akb48"></p>
<p>构建完毕之后，机器人也会给一个成功的标志，然后去阿里云的云仓库一看，嗯，果然已经推送过来了！如图：<br><img data-src="/images/jenkinsdingding6.png" alt="akb48"></p>
<p>再<code>docker run -dit --name chen-pytest registry.cn-hangzhou.aliyuncs.com/lechangetest/chentest:20180831</code>，也能看到新创建的镜像是可以启动的：<br><img data-src="/images/jenkinsdingding7.png" alt="akb48"></p>
<p>至此整个“Jenkins自动构建镜像并且发送钉钉通知”部分就结束了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://jimmysong.io/posts/kubernetes-jenkins-ci-cd/">https://jimmysong.io/posts/kubernetes-jenkins-ci-cd/</a><br><a href="https://help.aliyun.com/document_detail/32196.html">https://help.aliyun.com/document_detail/32196.html</a><br><a href="http://www.cnblogs.com/jianxuanbing/p/7211006.html">http://www.cnblogs.com/jianxuanbing/p/7211006.html</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>钉钉</tag>
        <tag>Jenkins</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s的基础操作</title>
    <url>/2018/08/27/K8s%E4%BB%8E%E9%83%A8%E7%BD%B2%E5%88%B0%E6%89%A9%E5%AE%B9/</url>
    <content><![CDATA[<h2 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h2><p>kubenetes:阿里云服务，版本<code>v1.10.4</code>，三个master，一个node，我也不知道为啥阿里云设定master最少是3个，而node最少可以是1个…<br>服务器:阿里云<code>Centos 7.4</code></p>
<h2 id="部署服务"><a href="#部署服务" class="headerlink" title="部署服务"></a>部署服务</h2><p>首先，我们先部署一个以dockhub最新nginx镜像为底的nginx。命令如下：<code>kubectl run nginx-test --image=nginx:latest --port=80</code>。同理，再部署一个最新版redis的话，就是找葫芦画瓢：<code>kubectl run redis-test --image=redis:latest --port=6379</code>。</p>
<p>两个命令敲完，这就给k8s下达了一个deployment（部署任务），可用<code>kubectl get deployments</code>和<code>kubectl get pods</code>命令查看：<br><img data-src="/images/k8s10.png" alt="paradin"></p>
<p>可以看到现在已经生成了对应的pod，而pod里就是容器了，容器里就是对应的服务。如果想爬进这个容器看一下里面的文件等情况，命令是：<code>kubectl exec -it nginx-test-bb95c4645-7qpbj bash</code>。</p>
<p>这里插播一下<code>kubectl get deployment</code>里各参数的含义：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">DESIRED</span>：对应.<span class="property">spec</span>.<span class="property">replicas</span>，用户设定的期望副本数</span><br><span class="line"><span class="variable constant_">CURRENT</span>：对应.<span class="property">status</span>.<span class="property">replicas</span>，目前运行的副本数</span><br><span class="line"><span class="variable constant_">UP</span>-<span class="variable constant_">TO</span>-<span class="attr">DATE</span>:对应.<span class="property">status</span>.<span class="property">updatedReplicas</span>，包含最新的pod template的副本数</span><br><span class="line"><span class="variable constant_">AVAILABLE</span>：对应.<span class="property">status</span>.<span class="property">availableReplicas</span>，进入正常状态的副本数</span><br></pre></td></tr></table></figure></p>
<p>但是现在这个服务是外网无法访问的，因为宿主机还没有一个端口与这个nginx容器的80端口相对应。所以要暴露一个端口给外部用于访问。命令是：<code>kubectl expose deployment/kubernetes-bootcamp --type=&quot;NodePort&quot; --port 80</code>，然后用<code>kubectl get services</code>查看一下效果：<br><img data-src="/images/k8s11.png" alt="paradin"></p>
<p>然后在对应的master和node里就看到宿主机随机分配的那个30497端口已经启动了，如图：<br><img data-src="/images/k8s12.png" alt="paradin"></p>
<p>在浏览器上访问一下30497端口，果然可以访问到nginx服务：<br><img data-src="/images/k8s13.png" alt="paradin"></p>
<h2 id="扩容服务"><a href="#扩容服务" class="headerlink" title="扩容服务"></a>扩容服务</h2><p>服务嘛，总有高峰低谷。比如微博，突然爆出来哪个娱乐明星的新闻，肯定就会有大量的流量涌入，此时就需要扩容，那么k8s的扩容很简单，就是pod的复制，如果要把上面那个nginx-test的部署任务进行扩展，命令就是<code>kubectl scale deployments/nginx-test  --replicas=4</code>，如图：<br><img data-src="/images/k8s14.png" alt="paradin"></p>
<p>可见nginx-test又生成了三个pod，与原来的组成了4个pod，而另一个redis的部署任务是没有变化的。</p>
<p>用<code>kubectl get pods -o wide</code>可见，每一个pod分配到了不同的虚拟IP上，而且node都是阿里云的那台node服务器。<br><img data-src="/images/k8s15.png" alt="paradin"></p>
<p>在阿里云控制台也能看到里面的情况：<br><img data-src="/images/k8s16.png" alt="paradin"></p>
<p>此时进入到node节点，<code>docker ps -a</code>就会看到新的nginx景象生成，同时也生成了三个<code>/pause</code>的容器：<br><img data-src="/images/k8s17.png" alt="paradin"></p>
<p>kubernetes中的pause容器主要为每个业务容器提供以下功能：</p>
<ol>
<li>在pod中担任Linux命名空间共享的基础；</li>
<li>启用pid命名空间，开启init进程。</li>
</ol>
<p><font color=red>注意！目前kubernetes似乎仅仅支持共享网络，还不支持进程体系、文件系统之间的共享。</font>如果此时在访问，就会看到访问会相对均匀的落到这四个pod中的每一个，起到一个负载均衡的作用。如果高峰期过了，不需要那么多pod了，就<code>kubectl scale deployments/nginx-test  --replicas=1</code>，pod就会恢复成1个，据我几次试验，每次都是保留最老的那一个pod。</p>
<h2 id="yaml文件创建一个pod"><a href="#yaml文件创建一个pod" class="headerlink" title="yaml文件创建一个pod"></a>yaml文件创建一个pod</h2><p>K8s的yaml文件的文法和规矩，官方社区就有教程：<a href="https://www.kubernetes.org.cn/1414.html">https://www.kubernetes.org.cn/1414.html</a> 。但是如果要搭配阿里云的私有镜像，需要先参考一下阿里云文档：<a href="https://help.aliyun.com/document_detail/86562.html">https://help.aliyun.com/document_detail/86562.html</a> 。<font color=red>注意，这个方法不能在命令行里使用，只能在yaml或者json里用。</font>这里先写一个简单的nginx配置文件<code>pod-nginx.yaml</code>做例子，全文如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="attr">apiVersion</span>: v1</span><br><span class="line"><span class="attr">kind</span>: <span class="title class_">Pod</span></span><br><span class="line"><span class="attr">metadata</span>:</span><br><span class="line">  <span class="attr">name</span>: aliyun-nginx</span><br><span class="line">  <span class="attr">labels</span>:</span><br><span class="line">    <span class="attr">app</span>: web</span><br><span class="line"><span class="attr">spec</span>:</span><br><span class="line">  <span class="attr">restartPolicy</span>: <span class="title class_">Always</span>         #表明该容器一直运行，默认k8s的策略，在此容器退出后，会立即创建一个相同的容器</span><br><span class="line">  <span class="attr">nodeSelector</span>:  </span><br><span class="line">   	<span class="attr">zone</span>: node1			#节点选择</span><br><span class="line">  <span class="attr">containers</span>:</span><br><span class="line">  - <span class="attr">name</span>: aliyun-test-nginx</span><br><span class="line">    <span class="attr">image</span>: registry-vpc.<span class="property">cn</span>-hangzhou.<span class="property">aliyuncs</span>.<span class="property">com</span>/lechangetest/<span class="attr">chentest</span>:<span class="number">1.1</span></span><br><span class="line">    <span class="attr">imagePullPolicy</span>: <span class="title class_">IfNotPresent</span>      #可选择<span class="title class_">Always</span>、<span class="title class_">Never</span>、<span class="title class_">IfNotPresent</span>，即每次启动时检查和更新images的策略，<span class="title class_">IfNotPresent</span>是节点上没有此nginx镜像时才执行pull操作</span><br><span class="line">    <span class="attr">ports</span>:</span><br><span class="line">    - <span class="attr">containerPort</span>: <span class="number">80</span>       #容器开发对外的端口</span><br><span class="line">      <span class="attr">hostPort</span>: <span class="number">33664</span>            #映射到主机的端口/对外映射的端口（一般可以不写）</span><br><span class="line">  <span class="attr">imagePullSecrets</span>:</span><br><span class="line">    - <span class="attr">name</span>: regsecret			#这句话为了通过阿里云似有仓库的鉴权</span><br></pre></td></tr></table></figure></p>
<p>保存退出，再<code>kubectl create -f pod-redis.yaml</code>把这个文件执行一下。然后<code>kubectl get pod</code>看一下效果：<br><img data-src="/images/k8s18.png" alt="paradin"></p>
<p>发现我们创建那个redis-pod状态是<code>Pending</code>（等待中），那就是不成功啊。于是就<code>kubectl describe pod/pod-redis</code>查看一下原因，反馈如下：<br><img data-src="/images/k8s19.png" alt="paradin"></p>
<p>这个错误的意思是“如果指定的label在所有node上都无法匹配，则创建Pod失败”。原来是我没有配置<code>kubectl label nodes</code>，那先把<code>pod-redis</code>删除，再把<code>nodeSelector</code>那一段去掉，改成<code>nodeName: cn-hangzhou.i-bp1978gmunq3oalfcqlx</code>，去掉再重新create一下。<code>kubectl get pod</code>检查：<br><img data-src="/images/k8s20.png" alt="paradin"></p>
<p>然后就是给这个pod增加一个对外的端口。<code>kubectl expose pod/aliyun-nginx --type=&quot;NodePort&quot; --port 80</code>，效果如下：<br><img data-src="/images/k8s21.png" alt="paradin"></p>
<p>再去浏览器里，输入<code>node的外网网址：31829</code>看看效果：<br><img data-src="/images/k8s22.png" alt="paradin"></p>
<p>配置成功，当然这整个过程也可以在阿里云的控制台操作，更简单更直观，而且阿里云还会自动把对外端口配置到SLB里，具体步骤可以看阿里云的官方文档。</p>
<h2 id="升级与回滚"><a href="#升级与回滚" class="headerlink" title="升级与回滚"></a>升级与回滚</h2><p>假设我们把<code>nginx-test</code>这个deployment的镜像升级成阿里云私有仓库的1.1版本，那么命令是：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">kubectl set image deployments/nginx-test nginx-test=registry.<span class="property">cn</span>-hangzhou.<span class="property">aliyuncs</span>.<span class="property">com</span>/lechangetest/<span class="attr">chentest</span>:<span class="number">1.1</span></span><br></pre></td></tr></table></figure></p>
<p>升级之后，<code>kubectl get pod</code>发现有几个节点不正常，如图：<br><img data-src="/images/k8s23.png" alt="paradin"></p>
<p>那么这种情况下需要紧急回滚，回滚命令：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">kubectl rollout undo deployment/nginx-test</span><br></pre></td></tr></table></figure></p>
<p>一会就看到回滚成功了。如图：<br><img data-src="/images/k8s24.png" alt="paradin"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://jimmysong.io/posts/what-is-a-pause-container/">https://jimmysong.io/posts/what-is-a-pause-container/</a><br><a href="https://blog.csdn.net/mailjoin/article/details/79686937">https://blog.csdn.net/mailjoin/article/details/79686937</a><br><a href="http://pipul.org/2016/05/why-we-need-the-pod-and-service-of-kubernetes/">http://pipul.org/2016/05/why-we-need-the-pod-and-service-of-kubernetes/</a><br><a href="https://www.imooc.com/article/30473">https://www.imooc.com/article/30473</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>容器</tag>
        <tag>阿里云</tag>
        <tag>kubenetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Join与Where的链接Sql</title>
    <url>/2020/11/30/Join%E4%B8%8Ewhere%E7%9A%84%E8%BF%9E%E7%94%A8Sql/</url>
    <content><![CDATA[<h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>假设我们有这样的几个表，第一个表是公司组织关系product_line，表内容如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">+----+-------------------+------------------------+</span><br><span class="line">| <span class="built_in">id</span> | product_line_name | parent_product_line_id |</span><br><span class="line">+----+-------------------+------------------------+</span><br><span class="line">|  <span class="number">1</span> | 库存               |                     <span class="number">39</span> |</span><br><span class="line">|  <span class="number">2</span> | 服务表达           |                     <span class="number">39</span> |</span><br><span class="line">|  <span class="number">3</span> | 履约               |                     <span class="number">39</span> |</span><br><span class="line">|  <span class="number">4</span> | 商货品             |                     <span class="number">39</span> |</span><br><span class="line">|  <span class="number">5</span> | 财务结算            |                     <span class="number">39</span> |</span><br><span class="line">+----+-------------------+------------------------+</span><br></pre></td></tr></table></figure></p>
<p>这里的39是他们的父部门的代号，还有一个表是每一个表的对账规则rule_case，表内容如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">+----+---------+---------------+-----+-----------------+</span><br><span class="line">| <span class="built_in">id</span> | deleted | rule_name     | app | product_line_id |</span><br><span class="line">+----+---------+---------------+-----+-----------------+</span><br><span class="line">|  <span class="number">1</span> |       <span class="number">0</span> | 库存规则<span class="number">1</span>       | aaa | <span class="number">1</span>               |</span><br><span class="line">|  <span class="number">2</span> |       <span class="number">0</span> | 库存规则<span class="number">2</span>       | aaa | <span class="number">1</span>               |</span><br><span class="line">|  <span class="number">3</span> |       <span class="number">0</span> | 履约规则<span class="number">1</span>       | bbb | <span class="number">3</span>               |</span><br><span class="line">|  <span class="number">4</span> |       <span class="number">0</span> | 履约规则<span class="number">2</span>       | bbb | <span class="number">3</span>               |</span><br><span class="line">|  <span class="number">5</span> |       <span class="number">0</span> | 财务规则<span class="number">1</span>       | ccc | <span class="number">5</span>               |</span><br><span class="line">|  <span class="number">6</span> |       <span class="number">0</span> | 财务规则<span class="number">2</span>       | ccc | <span class="number">5</span>               |</span><br><span class="line">|  <span class="number">7</span> |       <span class="number">0</span> | 会员规则<span class="number">1</span>       | xxx | <span class="number">10</span>              |</span><br><span class="line">|  <span class="number">8</span> |       <span class="number">0</span> | 财务规则<span class="number">3</span>       | ccc | <span class="number">5</span>               |</span><br><span class="line">|  <span class="number">9</span> |       <span class="number">1</span> | 库存规则<span class="number">1</span>       | aaa | <span class="number">99</span>              |</span><br><span class="line">+----+---------+---------------+-----+-----------------+</span><br></pre></td></tr></table></figure><br>这里面product_line_id就是上面product_line里的id，可见“会员规则1”就不是父部门39的一员（这里最后一行的“库存规则1”也不是39的一员，另有他用，所以deleted&#x3D;1,做了逻辑删除）。</p>
<p>还有一个表，就是对账规则产生的对应任务及任务的结果rule_task，表内容如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">+----+--------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------+</span><br><span class="line">| <span class="built_in">id</span> | rule_case_id | result                                                                                                                                                                  | status |</span><br><span class="line">+----+--------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------+</span><br><span class="line">|  <span class="number">1</span> | <span class="number">1</span>            | &#123;<span class="string">&quot;sqlResult&quot;</span>:<span class="string">&quot;[&#123;&quot;</span>mig_task_status<span class="string">&quot;:&quot;</span>OVER_ERRO<span class="string">R&quot;,&quot;</span>COUNT(*)<span class="string">&quot;:871&#125;,&#123;&quot;</span>mig_task_status<span class="string">&quot;:&quot;</span>OVER_ERR_OWNER_NO_IS_BLANK<span class="string">&quot;,&quot;</span>COUNT(*)<span class="string">&quot;:2&#125;]&quot;</span>,<span class="string">&quot;execTime&quot;</span>:<span class="number">164</span>,<span class="string">&quot;resultNum&quot;</span>:<span class="number">2</span>,<span class="string">&quot;speNum&quot;</span>:<span class="number">0</span>&#125; |      <span class="number">2</span> |</span><br><span class="line">|  <span class="number">2</span> | <span class="number">2</span>            | &#123;<span class="string">&quot;sqlResult&quot;</span>:<span class="string">&quot;[]&quot;</span>,<span class="string">&quot;execTime&quot;</span>:<span class="number">131</span>,<span class="string">&quot;resultNum&quot;</span>:<span class="number">0</span>,<span class="string">&quot;speNum&quot;</span>:<span class="number">0</span>&#125;                                                                                                              |      <span class="number">2</span> |</span><br><span class="line">|  <span class="number">3</span> | <span class="number">6</span>            | &#123;<span class="string">&quot;sqlResult&quot;</span>:<span class="string">&quot;[]&quot;</span>,<span class="string">&quot;execTime&quot;</span>:<span class="number">131</span>,<span class="string">&quot;resultNum&quot;</span>:<span class="number">0</span>,<span class="string">&quot;speNum&quot;</span>:<span class="number">0</span>&#125;                                                                                                              |      <span class="number">2</span> |</span><br><span class="line">|  <span class="number">4</span> | <span class="number">4</span>            | &#123;<span class="string">&quot;sqlResult&quot;</span>:<span class="string">&quot;[&#123;&quot;</span>mig_task_status<span class="string">&quot;:&quot;</span>HEMA_ERR_CATEGORY_NAME_IS_BLANK<span class="string">&quot;,&quot;</span>COUNT(*)<span class="string">&quot;:44&#125;]&quot;</span>,<span class="string">&quot;execTime&quot;</span>:<span class="number">1374</span>,<span class="string">&quot;resultNum&quot;</span>:<span class="number">1</span>,<span class="string">&quot;speNum&quot;</span>:<span class="number">0</span>&#125;                                          |      <span class="number">2</span> |</span><br><span class="line">|  <span class="number">5</span> | <span class="number">3</span>            | &#123;<span class="string">&quot;sqlResult&quot;</span>:<span class="string">&quot;[&#123;&quot;</span>mig_task_status<span class="string">&quot;:&quot;</span>HEMA_ERRO<span class="string">R&quot;,&quot;</span>COUNT(*)<span class="string">&quot;:4&#125;]&quot;</span>,<span class="string">&quot;execTime&quot;</span>:<span class="number">1523</span>,<span class="string">&quot;resultNum&quot;</span>:<span class="number">1</span>,<span class="string">&quot;speNum&quot;</span>:<span class="number">0</span>&#125;                                                                |      <span class="number">2</span> |</span><br><span class="line">|  <span class="number">6</span> | <span class="number">3</span>            | &#123;<span class="string">&quot;sqlResult&quot;</span>:<span class="string">&quot;[]&quot;</span>,<span class="string">&quot;execTime&quot;</span>:<span class="number">1656</span>,<span class="string">&quot;resultNum&quot;</span>:<span class="number">0</span>,<span class="string">&quot;speNum&quot;</span>:<span class="number">0</span>&#125;                                                                                                             |      <span class="number">2</span> |</span><br><span class="line">|  <span class="number">7</span> | <span class="number">7</span>            | 这是会员规则的任务                                                                                                                                             |      <span class="number">2</span> |</span><br><span class="line">|  <span class="number">8</span> | <span class="number">7</span>            | 这是会员规则的任务<span class="number">2222</span>                                                                                                                                         |      <span class="number">2</span> |</span><br><span class="line">+----+--------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------+</span><br></pre></td></tr></table></figure></p>
<p>这种类型在工作中很常见，那么需要查询所有父部门是39的rule，sql很简单：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">select * <span class="keyword">from</span>  rule_case WHERE deleted = <span class="number">0</span> <span class="keyword">and</span> product_line_id IN (</span><br><span class="line">     select <span class="built_in">id</span> </span><br><span class="line">     <span class="keyword">from</span> product_line </span><br><span class="line">     where parent_product_line_id = <span class="number">39</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>效果如图：<br><img data-src="/images/join%E6%90%AD%E9%85%8Dwhere.png" title="链接两个表就用这种办法"></p>
<p>但是如果要链接三个表，比如要查询所有父部门是39的规则对应的任务结果？怎么写？</p>
<p>一般来说，链接多个表都是用join，左join右join看以哪个表为准。但是如果你先写where在where的基础上再去join那就回报错，比如这个语句：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">select rule_name <span class="keyword">from</span> rule_case where product_line_id <span class="keyword">in</span> (select <span class="built_in">id</span> <span class="keyword">from</span> product_line where parent_product_line_id = <span class="number">39</span>) inner join rule_task on rule_case.<span class="built_in">id</span> = rule_task.rule_case_id;</span><br></pre></td></tr></table></figure></p>
<p>错误如下：<br><img data-src="/images/join%E6%90%AD%E9%85%8Dwhere2.png" title="mysql爆格式有误"></p>
<p>格式有误，应该格式这么写：<code>select * from 表A a left join 表B b on (a.XX=b.XX) left join 表C c on (a.YY=C.YY) where a.GG=MM and b.ui=NN</code></p>
<p>所以语句就是：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">select rule_name,rule_task.result <span class="keyword">from</span> rule_case inner join rule_task on rule_case.<span class="built_in">id</span> = rule_task.rule_case_id where rule_case.product_line_id <span class="keyword">in</span> (select <span class="built_in">id</span> <span class="keyword">from</span> product_line where parent_product_line_id = <span class="number">39</span>);</span><br></pre></td></tr></table></figure><br>结果如图：<br><img data-src="/images/join%E6%90%AD%E9%85%8Dwhere3.png" title="先join再where也不迟"></p>
<h2 id="Django2里怎么用？"><a href="#Django2里怎么用？" class="headerlink" title="Django2里怎么用？##"></a>Django2里怎么用？##</h2><p>如果是在<code>django2.1</code>里也要做这种多表操作，上面的语句就是这样的：</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/haibo0668/article/details/52453232">https://blog.csdn.net/haibo0668/article/details/52453232</a><br><a href="https://database.51cto.com/art/201908/602009.htm">https://database.51cto.com/art/201908/602009.htm</a><br><a href="https://zhuanlan.zhihu.com/p/59656673">https://zhuanlan.zhihu.com/p/59656673</a><br><a href="https://www.cnblogs.com/neozheng/p/9160526.html">https://www.cnblogs.com/neozheng/p/9160526.html</a></p>
<p><img data-src="/images/%E5%8F%B6%E5%85%A8%E7%9C%9F.gif" title="叶全真真是漂亮啊！"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Mysql5.7</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins搭配ansible部署</title>
    <url>/2018/06/12/Jenkins%E6%90%AD%E9%85%8Dansible%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="架构流程"><a href="#架构流程" class="headerlink" title="架构流程"></a>架构流程</h2><p>现在运维组工具里加入了gitlab这个版本控制工具，再加上原有的jenkins和ansible，整个代码模块部署流程如下：<br>1.在代码服务器上push更改的代码到gitlab；<br>2.gitlab通过webhook推送事件到jenkins,触发构建任务；<br>3.jenkins从gitlab将最新代码拉取下来；<br>4.jenkins通过ansible将最新的代码部署到应用服务器；<br>5.推送构建状态到gitlab；</p>
<h2 id="安装ansible"><a href="#安装ansible" class="headerlink" title="安装ansible"></a>安装ansible</h2><p>jenkins虽然支持ansible，但是前提是jenkins所在的主机上要有ansible程序，安装ansible的方法如下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install --upgrade pip</span><br><span class="line">pip install paramiko PyYAML Jinja2 httplib2 six</span><br><span class="line">pip install ansible		#安装的是2.5.4版本</span><br></pre></td></tr></table></figure></p>
<p>然后需要jenkins服务器与代码服务器之间建立ssh免密码登陆的关系，这里就不说细节了，可以去看一下<a href="http://blog.51cto.com/chenx1242/1763978">http://blog.51cto.com/chenx1242/1763978</a> 这个文章。</p>
<p>再去<code>/etc/ansible/hosts</code>手动输入一下授信服务器的IP地址，启动一下ansible看效果：<br><img data-src="/images/jenkinsansible2.png" alt="akb48"></p>
<p>如果在启动ansible的时候出现了如下的错误：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/lib/python2.7/site-packages/requests/__init__.py:80: RequestsDependencyWarning: urllib3 (1.21.1) or chardet (2.2.1) doesn&#x27;t match a supported version!</span><br><span class="line">  RequestsDependencyWarning)</span><br></pre></td></tr></table></figure></p>
<p>那就是python库中<code>urllib3 (1.21.1)</code> or <code>chardet (2.2.1)</code>的版本不兼容，解决办法如下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip uninstall urllib3</span><br><span class="line">pip uninstall chardet</span><br><span class="line">pip install requests</span><br></pre></td></tr></table></figure></p>
<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>登陆jenkins的web页面，选择<code>系统管理</code>—&gt;<code>管理插件</code>，安装如下三个插件：<code>Ansible plugin</code>、<code>Ansible Tower Plugin</code>、<code>AnsiColor</code>。如图：<br><img data-src="/images/jenkinsansible1.png" alt="akb48"></p>
<p>安装插件并且重启了ansible之后，还是<code>系统管理-</code>–&gt;<code>全局工具配置</code>，找到<code>ansible安装</code>，分别把ansible的路径根据实际情况填写进去，如图：<br><img data-src="/images/jenkinsansible3.png" alt="akb48"></p>
<p>填写完毕之后保存即可。</p>
<h2 id="配置工程"><a href="#配置工程" class="headerlink" title="配置工程"></a>配置工程</h2><p>打开某一个project，就用之前在<a href="https://rorschachchan.github.io/2018/05/25/Gitlab-Jenkins%E6%90%AD%E5%BB%BA%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E7%B3%BB%E7%BB%9F/">https://rorschachchan.github.io/2018/05/25/Gitlab-Jenkins搭建持续集成系统/</a> 这个文章里用到的jicheng-test，因为它已经跟gitlab集成了，所以只要gitlab有commit变化，就会webhook到jenkins进行操作。</p>
<p>配置jicheng-test，选择<code>构建</code>这个标签页。在<code>增加构建步骤</code>选择<code>Invoke Ansible Ad-Hoc Command</code>，这里我为了做实验随便写了一点命令，如图：<br><img data-src="/images/jenkinsansible4.png" alt="akb48"></p>
<p>上面的配置就是先让jenkins输出<code>这个是来自jenkins机器的信息！！</code>，然后启动ansible，对<code>/etc/ansible/hosts</code>里的所有ip机器执行<code>hostname</code>和<code>cd /mnt ; echo &quot;我是你大爷！&quot; &gt;&gt; 321.txt</code>这两个命令。</p>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>前文说了，这个jicheng-test已经做了<code>gitlab+jenkins</code>的配置，所以只要在代码服务器的git文件夹里，执行commit，代码被push到gitlab服务器上的同时也会触发jenkins打包。</p>
<p>于是操作如图：<br><img data-src="/images/jenkinsansible5.png" alt="akb48"></p>
<p>在gitlab的网页端查看代码已经上传：<br><img data-src="/images/jenkinsansible6.png" alt="akb48"></p>
<p>再去jenkins里确认是否被成功触发了：<br><img data-src="/images/jenkinsansible7.png" alt="akb48"></p>
<p>这次操作显示蓝灯，就是OK，点击选择控制台输出，查看一下执行细节：<br><img data-src="/images/jenkinsansible8.png" alt="akb48"></p>
<p>效果达到！试验成功！</p>
<p>如果需要回滚，就在jenkins新建一个与gitlab相连的project，切换gitlab的分支，然后重新commit，触发jenkins打包并且ansible部署即可。</p>
<h2 id="故障排错"><a href="#故障排错" class="headerlink" title="故障排错"></a>故障排错</h2><p>可能在jenkins集成的时候出现如下错误:<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	代码服务器ip	| UNREACHABLE! =&gt; &#123;</span><br><span class="line">   	&quot;changed&quot;: false, </span><br><span class="line">   	&quot;msg&quot;: &quot;Failed to connect to the host via ssh: Host key verification failed.\r\n&quot;, </span><br><span class="line">   	&quot;unreachable&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是因为jenkins在执行ansible是通过jenkins用户去操作的，虽然我们在安装ansible那一步的时候已经构建了服务器之间的ssh关系，但是那只是root用户的，所以如果没配置jenkins用户的ssh免密码登录，那么<code>sudo su -s /bin/bash jenkins</code>切换到jenkins用户在<code>ssh jenkins@目标IP</code>这一步的时候，会出现如下的提示：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The authenticity of host &#x27;目标IP(目标IP)&#x27; can&#x27;t be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:Nerx/EZH+ul0/qeb21+ii5EctQ0mO8hijIDlAWEGje8.</span><br><span class="line">ECDSA key fingerprint is MD5:6e:d8:6d:17:ca:79:9c:5e:bc:7e:9e:e6:33:41:08:25.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? </span><br></pre></td></tr></table></figure></p>
<p>因为ansible不会主动帮你输入yes，所以还需要在jenkins用户下把<code>id_dsa.pub</code>文件添加到代码服务器的<code>authorized_keys</code>里，制作一个ssh免密码登录。如果这时候你手动执行一下<code>ssh jenkins@目标IP</code>并且输入yes之后，再重新构建这个project就会发现错误变样了：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	代码服务器ip | UNREACHABLE! =&gt; &#123;</span><br><span class="line">   	&quot;changed&quot;: false, </span><br><span class="line">   	&quot;msg&quot;: &quot;Failed to connect to the host via ssh: Permission denied (publickey,gssapi-keyex,gssapi-with-mic,password).\r\n&quot;, </span><br><span class="line">   	&quot;unreachable&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>原因还是上面的话，由于目标机器上是没有jenkins这个用户的，所以自然也不会存在登录密码，即使用了jenkins用户制作了<code>authorized_keys</code>也是没用，所以需要指定ssh到目标IP的用户，如果是ansible的命令就是<code>ansible all -i /etc/ansible/hosts -u root -m shell -a &quot;具体的shell命令&quot;</code>，但是jenkins里配置root的地方很难找，所以就可以在<code>/etc/ansible/hosts</code>里更改一下，改成如下的样子：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">目标ip地址 ansible_ssh_user=root			#指定用root用户登录到目标IP，</span><br></pre></td></tr></table></figure></p>
<p>这样执行命令就没有障碍了，不过root用户权限过大，实际生产环境还是建立一个更加保险的账号最佳。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>ansible</tag>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux运维工程师笔试题第二十三套</title>
    <url>/2024/05/27/Linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E9%A2%98%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E5%A5%97/</url>
    <content><![CDATA[<ol>
<li>请简单说一下python的垃圾回收机制</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">核心机制：Python 的垃圾回收机制主要由 引用计数、标记-清除 和 分代回收 三部分组成，共同管理内存中无用对象的回收。</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>) 引用计数（Reference Counting）</span><br><span class="line">原理：每个对象维护一个引用计数器，记录有多少变量引用该对象。当计数器为 <span class="number">0</span> 时，对象立即被回收。</span><br><span class="line">优点：实时性：对象一旦无引用，立即释放内存。</span><br><span class="line">缺点：<span class="number">1.</span>无法处理循环引用（如 a = []; a.append(a)，导致引用计数始终为 <span class="number">1</span>，但实际已无用）。</span><br><span class="line">	 <span class="number">2.</span>性能开销：每次赋值/释放都需要修改计数器，可能影响性能。</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>) 标记-清除（Mark <span class="keyword">and</span> Sweep）</span><br><span class="line">目的：解决引用计数无法处理循环引用的问题。</span><br><span class="line">流程：</span><br><span class="line">	<span class="number">1.</span>标记阶段：从根对象（如全局变量、线程栈）出发，遍历所有可达对象并标记为“存活”。</span><br><span class="line">	<span class="number">2.</span>清除阶段：回收未被标记的对象（不可达对象）。</span><br><span class="line">触发时机：定期自动触发（默认每分配 <span class="number">700</span> 个对象或 <span class="number">10</span> 次小对象分配后触发）。</span><br><span class="line">配置：可通过 <span class="built_in">print</span>(gc.get_threshold()) 调整回收频率。默认是 (<span class="number">700</span>, <span class="number">10</span>, <span class="number">10</span>) 。</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>) 分代回收（Generational Collection）</span><br><span class="line">原理：将对象按存活时间分为 <span class="number">3</span> 代（Generation <span class="number">0</span>~<span class="number">2</span>），存活时间越长，回收频率越低。</span><br><span class="line">优势：大多数对象生命周期短，分代回收可减少不必要的检查。</span><br><span class="line">触发规则：当某一代的对象数量超过阈值时，触发该代的垃圾回收。</span><br><span class="line">强制执行全量 GC：gc.collect()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>列表和元祖和字典和集合的区别<br><img data-src="/images/python%E9%9D%A2%E8%AF%95.png" alt="paradin" title="集合适合去重、快速成员检测（如唯一用户ID集合）。列表存储有序且可能变化的数据（如任务队列）。"><br><img data-src="/images/python%E9%9D%A2%E8%AF%952.png" alt="paradin" title="元祖适合存储不可变数据（如配置参数、固定数据）。字典适合快速查找和存储键值对（如用户信息、缓存）"></p>
</li>
<li><p>pod起不来的原因一般都有啥？<br>首先<code>kubectl get pods -n &lt;namespace&gt;</code>，查看错误提示是啥：<br> Pending：未调度或资源不足。<br> CrashLoopBackOff：容器启动后立即崩溃。<br> Error：容器启动失败。<br> ImagePullBackOff：镜像拉取失败。</p>
</li>
</ol>
<p>然后 <code>kubectl describe pod &lt;pod-name&gt; -n &lt;namespace&gt; </code>查看pod详情。</p>
<p>然后 <code>kubectl logs &lt;pod-name&gt; -n &lt;namespace&gt;</code>查看容器日志，如果容器已崩溃，再加上<code>--previous </code>。</p>
<ol start="4">
<li><p>如何快速定位Pod处于Pending状态的原因？<br>当Pod处于 Pending 状态时，通常表示Kubernetes调度器（Scheduler）无法为Pod分配节点。kubectl describe pod <pod-name> -n <namespace> 看一下pod详细信息，重点关注 Events 部分，通常会直接提示错误原因，例如：<br> a.资源不足（Insufficient CPU&#x2F;Memory）<br> b.节点选择器（NodeSelector）不匹配，此时需要查看标签kubectl get nodes –show-labels<br> c.污点（Taint）与容忍度（Toleration）冲突，此时需要kubectl describe node <node-name> | grep Taints 查看污点<br> d.持久卷（PersistentVolume）无法绑定</p>
</li>
<li><p>gitlab冲突处理?<br>首先<code>git checkout dev</code>你从当前分支切换到指定的分支dev。</p>
</li>
</ol>
<p><code>git pull origin dev</code> 拉取最新代码（Pull），确保你本地的代码是最新的。<br><code>git status</code> 查看哪些文件发生了冲突,比如出现了<code>both modified:   app.py</code>，这说明<code>app.py</code>文件存在冲突，然后处理具体的冲突。</p>
<p>然后<code>git add app.py</code> 将修改后的文件标记为冲突已解决。</p>
<p>下一步是<code>git commit -m &quot;Resolved merge conflict&quot;</code>提交合并（Commit）。</p>
<p>最后<code>git push origin dev</code>将代码推送到远程仓库。	</p>
<ol start="6">
<li>python如何在一个函数内部修改全局变量?<br>函数内部global声明 修改全局变量, 比如：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    a = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">func()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>python里，map()函数有用过么？<br>map()函数可以将一个函数应用到一个序列上的每一个元素，并返回一个新的迭代器。举个例子：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个函数，计算一个数的平方</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始列表</span></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 map() 函数将 square 函数应用到 numbers 列表的每个元素上</span></span><br><span class="line">squared_numbers = <span class="built_in">list</span>(<span class="built_in">map</span>(square, numbers))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line"><span class="built_in">print</span>(squared_numbers)  <span class="comment"># 输出: [1, 4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure>

<ol start="8">
<li>统计字符串每个单词出现的次数”kjalfj;ldsjafl;hdsllfdhg;lahfbl;hl;ahlf;h”</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">a = <span class="string">&quot;kjalfj;ldsjafl;hdsllfdhg;lahfbl;hl;ahlf;h&quot;</span></span><br><span class="line">res = Counter(a)</span><br><span class="line"><span class="built_in">print</span> (res)</span><br></pre></td></tr></table></figure>

<ol start="9">
<li><p>list里的append和extend的区别是啥？<br>list里的+方法等价于extend</p>
</li>
<li><p>CPU 使用率里的%usr %system %iowait 这些都是啥？</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">用户 CPU 使用率（%usr）：包括用户态 CPU 使用率（user）和低优先级用户态 CPU 使用率（nice），表示 CPU 在用户态运行的时间百分比。用户 CPU 使用率高，说明用户态进程占用了较多的 CPU，应该着重排查进程的性能问题。</span><br><span class="line">系统 CPU 使用率（%system）：表示 CPU 在内核态运行的时间百分比（不包括中断）。系统 CPU 使用率高，说明内核比较繁忙，应该着重排查内核线程或者系统调用的性能问题。往往它高了会带动%usr也变高。查看指标：mpstat -P ALL <span class="number">1</span></span><br><span class="line">等待 I/O 的 CPU 使用率（%iowait）：通常也称为 iowait，表示等待 I/O 的时间百分比。iowait 高，通常说明系统与硬件设备的 I/O 交互时间比较长，应该着重排查系统存储是不是出现了 I/O 问题。</span><br><span class="line">软中断和硬中断的 CPU 使用率（%softirq %irq ）：分别表示内核调用软中断处理程序、硬中断处理程序的时间百分比。它们的使用率高，通常说明系统发生了大量的中断，应该着重排查内核中的中断服务程序。</span><br></pre></td></tr></table></figure>

<ol start="11">
<li><p>系统的 CPU 使用率很高，却找不到高 CPU 的应用？<br>有可能是短时应用导致的问题：<br>a.应用里直接调用了其他二进制程序，这些程序通常运行时间比较短，通过 top 等工具也不容易发现。<br>b.应用本身在不停地崩溃重启，而启动过程的资源初始化，很可能会占用相当多的 CPU。</p>
</li>
<li><p>应用的Metaspace 使用率高，都有什么样的原因？<br>a. 加载的类数量多，类加载也会导致 CPU升高（少数静态类加载除外）<br>b. 新类与老类共存（未卸载旧类）<br>c. Metaspace 泄漏（Memory Leak）<br>d. JVM 参数配置不当</p>
</li>
<li><p>场景题，现在发现由于索引缺失且数据库许久没有清除数据，导致了慢sql问题，你应该如何止血？<br>这里建议先联系DBA启动“CPU放开”预案，暂时获取到额外的cpu能力，此时索引构建可能会影响线上业务的情况，那么剩下的步骤就是：停止主备同步、备库构建索引、开启数据同步、数据追平后做主备切换。</p>
</li>
<li><p>接上面，为什么要在备库创建索引，主库不可以么？<br>InnoDB 存储引擎下执行CREATE INDEX会 锁表（表级锁），禁止读写操作。可通过 SHOW PROCESSLIST 查看是否出现 Waiting for table metadata lock。即使不锁表，索引构建仍会占用大量内存和 I&#x2F;O，可能影响性能。</p>
</li>
<li><p>如果流量下跌，排查的步骤是什么？<br>a. 首先先看成功率是否符合预期，以及对应的上游的流量是否也下跌，如果成功率不符合预期，或者上游的流量没有下跌，那么可能是我们自身应用出了问题，需要第一时间判断问题并止血。<br>b. 如果上游链路也流量下跌，无论是直接依赖还是场景依赖（比如carts2 查看购物车是 buy2 渲染订单的前置步骤）请立即联系上游应用对应的负责人，跟进上游的进展。<br>c. 如果是单独一个机房或者某个地域出现流量下跌，马上看其他同机房或者同地域的应用是否也同时出现下跌，如果也在下跌立即联系集团侧容灾负责人。这种情况大概率是机房网络或入口网关出现故障。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>大牛之路</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>面试</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux运维工程师笔试题第二十二套</title>
    <url>/2024/05/12/Linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E9%A2%98%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E5%A5%97/</url>
    <content><![CDATA[<ol>
<li>篮子里有100个苹果，将这些苹果进行编号，从0开始到99。现在将这些苹果分成4份，第一份20个，第二份30个，第三份38个，最后一份12个，要求是苹果的编号不能连续。</li>
</ol>
<p>【思路】通过构造性方法分配苹果，确保每份内部无连续编号：<br>第一份（20 个苹果）：选取前 20 个奇数（1, 3, 5, …, 39）。奇数之间相差 2，无连续编号。<br>第二份（30 个苹果）：选取剩余的奇数（41, 43, …, 99）。	同样无连续编号。<br>第三份（38 个苹果）：选取前 38 个偶数（0, 2, 4, …, 74）。这些苹果之间相差 2，无连续编号。<br>第四份（12 个苹果）：选取后 12 个偶数（76, 78, …, 98）。同样无连续编号。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成各分组的苹果编号</span></span><br><span class="line">group1 = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">40</span>, <span class="number">2</span>))       <span class="comment"># 第一份：20 个奇数（1, 3, ..., 39）</span></span><br><span class="line">group2 = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">41</span>, <span class="number">100</span>, <span class="number">2</span>))      <span class="comment"># 第二份：30 个奇数（41, 43, ..., 99）</span></span><br><span class="line">group3 = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">75</span>, <span class="number">2</span>))        <span class="comment"># 第三份：38 个偶数（0, 2, ..., 74）</span></span><br><span class="line">group4 = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">76</span>, <span class="number">99</span>, <span class="number">2</span>))       <span class="comment"># 第四份：12 个偶数（76, 78, ..., 98）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证各分组数量是否正确</span></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(group1) == <span class="number">20</span>, <span class="string">&quot;第一份数量错误&quot;</span></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(group2) == <span class="number">30</span>, <span class="string">&quot;第二份数量错误&quot;</span></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(group3) == <span class="number">38</span>, <span class="string">&quot;第三份数量错误&quot;</span></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(group4) == <span class="number">12</span>, <span class="string">&quot;第四份数量错误&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证各分组内部无连续编号</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">has_consecutive</span>(<span class="params">numbers</span>):</span><br><span class="line">    sorted_numbers = <span class="built_in">sorted</span>(numbers)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(sorted_numbers)):</span><br><span class="line">        <span class="keyword">if</span> sorted_numbers[i] - sorted_numbers[i-<span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> group <span class="keyword">in</span> [group1, group2, group3, group4]:</span><br><span class="line">    <span class="keyword">assert</span> <span class="keyword">not</span> has_consecutive(group), <span class="string">&quot;存在连续编号&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证所有苹果编号被唯一分配</span></span><br><span class="line">all_apples = <span class="built_in">set</span>(<span class="built_in">range</span>(<span class="number">100</span>))</span><br><span class="line">assigned = <span class="built_in">set</span>(group1 + group2 + group3 + group4)</span><br><span class="line"><span class="keyword">assert</span> all_apples == assigned, <span class="string">&quot;苹果编号未全部分配或重复&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;分组结果：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;第一份: <span class="subst">&#123;group1&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;第二份: <span class="subst">&#123;group2&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;第三份: <span class="subst">&#123;group3&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;第四份: <span class="subst">&#123;group4&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>


<ol start="2">
<li>编写一个函数，在字符串数组中查找最长的公共前缀字符串。 如果没有公共前缀，则返回空字符串” “。<br>输入：strs &#x3D; [“present”,”promotion”,”protect”]<br>输出：”pr”<br>输入：strs &#x3D; [“al”,”trace”,”mtr”]<br>输出：” “</li>
</ol>
<p>【思路】<br>先确定拿到的strs里最少的单词的长度，然后就拿第一个单词的第一个字母开始对比，如果跟第二个单词的第一个字母相同，再比较第三个单词的第一个字母，如果三个都相同，则比较第二个字母。一直到不相同结束。</p>
<p>【代码】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">longest_common_prefix</span>(<span class="params">strs</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 找到最短的字符串长度</span></span><br><span class="line">    min_length = <span class="built_in">min</span>(<span class="built_in">len</span>(s) <span class="keyword">for</span> s <span class="keyword">in</span> strs)</span><br><span class="line">    </span><br><span class="line">    prefix = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(min_length):</span><br><span class="line">        char = strs[<span class="number">0</span>][i]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">all</span>(s[i] == char <span class="keyword">for</span> s <span class="keyword">in</span> strs):  <span class="comment"># 判断是否所有字符串的当前位置字符相同，这里如果都相同，就是返回都是Ture,外面再套了一层all</span></span><br><span class="line">            prefix += char</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> prefix</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试示例</span></span><br><span class="line">strs1 = [<span class="string">&quot;present&quot;</span>, <span class="string">&quot;promotion&quot;</span>, <span class="string">&quot;protect&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(longest_common_prefix(strs1))  <span class="comment"># 输出: &quot;pr&quot;</span></span><br><span class="line"></span><br><span class="line">strs2 = [<span class="string">&quot;al&quot;</span>, <span class="string">&quot;trace&quot;</span>, <span class="string">&quot;mtr&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(longest_common_prefix(strs2))  <span class="comment"># 输出: &quot;&quot;</span></span><br><span class="line"></span><br><span class="line">strs3 = []</span><br><span class="line"><span class="built_in">print</span>(longest_common_prefix(strs3))  <span class="comment"># 输出: &quot;&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>给定一个整数x，如果x是回文整数，则返回true。 当一个整数向后读取与向前读取相同时，它就是一个回文。例如，121是回文，而123不是。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_palindrome</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="comment"># 将整数转换为字符串</span></span><br><span class="line">    str_x = <span class="built_in">str</span>(x)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 比较原字符串和反转后的字符串是否相同</span></span><br><span class="line">    <span class="keyword">return</span> str_x == str_x[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试示例</span></span><br><span class="line"><span class="built_in">print</span>(is_palindrome(<span class="number">121</span>))  <span class="comment"># 输出: True</span></span><br><span class="line"><span class="built_in">print</span>(is_palindrome(-<span class="number">121</span>))  <span class="comment"># 输出: False</span></span><br><span class="line"><span class="built_in">print</span>(is_palindrome(<span class="number">123</span>))  <span class="comment"># 输出: False</span></span><br><span class="line"><span class="built_in">print</span>(is_palindrome(<span class="number">1221</span>))  <span class="comment"># 输出: True</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在一个整型数组中, 找到两个index，其对应的两个数相加为给出的目标数字。 你可以假设每个输入都有且仅有一个解。给定一个整数数组nums和一个整数目标值target，返回两个数字的索引，使它们相加到目标值。<br>您可以假设每个输入都只有一个答案，但是不能两次使用同一元素。可以按任何顺序返回答案。<br>示范<br>输入：nums &#x3D; [3,2,4], target &#x3D; 6<br>输出：[1,2]<br>输入：nums &#x3D; [1,2,9], target &#x3D; 10<br>输出：[0,2]</li>
</ol>
<p>【思路】先拿到nums里每一个元素的index和对应的值，然后用目标数target逐一减去每一个元素，看剩下的值是否在，因为是要求返回两个数字的索引，所以存在就拿到另一个值的index，如果不存在就返回空就得了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">two_sum</span>(<span class="params">nums, target</span>):</span><br><span class="line">    num_dict = &#123;&#125;  <span class="comment"># 创建一个字典</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> index, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):  <span class="comment"># 逐一获得目标数组的值num和索引i</span></span><br><span class="line">        complement = target - num    <span class="comment"># 然后就是目标值-目标数组的值num，看剩余的的值是否在</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> complement <span class="keyword">in</span> num_dict:</span><br><span class="line">            <span class="keyword">return</span> [num_dict[complement], index]</span><br><span class="line">        </span><br><span class="line">        num_dict[num] = index</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 题目假设一定有解，所以这里不会到达</span></span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>]</span><br><span class="line">target = <span class="number">26</span></span><br><span class="line"><span class="built_in">print</span>(two_sum(nums, target))  <span class="comment"># 输出: [2, 3]</span></span><br></pre></td></tr></table></figure>


<ol start="5">
<li><p><code>select * from A where exists (select * from B where A.id=B.id); </code>和 <code>select * from A where A.id in (select id from B);</code>如果A表有100条数据，B表有10000条，请问哪个sql语句执行效率高？<br>【答案】EXISTS 可以利用索引快速查找并提前终止，减少不必要的扫描。IN 需要生成并存储较大的结果集，可能导致内存开销和性能下降。所以，EXISTS 语句的执行效率更高。</p>
</li>
<li><p>简述CGROUP如何限制进程cpu使用<br>【答案】首先需要在系统中创建一个CGroup，并为其配置相应的资源限制。这通常涉及到创建目录结构和设置文件。例如，在 <code>/sys/fs/cgroup/cpu/</code> 下创建一个名为 <code>my_cgroup</code> 的CGroup：<code>mkdir /sys/fs/cgroup/cpu/my_cgroup</code></p>
</li>
</ol>
<p>然后，设置CPU份额。CGroup提供了两种方式来限制CPU使用：CPU份额（CPU shares）和CPU配额（CPU quotas）。CPU份额决定了各个任务之间的相对优先级。例如，如果两个任务A和B的CPU份额分别是1024和512，那么任务A将获得大约两倍于任务B的CPU时间。</p>
<p>设置CPU份额：<code>echo 1024 &gt; /sys/fs/cgroup/cpu/my_cgroup/cpu.shares</code></p>
<p>CPU配额允许你精确地限制任务在一定时间内能够使用的CPU时间。例如，你可以设置一个任务在一个周期内最多只能使用50%的CPU时间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">echo <span class="number">50000</span> &gt; /sys/fs/cgroup/cpu/my_cgroup/cpu.cfs_quota_us</span><br><span class="line">echo <span class="number">100000</span> &gt; /sys/fs/cgroup/cpu/my_cgroup/cpu.cfs_period_us</span><br></pre></td></tr></table></figure>

<p>这里，<code>cpu.cfs_quota_us</code> 表示在一个周期内允许的最大CPU时间（单位是微秒），而 <code>cpu.cfs_period_us</code> 表示周期的长度（单位也是微秒）。上面的例子表示在一个周期（100000微秒，即0.1秒）内，最多使用50000微秒（即0.05秒）的CPU时间。</p>
<p>最后，将特定的进程添加到CGroup中，以便它们受到资源限制的影响。例如，将PID为1234的进程添加到 <code>my_cgroup</code> 中：<code>echo 1234 &gt; /sys/fs/cgroup/cpu/my_cgroup/tasks</code></p>
<p>现在可以通过读取相关文件来监控CGroup的状态和统计信息。<code>cat /sys/fs/cgroup/cpu/my_cgroup/cpuacct.usage</code></p>
<ol start="7">
<li>http 301 500和502 含义<br>【答案】</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">301</span> Moved Permanently（永久重定向），此时客户端会缓存新 URL。而<span class="number">302</span>（临时重定向），客户端不会缓存新 URL。</span><br><span class="line"><span class="number">500</span> Internal Server Error（服务器内部错误），直接去后端服务器上看问题吧，通常由代码缺陷、配置错误或依赖服务故障引起。</span><br><span class="line"><span class="number">502</span> Bad Gateway（错误网关）,即作为网关或代理的服务器（如 Nginx、反向代理）从上游服务器（后端服务）收到无效响应。有可能是反向代理的nginx挂了，或者是后端服务超时了。</span><br><span class="line"><span class="number">503</span> service unavialable:服务器尚未处于可以接受请求的状态。通常造成这种情况的原因是由于服务器停机维护或者已超载。</span><br><span class="line"><span class="number">504</span> Gateway timeout：正常情况下，是由于被请求服务器发送超时引起。</span><br><span class="line"><span class="number">505</span> http协议不支持。</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>如何限制单个容器的最大磁盘占用？<br>【答案】</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">docker create \</span><br><span class="line">  --name my_container \</span><br><span class="line">  --storage-opt size=10G \</span><br><span class="line">  your_image</span><br></pre></td></tr></table></figure>

<ol start="9">
<li><p>A和B两台服务器，如何让A可以访问B的ssh，B不能访问A的ssh服务<br>【答案】这里主要是“B不能访问A的ssh服务”，iptables配置如下：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设 A 的 IP 是 192.168.1.100，</span></span><br><span class="line"><span class="comment"># 需要在B侧配置</span></span><br><span class="line">sudo iptables -A INPUT -p tcp --dport <span class="number">22</span> -s <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span> -j DROP</span><br><span class="line">解释：</span><br><span class="line">	-A INPUT：添加到输入链。</span><br><span class="line">	-p tcp --dport <span class="number">22</span>：针对 SSH 的 TCP <span class="number">22</span> 端口。</span><br><span class="line">	-s <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span>：指定源 IP 为 A 的地址。</span><br><span class="line">	-j DROP：丢弃该流量（即拒绝连接）。</span><br><span class="line"></span><br><span class="line">sudo service iptables save <span class="comment">#保存</span></span><br></pre></td></tr></table></figure>
<p>如果需要 完全禁止 B 访问 A 的所有服务，而不仅仅是 SSH，则在A侧配置：<code>sudo iptables -A INPUT -s B的IP地址 -j DROP </code></p>
</li>
<li><p>谈谈DNS 两种方式<br>【答案】</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">递归 DNS（Recursive DNS）</span><br><span class="line">递归 DNS 服务器负责为客户端解析域名，递归查询整个 DNS 层级（根服务器 → 顶级域服务器 → 权威服务器），直到获取最终的 IP 地址。</span><br><span class="line">特点：客户端视角：客户端只需向递归 DNS 发起请求，无需关心 DNS 查询过程。缓存优化：递归 DNS 通常会缓存结果，减少重复查询。</span><br><span class="line">权威 DNS（Authoritative DNS）</span><br><span class="line">权威 DNS 服务器负责管理特定域名的解析数据（如 example.com 的 A 记录、CNAME 记录等），直接返回域名对应的 IP 地址。</span><br><span class="line">特点：层级关系：每个域名需配置一个或多个权威服务器（主服务器 + 从服务器）。数据源：解析数据存储在区域文件（Zone File）中。</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>谈谈bind高可用机制<br>【答案】</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">主从服务器（Primary/Secondary）：通过主服务器（Primary）和从服务器（Secondary）的协作，确保在主服务器故障时，从服务器仍能提供解析服务。</span><br><span class="line">负载均衡 + VIP（Virtual IP）：通过虚拟 IP（VIP）和负载均衡器（如 HAProxy）将流量分发到多个 BIND 实例，实现无缝故障转移。</span><br><span class="line">DNSSEC + 区域签名：通过 DNSSEC（DNS Security Extensions）对区域数据进行签名，确保数据完整性和防篡改。</span><br><span class="line">自动故障切换（Keepalived + VRRP）：使用 Keepalived 实现主备服务器的自动切换，当主服务器宕机时，VIP 自动转移到备用服务器。</span><br></pre></td></tr></table></figure>

<ol start="12">
<li>mysql主从同步的全同步复制和半同步复制是啥？<br>【答案】</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mysql默认的复制方式是异步的，主库把日志发送给从库后不关心从库是否已经处理，这样会产生一个问题就是假设主库挂了，从库处理失败了，这时候从库升为主库后，日志就丢失了。由此产生两个概念。</span><br><span class="line">全同步复制：主库写入binlog后强制同步日志到从库，所有的从库都执行完成后才返回给客户端，但是很显然这个方式的话性能会受到严重影响。</span><br><span class="line">半同步复制：和全同步不同的是，半同步复制的逻辑是这样，从库写入日志成功后返回ACK确认给主库，主库收到至少一个从库的确认就认为写操作完成。</span><br></pre></td></tr></table></figure>

<ol start="13">
<li>free -m 这个命令的输出是啥意思？<br>【答案】</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">total：总内存大小（单位：MB）。used + free + buff/cache ≈ total，这是正常现象。</span><br><span class="line">used：已使用的内存大小（包括缓存和缓冲区）。used 为 <span class="number">0</span> 时，表示物理内存足够，无需使用交换分区。used 明显大于 <span class="number">0</span>，说明物理内存不足，系统开始使用磁盘作为虚拟内存（性能可能下降）。</span><br><span class="line">free：完全空闲的内存大小（未被使用）。</span><br><span class="line">shared：共享内存大小（通常由多个进程共享的内存区域）。</span><br><span class="line">buff/cache：内核缓存和缓冲区占用的内存大小（这部分可以被快速释放以供应用程序使用）。</span><br><span class="line">available：可用内存大小（预估当前系统可分配的内存，比 free + buff/cache 更合理）。如果 available 接近 <span class="number">0</span>，可能需要优化内存使用或增加内存。</span><br><span class="line">Mem：物理内存（RAM）的统计信息。</span><br><span class="line">Swap：交换分区（Swap）的统计信息。</span><br><span class="line"></span><br><span class="line">结合 watch 命令实时监控内存：watch -n <span class="number">1</span> free -m </span><br></pre></td></tr></table></figure>

<ol start="14">
<li>tair的读写RT都有升高，跟有热点 key是什么关系？</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）单节点负载过载</span><br><span class="line">现象：热点 Key 通常集中在 单个缓存节点（Tair 的数据分片机制下，Key 分布不均可能导致热点集中）。</span><br><span class="line">结果：a.该节点的 CPU、内存、网络带宽被耗尽。  </span><br><span class="line">     b.请求排队等待，导致 RT 明显上升，甚至触发超时或熔断。</span><br><span class="line">（<span class="number">2</span>）线程阻塞与锁竞争</span><br><span class="line">现象：对热点 Key 的并发读写操作可能引发 锁竞争（如原子操作 INCR、分布式锁）。</span><br><span class="line">结果：</span><br><span class="line">    a.大量线程等待锁释放，导致 请求堆积。</span><br><span class="line">例如：秒杀场景中对库存的频繁减扣。</span><br><span class="line">（<span class="number">3</span>）网络拥塞</span><br><span class="line">现象：大量请求集中访问热点 Key，导致节点与客户端之间的网络链路饱和。</span><br><span class="line">结果：a.网络延迟增加，RT 上升。</span><br><span class="line">    b.可能波及同节点的其他非热点 Key 请求（“木桶效应”）。</span><br><span class="line">（<span class="number">4</span>）缓存穿透或击穿</span><br><span class="line">现象：</span><br><span class="line">    a.缓存穿透：非法 Key 的高频查询（如攻击性扫描）。</span><br><span class="line">    b.缓存击穿：热点 Key 过期后，大量请求直接穿透到后端数据库。</span><br><span class="line">结果：后端数据库压力激增，导致整体 RT 雪崩式升高。</span><br></pre></td></tr></table></figure>

<ol start="15">
<li>什么场景下的GC耗时很长可以通过增加容器数来有效解决？<br>GC（垃圾回收）耗时长通常由以下原因导致：<br>堆内存过大：Full GC 扫描的堆内存越大，耗时越长。<br>高并发负载：单容器处理大量请求，导致对象分配速度快，GC 频率升高。</li>
</ol>
<p>增加容器数 的本质是 水平扩展，通过分散负载和减少单容器内存压力，间接降低 GC 耗时。</p>
<ol start="16">
<li>无序正整数数字中找出所有元素拼接后的最小值，比如 [1,3,2],得到 123。<br>【思路】这个题不能简单的用sort从小到大排序然后组合起来就交卷，因为有一种情况，假设给的列表是[1,30,2,15]，直接sort后的得到的答案是121530,但是实际最小的值应该是115230，核心原因就是2虽然小于15，但是放在数字里作为百位数或者千位数这个逻辑就不对了。<br>但是sort还是要sort的，毕竟它是唯一一个python具备排序的功能。核心点是sort是可以带入key的，比如sort(key&#x3D;len)，这个的效果就是按照各个元素的字符串长度来排序了，不要简单的以为sort只能排数字大小。</li>
</ol>
<p>但是这个key怎么来？这里还有一个问题，就是如何判断我们上面说的“2和15谁前谁后”了，这里用字符串的比较功能，因为”2”+”15” &#x3D; “215”, 而 “15”+”2” &#x3D; “152”,通过字符串的比较，返回1 -1 和0这三种情况，然后用这三种情况作为key就行了。</p>
<p>这题比较难的地方就是用到了<code>cmp_to_key</code>这个东西，估计在笔试的时候用python的同学很难想到它。我当时面字节数据中台的时候就让写这道题，我就没写出来，很囧。这道题是明显的java更好写（Comparator是自带的模块），但是python反而不好写的典型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> cmp_to_key</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 将所有数字转换为字符串</span></span><br><span class="line">        nums_str = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>, nums))  <span class="comment"># 这里用到了map函数的一个特性，就是map的用法是（函数，目标），达到每个目标都这个函数的影响，而str本身也是一个函数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 自定义比较函数</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">compare</span>(<span class="params">a: <span class="built_in">str</span>, b: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> a + b &lt; b + a:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>  <span class="comment"># a 应排在 b 前面</span></span><br><span class="line">            <span class="keyword">elif</span> a + b &gt; b + a:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>   <span class="comment"># a 应排在 b 后面</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 按自定义规则排序</span></span><br><span class="line">        nums_str.sort(key=cmp_to_key(compare))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 处理全零的情况</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">all</span>(s == <span class="string">&#x27;0&#x27;</span> <span class="keyword">for</span> s <span class="keyword">in</span> nums_str):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(nums_str)</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 示例 1</span></span><br><span class="line"><span class="built_in">print</span>(Solution().minNumber([<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>]))  <span class="comment"># 输出: &quot;123&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2</span></span><br><span class="line"><span class="built_in">print</span>(Solution().minNumber([<span class="number">3</span>, <span class="number">30</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">9</span>]))  <span class="comment"># 输出: &quot;3033459&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 3</span></span><br><span class="line"><span class="built_in">print</span>(Solution().minNumber([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]))  <span class="comment"># 输出: &quot;0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 4</span></span><br><span class="line"><span class="built_in">print</span>(Solution().minNumber([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]))  <span class="comment"># 输出: &quot;012&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里估计有人会懵逼，明明compare里要求参数是a和b，但是实际只传入了一个list，没有a b，这个是怎么成功的？因为排序算法（如 list.sort() 或 sorted()）会自动调用比较函数，无需手动传递参数。也就是说compare(a, b) 并不是直接调用的，而是通过cmp_to_key和Python的排序算法隐式调用的:</span></span><br><span class="line"><span class="comment">#   a.排序算法会自动遍历所有元素对，并为每一对调用比较函数。</span></span><br><span class="line"><span class="comment">#   b.a 和 b 是排序算法动态传入的，你只需要定义比较逻辑即可。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我后来遛弯的时候想了一下另一个方法：可以先取到整个list的数字位数，比如[1,3,2,15],那么就是5位数，然后通过ljust(5,0)这个方法对每一个元素补0到5位数，那么1就是10000，2就是20000，15就是15000，3就是30000，然后对他们进行sort排序，得到了[10000，15000，20000，30000]，然后逐一用rstrip剔除掉多余的0，得到[1,15,2,3]，那么就是最小的拼接和：11523。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是后来问了ai，发现这个方法有一个漏洞，就是当出现[1,100]的时候，因为1000=1000，那么可能会得到1100是最小和，其实应该是1001才对，所以还是字符串比较法是完美的。</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>大牛之路</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>面试</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux运维工程师笔试题第二十五套</title>
    <url>/2025/06/12/Linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E9%A2%98%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%94%E5%A5%97/</url>
    <content><![CDATA[<ol>
<li><p>返回数组中第K个最大的元素。比如nums &#x3D; [3,2,1,6,5,4],k &#x3D; 2,就返回5<br>【思路】首先注意一个问题，比如nums有重复值，比如[1,4,4,4,4,4]，那么第二大的元素是4还是1？肯定是4，所以完全不需要对nums进行set去重，直接sort排序，对排序后且去重的nums取[-k]就是数组中第K个最大的元素。</p>
</li>
<li><p>以数据intervals表示若干个区间的集合，其中单个区间是intervals[i] &#x3D; [start,end],请用python合并所有重叠区间，返回一个不重叠的区间数组。该数组需恰好覆盖输入数组中的所有区间。比如intervals&#x3D;[[1,3],[2,6],[8,29],[30,99]],返回[[1,6],[8,29,][30,99]]。<br>【思路】这个我开始的想法是将intervals每个数组展开到一个新的list1里，然后for循环比较，如果相邻的左边比右边大，就删除两者。最后因为索引会溢出，强制加上最后一个，最后在恢复成两两一对的数组。但是这个做法是有问题的，首先不建议对list进行remove或者pop，因为会打乱索引，搞得局面很难收拾。其次如果因为索引超出，强制写死最后一个，如果最后一个又不是整个intervals最大值就很尴尬。所以这个最好的办法就是“排序 + 合并”。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">intervals</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> intervals:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 按 start 排序</span></span><br><span class="line">    intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">    merged = [intervals[<span class="number">0</span>]]  <span class="comment"># 初始化合并后的列表</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> current <span class="keyword">in</span> intervals[<span class="number">1</span>:]:</span><br><span class="line">        last = merged[-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 如果当前区间的 start &lt;= 上一个区间的 end → 重叠，合并</span></span><br><span class="line">        <span class="keyword">if</span> current[<span class="number">0</span>] &lt;= last[<span class="number">1</span>]:</span><br><span class="line">            merged[-<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(last[<span class="number">1</span>], current[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            merged.append(current)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> merged</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">intervals = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">29</span>],[<span class="number">30</span>,<span class="number">99</span>]]</span><br><span class="line"><span class="built_in">print</span>(merge(intervals))  <span class="comment"># 输出 [[1, 6], [8, 29], [30, 99]]</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>mysql用唯一索引来去重，这个是什么原因？<br>唯一索引具备唯一性约束，即当在某个字段（或字段组合）上创建唯一索引后，MySQL 会自动检查插入或更新的数据是否违反唯一性约束。<br> a. 如果插入的数据与现有数据重复，MySQL 会抛出 Duplicate entry 错误（错误码 1062）。<br> b. 如果更新的数据导致唯一性冲突，也会报错。<br> c. 比较常见的场景就是“防止用户重复提交表单（如投票、优惠券领取）”，由数据库层强制保证数据唯一性，无需应用层校验，但是可能增加写操作的延迟。这也是一种“防呆机制”的体现。</p>
</li>
<li><p>有一个字符串它的构成是词+空格的组合，如“北京 杭州 杭州 北京”， 要求输入一个匹配模式（简单的以字符来写）， 比如 aabb, 来判断该字符串是否符合该模式， 举个例子：1. pattern &#x3D; “abba”, str&#x3D;”北京 杭州 杭州 北京” 返回 ture  2. pattern &#x3D; “aabb”, str&#x3D;”北京 杭州 杭州 北京” 返回 false  3. pattern &#x3D; “baab”, str&#x3D;”北京 杭州 杭州 北京” 返回 ture<br>【思路】因为是匹配模式，就让人联想到k-v这样的模式，那么对于python来说dict（字典）是最好不过的选择。所以可以以pattern里的每一个元素作为k，然后str对应索引的那个所谓v。如果不在dict里，就先写进去对应的k-v，然后如果k存在那么就比较v，如果v不对，就直接返回false。如果v对就返回ture。不过这里要注意一下，这里需要“双映射机制”，因为有可能出现“模式（pattern）：aba，字符串（string）：dog dog dog“这样的一对多的情况。</p>
</li>
</ol>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">def</span> <span class="title function_">is_match</span>(<span class="params">pattern, string</span>):</span><br><span class="line">    words = string.split()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pattern) != <span class="built_in">len</span>(words):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    pattern_to_word = &#123;&#125;</span><br><span class="line">    word_to_pattern = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> p, w <span class="keyword">in</span> <span class="built_in">zip</span>(pattern, words):</span><br><span class="line">        <span class="keyword">if</span> p <span class="keyword">in</span> pattern_to_word:</span><br><span class="line">            <span class="keyword">if</span> pattern_to_word[p] != w:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">in</span> word_to_pattern:</span><br><span class="line">                <span class="comment"># 该词已被其他模式字符映射</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            pattern_to_word[p] = w</span><br><span class="line">            word_to_pattern[w] = p</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试用例</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 示例1: 模式 abba</span></span><br><span class="line">    <span class="built_in">print</span>(is_match(<span class="string">&quot;abba&quot;</span>, <span class="string">&quot;北京 杭州 杭州 北京&quot;</span>))  <span class="comment"># 输出: True</span></span><br><span class="line">    <span class="comment"># 示例2: 模式 aabb</span></span><br><span class="line">    <span class="built_in">print</span>(is_match(<span class="string">&quot;aabb&quot;</span>, <span class="string">&quot;北京 杭州 杭州 北京&quot;</span>))  <span class="comment"># 输出: False</span></span><br><span class="line">    <span class="comment"># 示例3: 模式 baab</span></span><br><span class="line">    <span class="built_in">print</span>(is_match(<span class="string">&quot;baab&quot;</span>, <span class="string">&quot;北京 杭州 杭州 北京&quot;</span>))  <span class="comment"># 输出: True</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>域名被劫持，是什么原理？<br>域名被劫持是指攻击者通过非法手段篡改域名解析结果或控制域名所有权，将用户引导至恶意网站，窃取敏感信息（如账号密码、支付数据）或进行网络钓鱼。</li>
</ol>
<p>常见手段：<br>    a.DNS 缓存投毒（DNS Cache Poisoning）：攻击者向 DNS 服务器注入错误的 IP 地址，导致后续查询返回恶意地址。<br>    b.入侵DNS 服务器:攻击者入侵目标域名的 DNS 服务器，修改 A 记录或 CNAME 记录。<br>    c.本地 DNS 劫持:在局域网或运营商网络中，攻击者通过 ARP 欺骗或路由器漏洞篡改本地 DNS 配置。<br>    d.域名所有权劫持:攻击者通过盗用域名注册商账户或社会工程学手段，将域名转移到自己控制的账户下，从而控制域名所有权。<br>    e.CDN 劫持:攻击者通过篡改 CDN 配置或利用 CDN 服务漏洞，将域名流量劫持到恶意内容。<br>    等等</p>
<ol start="6">
<li>DAO层是啥？<br>DAO层负责与数据库进行交互，DAO层的主要职责是将数据库操作与业务逻辑分离，提供统一的接口供上层调用。常见技术是JDBC、MyBatis等等。好处如下：<br> a.DAO 中的数据库操作可被多个业务逻辑复用。<br> b.为了业务逻辑层（Service）不直接操作数据库，而是通过 DAO 接口调用，降低模块间的依赖。<br> c.数据库变更（如更换数据库类型）只需修改 DAO 层，无需改动上层代码。</li>
</ol>
<p>如果是python的话，可以用SQLAlchemy、Django ORM模拟 DAO 层的功能。</p>
<ol start="7">
<li>某个java应用启动很慢，有什么思路去解决？<br>主要的几个着力点就是：<br> a.应用镜像包减小：Docker 的镜像由多层只读层（Layer）组成，每个 RUN、COPY、ADD 指令会生成一个新的镜像层（含安装包和临时文件）。合并多个这种指令可以减少镜像层数，从而减小镜像体积。<br> b.清理删除无用的jar<br> c.应用分层构建<br> d.梳理所有的依赖服务，没必要的依赖就可以干掉了。我曾经见过我们的一个国际化的应用，在特定场景下依赖的服务只在某一个单元环境部署，比如应用A在新加坡部署时只依赖新加坡的服务，在杭州部署时会依赖杭州的服务，但代码中的所有consumer还是会在启动的时候全都初始化一遍，导致新加坡部署时HSF consumer还是会对杭州的服务进行初始化，但并没有服务地址可以获取到，就会默认等待3s，服务多了这个时间就会很长了。<br> e.数据库、缓存这样的中间件在启动的时候会初始化，这里也可以操作一下：比如TDDL（它是在阿里巴巴开源的druid基础上做的）做了分库分表，而且分表数量较多，那么初始化可能会耗费大量时间，就算做了异步，也会因为长尾的原因无法起到太大效果，建议从根本上降低tddl的初始化耗时。</li>
</ol>
<p>其实在启动的时候，可以关注CPU开销，如果不高，那么就是很多时间在等待（等网络，等io、等锁、等资源），这里要分别关注。按理说jvm停了，cpu就低了，jvm加载类的时候，执行cpu应该很高。</p>
<p>等io还是等锁可以用<code>jstack</code>来看，查看是否有线程处于<code> BLOCKED（等待锁）或 WAITING（等待 I/O）</code>状态。</p>
<ol start="8">
<li>如果一个应用在启动的时候发现线程池满，有什么思路？<br>一般来说应用启动的时候线程池满，会同时搭配cpu飙升的情况，同时要看他的<code>code_cache</code>利用率，如果<code>code_cache</code>利用率此时利用率较低，则可以证明“这个应用在启动的过程中是没有预热的，所以启动完成后，cpu直接会到100%”。</li>
</ol>
<p><img data-src="/images/cpu%E5%90%AF%E5%8A%A8%E7%9A%84%E6%97%B6%E5%80%99%E9%AB%98.png" alt="paradin" title="启动的时候CPU一波飙升"><br><img data-src="/images/%E9%93%BE%E6%8E%A5%E6%B1%A0%E6%89%93%E6%BB%A1.png" alt="paradin" title="可以看到HSF线程池打满"><br><img data-src="/images/code_cache%E4%BD%8E.png" alt="paradin" title="但是code_cache很低，是慢慢爬上来的"></p>
<p>那么遇到这种情况，就需要对“代码进行预热”，以解决应用刚启动时，部分请求超时或线程池被打满问题，保证应用提供持续稳定的低响应时间和高吞吐量。</p>
<ol start="9">
<li><p>去年你做过的最关键的事儿？</p>
</li>
<li><p>你们做了哪些事儿有效的提升了SLA？</p>
</li>
<li><p>你们为了应付流量上涨都有什么策略？<br>a. 根据历史的监控情况，做好单链路压测和全链路压测，来做好容器的规划，一半预留30%。<br>b. 服务尽量做到无状态，将状态数据（session等）外存到redis，这样随时都可以扩容。<br>c. 配置k8s 的HPA触发自动扩容。<br>d. 启动的时候预加载缓存&#x2F;缩容的时候延迟下线，避免请求丢失。<br>e. 做好限流，sentinel做好服务层接口限流。<br>f. 通知、日志这些能做异步化的做异步化。<br>g. 排队机制。<br>h. 紧急预案，比如临时取消一些非核心的逻辑。</p>
</li>
<li><p>场景题：我有一个应用，是产出短链接的，每一次产出都不一样，可以被用户分享到各个社交平台，然后用户点击访问。读qps大约3000，写qps大约1000，每一个短链接有效期30天。  从以上几个信息，你能判断出我这个应用需要做哪些稳定性的建设么？</p>
</li>
</ol>
]]></content>
      <categories>
        <category>大牛之路</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>面试</tag>
        <tag>算法题</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s里pod的调度笔记</title>
    <url>/2019/09/11/K8s%E9%87%8Cpod%E8%B0%83%E5%BA%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>k8s里对pod的调度的过程简单说就是：当<code>Scheduler</code>通过<code>API server</code>的watch接口监听到新建Pod副本的信息后，它会检查所有符合该Pod要求的Node列表，开始执行Pod调度逻辑。调度成功后将Pod绑定到目标节点上，目标Node上的<code>kubelet</code>服务进程接管后继工作，负责Pod生命周期的后半生。同时<code>Scheduler</code>并将绑定信息传给<code>API server</code>写入etcd中。</p>
<p><code>Kubernetes Scheduler</code>提供的调度流程分三步：</p>
<ol>
<li>预选策略(predicate)：遍历nodelist，选择出符合要求的候选节点，Kubernetes内置了多种预选规则供用户选择。</li>
<li>优选策略(priority)：在选择出符合要求的候选节点中，采用优选规则计算出每个节点的积分，最后选择得分最高的。</li>
<li>选定(select)：如果最高得分有好几个节点，select就会从中随机选择一个节点。</li>
</ol>
<p>而具体方案有以下几种：<br>pod对pod：podAffinity和podantiAffinity<br>pod对node：nodeName、nodeSelector、Taint和Toleration、nodeAffinity和nodeantiAffinity、DeamonSet</p>
<h2 id="强指定nodeName"><a href="#强指定nodeName" class="headerlink" title="强指定nodeName"></a>强指定nodeName</h2><p>先看一下当前node的情况：<br><img data-src="/images/k8s41.png" alt="paradin"></p>
<p>最简单无脑的把pod分配到node上的方法就是<code>nodeName</code>，这个方法是不走schedule分配的，而是直接到对应的node上由kubelet创建pod，举个例子，写一个<code>pod.yaml</code>：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    run: pod-manual-schedule</span><br><span class="line">  namespace: default</span><br><span class="line">  name: pod-manual-schedule</span><br><span class="line">spec:</span><br><span class="line">  nodeName: <span class="string">&quot;node2&quot;</span>		<span class="comment">#这里填写的是NAME段，指定这个pod去node2节点上</span></span><br><span class="line">  <span class="comment">#nodeSelector:</span></span><br><span class="line">     <span class="comment">#  cloudnil.com/role: dev #指定调度节点为带有label标记为：cloudnil.com/role=dev的node节点</span></span><br><span class="line">  <span class="comment">#schedulerName: default-scheduler		#调度器可以自己确定，一般来说这一行不写，即默认的那个调度器</span></span><br><span class="line">  containers:</span><br><span class="line">    - name: my-pod</span><br><span class="line">      image: nginx:<span class="number">1.11</span><span class="number">.9</span></span><br></pre></td></tr></table></figure></p>
<p><code>kubectl apply -f pod.yaml</code>之后，查看一下效果，果然分配到了node2上：<br><img data-src="/images/k8s42.png" alt="paradin"></p>
<p><code>kubectl delete -f 1.yaml</code>删掉该pod。</p>
<p>跟<code>nodeName</code>差不多功效的是<code>nodeSelector</code>，只不过后者靠label而不是名字来给pod指定node。</p>
<p>但是要注意！！！如果在创建<code>deployment/pod</code>的时候指定了<code>nodeName</code>，那么k8s是不会做调度的，也就是说不管该node上的剩余资源是否满足request，都会硬往里塞。那么如果node上的剩余资源不足，就会发现pod处于<code>outofcpu/outofmem</code>。</p>
<h2 id="亲和性nodeaffinity"><a href="#亲和性nodeaffinity" class="headerlink" title="亲和性nodeaffinity"></a>亲和性nodeaffinity</h2><p>通过<code>nodeAffinity</code>调度pod就多了一丝动态选择的味道，不像<code>nodeName</code>那么死板了。首先<code>kubectl label nodes node3 has-eip=yes</code>先给node3打上<code>has-eip=yes</code>这样的label，然后写一个pod.yaml如下：<br>	<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">apiVrsion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    run: node-affinity</span><br><span class="line">  namespace: <span class="keyword">default</span></span><br><span class="line">  name: node-affinity</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: my-pod</span><br><span class="line">      image: nginx:<span class="number">1.11</span><span class="number">.9</span></span><br><span class="line">      imagePullPolicy: IfNotPresent</span><br><span class="line">  affinity:</span><br><span class="line">    nodeAffinity:</span><br><span class="line">      requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">        nodeSelectorTerms:</span><br><span class="line">          - matchExpressions:</span><br><span class="line">              - key: has-eip</span><br><span class="line">                operator: In</span><br><span class="line">                values:</span><br><span class="line">                  - <span class="string">&quot;yes&quot;</span></span><br></pre></td></tr></table></figure></p>
<p><code>kubectl apply -f pod.yaml</code>之后，查看一下效果，果然分配到了node3上：<br><img data-src="/images/k8s43.png" alt="paradin"></p>
<p>如果说就是不信邪，要把nodeAffinity和nodeName&#x2F;nodeSelector一起用，而且还不是指向同一个node，那么这个pod就会调度失败，卡在<code>Predicate MatchNodeSelector failed</code>这个阶段。</p>
<h2 id="谈谈topologyKey"><a href="#谈谈topologyKey" class="headerlink" title="谈谈topologyKey"></a>谈谈topologyKey</h2><p>众所周知，为了照顾pod之间的超亲密关系，k8s还有一个podAffinity，比如一个yaml如下：<br>	<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    run: pod-affinity</span><br><span class="line">  namespace: <span class="keyword">default</span></span><br><span class="line">  name: pod-affinity</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: my-pod</span><br><span class="line">      image: nginx:<span class="number">1.11</span><span class="number">.9</span></span><br><span class="line">      imagePullPolicy: IfNotPresent</span><br><span class="line">  affinity:</span><br><span class="line">    podAffinity:</span><br><span class="line">      requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">      - labelSelector:</span><br><span class="line">          matchExpressions:</span><br><span class="line">            - key: run</span><br><span class="line">              operator: In</span><br><span class="line">              values:</span><br><span class="line">                - <span class="string">&quot;node-affinity&quot;</span></span><br><span class="line">        topologyKey: kubernetes.io/hostname</span><br></pre></td></tr></table></figure></p>
<p>这里面有一个元素叫<code>topologyKey</code>，对它的讲解并不多，很多资料也是一句带过。我这里打算研究一番：</p>
<p>topologyKey是<code>拓扑域</code>，即一个范围。这个范围可大可小，可以是地区、机房也可以是一个node。它实际对应的还是一个node的标签，也就是说，其实topologyKey就是用于筛选Node的。</p>
<p>结合我上面那个yaml，这个yaml意思就是要在<code>default</code>这个命名空间里创建一个叫<code>pod-affinity</code>的pod，它要求必须与<code>run：node-affinity</code>这样的pod在同一个node里，而且这个node还要有<code>kubernetes.io/hostname</code>这样的label。</p>
<p>那么如何判断一个node的label里有没有<code>kubernetes.io/hostname</code>？使用<code>kubectl get nodes -o wide --show-labels</code> 看一下：<br><img data-src="/images/k8s44.png" alt="paradin"></p>
<p>可见图里三个node都有<code>kubernetes.io/hostname</code>，但是如何结合拓扑域呢？举个例子：Pod1在<code>k8s.io/hostname=node1</code>的Node上，Pod2在<code>k8s.io/hostname=node2</code>的Node上，Pod3在<code>k8s.io/hostname=node1</code>的Node上，则Pod2和Pod1、Pod3不在同一个拓扑域，而Pod1和Pod3在同一个拓扑域。</p>
<p>注意！原则上，<code>topologyKey</code>可以是任何合法的标签Key。但是出于性能和安全原因，<code>对topologyKey</code>有一些限制：</p>
<ol>
<li>于亲和性和 <code>requiredDuringSchedulingIgnoredDuringExecution</code>的Pod反亲和性，<code>topologyKey</code>不能为空。</li>
<li>对于<code>requiredDuringSchedulingIgnoredDuringExecution</code> 的Pod反亲和性，引入<code>LimitPodHardAntiAffinityTopology</code>准入控制器来限制<code>topologyKey</code>只能是 <code>kubernetes.io/hostname</code>。如果要使用自定义拓扑域，则可以修改准入控制器，或者直接禁用它。</li>
<li>对于 <code>preferredDuringSchedulingIgnoredDuringExecution</code> 的Pod反亲和性，空的<code>topologyKey</code> 表示所有拓扑域。截止v1.12版本，所有拓扑域还只能是<code>kubernetes.io/hostname</code>、<code>failure-domain.beta.kubernetes.io/zone</code>和<code>failure-domain.beta.kubernetes.io/region</code>的组合。</li>
<li>除上述情况外，<code>topologyKey</code>可以是任何合法的标签key。</li>
</ol>
<h2 id="timeAdded的问题"><a href="#timeAdded的问题" class="headerlink" title="timeAdded的问题"></a>timeAdded的问题</h2><p>在Node的<code>taint</code>的配置里，可能会有<code>timeAdded</code>这样的字眼：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">taints:</span><br><span class="line">  - effect: NoSchedule</span><br><span class="line">    key: dedicated</span><br><span class="line">    timeAdded: null</span><br><span class="line">    value: master</span><br></pre></td></tr></table></figure></p>
<p>这个<code>timeAdded</code>是啥？很少有人介绍，就有人误认为效果是类似<code>toleration</code>里的<code>tolerationSeconds</code>，其实是不对的。</p>
<p><code>timeadded</code>只有在<code>effect:NoExecute</code>里才有具体的值，其余时候都是<code>null</code>，这个字段的设计用途是：“考虑到不同的node可能时间不一致，如果k8s组件出现时间误差的时候，通过<code>timeAdded</code> + <code>pod.tolerationSeconds</code>小于等于<code>time.Now</code>来保证taint能成功的把pod转移到其他的node去”。</p>
<p>不过这个字段据说要慢慢被淘汰掉了，所以可以不用太关注它。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://bazingafeng.com/2019/03/31/k8s-affinity-topologykey/">http://bazingafeng.com/2019/03/31/k8s-affinity-topologykey/</a><br><a href="https://github.com/kubernetes/kubernetes/issues/42394">https://github.com/kubernetes/kubernetes/issues/42394</a><br><a href="https://segmentfault.com/a/1190000018446858">https://segmentfault.com/a/1190000018446858</a></p>
<p><img data-src="/images/%E5%85%AB%E6%9D%91%E5%A1%81%E6%89%A3%E7%89%B9%E7%BA%B3.gif" alt="paradin" title="八村塁扣特纳是他在今年世界杯为数不多的亮点"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>节点调度</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux运维工程师笔试题第二十套</title>
    <url>/2019/09/16/Linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E9%A2%98%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%A5%97/</url>
    <content><![CDATA[<h2 id="试题正文"><a href="#试题正文" class="headerlink" title="试题正文"></a>试题正文</h2><ol>
<li><p>请解释Deployment、ReplicaSets、StatefulSets、Pod、Job、CronJob的不同用途<br><code>Deployment</code>的应用场景： 无状态的、轻量级应用<br><code>StatefulSets</code>的应用场景： 有状态的应用，每个节点有固定的的身份ID、Pod的启动有先后顺序、存储使用持久化存储卷（PV&#x2F;PVC）；<br><code>Deployment</code>和<code>Statefulset</code>之间很显著的区别是deployment的pod名每次重启之后会变，而stateful不会变，另外statefuset的启动是有顺序的。<br><code>Job</code>的应用场景： 负责处理任务，即仅执行一次的任务，它保证批处理任务的一个或多个Pod成功结束；<br><code>CronJob</code>的应用场景: 在给定的时间点运行一个任务，也可以周期性地在给定时间点运行；</p>
</li>
<li><p>Kubernetes 如何处理持久性？<br>根据独立的存储系统如NFS、iSCSI、cephfs、glusterfs等，创建动态&#x2F;静态PV，然后对应绑定PVC，然后在POD里使用PVC即可。</p>
</li>
<li><p>什么是sidecar容器？你能给出一个用例，说明你为什么要使用它么？<br>将应用程序的功能划分为单独的进程可以被视为 Sidecar 容器。Sidecar的设计模式允许你为应用程序添加许多功能，而无需额外第三方组件的配置和代码。<br>实际的应用场景是比如一些服务，还要搭配<code>监控、日志、集中化配置和网络服务</code>这样的附属服务的时候，就可以考虑用sidecar模式。</p>
</li>
<li><p>kubernetes包含几个组件。 各个组件的功能是什么。组件之间是如何交互的。<br>k8s大致分为3个部分：Master节点、Node节点、应用。</p>
</li>
</ol>
<p>Master节点提供集群的控制面板，其下组件有：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kube-apiserver 提供k8s的API调用服务。</span><br><span class="line">etcd 数据中心，存储集群的所有数据。</span><br><span class="line">kube-scheduler 调度器，负责给新创建的容器分配节点等。</span><br><span class="line">kube-controller-manager 控制管理器，负责监控和维护集群状态。</span><br><span class="line">cloud-controller-manager 是提供给第三方开发k8s特性的。</span><br></pre></td></tr></table></figure></p>
<p>其中controller又包含：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Node Controller 报告节点健康状态。</span><br><span class="line">Replication Controller 维护rc的pod个数，pod挂掉又控制重启。</span><br><span class="line">Endpoints Controller 填充Endpoint对象，主要是给Service和Pod。</span><br><span class="line">Service Account &amp; Token Controllers 创建帐号和Token。</span><br></pre></td></tr></table></figure></p>
<p>Node节点组件：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kubelet 管理Pod里面的容器。</span><br><span class="line">kube-proxy 管理网络路由规则。</span><br><span class="line">container runtime 容器运行环境，如Docker等。</span><br></pre></td></tr></table></figure></p>
<p>应用都是部署在<code>kube-system</code>这个命名空间下的。如：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DNS dns服务。</span><br><span class="line">Dashboard web管理界面。</span><br><span class="line">Container Resource Monitoring 容器资源管理和监控，如cAdvisor、Prometheus。</span><br><span class="line">Cluster-level Logging 日志收集分节点、集群、应用三种类型，可用elk或fluentd等。</span><br></pre></td></tr></table></figure></p>
<ol start="5">
<li><p>k8s中的pod内几个容器之间的关系是什么。<br>一个Pod是一组容器的集合，像豌豆荚于豌豆。提供容器间存储和网络的共享，和一系列运行规范。Pod里面的容器共享网络，因此可使用localhost通讯。由于也共享存储，所以可以使用IPC和共享内存进行通讯。</p>
</li>
<li><p>如何在 Kubernetes 中实现负载均衡？<br>通过创建service来实现负载均衡，<code>Service Cluster IP</code> 是一个虚拟 IP，它与<code>pod IP</code>的映射关系是通过<code>iptables</code>，而且用的是使用类似轮询的负载均衡策略（iptables规则里有–probability 0.33332999982这样的标记）。</p>
</li>
<li><p>Deployment、Rc、Rs有什么区别。 其使用方式使用条件和原理是什么。<br><code>Replication Controller</code>是最早的部署、升级Pod的管理工具，他能保证pod的健康个数。<br><code>Replication Set</code>包含RC的所有功能，它比RC强的地方就是RC只支持等式的seletor，而RS的用法更丰富。<br><code>Deployment</code>比RS还高级，而且支持历史回溯、回滚、查看事件状态、暂停启动升级等功能，而且它支持两种升级方案：Recreate（全毁重建）、RollingUpdate（默认，逐步替换）</p>
</li>
<li><p>Cgroup中的cpu有哪几种限制方式。<br>Cgroup限制CPU的方式有三种：<code>cpuset</code>、<code>cpuquota</code>、<code>cpushares</code>，具体如下：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cpuset隔离方式是以分配核心的方式进行资源隔离，可以提供的资源分配最小粒度是核心，不能提供更细粒度的资源隔离，但是隔离之后运算的相互影响最低。需要注意的是在服务器开启了超线程的情况下，要小心选择分配的核心，否则不同cgroup间的性能差距会比较大。</span><br><span class="line">cpuquota给我们提供了一种比cpuset可以更细粒度的分配资源的方式，并且保证了cgroup使用cpu比率的上限，相当于对cpu资源的硬限制。</span><br><span class="line">cpushares给我们提供了一种可以按权重比率弹性分配cpu时间资源的手段：当cpu空闲的时候，某一个要占用cpu的cgroup可以完全占用剩余cpu时间，充分利用资源。而当其他cgroup需要占用的时候，每个cgroup都能保证其最低占用时间比率，达到资源隔离的效果。</span><br></pre></td></tr></table></figure></li>
</ol>
<p>注意！Linux cgroup和Docker都将CPU核心数分成了1024个时间片（shares），而Kubernetes将它分成了1000个shares。所以有时候用docker inspect和kubectl查看有小小的误差。</p>
<ol start="9">
<li><p>k8s是如何使用实现request和limit的？<br>CPU 资源限制和内存资源限制一样都是由cgroup控制</p>
</li>
<li><p>kubectl run这个命令敲下去会有什么过程？<br>首先kubectl会先进行客户端验证的操作，kubectl run会自己判断创建的资源类型，比如当<code>-–replicas=1</code>的时候<code>--restart=Never</code>，那么生成的就是pod。如果有指定参数<code>--generator</code>，可以来部署其他多种资源类型。</p>
</li>
</ol>
<p>然后通过<code>apiVersion</code>字段生成REST路径并且真正地发送HTTP请求。一旦请求发送到kube-apiserver之后获得成功的响应，kube-apiserver将对HTTP请求进行反序列化，然后利用得到的结果构建运行时对象的信息（有点像kubectl生成器的逆过程），并保存到etcd中。</p>
<p>此时Scheduler开始调度，第一轮算法是淘汰掉不满足pod需求的节点，第二轮算法是在符合要求的候选节点上进行优选，将结果打分。一旦找到了合适的节点，Scheduler就会创建一个Binding对象，该对象的Name和Uid与Pod相匹配，然后通过POST请求发送给apiserver。apiserver会把该资源与对应的node记录到etcd里。</p>
<p>Kubelet服务进程会根据度结果先创建pause容器，然后再进行业务Pod的创建。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juejin.im/post/5d28508ff265da1b7638ceeb">https://juejin.im/post/5d28508ff265da1b7638ceeb</a> （kubectl 创建 Pod 背后到底发生了什么？）<br><img data-src="/images/%E5%B9%BC%E8%A9%B9%E5%8A%A9%E6%94%BB%E9%87%8C%E5%9F%BA%E6%88%B4%E7%BB%B4%E6%96%AF.gif" alt="paradin" title="幼詹放弃扣篮，助攻里基代维斯"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>大牛之路</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux运维工程师笔试题第二十四套</title>
    <url>/2025/06/09/Linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E9%A2%98%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%9B%9B%E5%A5%97/</url>
    <content><![CDATA[<ol>
<li>在一个整形数组中， 1 ≤ a[i] ≤ n (n &#x3D; 数组长度), 有些数出现两次，有些数出现一次。需要找到所有出现两次的数字。算法复杂度越小越好。比如[4, 3, 2, 7, 8, 2, 3, 1]，能返回[2,3]<br>【思路】首先这个数组长度是n，那么索引就是0～n-1。要取两个一样的数，因为他们的值是一样的，但是索引又不一样，怎么能够搭配“值跟索引”的关系呢？就借用值一样的前提，那么他们这个“数对应的索引”的值是同一个值，那么这个值可以取负来标记。当第二次取的时候，发现是负数则加入到一个新的列表里，最后这个列表的内容就是结果。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_duplicates</span>(<span class="params">nums</span>):</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">        idx = <span class="built_in">abs</span>(x) - <span class="number">1</span>		<span class="comment"># 这里为啥是减1？因为长度是n，索引就是0～n-1</span></span><br><span class="line">        <span class="keyword">if</span> nums[idx] &lt; <span class="number">0</span>:</span><br><span class="line">            res.append(<span class="built_in">abs</span>(x))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            nums[idx] = -<span class="number">1</span> * nums[idx]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">nums = [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(find_duplicates(nums))  <span class="comment"># 输出: [2, 3]</span></span><br></pre></td></tr></table></figure>

<p>如果你想玩暴力，那么就是每一个值都要比较，原列表元素少还好办，如果元素很多的话，需要比较n的平方次，计算量非常大，如果不考虑时间复杂度可以这么搞。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findDuplicates</span>(<span class="params">nums</span>):</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[j] == nums[i]:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">2</span> <span class="keyword">and</span> nums[i] <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">            res.append(nums[i])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>数组中，所有数字都出现两次，只有一个数字出现一次，找到他。<br>【思路】要找出数组中唯一出现一次的数字（其余所有数字均出现两次），最高效的方法是使用<code>异或运算（^）</code>。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            result ^= num</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例调用</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    sol = Solution()</span><br><span class="line">    <span class="built_in">print</span>(sol.singleNumber([<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>]))  <span class="comment"># 输出: 4</span></span><br><span class="line">    <span class="built_in">print</span>(sol.singleNumber([<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>]))        <span class="comment"># 输出: 1</span></span><br><span class="line">    <span class="built_in">print</span>(sol.singleNumber([<span class="number">1</span>]))              <span class="comment"># 输出: 1（单个元素）</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>一维数组查找指定数字。无序数组怎么查？有序数组呢？<br>无需数组好像只能暴力轮询，有序数组可以用“二分查找”法：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search</span>(<span class="params">nums, target</span>):</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母集合相同，但排列不同的字符串。<br>示例:<br>输入: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br>输出:<br>[<br>[“ate”,”eat”,”tea”],<br>[“nat”,”tan”],<br>[“bat”]<br>]</li>
</ol>
<p>【思路】字符串相同但是排列不同，那么意思就是排列相同的话他们就是一个字符串。如何排列相同呢？那么就用到sort()，所以我们可以利用排列后是同一个字符串作为一个key，而具体的不同排列作为value。所以我们可以上来建立一个dict，格式是{同一个字符串：[]}，然后一点一点把后面的[]填满。那么这个格式的dict可以用defaultdict来创建。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">group_anagrams</span>(<span class="params">strs</span>):</span><br><span class="line">    groups = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">        key = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">sorted</span>(s))。<span class="comment"># 这里进行对字符串进行按照字母排序</span></span><br><span class="line">        groups[key].append(s)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(groups.values())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例测试</span></span><br><span class="line">input_strs = [<span class="string">&quot;eat&quot;</span>, <span class="string">&quot;tea&quot;</span>, <span class="string">&quot;tan&quot;</span>, <span class="string">&quot;ate&quot;</span>, <span class="string">&quot;nat&quot;</span>, <span class="string">&quot;bat&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(group_anagrams(input_strs))</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>唠唠mysql的having语句<br>HAVING 是 SQL 中用于过滤分组后结果的子句，通常与 GROUP BY 一起使用，可以在 HAVING 中使用聚合函数的别名。<br>与 WHERE 的区别：<br> a. WHERE 在分组前过滤原始数据。<br> b. HAVING 在分组后过滤聚合结果。</p>
</li>
<li><p>不要用其他内置工具，纯手动计算阶乘来计算 1! + 2! + 3! + … + 20! 的和<br>【思路】如果用内置工具，就用math.factorial，直接拿到阶乘。但是题目里要求不要用，就可以先写一个函数，函数的能力就是阶乘。传入的是20，然后设定一个a&#x3D;1，然后range(1,21)，a轮询自己乘自己得到阶乘。然后再加上一个for循环求和即可。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">jiecheng</span>(<span class="params">n:<span class="built_in">int</span></span>):</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        a = a*i   <span class="comment"># 直接用上一个结果*最新</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">21</span>):</span><br><span class="line">    total = total + jiecheng(x)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(total)</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>利用递归方法求5!</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">jiecheng</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> n * jiecheng(n-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(jiecheng(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>给定一个字符串，将其进行压缩，例如abbcccdddd，压缩后为a1b2c3d4</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">total = <span class="string">&#x27;&#x27;</span></span><br><span class="line">str1 = <span class="string">&#x27;abbcccdddd&#x27;</span></span><br><span class="line">str2 = <span class="built_in">sorted</span>(<span class="built_in">set</span>(str1))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> str2:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(i,<span class="built_in">str</span>(str1.count(i)))</span><br><span class="line">    total = total + <span class="built_in">str</span>(str1.count(i))+i</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(total)</span><br></pre></td></tr></table></figure>

<ol start="9">
<li><p>大表join小表，有什么加速手段？<br>将小表作为驱动表（Build Side）,逐条扫描小表，然后在大表中查找匹配数据。因为小表行数少，减少循环次数。<br>在大表的 Join 字段上建立索引，这种适合“小表驱动 + 大表的 Join 字段无索引”的场景。<br>在 Join 前对大表进行过滤，如果大表按 Join 字段分区，利用分区信息跳过无关分区，这样是为了减少参与 Join 的数据量。</p>
</li>
<li><p>给定一个字符串s，找出最长的不含重复元素的“最长子串”。比如s&#x3D;’abcabcbb’，最长的子串就是‘abc’。<br>【思路】因为是不重复元素，那么就用set()。这个要用到滑动块的思路，这个滑动块最开始长度为0，然后右移一格，发现里面的元素不在这个set()里，就继续右移一格，发现元素在set()里，就左移，直到左右指针相遇代表已经遍历了整个字符串s。然后取这个set()里最多的元素个数就行了。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">longest_unique_substring</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    sw = <span class="built_in">set</span>()  <span class="comment"># 这个是一个滑动窗口</span></span><br><span class="line">    l = res = <span class="number">0</span> <span class="comment"># 左指针 和 result = 0</span></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="keyword">while</span> s[r] <span class="keyword">in</span> sw:  <span class="comment"># 这里用while是因为有可能是abb这样连续2个b的情况，持续移除左边界字符</span></span><br><span class="line">            sw.remove(s[l])</span><br><span class="line">            l = l+<span class="number">1</span> <span class="comment">#去除最左边的元素，然后左移一格</span></span><br><span class="line"></span><br><span class="line">        sw.add(s[r])</span><br><span class="line">        res = <span class="built_in">max</span>(res,r-l+<span class="number">1</span>) <span class="comment"># 这里加1的原因是l r都是索引，是从0开始的，而数量是从1开始，所以要+1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    s = <span class="string">&#x27;abcabcbb&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(longest_unique_substring(s))</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>什么是回表？<br>假设有一个表<code>users</code>，结构如下：<br>CREATE TABLE users (<br>id INT PRIMARY KEY,         – 聚簇索引（主键）<br>name VARCHAR(100),          – 普通字段<br>age INT,<br>INDEX idx_name (name)       – 非聚簇索引<br>);</li>
</ol>
<p><code>SELECT * FROM users WHERE name = &#39;Alice&#39;; </code>这个语句使用 idx_name 索引：查找 name &#x3D; ‘Alice’ 的记录，得到对应的 主键 id。而回表就是：“再根据主键 id，到聚簇索引中查找完整的数据行（如 age 字段）”这个过程。回表每次回表都需要额外的 I&#x2F;O 操作。</p>
<ol start="12">
<li><p>为什么”产生大量生命周期长&#x2F;无法回收的对象，会导致GC频繁”?</p>
</li>
<li><p>那为什么GC会让CPU飙升？</p>
</li>
<li><p>dig命令和nslookup命令有用过么？</p>
</li>
</ol>
]]></content>
      <categories>
        <category>大牛之路</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>面试</tag>
        <tag>算法题</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux运维工程师笔试题第十七套</title>
    <url>/2019/02/19/Linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E9%A2%98%E7%AC%AC%E5%8D%81%E4%B8%83%E5%A5%97/</url>
    <content><![CDATA[<h2 id="试题内容"><a href="#试题内容" class="headerlink" title="试题内容"></a>试题内容</h2><ol>
<li>如果网站配置了多域名，要根据不同的域名分别https访问，应该怎么配置？<br>在rewrite的时候使用$host，如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">server</span><br><span class="line">&#123;</span><br><span class="line">        listen       <span class="number">80</span>;</span><br><span class="line">        server_name www.test.com www.test.com.cn;</span><br><span class="line">        index index.html index.htm index.php;</span><br><span class="line">		root /home/wwwroot;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                rewrite ^/(.*)$ https://$host/$<span class="number">1</span> permanent;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>如果是要笨一点的方法就是：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">server  </span><br><span class="line">   &#123;  </span><br><span class="line">       listen       <span class="number">80</span>;  </span><br><span class="line">       server_name www.test.com www.test.com.cn;  </span><br><span class="line">       index index.html index.htm index.php;  </span><br><span class="line">       root /home/wwwroot;  </span><br><span class="line"> </span><br><span class="line">       <span class="keyword">if</span> ($host = <span class="string">&#x27;www.test.com.cn&#x27;</span> ) &#123;  </span><br><span class="line">               rewrite ^/(.*)$ https://www.test.com.cn/$<span class="number">1</span> permanent;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">if</span> ($host = <span class="string">&#x27;www.test.com&#x27;</span> ) &#123;  </span><br><span class="line">               rewrite ^/(.*)$ https://www.test.com/$<span class="number">1</span> permanent;  </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>ps.阿里云的SLB绑定多个HTTPS证书的文档：<a href="https://help.aliyun.com/document_detail/87023.html?spm=a2c4g.11186623.6.741.7e11301bVLBAJz">https://help.aliyun.com/document_detail/87023.html?spm=a2c4g.11186623.6.741.7e11301bVLBAJz</a></p>
<ol start="2">
<li>在Nginx中，如何使用未定义的服务器名称来阻止处理请求?<br>只需将请求删除的服务器就可以定义为： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Server &#123;</span><br><span class="line">	listen <span class="number">80</span>;</span><br><span class="line">	server_name <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">444</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这里，服务器名被保留为一个空字符串，它将在没有“主机”头字段的情况下匹配请求，而一个特殊的Nginx的非标准代码444被返回，从而终止连接。</p>
<ol start="3">
<li>ajax是同步还是异步，怎么样实现同步?<br>ajax里async属性默认的设置值为<code>true</code>，这种情况为<code>异步方式</code>。即网页里有两个函数func(x)和func(y)，在打开网页的时候，后台会先去执行func(x)，然后等待server返回结果，同时还有一个线程会去执行func(y)。</li>
</ol>
<p>当把async设为<code>false</code>时，这时ajax的请求是<code>同步</code>的，也就是说，这个时候ajax块发出请求后，他会等待在func(x)这个地方，不会去执行func(y)，直到func(x)部分执行完毕。</p>
<ol start="4">
<li><p>nginx如何实现http跳转https?<br>需要用到地址重写代码，用以下代码能让http强制跳转到https:</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">80</span>;</span><br><span class="line">    listen [::]:<span class="number">80</span>;		<span class="comment">#支持ipv6</span></span><br><span class="line">    server_name www.test.com;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">301</span> https://$server_name$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果某个网站做了两个域名，分别是<a href="https://www.aaa.com和https//www.bbb.com%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%81%9A%E4%BA%86www.aaa.com">https://www.aaa.com和https://www.bbb.com，如果做了www.aaa.com</a> cname到<a href="http://www.bbb.com，那么浏览器打开www.aaa.com会是什么界面？">www.bbb.com，那么浏览器打开www.aaa.com会是什么界面？</a><br>打开页面会出现“https证书不正确”的风险提示。</p>
</li>
<li><p>接着上面问题，在nginx里做了rewrite或者配置了显性URL，此时取消掉<a href="http://www.aaa.com本身的ip（即www.aaa.com没有ip,但是www.bbb.com有ip），浏览器里打开www.aaa.com会是什么界面？">www.aaa.com本身的ip（即www.aaa.com没有ip,但是www.bbb.com有ip），浏览器里打开www.aaa.com会是什么界面？</a><br>会显示“无法找到<a href="http://www.aaa.com的ip地址”(第一步就失败了...)./">www.aaa.com的IP地址”（第一步就失败了...）。</a></p>
</li>
<li><p>要求<code>a.com</code>和<code>www.a.com</code>都跳到<code>www.b.com</code>，而<code>www.a.com/123</code>不跳，如何配置？<br>配置如下：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen   <span class="number">80</span>;</span><br><span class="line">        server_name www.a.com a.com;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#根目录跳转</span></span><br><span class="line">        location / &#123;</span><br><span class="line">                rewrite .+ http://www.b.com/ permanent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#非根目录本地执行</span></span><br><span class="line">        location ~* /.+ &#123;</span><br><span class="line">            <span class="comment">#已省略余下通用配置内容</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了安全，Web服务器不要求启用所有可用的方法，只允许<code>GET</code>，<code>HEAD</code>和<code>POST</code>方法，其他的全部过滤掉。实现其功能的代码如下：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ($request_method !~ ^(GET|HEAD|POST)$ ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">444</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对&#x2F;download&#x2F;目录做“最大下载速度20K，同时最多2个并发链接的限制”</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">        limit_zone my_zone $binary_remote_addr 10m;	<span class="comment">#在 http 段配置定义一个limit_zone</span></span><br><span class="line">        server &#123;</span><br><span class="line">                 location /download/ &#123;</span><br><span class="line">                                       limit_conn my_zone <span class="number">2</span>;	<span class="comment">#limit_conn和 limit_rate参数进行限速设置</span></span><br><span class="line">                                       limit_rate 20k;</span><br><span class="line">                                     &#125;</span><br><span class="line">               &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>limit_zone</code>:针对每个 IP 定义一个存储 session 状态的容器。本例中定义了一个my_zone的10m大小的容器。</p>
</li>
<li><p><code>limit_conn my_zone 2</code>：限制在my_zone中记录状态的每个IP只能发起2个并发连接。本例中，客户端访问&#x2F;download目录时，会限制2个并发连接。 </p>
</li>
<li><p><code>limit_rate 20k</code>：对每个连接限速20k。注意，这里是对连接限速，而不是对IP限速。如果一个IP允许2个并发连接，那么这个IP就是限速为<code>limit_rate*2</code>，在设置的时候要根据自己的需要做设置调整。</p>
</li>
<li><p>简单说明nginx配置文件里面alias和root的区别<br>Nginx配置文件server中指定两个location执行，分别为root和alias指令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">location /test/ &#123;</span><br><span class="line">           alias /www/test/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>按照上述配置，则访问&#x2F;test&#x2F;目录里面的文件时，nginx会去<code>/www/test/</code>目录找文件：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">location /test/ &#123;</span><br><span class="line">          root /www/test;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>按照这种配置，则访问&#x2F;test&#x2F;目录下的文件时，nginx会去<code>/www/test/test/</code>目录下找文件。</p>
<p>另一个区别是alias后面必须要用<code>/</code>结束，否则会找不到文件，而root则对<code>/</code>可有可无。</p>
<p><font color=red>注意！location后面的&#x2F;test&#x2F;如果是&#x2F;test的话（没有用&#x2F;收尾），而同时alias的文件夹是有&#x2F;收尾的话，就会出现“目录穿越”漏洞，即外来人可以访问你&#x2F;www&#x2F;test..&#x2F;即www文件夹的内容。</font>详情可见 <a href="https://www.leavesongs.com/PENETRATION/nginx-insecure-configuration.html">https://www.leavesongs.com/PENETRATION/nginx-insecure-configuration.html</a> 。</p>
<ol start="12">
<li><p>CDN缓存命中率下降的因素有哪些？</p>
</li>
<li><p>客户是否刷新过缓存？<br>答：如果刷新缓存，有可能会短时间表现命中率下降。特别说明下：CDN的url或者目录刷新是清除CDN缓存的动作（这个比较容易理解偏差）</p>
</li>
<li><p>带宽是否突增？并且访问的都是新的URL？<br>答：带宽突增或者访问的新URL较多，会导致CDN节点回源较多，命中率会表现有下降趋势。</p>
</li>
<li><p>源站是否有新内容发布？<br>答：CDN节点访问新内容，导致CDN节点回源较多，命中率会表现有下降趋势。</p>
</li>
<li><p>源站是否出现过异常导致5XX和4XX增加，由于5XX和4XX不缓存，会表现命中率下降。</p>
</li>
<li><p>源站的访问url的header参数，或者在CDN控制管理后台的缓存配置规则是否改变过？<br>答：缓存时长的调整，有可能会带来命中率的变化。</p>
</li>
<li><p>如果判断url是否命中CDN缓存？<br>查看响应头信息中的<code>X-Cache</code>字段。</p>
</li>
<li><p>显示<code>MISS</code>，说明没有命中CDN缓存，是回源的。</p>
</li>
<li><p>显示<code>HIT</code>，是命中了CDN缓存。</p>
</li>
</ol>
<p>除了<code>X-Cache</code>还有如下几个参数与CDN有关：<br><code>X-Swift-SaveTime</code>：内容开始在CDN上缓存的时间。由于系统时间是GMT时间，所以需要折算成北京时间。<br><code>X-Swift-CacheTime</code>：CDN的默认缓存时间，以秒为单位。<br><code>Age</code>：该内容在CDN上已经缓存了的时间。</p>
<ol start="14">
<li>AJAX从b.com请求另一个域a.com的地址会有跨域的问题，如何配置？<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">		listen       <span class="number">80</span>;</span><br><span class="line">		server_name  b.com;</span><br><span class="line">		location /&#123;</span><br><span class="line">			add_header <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="string">&#x27;http://a.com&#x27;</span>;</span><br><span class="line">			add_header <span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="string">&#x27;true&#x27;</span>;</span><br><span class="line">			add_header <span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="string">&#x27;GET&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>第一条add_header：授权从a.com的请求<br>第二条add_header：当该标志为真时，响应于该请求是否可以被暴露<br>第三条add_header：指定请求的方法，可以是GET，POST，PUT，DELETE，HEAD<br>如果想允许来自任何域的请求，可以这样：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">	    listen <span class="number">80</span>;</span><br><span class="line">	    server_name b.com;</span><br><span class="line">	    location /&#123;</span><br><span class="line">		    Access-Control-Allow-Origin: *</span><br><span class="line">	    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<ol start="15">
<li><p>如果想配置2-3个域设置为信任，其他的域名被排除，应该如何配置？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">	    listen <span class="number">80</span>;</span><br><span class="line">	    server_name b.com;</span><br><span class="line">	    location /&#123;</span><br><span class="line">                <span class="keyword">if</span> ( $http_referer ~* (a.com|b.com|c.com)  ) &#123; </span><br><span class="line">		        Access-Control-Allow-Origin: *</span><br><span class="line">                &#125;</span><br><span class="line">	    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将不带www的访问强制加上www怎么做？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">       <span class="comment"># 下面这句就是当识别到 HOST 不是带 www 的全部都 302 带上 www</span></span><br><span class="line"><span class="keyword">if</span> ( $host != <span class="string">&#x27;www.your-domain.com&#x27;</span> ) &#123;</span><br><span class="line">	rewrite ^(.*)$ https://www.your-domain.com$<span class="number">1</span> permanent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个日志文件a.log有1000万行,结构如下：<br>a1,190,c1<br>a2,301,c2<br>a3,90,c3<br>a4,190,c4<br>a5,170,c5<br>…<br>使用Linux命令查找并输出第二例字段最大的三个值？</p>
</li>
</ol>
<p>答案：<code>cat a.log | awk -F&#39;,&#39; &#39;{print $2}&#39; | sort -k1nr | head -n 3</code></p>
<ol start="18">
<li>在mysql InnoDB引擎中，一个update事务：<code>update users set status = &#39;delete&#39; where id = 100; </code>正在执行，在commit之前；另一个查询请求<code>select * from users where id = 100;</code>会被阻塞住么？如果不会，会查到什么数据?<br>答：不阻塞，其可以查询出100（因为读的时候不涉及锁，且事务未提交，所以可以查询出）</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://my.oschina.net/mrpei123/blog/1794001">https://my.oschina.net/mrpei123/blog/1794001</a><br><a href="http://note.qidong.name/2017/09/nginx-https-hsts/">http://note.qidong.name/2017/09/nginx-https-hsts/</a><br><a href="https://www.ssllabs.com/ssltest/index.html%EF%BC%88%E6%B5%8B%E8%AF%95ssl%E5%AE%89%E5%85%A8%E7%9A%84%E7%BD%91%E7%AB%99%EF%BC%89">https://www.ssllabs.com/ssltest/index.html（测试ssl安全的网站）</a></p>
]]></content>
      <categories>
        <category>大牛之路</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>面试笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux运维工程师笔试题第十九套</title>
    <url>/2019/07/01/Linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E9%A2%98%E7%AC%AC%E5%8D%81%E4%B9%9D%E5%A5%97/</url>
    <content><![CDATA[<h2 id="试题内容"><a href="#试题内容" class="headerlink" title="试题内容"></a>试题内容</h2><ol>
<li><p>简述一下客户端请求网页里a.css的过程。<br><img data-src="/images/css5.png" alt="akb48"></p>
</li>
<li><p>HTTP 协议中与缓存相关的<code>HTTP Header</code>有哪些?<br>见<a href="https://segmentfault.com/a/1190000014445687?utm_source=index-hottest/*&%5E%25$">https://segmentfault.com/a/1190000014445687?utm_source=index-hottest/*&amp;^%$</a> 这篇文章吧。</p>
</li>
<li><p>SQL语句：<code>update apps set ID=&quot;12345&quot; and NAME=&quot;李四&quot; where ID=&quot;100001&quot; and NAME=&quot;张三&quot;</code>的执行结果是什么？为什么会有这个结果？<br><img data-src="/images/css6.png" alt="akb48"></p>
</li>
</ol>
<p>mysql官方要求以逗号分隔的<code>col_name=value</code>列表，如果是and的话，题目中的句子实际执行效果是<code>update apps set ID=（&quot;12345&quot; and NAME=&quot;李四&quot;） where ID=&quot;11111&quot; and NAME=&quot;张三&quot;</code>，即括号里的是一个逻辑表达式，但是由于NAME是等于张三而不是李四，于是就等于<code>ID=&quot;12345&quot; and False</code>，即False，在mysql里False等于0。所以出现了这个情况。</p>
<ol start="4">
<li><p>接上题，如果要正确达到目的应该怎么写？<br>正确写法是：<code>update apps set ID=&quot;12345&quot;，NAME=&quot;李四&quot; where ID=&quot;100001&quot; and NAME=&quot;张三&quot;</code>，这样才能达到同时修改两个列的目的。</p>
</li>
<li><p>POST和GET的区别<br>见<a href="https://www.cnblogs.com/logsharing/p/8448446.html">https://www.cnblogs.com/logsharing/p/8448446.html</a> 这篇文章吧。</p>
</li>
<li><p>如何保证用户鉴权过程是安全的？<br>用户在网页输入用户名A和密码B，对“A+B+有规律的字符串”进行加密得到C，将A和C传递给服务器。由于A是明文的，服务器可根据A去数据库里得到相应的密码B，也用同样的步骤生成D，比较C和D是否相同即可。</p>
</li>
<li><p>Lunix如何查看某个进程的线程？<br>两种方法：<br>1）<code>ps -T -p pid</code>，返回的结果里spid就是线程号<br>2）<code>top -H -p pid</code><br>3）<code>pstree -p 进程用户名 | grep 进程名</code>，<code>ps -Lf 进程名</code>，<code>pstack 进程名</code></p>
</li>
<li><p>数据库事务隔离级别<br>数据库事务的隔离级别有4个，由低到高依次为<code>Read uncommitted</code>(读未提交） 、<code>Read committed</code>（读提交，SQL和ORACLE的默认规则） 、<code>Repeatable read</code>（重复读，MYSQL默认的） 、<code>Serializable</code>（序列化，效率低但是最准确） ，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</p>
</li>
<li><p>将软连接的原文件删除，能否编辑此软连接？会有什么现象？<br>可以通过echo命令编辑此软连接，结果生成名跟原文件一样的文件，inode也一样，但是文件内容已经是echo的新内容了。</p>
</li>
<li><p>如何识别此文件是硬链接？<br>使用ll -hit查看文件，如果索引数不是1就是硬链接。</p>
</li>
<li><p>数据库延迟同步的语句是什么？<br>一般来说为了防止数据库误操作，都会给一个异地备份数据库配置延迟同步功能，语句如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mysql&gt;stop slave;</span><br><span class="line">mysql&gt;CHANGE MASTER TO MASTER_DELAY = <span class="number">1800</span>；单位为秒</span><br><span class="line">mysql&gt;start slave;</span><br></pre></td></tr></table></figure>
</li>
<li><p>SQL语句执行很慢的原因都有什么？<br>见<a href="https://zhuanlan.zhihu.com/p/62941196">https://zhuanlan.zhihu.com/p/62941196</a> 这篇文章。</p>
</li>
<li><p>什么场景会造成CPU低而负载确很高呢？<br>造成这种现象的原因是：<code>等待磁盘I/O完成的进程过多，导致进程队列长度过大，但是cpu运行的进程却很少，这样就体现到负载过大了，cpu使用率低</code>。具体表现有以下场景：<br>场景一：磁盘读写请求过多就会导致大量I&#x2F;O等待：上面说过，cpu的工作效率要高于磁盘，而进程在cpu上面运行需要访问磁盘文件，这个时候cpu会向内核发起调用文件的请求，让内核去磁盘取文件，这个时候会切换到其他进程或者空闲，这个任务就会转换为不可中断睡眠状态。当这种读写请求过多就会导致不可中断睡眠状态的进程过多，从而导致负载高，cpu低的情况。</p>
</li>
</ol>
<p>场景二：MySQL中存在没有索引的语句或存在死锁等情况：我们都知道MySQL的数据是存储在硬盘中，如果需要进行sql查询，需要先把数据从磁盘加载到内存中。当在数据特别大的时候，如果执行的sql语句没有索引，就会造成扫描表的行数过大导致I&#x2F;O阻塞，或者是语句中存在死锁，也会造成I&#x2F;O阻塞，从而导致不可中断睡眠进程过多，导致负载过大。<br>具体解决方法可以在MySQL中运行show full processlist命令查看线程等待情况，把其中的语句拿出来进行优化。</p>
<p>场景三：外接硬盘故障，常见有挂了NFS，但是NFS server故障：比如我们的系统挂载了外接硬盘如NFS共享存储，经常会有大量的读写请求去访问NFS存储的文件，如果这个时候NFS Server故障，那么就会导致进程读写请求一直获取不到资源，从而进程一直是不可中断状态，造成负载很高。</p>
<ol start="14">
<li>为什么普通用户没有&#x2F;etc&#x2F;passwd的写权限，可以修改用户密码?<br>这是应为passwd命令的权限是<code>-rwsr-xr-x. 1 root root</code>，其中这个s的意思是被赋予了SetUID权限，即passwd命令执行时是以root身份执行的，即可以更改密码的原因。<br><img data-src="/images/%E8%B5%8C%E5%8D%9A%E9%BB%98%E7%A4%BA%E5%BD%952.jpg" alt="akb48"></li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/kaiye/kaiye.github.com/issues/3">https://github.com/kaiye/kaiye.github.com/issues/3</a><br><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html">https://tech.meituan.com/2014/08/20/innodb-lock.html</a> （Innodb中的事务隔离级别和锁的关系）<br><a href="https://segmentfault.com/a/1190000020459073">https://segmentfault.com/a/1190000020459073</a> （CPU 使用率低高负载的原因）</p>
]]></content>
      <categories>
        <category>大牛之路</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>mysql</tag>
        <tag>http网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux运维工程师笔试题第十八套</title>
    <url>/2019/03/04/Linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E9%A2%98%E7%AC%AC%E5%8D%81%E5%85%AB%E5%A5%97/</url>
    <content><![CDATA[<h2 id="试题内容"><a href="#试题内容" class="headerlink" title="试题内容"></a>试题内容</h2><p>1.docker的exec与attach命令有啥区别？<br><code>attach</code>开启一个和正在运行的进程交互的终端，如果该进程结束，原docker container的进程也会结束。<br><code>exec</code>可以开启多个终端实例，<code>exec -i /bin/bash</code>，由此可见exec其实是在运行中的容器中执行一个命令。</p>
<p>2.docker的CMD与ENTRYPOINT命令有啥区别？<br><code>CMD</code>的命令会被<code>docker run</code>里的命令覆盖，而<code>ENTRYPOINT</code>命令不会。<br>如果要覆盖<code>ENTRYPOINT</code>，则在<code>docker run</code>里添加<code>--entrypoint</code>标签来覆盖即可。<br>如果dockerfile里指定了<code>WORKDIR</code>，那么无论是<code>CMD</code>还是<code>ENTRYPOINT</code>命令都是在这个WORKDIR目录里执行。</p>
<p>3.docker的kill和stop命令有啥区别？<br>stop是“优雅退出”，先发送SIGTERM信号，在一段时间之后（10s）再发送SIGKILL信号。Docker内部的应用程序可以接收SIGTERM信号，然后做一些“退出前工作”，比如保存状态、处理当前请求等。<br>kill是“暴力退出”，即发送SIGKILL信号，应用程序直接退出。</p>
<p>4.假设有一个AAA的容器，现在需要备份它的挂载卷&#x2F;DATA里的数据，请问如何操作？<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">docker run --volumes-form A -v /tmp:/backup --name BACKUP ubuntu tar cvf /backup/A.tar /DATA</span><br></pre></td></tr></table></figure></p>
<p>上面这个语句新建立一个叫BACKUP的容器，它与A容器挂载情况相同（即都是挂载&#x2F;DATA），同时将本地的&#x2F;tmp挂载到容器的&#x2F;backup，在容器生成的时候，执行了<code>tar cvf /backup/A.tar /DATA</code>将DATA文件夹的内容进行了打包，又由于&#x2F;tmp已经与&#x2F;backup挂载，所以就可以直接从宿主机上的&#x2F;tmp里得到A.tar了。</p>
<p>4.linux里删除某个用户的所有进程的语句？<br>ps -u username | grep -v PID | awk ‘{print$1}’| xargs kill -9<br>或者killall -u username</p>
<p>5.linux如何彻底删除一个用户？<br>userdel -r zhidao（前提是这个用户下已经没有程序运行了）</p>
<p>6.杀死某进程的命令？<br>ps -ef |grep 进程名 |grep -v grep|awk ‘{print $2}’|xargs kill -9<br>注意！这里awk后面是单引号不是双引号 </p>
<p>7.普通用户如何访问docker?<br>使用<code>gpasswd -a lcshop docker</code>把该用户添加到docker组即可。</p>
<p>8.输入ping IP后敲回车，发包前会发生什么？<br>首先要知道，ICMP协议是三层（网络层协议），因为不带端口所以肯定不是四层，又因为依赖IP地址所以肯定比2层高。</p>
<p>其次ping可以帮我们了解到是否能够与对方连通，但是ping如果能不开就不开，因为网络上会有无聊的人给你发大量的ping包把你的带宽占满。</p>
<p>回到题目中，假设是下图中的A在ping B:<br><img data-src="/images/mysql-sock9.png" alt="akb48"></p>
<p>回车之后，主机A就要封装二层报文，它会先查自己的MAC地址表，如果没有B的MAC地址，就会向外发送一个ARP广播包。交换机会收到这个报文后，由于交换机有学习MAC地址的功能，所以他会检索自己有没有保存主机B的MAC，如果有，就直接返回给主机A；如果没有，就会向所有端口发送ARP广播，其它主机收到后，发现不是在找自己，就纷纷丢弃了该报文，不去理会。直到主机B收到了报文后，就立即响应，我的MAC地址是多少，同时它也学到主机A的MAC地址，并按同样的ARP报文格式返回给主机A，这时候主机A学到了主机B的MAC，就把B的MAC地址封装到ICMP包中，向主机B发送一个回显请求，主机B收到该报文后，知道是主机A的一个回显请求，就会返回一个相同格式的报文。这样就完成了同一个网段的Ping的过程。</p>
<p>如果主机A要ping主机C，那么主机A发现主机C的IP和自己不是同一网段，它就去找网关转发，但是它也不知道网关的MAC情况下呢?就会像之前那个步骤一样：先发送一个ARP广播，学到网关的MAC，再发封装ICMP报文给网关路由器。当路由器收到主机A发过来的ICMP报文，发现自己的目的地址是其本身MAC地址，根据目的的IP2.1.1.1查路由表，发现2.1.1.1&#x2F;24的路由表项，得到一个出口指针，去掉原来的MAC头部加上自己的MAC地址向主机C转发。如果网关也没有主机C的MAC地址,还是要向前面一个步骤一样,ARP广播一下即可相互学到。路由器2端口能学到主机D的MAC,主机D也能学到路由器2端口的MAC。最后，在主机C已学到路由器2端口MAC，路由器2端口转发给路由器1端口，路由1端口学到主机A的MAC的情况下，他们就不需要再做ARP解析，就将ICMP的回显请求回复过来。</p>
<p>9.MySQL的数据如何恢复到任意时间点？</p>
<p>10.假设有一个dockerfile内容如下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ENTRYPOINT [&quot;top&quot;, &quot;-b&quot;]</span><br><span class="line">CMD [&quot;-c&quot;]</span><br></pre></td></tr></table></figure></p>
<p>然后凭借此dockerfile创建一个镜像，然后<code>docker run -it --rm --name test 镜像名称 -H</code>的实际结果是什么？</p>
<p>实际执行结果是相当于执行<code>top -b -H</code>，没有<code>-c</code>。因为使用exec格式（只能加双引号），在<code>docker run &lt;image&gt;</code>的所有参数，都会追加到<code>ENTRYPOINT</code>之后，并且会覆盖<code>CMD</code>所指定的参数。CMD与ENTRYPOINT一样，如果dockerfile有多个的话，只有最后一个生效。</p>
<p>11.假设有一个dockerfile A内容如下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENV name Cloud Man</span><br><span class="line">ENTRYPOINT [&quot;/bin/echo&quot;, &quot;Hello, $name&quot;]</span><br></pre></td></tr></table></figure><br>还有一个B dockerfile内容如下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENV name Cloud Man  </span><br><span class="line">ENTRYPOINT echo &quot;Hello, $name&quot; </span><br></pre></td></tr></table></figure></p>
<p>请问两者分别运行容器结果是啥？<br>A是<code>Hello, $name</code>，B是<code>Hello, Cloud Man</code>。A的环境变量并没有达到效果，如果想要达到效果，应该改成如下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENV name Cloud Man  </span><br><span class="line">ENTRYPOINT [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo Hello, $name&quot;]</span><br></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://stackoverflow.com/questions/30960686/difference-between-docker-attach-and-docker-exec">https://stackoverflow.com/questions/30960686/difference-between-docker-attach-and-docker-exec</a><br><a href="http://dockone.io/question/469">http://dockone.io/question/469</a><br><a href="https://www.ibm.com/developerworks/community/blogs/132cfa78-44b0-4376-85d0-d3096cd30d3f/entry/RUN_vs_CMD_vs_ENTRYPOINT_%E6%AF%8F%E5%A4%A95%E5%88%86%E9%92%9F%E7%8E%A9%E8%BD%AC_Docker_%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF_17?lang=en">https://www.ibm.com/developerworks/community/blogs/132cfa78-44b0-4376-85d0-d3096cd30d3f/entry/RUN_vs_CMD_vs_ENTRYPOINT_%E6%AF%8F%E5%A4%A95%E5%88%86%E9%92%9F%E7%8E%A9%E8%BD%AC_Docker_%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF_17?lang=en</a><br><a href="https://c.isme.pub/2018/07/11/python-interview/">https://c.isme.pub/2018/07/11/python-interview/</a></p>
]]></content>
      <categories>
        <category>大牛之路</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux运维工程师笔试题第十六套</title>
    <url>/2019/02/13/Linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E9%A2%98%E7%AC%AC%E5%8D%81%E5%85%AD%E5%A5%97/</url>
    <content><![CDATA[<h2 id="试题内容"><a href="#试题内容" class="headerlink" title="试题内容"></a>试题内容</h2><ol>
<li>Mysql的<code>bin-log</code>有几种形式？分析其特点<br><code>Statement Level</code>模式: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">简介：每一条会修改数据的sql都会记录到master的<span class="built_in">bin</span>-log中。Slave在复制的时候sql线程会解析成和原来master端执行过的相同语句来执行。</span><br><span class="line">优点：不需要记录每一行数据的变化，减少<span class="built_in">bin</span>-log的日志量，节约IO，提高性能。因为他只记录在master上所执行语句的细节，以及执行语句时候的上下文的信息。</span><br><span class="line">缺点：很多新功能的加入在复制的时候容易导致出现问题。</span><br></pre></td></tr></table></figure>
<code>Row Level</code>模式: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">简介:日志中会记录成每一行数据被修改的模式，然后再slave 端在对相同的数据进行修改。</span><br><span class="line">优点：在row level模式下，<span class="built_in">bin</span>-log中可以不记录执行的sql语句的上下文相关的信息。仅仅只需要记录那一条记录被修改了。所以row level的日志内容会非常清楚记录下每一行数据修改的细节，非常容易理解。而且不会出现某些特点情况下的存储过程，或function 以及triggeer的调用和触发无法被正确复制的问题。</span><br><span class="line">缺点：所有执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，可能会产生大量的日志。</span><br></pre></td></tr></table></figure></li>
</ol>
<p><code>Mixed</code>(前两种的混合模式):<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">根据执行的每一条具体的sql语句来区分对待记录日志的形式，即Mysql决定什么时候写statement格式的，什么时候写row格式的binlog。；</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li>如何在线正确清理MySQL的binlog？<br>手动删除方法如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#首先查看主从库正在使用的binlog文件名称 </span></span><br><span class="line">show master(slave) status\G</span><br><span class="line"><span class="comment">#删除之前一定要备份</span></span><br><span class="line">purge master logs before<span class="string">&#x27;2017-09-01 00:00:00&#x27;</span>; </span><br><span class="line"><span class="comment">#删除指定时间前的日志</span></span><br><span class="line">purge master logs to<span class="string">&#x27;mysql-bin.000001&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>自动删除的方法如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#通过设置binlog的过期时间让系统自动删除日志</span></span><br><span class="line"><span class="comment">#查看过期时间与设置过期时间</span></span><br><span class="line">show variables like <span class="string">&#x27;expire_logs_days&#x27;</span>; </span><br><span class="line"><span class="built_in">set</span> <span class="keyword">global</span> expire_logs_days = <span class="number">30</span>;</span><br></pre></td></tr></table></figure></p>
<p><code>binlog</code>记录了数据中的数据变动，便于对数据的基于时间点和基于位置的恢复。但是也要定时清理，不然越来越大。</p>
<ol start="3">
<li>简述MySQL主从复制原理及配置主从的完整步骤。<br>MySQL主从是一个异步过程（网络条件上佳的话，同步效果几乎是实时），原理就是从库得到主库的<code>binlog</code>，然后执行这个<code>binlog</code>的内容，达到两边数据库数据一致的目的。具体工作步骤如下：</li>
<li>主mysql服务器将数据库更新记录到binlog中，使用自己的<code>log dump</code>线程将<code>binlog</code>先读取然后加锁，再发送到从库，在从库当读取完成，甚至在发动给从节点之前，锁会被释放；</li>
<li>当从库上执行<code>start slave</code>命令之后，从节点会创建一个I&#x2F;O线程用来连接主节点，请求主库中更新的<code>binlog</code>。I&#x2F;O线程接收到主节点<code>binlog dump</code>进程发来的更新之后，保存在本地<code>relay log</code>中。</li>
<li>从库此时还有一个SQL线程，它负责读取<code>relay log</code>中的内容，解析成具体的操作并执行，最终保证主从数据的一致性。<br><img data-src="/images/mysql-sock9.png" alt="akb48"></li>
</ol>
<p><font color=red>切记！</font>在从库上使用<code>show slave status\G；</code>看到结果里的<code>Slave_IO_Running:Yes</code>和<code>Slave_SQL_Running:Yes</code>，才算是同步成功，两个YES缺一不可。</p>
<p>注意！MySQL只读实例的Binlog日志是没有记录更新信息的，所以它的Binlog无法使用。</p>
<ol start="4">
<li><p>如何理解MySQL里最大连接数和请求数之间的关系<br>假设某个数据库的最大连接数是1000，并不是指最多只能支持1000个访问，因为数据库与应用之间肯定会隔着中间件，这个中间件的连接池会管理链接，一般如果代码写的好、事物控制得当，一个事物完成连接会被连接池收回重复利用，所以不是说一个用户登录你的系统或网站就一直占用着，一个连接也可以包含多次请求。</p>
</li>
<li><p>MySQL出现IOPS过高，应该如何处理？<br>IOPS (Input&#x2F;Output Operations Per Second)，即每秒进行读写（I&#x2F;O）操作的次数。IOPS是指存储每秒可接受多少次主机发出的访问，主机的一次IO需要多次访问存储才可以完成。IOPS过高比较普遍的原因是<code>实例内存满足不了缓存数据或排序等需要，导致产生大量的物理IO</code>或者是<code>查询执行效率低，扫描过多数据行</code>。</p>
</li>
<li><p>Sort_Buffer_Size是什么参数？设置它对服务器性能有何影响？<br><code>Sort_Buffer_Size</code>是一个connection级参数，在每个connection第一次需要使用这个buffer的时候，一次性分配设置的内存。<code>Sort_Buffer_Size</code>并不是越大越好，由于是connection级的参数，过大的设置+高并发可能会耗尽系统内存资源。<code>Sort_Buffer_Size</code>超过256KB的时候，MySQL就会使用<code>mmap()</code>而不是<code>malloc()</code>来进行内存分配，导致性能损耗、效率降低。</p>
</li>
</ol>
<p>如果列长度大于<code>max_length_for_sort_data</code>的参数值的话，<code>iowait</code>会增加, 响应时间明显变长。此时通过<code>show processlist</code>查看,发现有很多session在处理sort操作,此时需要适当调大<code>max_length_for_sort_data</code>的参数值。</p>
<ol start="7">
<li>如何从MySQL全库备份中恢复某个库和某张表<br>主要用到的参数是–one-database简写-o的参数，举个例子： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">全库备份</span><br><span class="line">[root@HE1 ~]<span class="comment"># mysqldump -uroot -p --single-transaction -A --master-data=2 &gt;dump.sql</span></span><br><span class="line">只还原erp库的内容</span><br><span class="line">[root@HE1 ~]<span class="comment"># mysql -uroot -pMANAGER erp --one-database &lt;dump.sql</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>从全库备份中抽取出t表的表结构:<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sed -e<span class="string">&#x27;/./&#123;H;$!d;&#125;&#x27;</span> -e <span class="string">&#x27;x;/CREATE TABLE `t`/!d;q&#x27;</span> dump.sql</span><br></pre></td></tr></table></figure></p>
<p>从全库备份中抽取出t表的内容:<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">grep<span class="string">&#x27;INSERT INTO `t`&#x27;</span> dump.sql</span><br></pre></td></tr></table></figure></p>
<ol start="8">
<li>随意举出一次解决Mysql故障的事例<br>Mysql反应很慢，发现服务器CPU飙升，出现僵尸进程但是连接数并不高，<code>show processlist</code>发现有大量的<code>unauthenticated user</code>。通过更改配置文件<code>/etc/my.cnf</code>里的在[mysqld]那一栏中添加<code>skip-name-resolve</code>，然后重启mysql即可解决。</li>
</ol>
<p><font color=red>注意！</font> <code>skip-name-resolve</code>可以禁用dns解析，但是，这样不能在mysql的授权表中使用主机名了，只能使用IP。以前创建mysql用户是若用的是localhost现在则需要用127.0.0.1来代替在grant语句中执行一下添加该用户。</p>
<p>当然CPU飙升还有其他情况：查询以及大批量的插入或者是网络状态突然断了,导致一个请求服务器只接受到一半…</p>
<ol start="9">
<li><p>你们数据库是否支持emoji表情，如果不支持，如何操作？<br>如果是<code>utf8</code>字符集的话，需要升级至<code>utf8_mb4</code>方可支持。</p>
</li>
<li><p>mysqldump备份时，–master-data选项的作用是什么？还用过其他的参数么？<br><code>--master-data</code>选项的作用就是将二进制的信息写入到输出文件中，即写入备份的sql文件中。</p>
</li>
<li><p><code>--master-data=2</code>表示在dump过程中记录主库的binlog和pos点，并在dump文件中注释掉这一行；</p>
</li>
<li><p><code>--master-data=1</code>表示在dump过程中记录主库的binlog和pos点，并在dump文件中不注释掉这一行，即恢复时会执行；</p>
</li>
<li><p><code>--dump-slave=2</code>表示在dump过程中，在从库dump，mysqldump进程也要在从库执行，记录当时主库的binlog和pos点，并在dump文件中注释掉这一行；</p>
</li>
<li><p><code>--dump-slave=1</code>表示在dump过程中，在从库dump，mysqldump进程也要在从库执行，记录当时主库的binlog和pos点，并在dump文件中不注释掉这一行；</p>
</li>
</ol>
<p><font color=red>注意!</font>在从库上执行备份时，即–dump-slave&#x3D;2，这时整个dump过程都是stop io_thread的状态</p>
<p>加了<code>--single-transaction</code>就能保证innodb的数据是完全一致的，而myisam引擎无法保证（因为myisam压根就不支持事务），要保证myisam引擎数据一致必须加<code>--lock-all-tables</code>。</p>
<ol start="11">
<li>什么是数据库事务，事务有哪些特性？<br>一个数据库事务通常包含对数据库进行读或写的一个操作序列。它的存在包含有以下两个目的：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">为数据库操作提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。</span><br><span class="line">当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。</span><br></pre></td></tr></table></figure>
它的特性如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</span><br><span class="line">一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。</span><br><span class="line">隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</span><br><span class="line">持久性（Durability）：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。</span><br></pre></td></tr></table></figure></li>
</ol>
<p><font color=red>事务的原子性与一致性缺一不可。</font></p>
<ol start="12">
<li>数据表student有id,name,score,city字段，其中name中的名字可有重复，需要消除重复行,请写sql语句<br>语句如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">select distinct name <span class="keyword">from</span> student</span><br></pre></td></tr></table></figure></li>
</ol>
<p><font color=red>注意！</font>单独的<code>distinct</code>只能放在开头，否则就报语法错误。</p>
<ol start="13">
<li><code>select * from table limit 2,1;</code>、<code>select * from table limit 2 offset 1;</code>和<code>select * from employee limit 3;</code>这三个sql有什么区别？<br>第一个sql含义是跳过2条取出1条数据，limit后面是从第2条开始读，读取1条信息，即读取第3条数据；<br>第二个sql含义是从第1条（不包括）数据开始取出2条数据，limit后面跟的是2条数据，offset后面是从第1条开始读取，即读取第2,3条；<br>第三个sql含义是返回前三行；</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/wajika/p/6718552.html">https://www.cnblogs.com/wajika/p/6718552.html</a><br><a href="https://www.hollischuang.com/archives/898">https://www.hollischuang.com/archives/898</a><br><a href="https://zhuanlan.zhihu.com/p/50597960">https://zhuanlan.zhihu.com/p/50597960</a><br><a href="https://segmentfault.com/a/1190000008663001">https://segmentfault.com/a/1190000008663001</a><br><a href="https://segmentfault.com/a/1190000000616820">https://segmentfault.com/a/1190000000616820</a><br><a href="http://seanlook.com/2014/12/05/mysql_mysqldump_options_examples/">http://seanlook.com/2014/12/05/mysql_mysqldump_options_examples/</a><br><img data-src="/images/%E8%B5%8C%E5%8D%9A%E9%BB%98%E7%A4%BA%E5%BD%95.jpg" alt="akb48"></p>
]]></content>
      <categories>
        <category>大牛之路</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux运维工程师笔试题第十五套</title>
    <url>/2018/03/01/Linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E9%A2%98%E7%AC%AC%E5%8D%81%E4%BA%94%E5%A5%97/</url>
    <content><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>1.粘包是什么意思？<code>TCP</code>和<code>UDP</code>是否会出现粘包？出现了粘包如何处理？<br>[我的答案]粘包就是当客户端连续不断的往服务端发送数据包的时候，服务端接收的数据会出现两个数据包粘在一起的情况；UDP（非面向连接）是不会出现粘包的，因为UDP协议是基于报文的，UDP首部采用了16bit来指示UDP数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。而TCP（面向连接）是基于字节流的，它无法识别包的长度，所以会出现粘包的现象。</p>
<p>解决办法主要有以下三种：<br>1）发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了，有较高的效率而且少冗余，但是编程较复杂；<br>2）发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来，编程简单但是效率一般甚至很低；<br>3）可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开；</p>
<p>2.<code>time_wait</code>是什么情况？如果出现了过多的<code>close_wait</code>可能是什么原因？<br>[我的答案]<code>TIME_WAIT</code>是主动关闭连接的一方保持的状态，在保持这个状态2MSL<code>max segment lifetime</code>时间之后，彻底关闭回收资源。遇到<code>TIME_WAIT</code>数过大导致的服务器异常，很容易解决，修改下<code>/etc/sysctl.conf</code>就ok了。</p>
<p>如果一直保持在<code>CLOSE_WAIT</code>状态，那么只有一种情况，就是在对方关闭连接之后服务器程序自己没有进一步发出<code>ack</code>信号。换句话说，就是在对方连接关闭之后，程序里没有检测到，或者程序压根就忘记了这个时候需要关闭连接，于是这个资源就一直被程序占着。这个情况多半是代码的问题，在服务器端是无能为力的，要检查代码。</p>
<p>3.<code>epoll</code>和<code>select</code>的区别？边缘触发和水平触发的区别？<br>[我的答案]<code>select</code>查询速度较慢，因为他每次产生<code>fd</code>时候会有整体<code>fdset</code>的拷贝，而且每次有回送，<code>select</code>要查询整个<code>fdset</code>；<code>epoll</code>查询速度较快，因为他为每个<code>fd</code>都<code>regist</code>了一个单独的回调函数。</p>
<p>水平触发(LT)：当<code>epoll</code>检测到其上有事件发生并通知应用程序时，应用程序可以不立即处理，这样当应用程序再次调用<code>epoll</code>中调用函数时，<code>epoll</code>会再次通知应用程序此事件,直到被处理。</p>
<p>边沿触发(ET)：当<code>epoll</code>检测到其上有事件发生并通知应用程序时，应用程序必须立即处理，并且下一次的<code>epoll</code>调用，不会再向应用程序通知此事件。</p>
<p>所以<code>ET</code>模式大大得降低了同一个<code>epoll</code>事件被重复触发的次数，因此<code>ET</code>模式工作效率比<code>LT</code>模式更高。<code>select</code>、<code>poll</code>、<code>epoll</code>的默认工作模式都是水平触发(<code>LT</code>)模式，但是epoll是支持边沿触发(<code>ET</code>)模式的。 </p>
<p>4.<code>varchar</code>和<code>char</code>的区别是什么？utf8字符集下<code>varchar</code>最多存多少个字符？<br>[我的答案]前面那个问题去看<a href="http://blog.51cto.com/chenx1242/1742467%EF%BC%8C%E8%BF%99%E9%87%8C%E8%AF%B4%E5%90%8E%E9%9D%A2%E9%82%A3%E4%B8%AA%E3%80%82">http://blog.51cto.com/chenx1242/1742467，这里说后面那个。</a><br>在<code>utf-8</code>状态下的<code>varchar</code>，最大只能到 <code>(65535 - 2) / 3 = 21844 余 1</code>。<br>在<code>gbk</code>状态下的<code>varchar</code>, 最大只能到 <code>(65535 - 2) / 2 = 32766 余 1</code>。</p>
<p>5.<code>primary key</code>和<code>unique</code>的区别？<br>[我的答案]首先先说明<code>primary key = unique +  not null</code>，其次<code>Unique Key</code>可以是空，可以在一个表里的一个或多个字段定义，也就是爱有几个有几个，同时存在也可以；但是<code>Primary Key</code>不能为空不能重复，而其一个表里只能有一个<code>Primary Key</code>。</p>
<p>6.乐观锁是啥，悲观锁是啥？<br>[我的答案]悲观锁<code>Pessimistic Lock</code>, 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会<code>block</code>直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p>
<p>乐观锁<code>Optimistic Lock</code>, 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于<code>write_condition</code>机制的其实都是提供的乐观锁。</p>
<p>两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。</p>
<p>7.如何在python的三引号里添加变量？<br>[我的答案]<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">~$ python</span><br><span class="line"><span class="title class_">Python</span> <span class="number">2.7</span><span class="number">.3</span> (<span class="keyword">default</span>, <span class="title class_">Jan</span>  <span class="number">2</span> <span class="number">2013</span>, <span class="number">16</span>:<span class="number">53</span>:<span class="number">07</span>) </span><br><span class="line">[<span class="variable constant_">GCC</span> <span class="number">4.7</span><span class="number">.2</span>] on linux2</span><br><span class="line"><span class="title class_">Type</span> <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> or <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; context = <span class="string">&quot;&quot;</span><span class="string">&quot;Here is an example block template:</span></span><br><span class="line"><span class="string">...     name: %(name)s</span></span><br><span class="line"><span class="string">...     age: %(age)d</span></span><br><span class="line"><span class="string">...     job: %(job)s</span></span><br><span class="line"><span class="string">... &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; print context % <span class="title function_">dict</span>(name=<span class="string">&quot;Tim Wang&quot;</span>, age=<span class="number">45</span>, job=<span class="string">&quot;Coder&quot;</span>)</span><br><span class="line"><span class="title class_">Here</span> is an example block <span class="attr">template</span>:</span><br><span class="line">    <span class="attr">name</span>: <span class="title class_">Tim</span> <span class="title class_">Wang</span></span><br><span class="line">    <span class="attr">age</span>: <span class="number">45</span></span><br><span class="line">    <span class="attr">job</span>: <span class="title class_">Coder</span></span><br><span class="line"> &gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<p>8.<code>redis</code>满了会怎么样？<br>[我的答案]默认情况下<code>redis</code>满了就不会存储新的数据了，不过这个可以调整，<code>redis</code>在达到指定内存的时候可以通过设定的策略来做不同的动作，常见策略如下：<br>1）<code>noeviction</code>:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）<br>2）<code>allkeys-lru</code>: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。<br>3）<code>volatile-lru</code>: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。<br>4）<code>allkeys-random</code>: 回收随机的键使得新添加的数据有空间存放。<br>5）<code>volatile-random</code>: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。<br>6）<code>volatile-ttl</code>: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。</p>
<p>9.啥是“脏读”、“不可重复读”、“幻读”？<br>[我的答案]<code>脏读</code>又称无效数据的读出，是指在数据库访问中，事务T1将某一值修改，然后事务T2读取该值，此后T1因为某种原因撤销对该值的修改，这就导致了T2所读取到的数据是无效的。</p>
<p><code>不可重复读</code>是指在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。比如事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果。</p>
<p><code>幻读</code>是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。</p>
<p>10.ext2、ext3、ext4的区别是啥？<br>[我的答案]<code>ext3</code>和<code>ext2</code>的主要区别在于，<code>ext3</code>引入<code>Journal</code>。<br><code>ext2</code>和<code>ext3</code>的格式完全相同，只是在<code>ext3</code>硬盘最后面有一部分空间用来存放<code>Journal</code>（日志）的记录；<br>在<code>ext2</code>中，写资料到硬盘中时，先将资料写入缓存中，当缓存写满时才会写入硬盘中；<br>在<code>ext3</code>中，写资料到硬盘中时，先将资料写入缓存中，待缓存写满时系统先通知<code>Journal</code>，再将资料写入硬盘，完成后再通知<code>Journal</code>，资料已完成写入工作；<br>在<code>ext3</code>中，也就是有<code>Journal</code>机制里，系统开机时检查<code>Journal</code>的资料，来查看是否有错误产生，这样就快了很多；</p>
<p><code>ext4</code>和<code>ext3</code>的主要区别在于:首先<code>ext4</code>与<code>ext3</code>兼容,<code>ext3</code>只支持32,000个子目录，而额<code>ext4</code>支持无限数量的子目录;<code>ext3</code>所支持的16TB文件系统和最大的2TB的文件，而<code>ext4</code>分别支持1EB（1,048,576TB，1EB&#x3D;1024PB，1PB&#x3D;1024TB）的文件系统，以及16TB的文件;<code>ext3</code>的数据块分配策略是尽快分配，而<code>ext4</code>是尽可能地延迟分配，直到文件在<code>cache</code>中写完才开始分配数据块并写入磁盘;<code>ext4</code>允许关闭日志，以便某些有特殊需求的用户可以借此进一步提升性能等等等等。</p>
<p>11.简述一下A记录与NS记录的区别<br>1.A记录是名称解析的重要记录，它用于将特定的主机名映射到对应主机的IP地址上。你可以在DNS服务器中手动创建或通过DNS客户端动态更新来创建。<br>2.NS记录此记录指定负责此DNS区域的权威名称服务器。<br>3.A记录和NS记录的区别是，A记录直接给出目的IP，NS记录将DNS解析任务交给特定的服务器，NS记录中记录的IP即为该特定服务器的IP地址。<br>4.NS记录优先于A记录，A记录优先于CNAME记录。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.insanecoder.top/tcp-packet-splice-and-split-issue/">https://blog.insanecoder.top/tcp-packet-splice-and-split-issue/</a><br><a href="http://blog.csdn.net/tiandijun/article/details/41961785">http://blog.csdn.net/tiandijun/article/details/41961785</a><br><a href="http://www.redis.cn/topics/lru-cache.html">http://www.redis.cn/topics/lru-cache.html</a><br><a href="http://blog.csdn.net/d_guco/article/details/53166722">http://blog.csdn.net/d_guco/article/details/53166722</a><br><a href="http://www.hollischuang.com/archives/934">http://www.hollischuang.com/archives/934</a><br><a href="http://zhaodedong.leanote.com/post/Linux%EF%BC%9AExt2-Ext3-Ext4%E7%9A%84%E5%8C%BA%E5%88%AB">http://zhaodedong.leanote.com/post/Linux%EF%BC%9AExt2-Ext3-Ext4%E7%9A%84%E5%8C%BA%E5%88%AB</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>大牛之路</tag>
        <tag>面试经验</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux运维工程师笔试题第十四套</title>
    <url>/2018/01/17/Linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E9%A2%98%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%A5%97/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这几天一边看着《nginx高性能WEB服务器详解》，一边看着基础知识。那么最容易入眼的基础知识是什么呢？当然是面试题了，于是乎就找出来一些阿里（含滴滴和蚂蚁金服）的运维面试题，以题带看。</p>
<p>看完之后觉得阿里真的不是盖的，面试题的质量比那些晚上乱七八糟的题质量好多了，细节抠的真是非常细。我记得曾经有一个前辈曾经说过，工作中我们经常注意一些奇淫技巧，但是忽视了基础知识的重要性，现在好多程序员不会认认真真地读本书，喜欢快餐文化，受了市面上很多培训机构的影响，这是要不得的。</p>
<p>最后再说一句，以下所有的题都属于“开放性”试题，可以根据基本点去发散，说出你的理解和认识。但是注意，不要避重就轻耍滑头，问A，可以发散到A1、A2…但是不要发散到X、Y、Z，然后大谈特谈XYZ，这种“小聪明”就是找死的行为。</p>
<h2 id="废话到此为止，上题"><a href="#废话到此为止，上题" class="headerlink" title="废话到此为止，上题"></a>废话到此为止，上题</h2><p>1）<font color=blue>http一般是无状态的，怎么让它变成有状态的？</font><br>[我的答案]http协议跟IP协议、UDP协议一样都是无状态的，http的无状态意思是“每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况”。<font color=green>补充一下，TCP是有状态的，它的请求并不独立，它通过包头的一些控制字段来分别包的关系，这里可以自行脑补一下“三次握手”的图。</font></p>
<p>那么http是无状态的这一点是无法改变的，那么要变得“有状态”，就需要引入<code>cookie</code>和<code>session</code>，通过这两个机制去实现一个有状态的WEB应用。用一个表达式可以这么理解：<code>Web应用=http协议+session、cookies等状态机制+其他辅助的机制</code>。</p>
<p>2）<font color=blue>解释一下cookie和session的区别</font><br>[我的答案]<code>session</code>是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中，<code>session</code>是一个抽象概念，开发者为了实现中断和继续等操作，抽象出来的一个“会话”，接上面那道题，<code>session</code>这个东西是有状态的，服务器要维护一个有状态的东西是很消耗资源的（比如内存和空间），我估计天猫京东那规模的电商，肯定有一个专门的<code>session</code>集群。</p>
<p><code>Cookie</code>是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现<code>Session</code>的一种方式，<code>cookie</code>是一个实际存在的东西，它是在http协议中定义在<code>header</code>中的字段。同一个域名给的<code>cookie</code>肯定是一样的，所以每一个<code>cookie（key）</code>对应的<code>session（value）</code>是唯一的。</p>
<p><code>session</code>的常见实现要借助<code>cookie</code>来发送<code>sessionID</code>给客户端，如果浏览器禁用<code>cookie</code>，那么就要通过重写<code>url</code>来获取<code>sessionid</code>，各位可以联想一下电商的购物车，购物车可以实现在一个网站的不同页面把东西都放进一个购物车，这就是<code>session</code>的重点应用。现在也很流行一个<code>token</code>，其实<code>token</code>和<code>sessionid</code>是一个意思。</p>
<p>3）<font color=blue>多进程和多线程的区别，自己喜欢用哪个？为什么？</font><br>[我的答案]多进程：服务器每当接收到一个客户端信息的时候，从主进程里生成一个<font color=red>子进程</font>与客户端建立连接开始交互，每一个子进程之间互相独立不受干扰，完成任务就收回资源，内存等也会被回收；<br>多线程：服务器每当接收到一个客户端信息的时候，从主进程里生成一个<font color=red>线程</font>与客户端建立连接开始交互,多个线程位于同一个进程内，可以互相访问同样的内存等资源，彼此之间会有影响；<br>我个人更喜欢多进程，因为简单粗暴！<br><PS>关于多进程、多线程、同步、异步的原理，可以去看一下《nginx高性能WEB服务器详解》，第54页到56页的内容。</p>
<ol start="4">
<li><font color=blue>lvs脑裂如何解决，为什么会产生双master？双master时VIP通不通?</font><br>[我的答案]产生双master的原因：1）服务器开启了iptables防火墙，阻碍了心跳信息传输；2）服务器心跳网卡等信息写错了，导致心跳信息发送失败；3）心跳方式不搭配，心跳广播冲突；4）软件出bug了；</li>
</ol>
<p>额外补充一句，<font color=red>要排除脑裂问题，第一步是检查<code>iptables</code>,很可能是由于<code>iptables</code>把心跳信息隔断了，重要的话不说三遍也重要！</font></p>
<p>其他两个问题不会了，我在实际工作里没有接触到。</p>
<ol start="5">
<li><p><font color=blue>为什么TCP比UDP的信息更加可靠？详细说说tcp滑动窗口原理，窗口的大小如何确定。</font><br><code>TCP</code>可靠性由三个机制保证：1. 序号（<code>TCP</code>报文的序号）2. 确认（<code>ACK</code>机制）3. 重传（超时或者冗余的 <code>ACK</code>）<br><code>tcp</code>在传输的时候，因为接受方B能力有限，不可能一口气吃下所有发送方A所有的数据流信息，所以B要限制A每次发送的字节数量，并且一一确认，确认了之后A才可以继续发。<br>这样的话，A的在发送数据流的时候就会有四种形态：<br>1.已发送已确认；<br>2.已发送但没被确认；<br>3.未发送但是接受方已经准备好空间来接收；<br>4.未发送但是接受方尚未准备好空间来接收；<br>随着数据流的传输，这个形态是会时刻发生变化的，通过接受方B返回的确认信息来改变2的大小，同时B也会根据一次关于发送方A要发送多少字节确认自己的空间来改变3的大小。</p>
</li>
<li><p><font color=blue>简单说说cdn的工作原理，如何评估一个cdn sp做的好不好。</font><br>[我的答案]cdn的工作原理：通过权威dns服务器来实现优质节点的选择，通过缓存来减少源站的压力。</p>
</li>
</ol>
<p>IT界有个很有名的比喻，正向代理是“找马云借钱”，反向代理是“给10086打电话”，而反向代理就是CDN的实现原理雏形的一部分。详情可以看：<a href="http://www.iweir.cn/zheng-xiang-dai-li-yu-fan-xiang-dai-li/">http://www.iweir.cn/zheng-xiang-dai-li-yu-fan-xiang-dai-li/</a> 。</p>
<p>7）<font color=blue>dns查询的过程说一下，为什么要有cname而不是直接返回一个cdn边缘节点的ip。</font><br>[我的答案]先说一句题外话，<code>dns</code>主要是基于<code>udp</code>的！<br><code>dns</code>查询的过程以<code>www.taobao.com</code>为例：<br>1.在浏览器键入<code>www.taobao.com</code>,其实真正dns协议里用到的是<code>www.taobao.com.</code>最后还有一个点，可能是因为美观等原因，一般都不显示;<br>2.查询本地缓存（host文件或者是浏览器的缓存）中有没有该域名对应的记录，有的话就直接用了;<br>3.向运营商的DNS服务器发起dns解析的请求，一般称运营商的DNS服务器为<code>local dns</code>;<br>4.<code>local dns</code>会查询本地的缓存，<code>local dns</code>设置的缓存时间是有讲究的，过长过短都不好。另外<code>local dns</code>的查询是运营商的事，这里面水很深，外部不可控(这也是天朝能搭建特色墙的根源的思想雏形)；<br>5.<code>local dns</code>如果没有缓存，会把域名从右往左扫描，依次请求对应的服务器，例如对于域名<code>www.taobao.com.</code>，先去问负责.的根域名服务器，就是传说中全球只有几台的那些服务器，他们会答复<code>.com</code>是谁管理的，然后<code>local dns</code>又去找管理<code>.com</code>的服务器（假设名字为S1），去问问<code>taobao.com</code>是谁管，一般来说，在S1查到的记录是一条<code>cname</code>记录（阿里毕竟大公司，自己管理自己旗下的域名），然后就转到了阿里自己的DNS服务器上来了，一般称之为权威服务器；<br>6.权威服务器是阿里自己建的，然后根据公司内部的一些配置啊，调整啊，查到<code>www.taobao.com.</code>对应的服务器是谁，返回一个<code>IP</code>地址；<br>7.<code>local dns</code>缓存这个<code>IP</code>地址，并且回复浏览器；<br>8.浏览器和对应的<code>IP</code>地址的服务器建立<code>TCP</code>连接，发送<code>HTTP</code>报文；</p>
<p>用图表示就是：<br><img data-src="/images/cdnyuanli.png" alt="akb48"></p>
<p>至于说为什么不返回cdn边缘节点IP，是因为使用CNAME记录可以很方便地变更IP地址，毕竟服务商掌握着IP的生杀大权，哪一天需要换IP了，在这方面很不方便。</p>
<p>8）<font color=blue>举例说下正则表达式和扩展正则表达式、例如：url、ip、邮箱的正则表达式？</font><br>[我的答案]这三个都是网上找的，正则这个东西还是要多练多写。<br>url的正则表达式：<br><code>([/w-]+/.)+[/w-]+.([^a-z])(/[/w- ./?%&amp;=]*)?|[a-zA-Z0-9/-/.][/w-]+.([^a-z])(/[/w- ./?%&amp;=]*)? </code><br>ip的正则表达式：<br>^(1\d{2}|2[0-4]\d|25[0-5]|[1-9]\d|[1-9])\.”+”(1\d{2}|2[0-4]\d|25[0-5]|[1-9]\d|\d)\.”+”(1\d{2}|2[0-4]\d|25[0-5]|[1-9]\d|\d)\.”+”(1\d{2}|2[0-4]\d|25[0-5]|[1-9]\d|\d)$<br>邮箱的正则表达式：<br>^[a-zA-Z0-9.!#$%&amp;’<em>+/&#x3D;?^_&#96;{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61} [a-zA-Z0-9])?(?:.<a href="?:%5Ba-zA-Z0-9-%5D%7B0,61%7D%5Ba-zA-Z0-9%5D">a-zA-Z0-9</a>?)</em>$</p>
<p>9）<font color=blue>解释raid0、raid1、raid01、raid10、raid5、raid6，并分析各自读写性能？</font><br>[我的答案]<a href="https://rorschachchan.github.io/2018/01/31/%E7%AE%80%E6%9E%90raid0-raid1-raid10-raid01%E7%AD%89%E7%AD%89%E7%A1%AC%E7%9B%98%E6%90%AD%E9%85%8D/">https://rorschachchan.github.io/2018/01/31/简析raid0-raid1-raid10-raid01等等硬盘搭配/</a></p>
<p>10）<font color=blue>raid为什么不搞个raid50、raid15，不能搞是因为有什么冲突还是什么等等?</font><br>[我的答案]raid50是有的，但是用途不广泛。<br>raid15我是没听说过，因为raid1的写本身就不强（一样的内容要写两个盘里），raid5的写入能力更烂，那么raid15的磁盘写能力简直就是灾难。而且花了硬盘的钱只能存实际一半的量，正常人都不会这么做的。</p>
<h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><p><a href="https://segmentfault.com/a/1190000007243675">https://segmentfault.com/a/1190000007243675</a><br><a href="http://mertensming.github.io/2016/10/19/cookie-session/">http://mertensming.github.io/2016/10/19/cookie-session/</a><br><a href="https://wizardforcel.gitbooks.io/network-basic/content/index.html">https://wizardforcel.gitbooks.io/network-basic/content/index.html</a><br><a href="https://coolshell.cn/articles/11564.html">https://coolshell.cn/articles/11564.html</a><br><a href="https://coolshell.cn/articles/11609.html">https://coolshell.cn/articles/11609.html</a><br><a href="http://blog.sina.com.cn/s/blog_93b45b0f0101a4ix.html">http://blog.sina.com.cn/s/blog_93b45b0f0101a4ix.html</a><br><a href="http://www.cnblogs.com/549294286/p/5172435.html">http://www.cnblogs.com/549294286/p/5172435.html</a><br><a href="https://wizardforcel.gitbooks.io/network-basic/content/7.html%EF%BC%88%E8%BF%99%E4%B8%AA%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90%EF%BC%8C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89">https://wizardforcel.gitbooks.io/network-basic/content/7.html（这个墙裂推荐，基础知识）</a><br><a href="http://blog.jobbole.com/105500/">http://blog.jobbole.com/105500/</a><br><a href="http://www.austintek.com/LVS/LVS-HOWTO/HOWTO/LVS-HOWTO.failover.html">http://www.austintek.com/LVS/LVS-HOWTO/HOWTO/LVS-HOWTO.failover.html</a></p>
]]></content>
      <categories>
        <category>大牛之路</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>职场</tag>
      </tags>
  </entry>
  <entry>
    <title>Mycat 1.6.5的部署与启动</title>
    <url>/2018/07/05/Mycat%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>先说一下硬件：</p>
<ol>
<li>mycat服务器:阿里云ECS,centos7.4,2核2G1M带宽,外网带宽主要是为了yum安装方便；</li>
<li>数据库主库:阿里云RDS;</li>
<li>数据库读库:阿里云RDS只读实例;</li>
</ol>
<p>登陆阿里云ECS之后，首先先进行如下操作：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wget <span class="attr">http</span>:<span class="comment">//dl.mycat.io/1.6.5/Mycat-server-1.6.5-release-20180122220033-linux.tar.gz #下载1.6.5版本</span></span><br><span class="line">yum install java-<span class="number">1.8</span><span class="number">.0</span>-openjdk* -y 	#安装java <span class="number">1.8</span></span><br><span class="line">yum install -y mysql #安装mysql客户端</span><br><span class="line">useradd mycat	#创建mycat用户</span><br><span class="line">passwd mycat	#更改这个用户的密码</span><br><span class="line">tar -zxvf <span class="title class_">Mycat</span>-server-<span class="number">1.6</span><span class="number">.5</span>-release-<span class="number">20180122220033</span>-linux.<span class="property">tar</span>.<span class="property">gz</span> -C /usr/local	#解压缩/usr/local</span><br><span class="line">cd /usr/local/</span><br><span class="line">chown -R mycat.<span class="property">mycat</span> /usr/local/mycat/	#设置mycat目录的属主和属组</span><br></pre></td></tr></table></figure></p>
<p>然后登陆到阿里云RDS读库和写库，看一下大小写是否是“不敏感”,否则可能会发生表找不到的问题，阿里云的RDS默认是不敏感的：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">MySQL</span> [(none)]&gt; show <span class="variable language_">global</span> variables like <span class="string">&#x27;%lower_case%&#x27;</span>;</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| <span class="title class_">Variable</span>_name          | <span class="title class_">Value</span> |</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| lower_case_file_system | <span class="variable constant_">OFF</span>   |			#这个是“当前系统文件是否大小写敏感”，只读参数，无法修改</span><br><span class="line">| lower_case_table_names | <span class="number">1</span>     |			#这个是“表名是否大小写敏感”，可以修改，改完了重启生效</span><br><span class="line">+------------------------+-------+</span><br><span class="line"><span class="number">2</span> rows <span class="keyword">in</span> <span class="title function_">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<h2 id="Mycat原理和文件结构"><a href="#Mycat原理和文件结构" class="headerlink" title="Mycat原理和文件结构"></a>Mycat原理和文件结构</h2><p>Mycat的原理跟Atlas查不多，都是用一个虚拟的数据库作为前端，后面是挂上真实的写库和读库。如图：<br><img data-src="/images/mycat1.png" alt="akb48"></p>
<p>mycat文件夹的文件结构很简单：</p>
<ol>
<li><font color=red>conf</font>：配置文件；</li>
<li><font color=red>lib</font>：服务依赖的一些jar文件.；</li>
<li><font color=red>logs</font>：日志存储文件夹；</li>
<li><font color=red>bin</font>：可执行命令的地方：</li>
</ol>
<p>mycat的配置文件主要在<code>/usr/local/mycat/conf</code>文件夹里，里面有很多文件，但是主要的配置文件是如下几个：</p>
<ol>
<li><code>server.xml</code>用来配置虚拟数据库的信息；</li>
<li><code>schema.xml</code>用来配置真实读库写库的信息；</li>
<li><code>rule.xml</code>是分片规则的配置文件，分片规则的具体一些参数信息单独存放为文件；<br>注意！在这个目录下，配置文件修改，需要重启Mycat或者通过9066端口reload才会生效。</li>
</ol>
<p>首先在打开<code>server.xml</code>，在如下的地方做修改:<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;user name=<span class="string">&quot;root&quot;</span> defaultAccount=<span class="string">&quot;true&quot;</span>&gt;	&lt;!-- 这里是给虚拟库设定一个账号叫root，并且作为默认账号 --&gt;</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>chenx1242<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span>	&lt;!-- 账号root的密码 --&gt;</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>TESTDB<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span>	&lt;!-- 账号root对应的虚拟库,这个库保持默认比较好 --&gt;</span><br><span class="line">&lt;/user&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span>&gt;</span>									<span class="comment">&lt;!-- 这里是给虚拟库设定一个账号叫test，并且作为默认账号 --&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>26e9p69r<span class="tag">&lt;/<span class="name">property</span>&gt;</span>	<span class="comment">&lt;!-- 账号test的密码 --&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>TESTDB<span class="tag">&lt;/<span class="name">property</span>&gt;</span>	<span class="comment">&lt;!-- 账号test对应的虚拟库,这个库保持默认比较好 --&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;readOnly&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span>	<span class="comment">&lt;!-- 说明这个账号是只读账号 --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>然后打开<code>schema.xml</code>，编辑如下地方：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;dataHost name=<span class="string">&quot;localhost1&quot;</span> maxCon=<span class="string">&quot;1000&quot;</span> minCon=<span class="string">&quot;10&quot;</span> balance=<span class="string">&quot;0&quot;</span> writeType=<span class="string">&quot;0&quot;</span> dbType=<span class="string">&quot;mysql&quot;</span> dbDriver=<span class="string">&quot;native&quot;</span> switchType=<span class="string">&quot;1&quot;</span>  slaveThreshold=<span class="string">&quot;100&quot;</span>&gt;</span><br><span class="line">               <span class="language-xml"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span></span><br><span class="line">               &lt;!-- can have multi write hosts --&gt;</span><br><span class="line">               <span class="language-xml"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;阿里云RDS:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;账号&quot;</span>   <span class="attr">password</span>=<span class="string">&quot;对应密码&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                       <span class="comment">&lt;!-- can have multi read hosts --&gt;</span></span></span><br><span class="line"><span class="language-xml">               <span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;hostS1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;阿里云只读RDS:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;账号&quot;</span>   <span class="attr">password</span>=<span class="string">&quot;对应密码&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">               <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span></span><br><span class="line">			&lt;!-- <span class="language-xml"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostS2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;localhost:3316&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span> --&gt;</span><br><span class="line">               &lt;!-- <span class="language-xml"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;localhost:3316&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span> --&gt;</span><br><span class="line">   &lt;/dataHost&gt;</span><br></pre></td></tr></table></figure></p>
<p>检查好格式并保存之后，就到mycat目录下的&#x2F;bin&#x2F;里<code>./mycat start</code>就启动mycat了。启动成功之后，8066和9066都是被监听的，如图：<br><img data-src="/images/mycat2.png" alt="akb48"></p>
<p><img data-src="/images/mycat3.png" alt="akb48"></p>
<h2 id="启动故障排错"><a href="#启动故障排错" class="headerlink" title="启动故障排错"></a>启动故障排错</h2><p>如果启动mycat失败，可以去logs文件夹里看日志，这里举例几个有代表性的错误：</p>
<ol>
<li><p><code>wrapper.log</code>日志：<code>Caused by: io.mycat.config.util.ConfigException: SelfCheck###  schema mycat refered by user test is not exist!</code><br><code>server.xml</code>里schema最好选择默认的TESTDB，而不是错误里的自己起名的mycat。</p>
</li>
<li><p><code>wrapper.log</code>日志：<code>org.xml.sax.SAXParseException; lineNumber: 23; columnNumber: 3; The content of elements must consist of well-formed character data or markup</code><br>去检查一下<code>server.xml</code>的第23行，看一下是不是多了一个’&lt;’或者’&gt;’。</p>
</li>
<li><p><code>wrapper.log</code>日志：<code>Caused by: io.mycat.config.util.ConfigException: user root duplicated!</code><br><code>server.xml</code>里普通账号root，只读账号也叫root，冲突了。</p>
</li>
<li><p><code>wrapper.log</code>日志：<code>Caused by: org.xml.sax.SAXParseException; lineNumber: 16; columnNumber: 101; Element type &quot;WriteHost&quot; must be declared.</code><br><code>schema.xml</code>配置中writeHost写成了WriteHost导致报错。</p>
</li>
<li><p><code>mycat.log</code>日志如下：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">2018</span>-<span class="number">07</span>-<span class="number">06</span> <span class="number">15</span>:<span class="number">53</span>:<span class="number">22.894</span>  <span class="variable constant_">WARN</span> [$_NIOREACTOR-<span class="number">8</span>-<span class="variable constant_">RW</span>] (io.<span class="property">mycat</span>.<span class="property">backend</span>.<span class="property">mysql</span>.<span class="property">nio</span>.<span class="property">MySQLConnectionAuthenticator</span>.<span class="title function_">handle</span>(<span class="title class_">MySQLConnectionAuthenticator</span>.<span class="property">java</span>:<span class="number">91</span>)) - can<span class="string">&#x27;t connect to mysql server ,errmsg:Access denied for user &#x27;</span>数据库账号<span class="string">&#x27;@&#x27;</span>本地<span class="variable constant_">IP</span><span class="string">&#x27; (using password: YES) MySQLConnection [id=8, lastTime=1530863602566, user=数据库账号, schema=db3, old shema=db3, borrowed=false, fromSlaveDB=false, threadId=4555911, charset=utf8, txIsolation=3, autocommit=true, attachment=null, respHandler=null, host=阿里云写库地址, port=3306, statusSync=null, writeQueue=0, modifiedSQLExecuted=false]</span></span><br></pre></td></tr></table></figure>
<p><code>schema.xml</code>里把真实库的配置写错了。</p>
</li>
<li><p><code>mycat.log</code>日志：<code>(io.mycat.net.NIOConnector.finishConnect(NIOConnector.java:155)) - error: java.net.ConnectException: Connection refused</code><br><code>schema.xml</code>的<code>&lt;dataHost&gt;</code>字段是否写入了多余的数据库。</p>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://valleylord.github.io/post/201601-mycat-install/">http://valleylord.github.io/post/201601-mycat-install/</a><br><a href="https://www.jianshu.com/p/f15d64fcb2f3">https://www.jianshu.com/p/f15d64fcb2f3</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>读写分离</tag>
        <tag>数据库中间件</tag>
        <tag>mycat</tag>
      </tags>
  </entry>
  <entry>
    <title>Mycat配置文件解析与分表存储测试</title>
    <url>/2018/07/06/Mycat%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E4%B8%8E%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>前文已经部署了mycat并且启动，此时登陆到mycat的8066端口，可以看到有一个database，这个database里有几个tables，如图：<br><img data-src="/images/mycat5.png" alt="akb48"></p>
<p>这些库和表根本不是我数据库里的啊，那它是从哪里来的呢？前文说了，mycat有一个虚拟库（逻辑库），它会把逻辑库上的操作映射到真实库里，现在8066这个端口就是虚拟库，里面有几个逻辑表，但是这些表其实不是真正存在的。而mycat主要有三个配置文件，分别是<code>schema.xml</code>、<code>rule.xml</code>和<code>server.xml</code>，<code>server.xml</code>就是配置虚拟数据库的账号密码的地方，很简单没什么好说的，<code>rule.xml</code>是分片规则的配置文件，没事别动它。而<code>schema.xml</code>里是主要配置逻辑库和逻辑表的配置文件。</p>
<h2 id="配置文件解析"><a href="#配置文件解析" class="headerlink" title="配置文件解析"></a>配置文件解析</h2><p>去除掉注释的<code>schema.xml</code>文件是这样的：<br><img data-src="/images/mycat4.png" alt="akb48"></p>
<p>可以看到整个配置文件分为三大块，第一块是<code>schema</code>，第二块是<code>dataNode</code>，第三块是<code>dataHost</code>，其中第三块是跟读写分离相关的，所以这里就说前两个部分，先说第二块<code>dataNode</code>：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;dataNode name=<span class="string">&quot;dn1&quot;</span> dataHost=<span class="string">&quot;mycatTEST&quot;</span> database=<span class="string">&quot;db1&quot;</span> /&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;mycatTEST&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db2&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn3&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;mycatTEST&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db3&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>这一段表示该数据库有哪些数据节点，以及这些数据节点实际对应的数据服务器（这个节点跟<code>dataHost</code>的块有关）和数据库名，这里配置了3个节点dn1,dn2,dn3，都是在mycatTEST服务器上，也就是说我们需要在mycatTEST那个服务器，也就是下面writeHost的机器里先创建三个database，分别叫db1,db2,db3。我们在逻辑库上的操作都会分别下发到这三个db里，具体的下发算法在上面<code>schema</code>里有写。</p>
<p>再看第一块<code>schema</code>的内容：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;schema name=<span class="string">&quot;TESTDB&quot;</span> checkSQLschema=<span class="string">&quot;false&quot;</span> sqlMaxLimit=<span class="string">&quot;100&quot;</span>&gt;</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;travelrecord&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2,dn3&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;auto-sharding-long&quot;</span> /&gt;</span></span>	</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;company&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;ID&quot;</span> <span class="attr">type</span>=<span class="string">&quot;global&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2,dn3&quot;</span> /&gt;</span></span></span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;goods&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;ID&quot;</span> <span class="attr">type</span>=<span class="string">&quot;global&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2&quot;</span> /&gt;</span></span></span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;hotnews&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;ID&quot;</span> <span class="attr">autoIncrement</span>=<span class="string">&quot;true&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2,dn3&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;mod-long&quot;</span> /&gt;</span></span></span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;employee&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;ID&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;sharding-by-intfile&quot;</span> /&gt;</span></span></span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;customer&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;ID&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;sharding-by-intfile&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">childTable</span> <span class="attr">name</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;ID&quot;</span> <span class="attr">joinKey</span>=<span class="string">&quot;customer_id&quot;</span> <span class="attr">parentKey</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">childTable</span> <span class="attr">name</span>=<span class="string">&quot;order_items&quot;</span> <span class="attr">joinKey</span>=<span class="string">&quot;order_id&quot;</span> <span class="attr">parentKey</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">childTable</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">childTable</span> <span class="attr">name</span>=<span class="string">&quot;customer_addr&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;ID&quot;</span> <span class="attr">joinKey</span>=<span class="string">&quot;customer_id&quot;</span>  <span class="attr">parentKey</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br><span class="line">&lt;/schema&gt;</span><br></pre></td></tr></table></figure></p>
<p>这一段主要描述了虚拟数据库的schema即TESTDB中有哪些表，以及每个表分布在哪些数据节点上、分布的方法采用哪种算法。其他的选项含义如下：</p>
<ol>
<li><font color=red>checkSQLschema</font>:当该值设置为<code>true</code>时，如果我们执行语句<code>select * from TESTDB.travelrecord;</code>则MyCat会把语句修改为<code>select * from travelrecord;</code>。即把表示schema的字符去掉，避免发送到后端数据库执行时报<code>（ERROR 1146 (42S02): Table ‘testdb.travelrecord’ doesn’t exist）</code>。这里最好是采用默认的false；</li>
<li><font color=red>sqlMaxLimit</font>:当该值设置为某个数值时。每条执行的SQL语句，如果没有加上limit语句，MyCat也会自动的加上所对应的值。例如设置值为100，执行<code>select fromTESTDB.travelrecord;</code>的效果为和执行<code>select from TESTDB.travelrecord limit 100;</code>相同。需要注意的是，如果运行的schema为非拆分库的，那么该属性不会生效。需要手动添加limit语句；</li>
<li><font color=red>primaryKey</font>:该逻辑表对应真实表的主键，例如：分片的规则是使用非主键进行分片的，那么在使用主键查询的时候，就会发送查询语句到所有配置的DN上，如果使用该属性配置真实表的主键；</li>
<li><font color=red>type</font>:该属性定义了逻辑表的类型，目前逻辑表只有“全局表（global）”和”普通表”两种类型；</li>
<li><font color=red>autoIncrement</font>:mysql对非自增长主键，使用<code>last_insert_id()</code>是不会返回结果的，只会返回0。所以，只有定义了自增长主键的表才可以用<code>last_insert_id()</code>返回主键值。使用<code>autoIncrement=“true”</code>指定这个表有使用自增长主键，这样mycat才会不抛出分片键找不到的异常。这里最好是采用默认的false；</li>
<li><font color=red>rule</font>:该属性用于指定逻辑表要使用的规则名字，规则名字在<code>rule.xml</code>中定义，必须与tableRule标签中name属性属性值一一对应；</li>
<li><font color=red>joinKey</font>:插入子表的时候会使用这个列的值查找父表存储的数据节点；</li>
<li><font color=red>parentKey</font>: 属性指定的值一般为与父表建立关联关系的列名。程序首先获取joinkey的值，再通过parentKey属性指定的列名产生查询语句，通过执行该语句得到父表存储在哪个分片上。从而确定子表存储的位置；</li>
</ol>
<p>举个例子方便理解，<code>&lt;table name=&quot;employee&quot; primaryKey=&quot;ID&quot; dataNode=&quot;dn1,dn2&quot; rule=&quot;sharding-by-intfile&quot; /&gt;</code>，意思就是“这个employee的表，主键是ID，只在dn1和dn2以<code>sharding-by-intfile</code>的规则存储”。</p>
<h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>按照上面修改了配置文件之后，重启一波mycat，登陆mycat的9066管理端口，使用<code>show @@datanode;</code>和<code>show @@datasource;</code>可以查看到数据库源和datanode已经成功建立了，如图：<br><img data-src="/images/mycat7.png" alt="akb48"></p>
<p>手动在阿里云的RDS的读库上创建db1、db2、db3这三个databases，如图：<br><img data-src="/images/mycat6.png" alt="akb48"></p>
<p>由于阿里云读写同步，所以只读实例上也有了db1、db2、db3这三个databases。</p>
<p>此时再开一个窗口，登陆mycat的8066端口，看到里面有了TESTDB这个逻辑库以及里面的逻辑表，但是这些逻辑表实际是不存在的，如图：<br><img data-src="/images/mycat8.png" alt="akb48"></p>
<p>这时创建employee表，插入数据：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">create table <span class="title function_">employee</span> (id int not <span class="literal">null</span> primary key,name <span class="title function_">varchar</span>(<span class="number">100</span>),sharding_id int not <span class="literal">null</span>);</span><br><span class="line">insert into <span class="title function_">employee</span>(id,name,sharding_id) <span class="title function_">values</span>(<span class="number">1</span>,<span class="string">&#x27;leader us&#x27;</span>,<span class="number">10000</span>);</span><br><span class="line">insert into <span class="title function_">employee</span>(id,name,sharding_id) <span class="title function_">values</span>(<span class="number">2</span>, <span class="string">&#x27;me&#x27;</span>,<span class="number">10010</span>);</span><br><span class="line">insert into <span class="title function_">employee</span>(id,name,sharding_id) <span class="title function_">values</span>(<span class="number">3</span>, <span class="string">&#x27;mycat&#x27;</span>,<span class="number">10000</span>);</span><br><span class="line">insert into <span class="title function_">employee</span>(id,name,sharding_id) <span class="title function_">values</span>(<span class="number">4</span>, <span class="string">&#x27;mydog&#x27;</span>,<span class="number">10010</span>);</span><br></pre></td></tr></table></figure></p>
<p>检查一下数据已经被成功插入，并且如果使用<code>select * from</code>查看的话，会从两个datanode上去查，而且都自动加上了<code>limit 100</code>的字样，这一点符合我们在<code>schema.xml</code>里配置的<code>&lt;table name=&quot;employee&quot; primaryKey=&quot;ID&quot; dataNode=&quot;dn1,dn2&quot;/&gt;</code>和<code>sqlMaxLimit=&quot;100&quot;</code>，如图：<br><img data-src="/images/mycat9.png" alt="akb48"></p>
<p>再来到阿里云只读RDS数据库里，检查一下刚刚在虚拟数据库里操作的动作是否被正确映射过来。如图:<br><img data-src="/images/mycat10.png" alt="akb48" title="插入4条数据，这里轮询插入了1和3"><br><img data-src="/images/mycat11.png" alt="akb48" title="插入4条数据，这里轮询插入了2和4"></p>
<p>可见<code>writeType=“0”</code>已经成功，这就是分表存储。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/wangshuang1631/article/details/62898469">https://blog.csdn.net/wangshuang1631/article/details/62898469</a><br><a href="https://sylvanassun.github.io/2016/07/09/2016-07-09-MyCat/">https://sylvanassun.github.io/2016/07/09/2016-07-09-MyCat/</a><br><a href="http://codingo.xyz/index.php/2018/02/27/mycat1/">http://codingo.xyz/index.php/2018/02/27/mycat1/</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>读写分离</tag>
        <tag>数据库中间件</tag>
        <tag>mycat</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql.sock没了怎么办？</title>
    <url>/2018/10/15/Mysql-sock%E6%B2%A1%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/</url>
    <content><![CDATA[<p>今天在调整jumpserver堡垒机资产用户的时候，在点击“更新”的时候，爆出127.0.0.1:3306无法被访问，于是登录到服务器里一看，发现mysql进程挂了。先检查服务器存储空间，发现还很富裕，于是就启动mysql，爆出来如下错误：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@lcshop-jumpserver ~]# mysql</span><br><span class="line"><span class="variable constant_">ERROR</span> <span class="number">2002</span> (<span class="title class_">HY000</span>): <span class="title class_">Can</span><span class="string">&#x27;t connect to local MySQL server through socket &#x27;</span>/<span class="keyword">var</span>/lib/mysql/mysql.<span class="property">sock</span><span class="string">&#x27; (111)</span></span><br></pre></td></tr></table></figure></p>
<p>然后来到<code>/var/lib/mysql/</code>里，瞅着这个紫了吧唧的<code>mysql.sock</code>，脑子一抽，把它删了…</p>
<p>删了…</p>
<p>这尼玛，再次启动mysql，错误码从111变成2：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@lcshop-jumpserver mysql]# mysql</span><br><span class="line"><span class="variable constant_">ERROR</span> <span class="number">2002</span> (<span class="title class_">HY000</span>): <span class="title class_">Can</span><span class="string">&#x27;t connect to local MySQL server through socket &#x27;</span>/<span class="keyword">var</span>/lib/mysql/mysql.<span class="property">sock</span><span class="string">&#x27; (2)</span></span><br></pre></td></tr></table></figure></p>
<p>这一下就尴尬了，<code>mysql.sock</code>没了怎么生成？有人说“重启服务器可以生成”，事实证明这就是纯粹的扯淡。真实的方法是：<code>mysqld_safe &amp;</code>。<br><img data-src="/images/mysql-sock.png" alt="akb48"></p>
<p>如果<code>mysqld_safe &amp;</code>命令失败了，就要去查看一下mysql的日志，多半是某个文件权限不对，要改成mysql用户。</p>
<p>补充一句其他的问题：<code>ImportError: libxslt.so.0: cannot open shared object file: No such file or directory</code>，遇到这个问题怎么办？ <code>yum install  libxslt-devel -y</code><br><img data-src="/images/shaq.gif" alt="akb48" title="鲨鱼哥的拉杆上篮"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>jumpserver堡垒机</tag>
      </tags>
  </entry>
  <entry>
    <title>Mycat读写分离测试</title>
    <url>/2018/07/10/Mycat%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="配置文件解析"><a href="#配置文件解析" class="headerlink" title="配置文件解析"></a>配置文件解析</h2><p>前文说了<code>schema.xml</code>文件的前两块内容，真正与读写分离有关的是第三块<code>dataHost</code>内容：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;dataHost name=<span class="string">&quot;mycatTEST&quot;</span> maxCon=<span class="string">&quot;1000&quot;</span> minCon=<span class="string">&quot;10&quot;</span> balance=<span class="string">&quot;3&quot;</span> writeType=<span class="string">&quot;0&quot;</span> dbType=<span class="string">&quot;mysql&quot;</span> dbDriver=<span class="string">&quot;native&quot;</span> switchType=<span class="string">&quot;1&quot;</span>  slaveThreshold=<span class="string">&quot;100&quot;</span>&gt;</span><br><span class="line">           <span class="language-xml"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span></span><br><span class="line">           <span class="language-xml"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;rm-bp1099x0552q92edr.mysql.rds.aliyuncs.com:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;mycat&quot;</span> <span class="attr">password</span>=<span class="string">&quot;这里是密码&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;hostS1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;rr-bp1x35g0w6r767eu4.mysql.rds.aliyuncs.com:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;mycat&quot;</span> <span class="attr">password</span>=<span class="string">&quot;这里是密码&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>这里主要描述的就是逻辑库需要映射的后端真实数据库的情况。某些选项含义如下：</p>
<ol>
<li><font color=red>maxCon</font>:指定每个读写实例连接池的最大连接。也就是说，标签内嵌套的<code>writeHost</code>、<code>readHost</code>标签都会使用这个属性的值来实例化出连接池的最大连接数;</li>
<li><font color=red>minCon</font>:指定每个读写实例连接池的最小连接，初始化连接池的大小;</li>
<li><font color=red>balance</font>:负载均衡类型，目前的取值有4种：<br> balance&#x3D;“0”, 所有读操作都发送到当前可用的writeHost上。<br> balance&#x3D;“1”，所有读操作都随机的发送到readHost。<br> balance&#x3D;“2”，所有读操作都随机的在writeHost、readhost上分发。<br> balance&#x3D;”3”，所有读请求随机的分发到wiriterHost对应的readhost执行，writerHost不负担读压力</li>
<li><font color=red>writeType</font>:负载均衡类型，目前的取值有3种：<br> writeType&#x3D;“0”, 所有满足规则的写操作轮询的发送到可用的writeHost上。<br> writeType&#x3D;“1”，所有满足规则的写操作随机的发送到readHost。<br> writeType&#x3D;“2”，所有满足规则的写操作随机的在writeHost、readhost分发。（这一点我很怀疑，写操作怎么在readhost上进行）</li>
<li><font color=red>dbType</font>:指定后端连接的数据库类型，目前支持二进制的mysql协议，还有其他使用JDBC连接的数据库。例如：mongodb、oracle、 spark等;</li>
<li><font color=red>dbDriver</font>:指定连接后端数据库使用的Driver，目前可选的值有native和JDBC，当使用JDBC时则可以这么写：<code>jdbc:mysql://mycatTEST:3306/</code>;</li>
<li><font color=red>switchType</font>:主库切换算法，目前的取值有3种：<br> switchType&#x3D;”-1”,表示不自动切换<br> switchType&#x3D;”1”, 默认值，自动切换<br> switchType&#x3D;”2”, 基于MySQL主从同步的状态决定是否切换,心跳语句为<code>show slave status</code><br> switchType&#x3D;”3”,基于MySQL galary cluster的切换机制（适合集群）（1.4.1），心跳语句为<code>show status like &#39;wsrep%&#39;</code></li>
<li><font color=red>heartbeat</font>:这个标签内指明用于和后端数据库进行心跳检查的语句;</li>
<li><font color=red>writeHost &amp; readHost</font>:这两个标签都指定后端数据库的相关配置给mycat，用于实例化后端连接池。唯一不同的是，writeHost指定写实例、readHost指定读实例，组着这些读写实例来满足系统的要求。在一个dataHost内可以定义多个writeHost和readHost(我这里就配了一对，其实可以配很多对)。但是，如果writeHost指定的后端数据库宕机，那么这个writeHost绑定的所有readHost都将不可用。</li>
</ol>
<h2 id="Demo测试"><a href="#Demo测试" class="headerlink" title="Demo测试"></a>Demo测试</h2><p>先登陆主库，然后<code>show slave status \G;</code>命令看一下状态，重点是<code>Slave_IO_Running</code>、<code>Slave_SQL_Running</code>和<code>Seconds_Behind_Master</code>这三个字段，如图：<br><img data-src="/images/mycat12.png" alt="akb48"></p>
<p>关注这三个字段的原因是“Mycat心跳机制通过检测他们来确定当前主从同步的状态”，如果<code>Seconds_Behind_Master</code>的数值大于<code>slaveThreshold</code>，读写分离筛选器会过滤掉此Slave机器，防止读到很久之前的旧数据，而当主节点宕机后，切换逻辑会检查Slave上的<code>Seconds_Behind_Master</code>是否为0，为0时则表示主从同步，可以安全切换，否则不会切换。</p>
<p>确认完之后，再去<code>log4j2.xml</code>文件把日志级别改成<code>debug</code>。如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> &lt;<span class="title class_">Loggers</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">asyncRoot</span> <span class="attr">level</span>=<span class="string">&quot;debug&quot;</span> <span class="attr">includeLocation</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;RollingFile&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">asyncRoot</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Loggers</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>改完之后重启mycat。登陆到8066端口的mycat逻辑库，先创建一个库，再执行一个写的操作：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">CREATE</span> <span class="variable constant_">TABLE</span> <span class="string">`travelrecord`</span> (</span><br><span class="line"> 	<span class="string">`id`</span> <span class="title function_">int</span>(<span class="number">11</span>) <span class="variable constant_">NOT</span> <span class="variable constant_">NULL</span>,</span><br><span class="line"> 	<span class="string">`name`</span> <span class="title function_">varchar</span>(<span class="number">255</span>) <span class="variable constant_">NOT</span> <span class="variable constant_">NULL</span></span><br><span class="line">) <span class="variable constant_">ENGINE</span>=<span class="title class_">InnoDB</span> <span class="variable constant_">DEFAULT</span> <span class="variable constant_">CHARSET</span>=utf8;</span><br><span class="line">insert into <span class="title function_">travelrecord</span> (id,name) <span class="title function_">values</span>(<span class="number">5000010</span>,<span class="string">&#x27;bengbeng&#x27;</span>);</span><br></pre></td></tr></table></figure></p>
<p>在日志一看，发现这条记录已经被写入了dn2这个datanode里，如下：<br><img data-src="/images/mycat14.png" alt="akb48"></p>
<p>日志的意思是：逻辑库收到了insert命令，然后与真实库连接成功并且执行同步命令，<code>con need syn ,total syn cmd 1 commands</code>，之后发送查询sql，因为插入的那个数据是5000000，按照<code>auto-sharding-long</code>的规则，只会记录到db2的分片里。执行完后，会释放mycat逻辑库与真实Mysql连接也就是<code>release connection MySQLConnection</code>和<code>release channel MySQLConnection</code>。</p>
<p>再执行一个读的操作，比如<code>SELECT * FROM travelrecord;</code>，日志是这样记录的：<br><img data-src="/images/mycat13.png" alt="akb48"></p>
<p>与<code>schema.xml</code>里的<code>readhost</code>字段对比，的确是从hostS1上读取到的，由于balance&#x3D;”3”，所以只会从读库读取，由于读的操作db1、db2、db3这3个分片都会操作（需要把他们的内容拼接在一起才是完整的内容），于是日志会打印三遍，实验结束。至于其他的更改参数情况，可以去看参考资料里的第二篇文章，说的很详尽了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://valleylord.github.io/post/201601-mycat-log-analysis/">http://valleylord.github.io/post/201601-mycat-log-analysis/</a><br><a href="http://codingo.xyz/index.php/2018/03/08/mycat2/">http://codingo.xyz/index.php/2018/03/08/mycat2/</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>读写分离</tag>
        <tag>数据库中间件</tag>
        <tag>mycat</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-Atlas从库始终没有建立连接怎么办</title>
    <url>/2018/02/09/Mysql-Atlas%E4%BB%8E%E5%BA%93%E5%A7%8B%E7%BB%88%E6%B2%A1%E6%9C%89%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E6%80%8E%E4%B9%88%E5%8A%9E/</url>
    <content><![CDATA[<p>最近发现阿里云线上环境有一台hls模块的数据库从库一直没有连接，而主库却一直连接不断。在阿里云控制后台看到连接情况如下图：<br><img data-src="/images/atlas1.png" alt="paradin"></p>
<p><img data-src="/images/atlas2.png" alt="paradin"><br>上图是主库的，下面那个是从库的，两者差距很大，可见这样的配置是错误的，因为读库根本没有使用，也就是说读库的那份钱是在浪费！</p>
<p>来到对应的atlas服务器查看配置，看到atlas 的配置里规定管理接口的用户名和密码是默认的原始套餐，端口被改成了2346，如下面，<br><img data-src="/images/atlas3.png" alt="paradin"></p>
<p><img data-src="/images/atlas4.png" alt="paradin"><br>于是我们就在模块服务器（也就是图里的online-hls-001)上登录这个atlas服务器的管理端口，看一下效果：<br><img data-src="/images/atlas6.png" alt="paradin"></p>
<p>发现mysql根本没有反应，可当我们telnet去atlas的2346端口的时候，发现端口是通的：<br><img data-src="/images/atlas7.png" alt="paradin"></p>
<p>于是我们返回到atlas 的配置文件，把这台hls模块服务器的ip地址添加到<code>clients-ips</code>这个字段里。<br><img data-src="/images/atlas8.png" alt="paradin"></p>
<p>然后再用hls服务器去测试一下atlas的管理端口，<code>mysql -hatlas服务器ip地址 -uuser -ppwd</code>，然后使用<code>select * from backends;</code>,发现里面的两个库一个连接成功，另一个是失败的：<br><img data-src="/images/atlas9.png" alt="paradin"></p>
<p>两个库都可以ping通，state却有这样的差别。由此可见这台atlas根本没有连接到从库，导致从库的连接数始终为0。这个时候我们就要检查从库配置的账号密码是否正确，而且在阿里云控制后台给从库开启这个atlas的白名单，然后重新启动这个mysql-proxy进程，再登录atlas管理端口查看，发现从库由down转up了：<br><img data-src="/images/atlas10.png" alt="paradin"></p>
<p>但是此时的atlas日志里却出现了很多forbidden的warning的提示：<br><img data-src="/images/atlas11.png" alt="paradin"></p>
<p>这时候我们返回atlas的配置文件，把之前的修改过的<code>client-ips</code>这个字段注释掉，让所有合法ip都连接，然后重启atlas，这样这种forbidden ip的警告日志就会消失。</p>
<p>稍等一会，就会看到从库上也会出现连接数了，至此一切恢复到正常状态，故障排除！<br><img data-src="/images/atlas12.png" alt="paradin"></p>
<p>本次故障排除感谢<code>https://highdb.com/?s=atlas</code>这位大神的帮助！</p>
<h2 id="文末补充"><a href="#文末补充" class="headerlink" title="文末补充"></a>文末补充</h2><p>数据库访问使用了事务的话，从库也会建立连接，只是连接量要小于“非事务访问”，而不是一点连接都没有。</p>
<p>一般来说，在atlas配置文件里，主库写一个，而从库最好把主库和从库都写进去，如果希望从库承担读的任务多一点的话，可以把权重调高，比如我想从库与主库的读任务比是2：1，那么就可以这么写：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#<span class="title class_">Atlas</span>后端连接的<span class="title class_">MySQL</span>主库的<span class="variable constant_">IP</span>和端口，可设置多项，用逗号分隔</span><br><span class="line">proxy-backend-addresses = 主库地址:<span class="number">3306</span></span><br><span class="line">#<span class="title class_">Atlas</span>后端连接的<span class="title class_">MySQL</span>从库的<span class="variable constant_">IP</span>和端口，@后面的数字代表权重，用来作负载均衡，若省略则默认为<span class="number">1</span>，可设置多项，用逗号分隔</span><br><span class="line">proxy-read-only-backend-addresses = 从库地址:<span class="number">3306</span>@<span class="number">2</span>,主库地址:<span class="number">3306</span>@<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>读写分离中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql主从同步的几个要点总结</title>
    <url>/2018/10/23/Mysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E7%9A%84%E5%87%A0%E4%B8%AA%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="同步原理"><a href="#同步原理" class="headerlink" title="同步原理"></a>同步原理</h2><p>主从同步是Mysql非常常见的一个应用，也是非常重要的监控之处，这里简单总结在配置Mysql时候的几个要点，防止以后自己踩坑。</p>
<p>先说一下主从同步的原理，就是主数据库在数据库更新的时候会更新自己的<code>binlog</code>，同时也会向读数据库（一个或多个）传递这个<code>binlog</code>，此时从库开始一个<code>io_thread</code>这个线程用来接收这个<code>binlog</code>，然后把binlog写入到自己的<code>relaylog</code>，当<code>relaylog</code>发现有数据更新了，就开始一个<code>sql_thread</code>来按照主库更新自己的库，这样达到了“主库读库一致”的效果。图示如下：<br><img data-src="/images/mysql-sock2.png" alt="paradin"></p>
<p>上述过程：<br>主从延迟：「步骤2」开始，到「步骤7」执行结束。<br>步骤 2：存储引擎处理，时间极短<br>步骤 3：文件更新通知，磁盘读取延迟<br>步骤 4：Bin Log 文件更新的传输延迟，单线程<br>步骤 5：磁盘写入延迟<br>步骤 6：文件更新通知，磁盘读取延迟<br>步骤 7：SQL 执行时长</p>
<p>要监控主从同步是否出现异常，可以通过<code>show slave status\G</code>里的<code>Seconds_Behind_Master</code>字段来查看，如图：<br><img data-src="/images/mysql-sock3.png" alt="paradin"></p>
<p>但是要注意！<code>Seconds_Behind_Master</code>是有前提的，那就是主库跟读库之间的网络情况要良好，因为这个字段是从属服务器SQL线程和从属服务器I&#x2F;O线程之间的时间差距，（即比较<code>binlog</code>和<code>relaylog</code>执行sql的timestamp时间差），单位是秒。如果主服务器和从属服务器之间的网络连接较快，则从属服务器I&#x2F;O线程会非常接近主服务器，所以本字段能够十分近似地指示，从属服务器SQL线程比主服务器落后多少。如果网络较慢，则这种指示不准确；从属SQL线程经常会赶上读取速度较慢地从属服务器I&#x2F;O线程，因此，<code>Seconds_Behind_Master</code>经常显示值为0。即使I&#x2F;O线程落后于主服务器时，也是如此。换句话说，本列只对速度快的网络有用。</p>
<h2 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h2><ol>
<li>主库和读库的mysql版本保持一致，硬件情况也保持一致；</li>
<li><code>binlog</code>文件在生产系统中不易过大，建议小于500m，不然容易拖慢数据库性能；</li>
<li>设置slave前先检查一下设置的账号能不能远程登陆；</li>
<li>在设置多个库同步时，一个<code>binlog-do-db</code>参数对应一个库，不能一行写多个库；</li>
<li>如果出现了<code>Slave_IO_Running: No</code>这个状态，去主库上<code>show master status\G</code>，查看一下是否file跟从库的file是不是对不上；</li>
<li>代码里避免出现“查询读库后马上到主库操作”的字段，由于主从同步有延迟，这样很有可能会出现前端多次请求，而从库一致无法从主库得到最新的数据消息，所以sql被执行了好几次的错误，这样的情况可以考虑加入“可以用唯一索引限制”或者用<code>insert … select … where not exist</code>这种方式；</li>
<li>主库的慢sql太多的话，也会影响主从同步；</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://dba.stackexchange.com/questions/24793/mysql-replication-slave-is-continuously-lagging-behind-master">https://dba.stackexchange.com/questions/24793/mysql-replication-slave-is-continuously-lagging-behind-master</a><br><a href="http://ningg.top/inside-mysql-master-slave-delay/">http://ningg.top/inside-mysql-master-slave-delay/</a><br><a href="http://database.51cto.com/art/201108/287653.htm">http://database.51cto.com/art/201108/287653.htm</a><br><a href="https://zhuanlan.zhihu.com/p/28554242">https://zhuanlan.zhihu.com/p/28554242</a></p>
<p><img data-src="/images/roseisback.gif" alt="paradin" title="罗斯许久不见的大幅度变相接折叠上篮"></p>
]]></content>
      <categories>
        <category>大牛之路</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql判断不存在则插入，存在则更新或忽略</title>
    <url>/2020/07/31/Mysql%E5%88%A4%E6%96%AD%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%88%99%E6%8F%92%E5%85%A5%EF%BC%8C%E5%AD%98%E5%9C%A8%E5%88%99%E6%9B%B4%E6%96%B0%E6%88%96%E5%BF%BD%E7%95%A5/</url>
    <content><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>我有一个数据库，每天都要从公司的数据库同步一些数据。但是这样就遇到一个问题：希望先判断数据是否相同，如果相同就跳过，不同就更新或者新增。那么比较笨的方法就是先取到要插入的数据，判断一下<code>select count(*) from 表 where XXX=&quot;要插入的数据的某一列&quot;</code>，如果返回的值是0就是<code>insert</code>，如果返回的不是0那就<code>update</code>。</p>
<p>但是这样的方法比较low，而且还有一定的性能隐患，其实这个需求可以用一句MySQL语句来实现，但是前提是该表里有唯一键。</p>
<p>举个例子，比如我有一个这样的表，表里面记录了一些球员的基础信息，如图：<br><img data-src="/images/mysqlreplace1.png" alt="akb48" title="数据库的结构和数据"></p>
<p>现在我要插入一条如下的语句：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into players(name,team,number) values (&quot;james&quot;,&quot;cavaliers&quot;,&quot;23&quot;)</span><br></pre></td></tr></table></figure></p>
<p>可见新插的数据里，<code>name</code>列和<code>number</code>列一致，但是<code>team</code>不一致，那么要达到目标可以使用<code>replace into</code>语句，但是需要表里有<code>UNIQUE KEY</code>。什么是<code>UNIQUE KEY</code>(唯一键)这个是MySQL的基础知识，Google一下一大把，这里不多说了。我先<code>alter table </code>players<code> ADD unique (name);</code>如图：<br><img data-src="/images/mysqlreplace2.png" alt="akb48" title="name列多了UNI"></p>
<p>这样就指定了name是唯一键，即球员的名称不可以出现重复，此时使用：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">replace into players(name,team,number) values (&quot;james&quot;,&quot;cavaliers&quot;,&quot;23&quot;);</span><br></pre></td></tr></table></figure></p>
<p>效果如图：<br><img data-src="/images/mysqlreplace3.png" alt="akb48"></p>
<p>而且<code>replace into</code>还可以是作为<code>insert into</code>使用，如果<code>name</code>这一列是新的，就会直接<code>insert</code>。</p>
<p>但是这个时候不可以用<code>insert ingore</code>，因为是name为<code>UNIQUE KEY</code>，那么新插入的语句name是相同的，则不会插入，反而会爆出一个<code>warning</code>，使用<code>show warnnings</code>一看，提示name重复了，插入失败，但是语句是执行OK的，不会报error。如图：<br><img data-src="/images/mysqlreplace4.png" alt="akb48"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/t894690230/article/details/77996355">https://blog.csdn.net/t894690230/article/details/77996355</a><br><a href="https://blog.csdn.net/BuptZhengChaoJie/article/details/50992923">https://blog.csdn.net/BuptZhengChaoJie/article/details/50992923</a><br><a href="https://www.yiibai.com/mysql/unique-constraint.html">https://www.yiibai.com/mysql/unique-constraint.html</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>平台搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux运维工程师面试题第一套</title>
    <url>/2018/01/04/Linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E5%A5%97/</url>
    <content><![CDATA[<p>这套题的出处是<a href="http://blog.51cto.com/nolinux/1670406">http://blog.51cto.com/nolinux/1670406</a> ，看到了闲着没事周末就做一做，答案都是我自己在工作里得到的，不一定百分百准确，只是无聊的时候做做，现在拿出来跟各位分享一番。</p>
<p><strong>1、请写出五种系统性能分析工具，并简述其作用和特点</strong><br>[我的答案] top、free、vmstat、iostat、perf等等等等，如果你想装逼，可以回答fio,blktrace，oprofile。<br>具体的作用和特点这里不多说了，但是我着重要推荐vmstat，很实用很棒的一个命令。</p>
<p><strong>2、请写出web服务器的调优要点</strong><br>[我的答案]以nginx为例，个人总结有如下几个要点：<br>1）尽可能的少用http，因为http是有开销的；<br>2）尽可能的使用CDN；<br>3）添加Expire&#x2F;Cache-Control头，这个头是缓存用的，可以缓存图片和flash那样不轻易更改的文件，减少访问时间；<br>4）启动gzip压缩，这个没啥好说的了；<br>5）尽可能少的重定向，能rewrite就不要return，我也知道return比rewrite好写，但是重定向是需要时间的，增加一次重定向就会多一次web需求；<br>6）如果可以，把ajax也做缓存；<br>7）减少dns查询，很多网页会有外站的广告，这些广告也是会启动dns查询的，所以如果不缺钱，减少这种广告；<br>8）调好服务器里的TCP协议栈，这个无论是web服务器还是应用服务器都是必须的；</p>
<p><strong>3、请写出你知道或使用过的nginx扩展模块（注意标注知道和使用）</strong><br>[我的答案] 随便说几个，这玩意到时候结合工作过的情况说说吧：<br>Nginx负载均衡模块：nginx-upstream-fair<br>非阻塞访问redis模块：redis2-nginx-module<br>分布式图片实时动态压缩：ngx-fastdfs</p>
<p><strong>4、请简述你了解的自动化配置管理工具特点和运行原理</strong><br>[我的答案]我用的最多的就是ansible和saltstack，这俩都是python的，对于我这个半路出家的更亲切。<br>ansible基于SSH协议传输数据，不用装agent，配置比较简单，对windows支持惨不忍睹；<br>saltstack使用消息队列zeroMQ传输数据，如果1000台以上的话它速度比ansible还要快,要安装agent，对windows支持同样惨不忍睹；</p>
<p><strong>5、目前，有一个文件，内容如下：<br>     	172.16.100.1<br>     	172.16.100.2<br>     	172.16.100.3<br>     	172.16.100.4<br>   请使用while和ssh命令，登录文件内的ip并执行hostname命令</strong><br>[我的答案]这个我还真没有什么思路，不过应该是跟“&lt;”输入重定向命令结合的一个脚本吧。<br>PS,为啥不用ansible…哪怕pssh也可以啊！</p>
<p><strong>6、请使用awk命令将如下两份文件中名字相同的两行合并起来<br>   A文件：<br>      	大广州 21岁<br>      	广州大 23岁<br>      	州广大 22岁<br>      	广州大 24岁<br>   B文件：<br>      	广州大 男<br>     	大广州 男<br>      	州广大 男<br>      	广州大 男<br>输出效果：<br>    <code>大广州 21岁 男</code></strong><br>[我的答案]awk ‘NR&#x3D;&#x3D;FNR{a[$1]&#x3D;$2}NR&gt;FNR{print $0,a[$1]}’  第2个文件名 第1个文件名<br><img data-src="/images/awkpinjie.png" alt="awk拼接" title="awk拼接的效果"><br>PS，做完这道题，我已经不认识“广”“州”这两个字了…</p>
<p><strong>7、请使用绘图的方式简述TCP&#x2F;IP三次握手和四次断开的交互过程</strong><br>[我的答案]这种图满大街都是了，我这个灵魂画师在这里就不污染各位的眼睛，不过这里推荐各位去看一篇文章：<a href="https://mp.weixin.qq.com/s?__biz=MjM5NzA1MTcyMA==&mid=2651160450&idx=2&sn=1128438fa5287b6cee503880698642b2&scene=21">https://mp.weixin.qq.com/s?__biz=MjM5NzA1MTcyMA==&amp;mid=2651160450&amp;idx=2&amp;sn=1128438fa5287b6cee503880698642b2&amp;scene=21</a> 对原理讲的浅显易懂。<br>多说一句，网易招聘java的时候也问这个问题，不过他们问的是“为什么要三次握手？”</p>
<p><strong>8、请根据你的理解，简述高可用服务体系的相关组件，并列举该组件的具体实现服务名字</strong><br>[我的答案] 我觉得这个题是要问一些架构上的东西，以我工作环境为例：<br>统一配置:zookeeper、Consul、Etcd+Confd(这俩比较常见于动态管理nginx)<br>前端展示:nginx<br>消息队列:activemq、kafka<br>读写分离中间件:atlas<br>日志分析:elk</p>
<p><strong>9、请根据你的理解，简述负载均衡的实现方式</strong><br>[我的答案]负载均衡主要分为两种，硬件（F5）和软件（NGINX、Haproxy、LVS），硬件效果比较牛逼，它是把<strong>4-7层的负载均衡功能做到一个硬件里面</strong>，但是价格昂贵最近用的越来越少了。<br>软件的负载均衡又分两种，四层和七层：四层是<strong>在IP&#x2F;TCP协议栈上把网络包的IP地址和端口进行修改</strong>，达到转发的目的；七层就是<strong>在应用层里把HTTP请求、URL等具体的应用数据发送到具体的服务器上</strong>。四层的效率比七层的高，四层一般安排在架构的前端，七层一般就是在具体服务器的前端。<br>软件负载均衡比较常见的几个分配方式如下：<br>轮询：访问请求依序分发给后端服务器；<br>加权轮询：访问请求依序分发后端服务器，服务器权重越高被分发的几率也越大；<br>最小连接数： 将访问请求分发给当前连接数最小的一台后端服务器，服务器权重越高被分发的几率也越大；</p>
<p><strong>10、请根据你的理解，简述数据迁移工具和数据存储服务有哪些以及相关特点</strong><br>[我的答案]由于我公司主要都放在了阿里云，数据库用过的就这么几个:mysql、redis和elasticsearch。对于Storm和Hadoop这俩我还是初学者。<br>mysql:关系型数据库<br>elasticsearch:全文检索框架，这玩意逐渐向一个数据库靠拢了<br>redis:键值储存数据库</p>
<p>mysql的数据迁移最常见的就是mysqldump，但是要注意使用不当会锁表，<br>redis的数据迁移最稳妥的方法就是主从同步：在slave端启动redis，然后执行<code>slaveof master机器IP地址 6379</code>，然后使用<code>info</code>的时候查看<code>master_link_status</code>如果是<code>up</code>那就是OK了，再执行<code>slaveof no one</code>,提示OK就是OK了；<br>Elasticsearch的数据迁移工具就是Elasticsearch-Exporter，不过我对它仅仅只是了解，用的并不多； </p>
<p><strong>总结</strong><br>这套题不算难，方向是偏应用的，但是对云端服务的运维来说不算很友好，因为云厂商基本都把数据备份和数据迁移都做成自己的工具（比如阿里云的DTS），所以很多云服务的运维对这种东西了解不多。</p>
<p><img data-src="/images/welcomekuniao.jpg" alt="欢迎新人" title="欢迎来到巴塞罗那！库迪尼奥"></p>
]]></content>
      <categories>
        <category>大牛之路</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>职场</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql根据某几列过滤重复项</title>
    <url>/2020/10/30/Mysql%E6%A0%B9%E6%8D%AE%E6%9F%90%E4%B8%80%E5%88%97%E8%BF%87%E6%BB%A4%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<h2 id="把无用的字段去重掉"><a href="#把无用的字段去重掉" class="headerlink" title="把无用的字段去重掉"></a>把无用的字段去重掉</h2><p>Mysql里难保每一行不出现部分列内容重复，比如学生叫“杨洋”这种重名情况很常见，但是往往这种“脏数据”会导致同步任务出现错误，所以我们就要根据某一列去过滤重复项，举个例子，比如有这样一个表<code>rule_case</code>，表细节如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * <span class="keyword">from</span> rule_case;</span><br><span class="line">+----+---------+---------------+-----+-----------------+---------------------+--------------------------------+</span><br><span class="line">| <span class="built_in">id</span> | deleted | rule_name     | app | product_line_id | gmt_create          | comment                        |</span><br><span class="line">+----+---------+---------------+-----+-----------------+---------------------+--------------------------------+</span><br><span class="line">|  <span class="number">1</span> |       <span class="number">0</span> | 库存规则<span class="number">1</span> | aaa | <span class="number">1</span>               | <span class="number">2021</span>-03-02 <span class="number">15</span>:02:<span class="number">44</span> | 这是很正常的一个备注 |</span><br><span class="line">|  <span class="number">2</span> |       <span class="number">0</span> | 库存规则<span class="number">2</span> | aaa | <span class="number">1</span>               | <span class="number">2021</span>-03-02 <span class="number">15</span>:02:<span class="number">44</span> | 这是很正常的一个备注 |</span><br><span class="line">|  <span class="number">3</span> |       <span class="number">0</span> | 履约规则<span class="number">1</span> | bbb | <span class="number">3</span>               | <span class="number">2021</span>-03-02 <span class="number">15</span>:02:<span class="number">44</span> | 这是很正常的一个备注 |</span><br><span class="line">|  <span class="number">4</span> |       <span class="number">0</span> | 履约规则<span class="number">2</span> | bbb | <span class="number">3</span>               | <span class="number">2021</span>-03-02 <span class="number">15</span>:02:<span class="number">44</span> | 这是很正常的一个备注 |</span><br><span class="line">|  <span class="number">5</span> |       <span class="number">0</span> | 财务规则<span class="number">1</span> | ccc | <span class="number">5</span>               | <span class="number">2021</span>-03-02 <span class="number">15</span>:02:<span class="number">44</span> | 这是很正常的一个备注 |</span><br><span class="line">|  <span class="number">6</span> |       <span class="number">0</span> | 财务规则<span class="number">2</span> | ccc | <span class="number">5</span>               | <span class="number">2021</span>-03-02 <span class="number">15</span>:02:<span class="number">44</span> | 这是很正常的一个备注 |</span><br><span class="line">|  <span class="number">7</span> |       <span class="number">0</span> | 会员规则<span class="number">1</span> | xxx | <span class="number">10</span>              | <span class="number">2021</span>-03-02 <span class="number">15</span>:02:<span class="number">44</span> | 这是很正常的一个备注 |</span><br><span class="line">|  <span class="number">8</span> |       <span class="number">0</span> | 财务规则<span class="number">3</span> | ccc | <span class="number">5</span>               | <span class="number">2021</span>-03-02 <span class="number">15</span>:02:<span class="number">44</span> | 这是很正常的一个备注 |</span><br><span class="line">|  <span class="number">9</span> |       <span class="number">0</span> | 库存规则<span class="number">1</span> | aaa | <span class="number">1</span>               | <span class="number">2021</span>-03-01 <span class="number">20</span>:02:<span class="number">44</span> | 这是重复的记录<span class="number">1</span>         |</span><br><span class="line">| <span class="number">10</span> |       <span class="number">0</span> | 库存规则<span class="number">1</span> | aaa | <span class="number">1</span>               | <span class="number">2021</span>-03-01 <span class="number">15</span>:02:<span class="number">44</span> | 这是重复的记录<span class="number">2</span>         |</span><br><span class="line">+----+---------+---------------+-----+-----------------+---------------------+--------------------------------+</span><br></pre></td></tr></table></figure></p>
<p>可以看出第1条记录和9、10这俩记录其实就是重复记录，他们的很多信息相同，仅仅是创建时间和comment不同，如果这俩不是想要的信息，在二次加工的时候就应该去重。</p>
<p>去重的语句常见的有俩，一个是<code>distinct</code>，另一个是<code>group by</code>，但是他俩有各自的用法。</p>
<p><code>distinct</code>只能放在查询字段的最前面，而且他对后面所有的字段都起作用，即去重掉查询的所有字段完全重复的数据，而不是只对链接的单个字段重复的数据，拿上面的表实验一下：<br><img data-src="/images/mysql%E5%8E%BB%E9%87%8D1.png"></p>
<p>可见<code>select distinct rule_name,app,product_line_id from rule_case;</code>是对后面的<code>rule_name,app,product_line_id</code>都不同的情况列出来，而第9和10跟第一条的<code>rule_name,app,product_line_id</code>是一样的，就被去重掉，只保留第一个记录。</p>
<p>所以结论：要查询多个字段，但只针对一个字段去重，使用distinct去重的话是无法实现的。</p>
<p>再说<code>group by</code>,<code>group by</code>有一点跟<code>distinct</code>一样：也是对后面所有的字段均起作用，即 去重是查询的所有字段完全重复的数据，而不是只对<code>group by</code>后面连接的单个字段重复的数据。而返回结果排列不同，<code>distinct</code>会按数据存放顺序一条条显示，而<code>group by</code>会做个排序（一般是asc）。比如：<br><img data-src="/images/mysql%E5%8E%BB%E9%87%8D2.png" title="可以明显的看出对比"></p>
<p><code>group by</code>的结果可以根据<code>having</code>条件字段进行进一步的过滤，以及再加上<code>order by</code>进行排序和<code>limit</code>限制输出个数。格式是：where xxx,group by xxx,order by xxx,limit xxx。</p>
<p>那<code>distinct</code>和<code>group by</code>哪个效率更高？</p>
<p><code>distinct</code>操作只需要找出所有不同的值就可以了。而<code>group by</code>操作还要为其他聚集函数进行准备工作。从这一点上将，<code>group by</code>操作做的工作应该比<code>distinct</code>所做的工作要多一些。  </p>
<p>但实际上，<code>group by</code>效率会更高点，为什么呢？对于<code>distinct</code>操作，它会读取了所有记录，而<code>group by</code>需要读取的记录数量与分组的组数量一样多，也就是说比实际存在的记录数目要少很多。</p>
<h2 id="注意在MaxCompute-写法"><a href="#注意在MaxCompute-写法" class="headerlink" title="注意在MaxCompute 写法"></a>注意在MaxCompute 写法</h2><p>阿里云的MaxCompute是不支持使用<code>group by</code>的，会爆<code>FAILED: ODPS-0130071:[1,8] Semantic analysis exception - column reference 表.XXX列 should appear in GROUP BY key</code>这个错误，这里就直接用<code>select distinct key1,key2,key3 from 对应表;</code>来直接获取去重的行即可。</p>
<p>而且再补充一下，阿里云的MaxCompute的<code>INSERT OVERWRITE</code>不支持指定列插入功能，也就是说对应值只能按照表列的顺序插入，不能指定。据说INSERT INTO可以使用，但是它后面只能写值，不支持后面写<code>select XXX</code>的语句，所以为了避免麻烦，我个人都是在MaxCompute只建有用的列，然后用<code>insert overwrite table XXX.XXX SELECT DISTINCT A，B,C,D from XXX.AAA WHERE 具体条件;</code>来写入值。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://php-note.com/article/1753.html">http://php-note.com/article/1753.html</a></p>
<p><img data-src="/images/%E5%AD%97%E6%AF%8D%E5%93%A5%E7%A6%81%E5%8C%BA%E6%89%A3%E7%AF%AE.gif" title="我直呼好家伙！"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Mysql5.7</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql如何判断多列组合起来不重复</title>
    <url>/2020/04/24/Mysql%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E8%A1%8C%E9%83%BD%E4%B8%8D%E5%90%8C%E4%B8%BA%E4%B8%8D%E4%B8%80%E8%87%B4/</url>
    <content><![CDATA[<h2 id="Mysql下的判断"><a href="#Mysql下的判断" class="headerlink" title="Mysql下的判断"></a>Mysql下的判断</h2><p>我最近再做一个Django页面，这个页面主要是展现“攻防演习”的一个细节，判断攻击方一共攻击了多少个场景，如图：<br><img data-src="/images/mysql%E8%A1%8C%E4%B8%80%E8%87%B42.jpg" alt="akb48"></p>
<p>可见<code>practice_scene</code>和<code>app</code>都不同才能算是一个不同的场景，如果他俩相同就是同一个场景，因为攻击方是可以重复攻击同一个场景的。那么如何输出<code>practice_scene</code>和<code>app</code>都不同的列？</p>
<p>写法很简单：<code>SELECT * FROM naxxramas_cappractice where bluearmy_id =6 GROUP BY practice_scene, app ORDER BY id DESC</code>，效果如图：<br><img data-src="/images/mysql%E8%A1%8C%E4%B8%80%E8%87%B43.jpg" alt="akb48"></p>
<p>可见<code>practice_scene</code>和<code>app</code>相同的列已经整合成一个，只暴露了ID比较靠前的那一行。</p>
<p>而现在我想要得到的是行数，那就<code>SELECT count(*) FROM naxxramas_cappractice where bluearmy_id = 6 GROUP BY practice_scene, app ORDER BY id DESC</code>吧，很不幸，答案是错的，如图：<br><img data-src="/images/mysql%E8%A1%8C%E4%B8%80%E8%87%B41.jpg" alt="akb48" title="每一个不同的行数都输出了"><br>	<br>可见这样是把每一个类型的行数输出了，而我想要的只是一个3，怎么办？</p>
<p>答案是：<code>SELECT count(DISTINCT app,practice_scene) FROM naxxramas_cappractice where bluearmy_id =6;</code>  就搞定了，如图：<br><img data-src="/images/mysql%E8%A1%8C%E4%B8%80%E8%87%B44.jpg" alt="akb48"></p>
<h2 id="Django-里的判断"><a href="#Django-里的判断" class="headerlink" title="Django 里的判断"></a>Django 里的判断</h2><p>Django的<code>views.py</code>如何通过models来得到上面的“3”呢？如果是<code>Django 1.X</code>的话，可以使用<code>CAPPractice.objects.filter(bluearmy_id = 6).distinct(&#39;practice_scene, app&#39;)</code> 或者是 <code>CAPPractice.objects.values(&#39;Category&#39;).distinct()</code>。（CAPPractice是naxxramas_cappractice对应的model）</p>
<p>但是这个方法在2.2里已经不能使用了，会爆<code>django.db.utils.NotSupportedError: DISTINCT ON fields is not supported by this database backend</code>，这里我们改一下，<code>CAPPractice.objects.filter(bluearmy_id=6).values(&#39;app&#39;, &quot;practice_scene&quot;).distinct().count()</code> 就好了，然后直接在前端页面直接引用变量即可。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://stackoverflow.com/questions/3852104/select-distinct-individual-columns-in-django">https://stackoverflow.com/questions/3852104/select-distinct-individual-columns-in-django</a><br><a href="https://www.cnblogs.com/cpl9412290130/p/11777633.html">https://www.cnblogs.com/cpl9412290130/p/11777633.html</a><br><a href="https://blog.csdn.net/qq_36815739/article/details/83624100">https://blog.csdn.net/qq_36815739/article/details/83624100</a></p>
<p><img data-src="/images/%E9%87%91%E4%B8%89%E8%83%96%E7%9C%8B%E7%81%AB%E7%AE%AD.jpg" alt="akb48" title="时光匆匆，八年一过，抬头仰望，导弹入云"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql删除某几个字段重复的行</title>
    <url>/2021/04/21/Mysql%E5%88%A0%E9%99%A4%E6%9F%90%E5%87%A0%E4%B8%AA%E5%AD%97%E6%AE%B5%E9%87%8D%E5%A4%8D%E7%9A%84%E8%A1%8C/</url>
    <content><![CDATA[<p>脏数据是一个比较恶心的事情，每次处理都很麻烦。如果只是找以单字段重复的行，那还比较简单，可以看 <a href="https://www.yiibai.com/mysql/delete-duplicate-rows.html">https://www.yiibai.com/mysql/delete-duplicate-rows.html</a> 即可。但是实际工作中会有这样的情况：“找到按某几个字段的重复的行并且删除”。</p>
<p>举个例子：<br><img data-src="/images/%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E8%A1%8C.png" title="MYSQL上已经清理了，这个是odps的例子，他同步到mysql上会生成不重复的id"></p>
<p>上面那个例子里<code>cluster_name</code>和<code>num</code>这两个字段相同才算是一个重复行，而<code>env</code>和<code>dt_date</code>是可以不同的。那么首先先获取到重复的列的方法：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT p1.id </span><br><span class="line">from `naxxramas_slowsql_status` p1,`naxxramas_slowsql_status` p2 </span><br><span class="line">where p1.dt_date =&#x27;20210419&#x27; and p1.id&lt;&gt;p2.id and p1.cluster_name = p2.cluster_name and p1.num = p2.num and p1.dt_date = p2.dt_date </span><br><span class="line">group by p1.cluster_name;</span><br></pre></td></tr></table></figure></p>
<p>上面那个语句很简单，就是取出<code>id</code>不同但是<code>cluster_name</code>和<code>num</code>又相同的单列，而不是把所有的列都取出来。</p>
<p>那么如果要删除对应的行的语句如下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM `naxxramas_slowsql_status` </span><br><span class="line">where id IN (SELECT id FROM </span><br><span class="line">(SELECT p1.id from `naxxramas_slowsql_status` p1,`naxxramas_slowsql_status` p2 where p1.dt_date =&#x27;20210330&#x27; and p1.id&lt;&gt;p2.id and p1.cluster_name = p2.cluster_name and p1.num = p2.num and p1.dt_date = p2.dt_date </span><br><span class="line">group by p1.cluster_name) </span><br><span class="line">AS temp); </span><br></pre></td></tr></table></figure></p>
<p>这里要注意一下，不可以这么写：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM `naxxramas_slowsql_status` </span><br><span class="line">where id IN (</span><br><span class="line">SELECT p1.id </span><br><span class="line">from `naxxramas_slowsql_status` p1,`naxxramas_slowsql_status` p2 </span><br><span class="line">where p1.dt_date =&#x27;20210330&#x27; and p1.id&lt;&gt;p2.id and p1.cluster_name = p2.cluster_name and p1.num = p2.num and p1.dt_date = p2.dt_date </span><br><span class="line">group by p1.cluster_name); </span><br></pre></td></tr></table></figure></p>
<p>这么写会报错：<code>You can&#39;t specify target table &#39;naxxramas_slowsql_status&#39; for update in FROM clause</code>。这句话的意思是“不能在同一语句中更新select出的同一张表元组的属性值”，所以就要用上面的方法：将select出的结果通过中间表再select一遍。</p>
<p>或者使用<code>left join</code>, 比如要update，使用：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update x set available_material_id = null </span><br><span class="line">where id not in </span><br><span class="line">(select id from x where additional_info = 1);</span><br></pre></td></tr></table></figure></p>
<p>就会报错：<code>You can&#39;t specify target table &#39;x&#39; for update in FROM clause</code>。使用<code>left join</code>的sql就是：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update x left join</span><br><span class="line">       x xx</span><br><span class="line">       on x.id = xx.id and xx.additional_info = 1</span><br><span class="line">    set available_material_id = null</span><br><span class="line">    where xx.id is null;</span><br></pre></td></tr></table></figure><br><img data-src="/images/%E5%9B%BD%E7%8E%8B%E6%9D%AF%E5%B0%8F%E9%BB%91%E4%BC%99.gif" title="来之不易的冠军"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql和MaxCompute的多行合并一行</title>
    <url>/2021/10/10/Mysql%E7%9A%84%E5%88%86%E5%89%B2%E4%B8%8Ejoin/</url>
    <content><![CDATA[<p>公司的MaxCompute（也就是ODPS）有些表，开发者会把前端的信息拆开记录，比如这个：<br><img data-src="/images/odps%E5%90%88%E5%B9%B61.png" title="这个是前端对应页面"></p>
<p>对应的MaxCompute记录如下：<br><img data-src="/images/odps%E5%90%88%E5%B9%B62.png" title="可见他把每一行的信息都单独记录，这样方便他修正"></p>
<p>这种方法其实无疑会增加磁盘使用量的，原本可以一行搞定，却设置成了多行。但是作为使用方我们只能被动接受，所以遇到这种情况我们就需要merge一下我们需要的内容，这样让领导可以更加清晰直观的看到报表。</p>
<p>MaxCompute里拼接字符串的函数是<code>wm_concat</code>，官方文档是： <a href="https://www.alibabacloud.com/help/zh/doc-detail/48975.htm">https://www.alibabacloud.com/help/zh/doc-detail/48975.htm</a> 。直接使用它就可以把字符串通过连接符合并，但是有一个问题，就是我上图里，id_template_detail&#x3D;1592的值，有对应的含义，3就是“线上配置”，如图：<br><img data-src="/images/odps%E5%90%88%E5%B9%B63.png" title="配置的前端"></p>
<p>这样就涉及到一个<code>case...when</code>的转换，最后整个语句如下，这个是一个四表联合的查询：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SELECT  a.gmt_create AS 变更单提交时间</span><br><span class="line">        ,a.name_creator AS 变更发起人</span><br><span class="line">        ,b.super_show_name AS 主管</span><br><span class="line">        ,split_part(b.dept_name,<span class="string">&#x27;-&#x27;</span>,<span class="number">2</span>,<span class="number">3</span>) AS 域	-- 这里把部门按照-分开</span><br><span class="line">        ,a.title_order AS 变更内容</span><br><span class="line">        ,wm_concat(<span class="string">&#x27;,&#x27;</span>, (CASE </span><br><span class="line">            WHEN d.value_content=<span class="number">1</span> THEN <span class="string">&#x27;修复BUG&#x27;</span> </span><br><span class="line">            WHEN d.value_content=<span class="number">2</span> THEN <span class="string">&#x27;业务需求&#x27;</span> </span><br><span class="line">            WHEN d.value_content=<span class="number">3</span> THEN <span class="string">&#x27;线上配置&#x27;</span></span><br><span class="line">            ELSE d.value_content</span><br><span class="line">            END)) AS 变更理由</span><br><span class="line">        ,CONCAT(<span class="string">&quot;https://www.pornhub.com/&quot;</span>,a.<span class="built_in">id</span>) AS 变更链接</span><br><span class="line">FROM    变更信息表 AS a</span><br><span class="line">INNER  JOIN  员工表 AS b</span><br><span class="line">ON     LPAD(a.creator, <span class="number">10</span>, <span class="number">0</span>) = LPAD(b.work_no, <span class="number">10</span>, <span class="number">0</span>)		-- 工号前面的<span class="number">0</span>对齐</span><br><span class="line">INNER JOIN 变更关联模板表 <span class="keyword">as</span> c</span><br><span class="line">ON      a.<span class="built_in">id</span> = c.id_down_order</span><br><span class="line">INNER JOIN 变更模板信息细节表 AS d</span><br><span class="line">ON      d.id_order = c.<span class="built_in">id</span></span><br><span class="line">WHERE   a.gmt_create &gt; TO_CHAR( DATEADD( GETDATE() , -<span class="number">1</span>, <span class="string">&#x27;dd&#x27;</span> ) ,<span class="string">&#x27;yyyy-MM-dd 00:00:00&#x27;</span>)</span><br><span class="line">AND     a.title_order like <span class="string">&#x27;应用【%】变更&#x27;</span></span><br><span class="line">AND     b.dept_name IN (<span class="string">&#x27;A-a-1部门&#x27;</span>,<span class="string">&#x27;B-b-1部门&#x27;</span>,<span class="string">&#x27;C-c-1部门&#x27;</span>)</span><br><span class="line">AND     a.dt = TO_CHAR( DATEADD( GETDATE() , - <span class="number">1</span>, <span class="string">&#x27;dd&#x27;</span> ) ,<span class="string">&#x27;yyyyMMdd&#x27;</span>)</span><br><span class="line">AND     d.dt = TO_CHAR( DATEADD( GETDATE() , - <span class="number">1</span>, <span class="string">&#x27;dd&#x27;</span> ) ,<span class="string">&#x27;yyyyMMdd&#x27;</span>)</span><br><span class="line">AND     c.dt = TO_CHAR( DATEADD( GETDATE() , - <span class="number">1</span>, <span class="string">&#x27;dd&#x27;</span> ) ,<span class="string">&#x27;yyyyMMdd&#x27;</span>)</span><br><span class="line">GROUP BY CF单提交时间,变更发起人,工号,主管,域,变更内容,变更链接;</span><br></pre></td></tr></table></figure></p>
<p>如果是两个值，那么可以使用<code>if</code>,多个值就是<code>case...when</code>,他俩对应的文档是 <a href="https://help.aliyun.com/document_detail/48976.html#section-jvg-uf1-mnr">https://help.aliyun.com/document_detail/48976.html#section-jvg-uf1-mnr</a> 。</p>
<p>在上面的基础上，如果要查询有多少个是<code>修复BUG</code>,多少个是<code>业务需求</code>，可以这样：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select SUM(CASE WHEN d.value_content = 1 THEN 1 ELSE 0 END) AS bug_num,SUM(CASE WHEN d.value_content = 2 THEN 1 ELSE 0 END) AS demand_num form XXX GROUP BY 去重条件;</span><br></pre></td></tr></table></figure></p>
<p>如果是mysql，那么要把返回的多个行合并到一个行里，使用的函数是<code>group_concat</code>，举个例子，以id分组，把name字段的值打印在一行，分号分隔：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mysql&gt; select <span class="built_in">id</span>,group_concat(name separator <span class="string">&#x27;;&#x27;</span>) <span class="keyword">from</span> aa group by <span class="built_in">id</span>;</span><br></pre></td></tr></table></figure></p>
<p>在上面的基础上，把去冗余的name字段的值打印在一行，这次用默认的逗号分隔：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mysql&gt; select <span class="built_in">id</span>,group_concat(distinct name) <span class="keyword">from</span> aa group by <span class="built_in">id</span>;</span><br></pre></td></tr></table></figure></p>
<p>这样就达到了自由拼接select出你想要的结果的目的了。<br><img data-src="/images/%E4%B9%94%E4%B8%B9%E6%BB%9E%E7%A9%BA%E6%89%93%E6%9D%BF.webp" title="帮主滞空打板得分"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>MaxCompute</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql的强制类型转换导致全表扫描</title>
    <url>/2021/02/19/Mysql%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%AF%BC%E8%87%B4%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F/</url>
    <content><![CDATA[<p>MySQL在查询的时候要注意“强制类型转换导致死锁”的case，这里的强制类型转换主要有如下几种：</p>
<h2 id="列类型与where值类型不符"><a href="#列类型与where值类型不符" class="headerlink" title="列类型与where值类型不符"></a>列类型与where值类型不符</h2><p>我们先创建一个表，比如叫<code>article</code>:<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS article( </span><br><span class="line">	`aid` INT UNSIGNED AUTO_INCREMENT, </span><br><span class="line">	`title` VARCHAR(<span class="number">100</span>) NOT NULL, </span><br><span class="line">	`content` VARCHAR(<span class="number">2000</span>) NOT NULL,</span><br><span class="line">	`categories` NVARCHAR(<span class="number">2000</span>) NOT NULL,</span><br><span class="line">	`uid` INT NOT NULL,</span><br><span class="line">	`tid` INT NOT NULL,</span><br><span class="line"> 	PRIMARY KEY ( `aid` )</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure></p>
<p>我们都知道mysql自增的字段必须是主键,而表的主键一般都要使用自增id，不建议使用业务id，是因为使用自增id可以避免页分裂。创建表之后，<code>CREATE INDEX titleindex ON article (title)</code>，给<code>title</code>字段设定成索引。</p>
<p>再往表里插入一点数据，数据如下：<br><img data-src="/images/mysql%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F1.png" title="插入索引成功"></p>
<p>这是测试一下如下语句：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">explain select uid,tid <span class="keyword">from</span> article where title = <span class="string">&#x27;bbb&#x27;</span>;	<span class="comment">#&#x27;bbb&#x27;是字符串跟title的varchar一致</span></span><br><span class="line">explain select uid,tid <span class="keyword">from</span> article where title = <span class="number">123</span>;	<span class="comment">#123是int与title的varchar不一致</span></span><br></pre></td></tr></table></figure></p>
<p>测试效果：<br><img data-src="/images/mysql%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F2.png"></p>
<p>title是我们设定的索引列，第一个情况where的值与title类型相同，成功命中索引。第二个SQL就要面临强制类型转换，没有命中索引，扫描了全表。</p>
<p>这里补充一下，如果你直接使用<code>select uid,tid from article where title = 123;</code>会产生4个<code>warnings</code>，如图：<br><img data-src="/images/mysql%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F3.png"></p>
<p>其实这几个警告就是通知你，<code>title</code>这一列是<code>varchar</code>的，却在上面的sql语句里直接用了int类型赋予它。</p>
<p>再建一个表：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS `user`( </span><br><span class="line">	`uid` INT UNSIGNED AUTO_INCREMENT, </span><br><span class="line">	`username` VARCHAR(<span class="number">100</span>) NOT NULL, </span><br><span class="line">	`email` VARCHAR(<span class="number">40</span>) NOT NULL, </span><br><span class="line">	PRIMARY KEY ( `uid` )</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=latin1;</span><br></pre></td></tr></table></figure></p>
<p>查看<code>CHARSET</code>不能用<code>desc XXX</code>，而是用<code>show create table XXX</code>。如图：<br><img data-src="/images/mysql%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F4.png"></p>
<p>测试一下语句：<code>explain select * from article a,user b where a.uid=b.uid;</code>,如图：<br><img data-src="/images/mysql%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F5.png"></p>
<p>发现<code>article</code>的<code>uid</code>列不是索引，所以就要全表扫描，扫描了4行，但是<code>article</code>的每一条记录使用b即<code>user</code>的索引，所以只扫描一行。</p>
<p>再测试一下：<code>explain select * from article a,user b where a.uid=b.username;</code>，如图：<br><img data-src="/images/mysql%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F6.png"></p>
<p>发现uid跟username类型根本对不上，所以两个都要扫描全表。这里要注意！<code>NVARCHAR</code>跟<code>VARCHAR</code>不是同一个类型，也会触发扫描全表。</p>
<p>插播一句，如果要后期修改<code>CHARSET</code>,语句是<code>ALTER TABLE user DEFAULT CHARACTER SET utf8;</code>。</p>
<p>还有一种情况比较隐蔽，就是两个表字符集不同，比如一个是utf8另一个是lartin1。或者是字符集相同都是utf8但是排序规则不同，比如一个是<code>utf8_esperanto_ci</code>，另一个是默认的<code>utf8_general_ci</code>.那么这样即使对应的两个关联属性相同都是主键，也不会命中索引，只会导致笛卡尔积的循环计算(nested loop)。详情可见<a href="https://blog.csdn.net/weixin_32187037/article/details/113595144">https://blog.csdn.net/weixin_32187037/article/details/113595144</a> 的第二个例子。我用的是mysql8,这个问题已经被修复了，字符集不再影响索引了。</p>
<p>最后推荐一个很有含金量的一个case：<a href="https://www.cnblogs.com/MYSQLZOUQI/articles/3837828.html%EF%BC%8C%E5%8F%AF%E4%BB%A5%E9%87%8D%E7%82%B9%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%8B%E5%AE%83%E7%9A%84%E6%8E%92%E6%9F%A5%E8%BF%87%E7%A8%8B%E3%80%82">https://www.cnblogs.com/MYSQLZOUQI/articles/3837828.html，可以重点学习一下它的排查过程。</a></p>
<h2 id="查看sql执行的时长"><a href="#查看sql执行的时长" class="headerlink" title="查看sql执行的时长"></a>查看sql执行的时长</h2><p>在工作里经常要查看某个语句执行的时长，一般来说都是用<code>show profiles</code> + <code>show profile for query XXX</code>的方法，这里说一个新一点的：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> @d=now();</span><br><span class="line">你要执行的那个SQL语句;</span><br><span class="line">select timestampdiff(second,@d,now());</span><br></pre></td></tr></table></figure></p>
<p>有一点要注意，就是在最后面，一定要多copy一个空行，不然最后一个sql要你自己按回车执行，这样就不准了。</p>
<p>如果是数据比较少，SQL执行比较快，用毫秒为单位，那就是把最后一句改成<code>select timestampdiff(MICROSECOND, @d, now(3)) / 1000 as &#39;耗时(ms)&#39;;</code>即可以统计耗时的毫秒数。如图：<br><img data-src="/images/mysql%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F7.png"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/qq_29663071/article/details/75021980">https://blog.csdn.net/qq_29663071/article/details/75021980</a><br><a href="https://www.cnblogs.com/guodongdidi/p/6290782.html">https://www.cnblogs.com/guodongdidi/p/6290782.html</a><br><a href="https://www.sudops.com/mysql-console-can-not-type-chinese.html">https://www.sudops.com/mysql-console-can-not-type-chinese.html</a><br><a href="https://mp.weixin.qq.com/s/LvIvSUf-BVKU5ORNm_qUcA">https://mp.weixin.qq.com/s/LvIvSUf-BVKU5ORNm_qUcA</a> （mysql军规）</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql语句导出成excel时解决科学计数法的情况</title>
    <url>/2019/01/04/Mysql%E8%AF%AD%E5%8F%A5%E5%AF%BC%E5%87%BA%E6%88%90excel%E6%97%B6%E8%A7%A3%E5%86%B3%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%95%E7%9A%84%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<h2 id="普通情况导出excel"><a href="#普通情况导出excel" class="headerlink" title="普通情况导出excel"></a>普通情况导出excel</h2><p>将结果直接导出到<code>/tmp/result.xls</code>：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mysql -h127<span class="number">.0</span><span class="number">.0</span><span class="number">.1</span> -u用户名 -p密码 -e <span class="string">&quot;具体SQL命令&quot;</span> database名 &gt; /tmp/result.xls	<span class="comment">#请注意单引号双引号</span></span><br></pre></td></tr></table></figure></p>
<h2 id="解决科学计数法"><a href="#解决科学计数法" class="headerlink" title="解决科学计数法"></a>解决科学计数法</h2><p>有时候数据库里会有比较长的数字，比如订单号或者身份证号，但是由于excel的操蛋设定，长数字在导出后在Excel中打开后却是用科学计数法显示的，过长的话，后面几位数字全都转换为0了，解决这样问题的方法就是引入<code>CONCAT</code>：</p>
<p>比如我要从<code>sdb_b2c_delivery</code>这个tables里查询两个时间戳之间的情况，将结果导出到<code>/tmp/result.xls</code>：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mysql -h127<span class="number">.0</span><span class="number">.0</span><span class="number">.1</span> -u用户名 -p密码 -e <span class="string">&#x27;SELECT CONCAT(&quot;&quot;,对应的列名1),CONCAT(&quot;&quot;,对应的列名2) FROM sdb_b2c_delivery WHERE t_begin &gt;= 1543593600 AND t_begin &lt;= 1546271999;&#x27;</span> database名 &gt; /tmp/result.xls	<span class="comment">#请注意单引号双引号</span></span><br></pre></td></tr></table></figure></p>
<p>但是这样导出来的结果还是科学计数法，不过可以修改单元格格式，改成“数值”，然后把小数位数改成0即可。<br><img data-src="/images/excel10.png" alt="akb48"></p>
<h2 id="解决中文乱码的问题"><a href="#解决中文乱码的问题" class="headerlink" title="解决中文乱码的问题"></a>解决中文乱码的问题</h2><p>有时候数据库里会有中文，但是导出的时候发现excel看到的中文全是乱码，解决这样问题的方法需要加上<code>--default-character-set=utf8</code>，比如：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mysql -h127<span class="number">.0</span><span class="number">.0</span><span class="number">.1</span> -u用户名 -p密码 --default-character-<span class="built_in">set</span>=utf8 -e <span class="string">&#x27;SELECT CONCAT(&quot;&quot;,对应的列名1),CONCAT(&quot;&quot;,对应的列名2) FROM sdb_b2c_delivery WHERE t_begin &gt;= 1543593600 AND t_begin &lt;= 1546271999;&#x27;</span> database名 &gt; /tmp/result.xls	<span class="comment">#请注意单引号双引号</span></span><br></pre></td></tr></table></figure></p>
<p>将<code>result.xls</code>直接使用notepad++打开，然后将excel列的格式设置为文本，再粘贴就能得到正确的表格了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/2c8bfbfcd288">https://www.jianshu.com/p/2c8bfbfcd288</a><br><a href="https://qianrong.me/sql/2.html">https://qianrong.me/sql/2.html</a></p>
<p><img data-src="/images/akun.gif" alt="akb48" title="阿坤小角度攻破阿里森"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql里添加一列内容是另一个表的对应列</title>
    <url>/2021/03/25/Mysql%E9%87%8C%E6%B7%BB%E5%8A%A0%E4%B8%80%E5%88%97%E5%86%85%E5%AE%B9%E6%98%AF%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%A1%A8%E7%9A%84%E5%AF%B9%E5%BA%94%E5%88%97/</url>
    <content><![CDATA[<p>假设我有一个表叫<code>worker</code>，记录运动员的信息，里面的内容是这样的：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from worker;</span><br><span class="line">+----+--------+----------+-----+--------+</span><br><span class="line">| id | name   | team     | job | number |</span><br><span class="line">+----+--------+----------+-----+--------+</span><br><span class="line">|  1 | jordan | bulls    | sg  | NULL   |</span><br><span class="line">|  2 | kobe   | lakers   | sg  | NULL   |</span><br><span class="line">|  3 | shaq   | lakers   | c   | NULL   |</span><br><span class="line">|  4 | curry  | warriors | pg  | NULL   |</span><br><span class="line">|  5 | james  | heats    | sf  | NULL   |</span><br><span class="line">|  6 | harden | rockets  | sg  | NULL   |</span><br><span class="line">|  7 | green  | warriors | pf  | NULL   |</span><br><span class="line">|  8 | rodman | bulls    | pf  | NULL   |</span><br><span class="line">|  9 | pippen | bulls    | sf  | NULL   |</span><br><span class="line">+----+--------+----------+-----+--------+</span><br><span class="line">9 rows in set (0.29 sec)</span><br></pre></td></tr></table></figure></p>
<p>还有一个表是记录球员跟背号的关系的，叫<code>number</code>：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from number;</span><br><span class="line">+----+---------+--------+</span><br><span class="line">| id | name    | number |</span><br><span class="line">+----+---------+--------+</span><br><span class="line">|  1 | jordan  |     23 |</span><br><span class="line">|  2 | kobe    |     24 |</span><br><span class="line">|  3 | james   |      6 |</span><br><span class="line">|  4 | wade    |      3 |</span><br><span class="line">|  5 | iverson |      3 |</span><br><span class="line">|  6 | shaq    |     34 |</span><br><span class="line">|  7 | curry   |     30 |</span><br><span class="line">|  8 | rodman  |     91 |</span><br><span class="line">|  9 | pippen  |     33 |</span><br><span class="line">| 10 | duncan  |     21 |</span><br><span class="line">| 11 | green   |     23 |</span><br><span class="line">+----+---------+--------+</span><br><span class="line">11 rows in set (0.46 sec)</span><br></pre></td></tr></table></figure></p>
<p>现在我想让<code>worker</code>的<code>number</code>列的内容是<code>number</code>里对应球员的背号，这个语句怎么办？搞了半天，答案是:<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update worker a set a.number = (select b.number from number b where b.name=a.name) where exists (select null from number b where b.name=a.name);</span><br></pre></td></tr></table></figure></p>
<p>效果如图:<br><img data-src="/images/MySQL%E5%86%99%E5%88%97%E5%86%85%E5%AE%B9.png" title="number表里没有内容就是null"></p>
<p>这里要注意一下，如果<code>player</code>表有重复行，比如：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----+--------+----------+-----+--------+</span><br><span class="line">| id | name   | team     | job | number |</span><br><span class="line">+----+--------+----------+-----+--------+</span><br><span class="line">|  1 | james | cavs    | sf  | NULL   |</span><br><span class="line">|  2 | james | heats   | sf  | NULL   |</span><br><span class="line">|  3 | james | lakers  | sf  | NULL   |</span><br><span class="line">+----+---------+--------+</span><br><span class="line">11 rows in set (0.16 sec)</span><br></pre></td></tr></table></figure></p>
<p>那么上面语句会报错，提示“返回行不止一行”，这个时候需要添加<code>GROUP BY</code>，过滤重复项:<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update worker a set a.number = (select b.number from number b where b.name=a.name GROUP BY b.name) where exists (select null from number b where b.name=a.name);</span><br></pre></td></tr></table></figure></p>
<p>这样过滤重复项，只留一个James就好了，但是如果<code>number</code>有多个背号，比如詹姆斯穿6号还有23号，那么语句还是要改。<br><img data-src="/images/%E5%A4%A7%E8%B6%85%E5%A4%8D%E6%B4%BB.jpg" title="黑衣大超晒太阳"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx的allow、deny配置负载均衡真实IP的方法</title>
    <url>/2019/08/19/Nginx%E7%9A%84allow%E3%80%81deny%E9%85%8D%E7%BD%AE%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9C%9F%E5%AE%9EIP%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>先说一下故事背景：nginx前端有一个阿里云SLB，然后外界从443进入SLB，SLB将流量转到nginx的80端口，同时80做了一个反向代理到同机器的8082端口服务。8082服务的配置文件如下：<br><img data-src="/images/nginxV8.png" alt="抱光妹"></p>
<p>但是这样的配置发现了一个问题：虽然已经<code>allow 127.0.0.1</code>，但是在浏览器里还是能正常打开<code>/status</code>界面，如图：<br><img data-src="/images/nginxV9.png" alt="抱光妹"></p>
<p>原因是deny和allow后面跟着的IP都是<code>$remote_addr</code>，而我这个环境里后端8082的服务，看到的<code>$remote_addr</code>就是<code>127.0.0.1</code>，所以才会出现这样子。那么如何解决呢？</p>
<p>一般来说遇到这种有代理的情况，我们都是用<code>http_x_forwarded_for</code>来获取后端的真实IP，但是如何让deny和allow去搭配<code>http_x_forwarded_for</code>呢？用<code>real_ip_header</code>。</p>
<p>首先先<code>nginx -V</code>查看一下是否有<code>--with-http_realip_module</code>的模块，如果没有，那么需要重新编译nginx，如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">./configure  --prefix=/etc/nginx --sbin-path=/usr/sbin/nginx --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx.lock --http-client-body-temp-path=/var/cache/nginx/client_temp --http-proxy-temp-path=/var/cache/nginx/proxy_temp --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp --http-scgi-temp-path=/var/cache/nginx/scgi_temp --user=nginx --group=nginx --<span class="keyword">with</span>-http_ssl_module --<span class="keyword">with</span>-http_realip_module --<span class="keyword">with</span>-http_addition_module --<span class="keyword">with</span>-http_sub_module --<span class="keyword">with</span>-http_dav_module --<span class="keyword">with</span>-http_flv_module --<span class="keyword">with</span>-http_mp4_module --<span class="keyword">with</span>-http_gunzip_module --<span class="keyword">with</span>-http_gzip_static_module --<span class="keyword">with</span>-http_random_index_module --<span class="keyword">with</span>-http_secure_link_module --<span class="keyword">with</span>-http_stub_status_module --<span class="keyword">with</span>-http_auth_request_module --<span class="keyword">with</span>-threads --<span class="keyword">with</span>-stream --<span class="keyword">with</span>-stream_ssl_module --<span class="keyword">with</span>-mail --<span class="keyword">with</span>-mail_ssl_module --<span class="keyword">with</span>-file-aio --<span class="keyword">with</span>-ipv6 --<span class="keyword">with</span>-http_spdy_module --<span class="keyword">with</span>-cc-opt=<span class="string">&#x27;-O2 -g&#x27;</span></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p>
<p>然后将上面文件的<code>status|ping</code>那段<code>location</code>改成如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">location ~ ^/(status|ping)$ &#123;</span><br><span class="line">    real_ip_header X-Forwarded-For;</span><br><span class="line">    set_real_ip_from <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">0</span>;</span><br><span class="line">    real_ip_recursive on;</span><br><span class="line">    allow 准许访问的IP地址<span class="number">1</span>;</span><br><span class="line">    allow 准许访问的IP地址<span class="number">2</span>;</span><br><span class="line">    allow 准许访问的IP地址<span class="number">3</span>;</span><br><span class="line">    deny <span class="built_in">all</span>;</span><br><span class="line">    fastcgi_pass <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9000</span>;</span><br><span class="line">    include fastcgi.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>解释一下语法：</p>
<ol>
<li><code>real_ip_header X-Forwarded-For</code>表示从哪个header头检索出要的IP地址；</li>
<li><code>set_real_ip_from</code>真实服务器上一级代理的IP地址或者IP段，不过经过我的反复试验，发现这个代理地址无法确定。不过我胆子大，写了<code>0.0.0.0/0</code>，这代表所有转发的IP都会被承认；</li>
<li><code>real_ip_recursive</code>的用途：递归的去除所配置中的可信IP，排除<code>set_real_ip_from</code>里面出现的IP。如果出现了未出现这些IP段的IP，那么这个IP将被认为是用户的IP；</li>
</ol>
<p>重启nginx之后，就OK了。</p>
<p>不过问题还是有两个：</p>
<ol>
<li><code>http_x_forwarded_for</code>是可以伪造的，因为这个值是通过获取HTTP头的<code>X_FORWARDED_FOR</code>属性取得，那有没有比它更准确的方法？</li>
<li><code>set_real_ip_from</code>后面填写的IP究竟是不是<code>http_x_forwarded_for</code>多个IP后面的值？</li>
</ol>
<p><a href="https://blog.51cto.com/wks97/2084302">https://blog.51cto.com/wks97/2084302</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx动态编译新的模块</title>
    <url>/2018/01/03/Nginx%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91%E6%96%B0%E7%9A%84%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="开始动手"><a href="#开始动手" class="headerlink" title="开始动手"></a>开始动手</h2><p>打算给电脑上的nginx添加一个当时没有编译安装的echo-nginx-module模块，这是一个第三方模块，要知道nginx要添加模块是需要重新编译的，这一点跟apache不同，apache是在配置文件里引用.so文件的。</p>
<p>首先先<code>nginx -V</code>，查看一下nginx已经编译的模块都有啥，如图：<br><img data-src="/images/nginxV.png" alt="akb48" title="nginx模块一览"></p>
<p>于是我就<code>git clone https://github.com/openresty/echo-nginx-module</code>，但是发现竟然告诉我“git: command not found”。oh shit，原来这台nginx实验机器压根就没有装过git啊！而yum源里的软件基本上已经过时的太久了，就拿git来说吧，使用<code>yum info git </code>看到的版本是1.8.3.1。但是在<a href="https://github.com/git/git/releases">https://github.com/git/git/releases</a> 里可以看到，git的版本现在已经丧心病狂的到达了2.16的版本了。<br><img data-src="/images/yuminfogit.png" alt="akb48" title="git版本太落后"></p>
<h2 id="那么我们先安装git"><a href="#那么我们先安装git" class="headerlink" title="那么我们先安装git!"></a>那么我们先安装git!</h2><p>通过<code>yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel</code>和<code>yum install  gcc perl-ExtUtils-MakeMaker</code>来安装依赖库。<code>wget https://github.com/git/git/archive/v2.16.0-rc0.tar.gz</code>来下载2.16的git保存到centos里。<code>tar -xzvf v2.9.2.tar.gz -C /目标目录/</code>，然后在目标目录里面执行<code>make prefix=/usr/local/git all</code>和<code>make prefix=/usr/local/git install</code>，编译过程可能会比较长，请耐心等待。</p>
<p>编译结束之后，<code>echo &quot;export PATH=$PATH:/usr/local/git/bin&quot; &gt;&gt; /etc/bashrc</code>，把git添加到环境变量，再<code>source /etc/bashrc</code>让它实时生效，最后再一次看看<code>git --version</code>，大功告成！<br><img data-src="/images/gitversion.png" alt="akb48" title="展现git版本"></p>
<h2 id="编译新模块"><a href="#编译新模块" class="headerlink" title="编译新模块"></a>编译新模块</h2><p>git搞定了之后，重新<code>git clone https://github.com/openresty/echo-nginx-module</code>，然后在nginx的configure文件夹里面，把echo-nginx-module模块添加上。命令如下：<br><code>./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-pcre=/root/pcre-8.41 --with-http_v2_module --add-module=/root/echo-nginx-module-0.61</code>,我这里还附赠了一个“http_v2_module”。</p>
<p>configure完毕之后，去<code>make</code>一下就可以了，不要轻易<code>make install</code>，不然就是重新安装了。原来的nginx.conf等配置都没了。</p>
<p>养成替换nginx二进制文件的好习惯，如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.<span class="property">bak</span></span><br><span class="line">cp nginx编译目录/objs/nginx /usr/local/nginx/sbin/</span><br></pre></td></tr></table></figure></p>
<p>然后再打开看一下<code>nginx -V</code><br><img data-src="/images/nginxV2.png" alt="akb48" title="安装模块成功"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql里使用OUTER JOIN报错</title>
    <url>/2021/02/20/Mysql%E9%87%8C%E4%BD%BF%E7%94%A8OUTER-JOIN%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>延续 <a href="https://brucewayne2099.github.io/2021/02/19/Mysql%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%AF%BC%E8%87%B4%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F/">https://brucewayne2099.github.io/2021/02/19/Mysql的强制类型转换导致全表扫描/</a> 一文的表，再创建一个表：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS `<span class="built_in">type</span>`(</span><br><span class="line"> 	`tid` INT UNSIGNED AUTO_INCREMENT, </span><br><span class="line"> 	`typename` VARCHAR(<span class="number">100</span>) NOT NULL, </span><br><span class="line"> 	PRIMARY KEY ( `tid` ) </span><br><span class="line"> 	)ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure></p>
<p>再加上一些数据：<code>INSERT INTO type (typename) VALUES (&quot;good&quot;), (&quot;Bad&quot;), (&quot;Excellent&quot;);</code>。此时里面数据如下：<br><img data-src="/images/mysql%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F8.png" title="原始数据"></p>
<p>使用一下<code>SELECT article.aid,article.title,user.username,type.typename FROM article INNER JOIN user ON article.uid=user.uid INNER JOIN type ON article.tid=type.tid;</code>，效果如图：<br><img data-src="/images/mysql%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F9.png" title="用join将三个表组成一个大表"></p>
<p>那再试试<code>outer join</code>，发现有报错：<br><img data-src="/images/mysql%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F10.png" title="跪了..."></p>
<p>明明说<code>inner join A和B</code>获得的是A和B的交集(intersect)，<code>outer join A和B</code>获得的是A和B的并集(union)，为啥会报错？</p>
<p>答案是免费版的mysql不支持，只有企业版才支持。那既然普通的MySQL看来是不支持<code>full outer join</code>的了，可以这么处理：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">select article.aid,article.title,article.content,user.username <span class="keyword">from</span> `article` left join `user` on article.uid=user.uid </span><br><span class="line">union </span><br><span class="line">select article.aid,article.title,article.content,user.username <span class="keyword">from</span> `article` right join `user` on article.tid=user.uid;</span><br></pre></td></tr></table></figure></p>
<p>效果如图：<br><img data-src="/images/mysql%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F13.png" title="这个语句的效果就是求article跟user两表的排列并集"></p>
<h2 id="Mysql8远程链接的问题"><a href="#Mysql8远程链接的问题" class="headerlink" title="Mysql8远程链接的问题"></a>Mysql8远程链接的问题</h2><p>登进MySQL在命令行如下操作：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mysql&gt;use mysql</span><br><span class="line">mysql&gt;update user <span class="built_in">set</span> host=<span class="string">&#x27;%&#x27;</span> where user =<span class="string">&#x27;root&#x27;</span>; <span class="comment">#&#x27;%&#x27;表示允许外部访问</span></span><br><span class="line">mysql&gt;FLUSH PRIVILEGES;	<span class="comment">#将当前user和privilige表中的用户信息/权限设置从mysql库(MySQL数据库的内置库)中提取到内存里，不重启MySQL直接生效</span></span><br><span class="line">mysql&gt;GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span>WITH GRANT OPTION;</span><br></pre></td></tr></table></figure><br>然后Navicat就可以通过账户密码访问了。</p>
<p>如果Navicat爆出<code>mysql_native_password</code>这个错误，那就是要改一下root加密方式从<code>caching_sha2_password</code>修改成<code>mysql_native_password</code>:<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">update user <span class="built_in">set</span> plugin=<span class="string">&#x27;mysql_native_password&#x27;</span> where user=<span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<p>这样再去Navicat试试吧。<br><img data-src="/images/mysql%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F11.png" title="成功连接"></p>
<h2 id="mysql启动失败的排查方法"><a href="#mysql启动失败的排查方法" class="headerlink" title="mysql启动失败的排查方法"></a>mysql启动失败的排查方法</h2><p>机器原来用的是mysql8，但是发现还是用回mysql 5.7比较好，于是就卸载了mysql 8，安装了5.7。但是启动的时候，发现失败，使用<code>mysql --help | grep my.cnf</code>找到my.cnf的地址，然后在my.cnf里找log-error，发现对应的mysql错误日志路径，如图：<br><img data-src="/images/mysql%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F14.png"><br>打开日志后发现启动失败的原因是这样一句话：<code>[ERROR] [FATAL] InnoDB: Table flags are 0 in the data dictionary but the flags in file ./ibdata1 are 0x4800!</code>。</p>
<p>找到问题了，InnoDB的问题。原来安装的是mysql8.0版本，比现在的5.7版本要高，但在高版本数据库时创建的一些数据库数据都还在，使用的是高版本的InnoDB引擎，而低版本的数据库服务还是指向了这些数据，但是一些版本的数据格式不同，这个时候，我们只要把高版本的数据删掉就可以了，删掉后重新启动mysql就可以了。</p>
<p>删除高版本数据库时创建的数据，不是仅仅删除创建的一些数据库，而是把整个mysql的数据目录全部删除。语句是：<code>sudo rm -rf /var/lib/mysql/*</code>，然后<code>systemctl start mysqld</code>和<code>systemctl enable mysqld</code>就OK了。</p>
<h2 id="Royal-tsx启动失败和自动断开的问题"><a href="#Royal-tsx启动失败和自动断开的问题" class="headerlink" title="Royal tsx启动失败和自动断开的问题"></a>Royal tsx启动失败和自动断开的问题</h2><p>前几天过年没啥事，就手动把macos升级成了<code>Big Sur</code>，结果发现终端连接工具<code>royal tsx</code>就无法启动了。众所周知，Xshell是没有macos版的，很多人也直接用macos的终端来远程连接服务器，但是我还是喜欢有一个终端管理工具，当时就选择了<code>royal tax</code>，这更新了底层系统，应用启动失败，我就懵逼了。查了一圈，发现<a href="https://www.royalapps.com/blog/royal-tsx-and-macos-11-big-sur">https://www.royalapps.com/blog/royal-tsx-and-macos-11-big-sur</a> 里有说明，需要下载符合<code>Big Sur</code>的royal tax才可以。我下载的是5.0.0.7，果然，更新之后，问题解决了。</p>
<p>补充一下，如果用<code>Royal Tsx</code>做文件传输，那么就直接用他的file Transfer即可，方式用的是SFTP，22端口的那个，不要用FTP。</p>
<p>Royal rsx默认闲置一会就自动断开，这点很讨厌。可以这么改：在对应的回话<code>Connections</code>点击右键，选择<code>Properties</code>，左侧菜单栏选择<code>Advanced</code>，然后点击<code>Session</code>,如图配置即可：<br><img data-src="/images/mysql%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F12.png" title="7200秒之后再断开"></p>
<p>这里取消了“当session结束不自动关闭窗口”，同时设置闲置的时候发送一个ascii码来拒绝断开操作。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/lyhabc/p/3378753.html">https://www.cnblogs.com/lyhabc/p/3378753.html</a><br><a href="https://blog.csdn.net/h996666/article/details/80921913">https://blog.csdn.net/h996666/article/details/80921913</a><br><a href="https://blog.csdn.net/qq_35456045/article/details/105554783">https://blog.csdn.net/qq_35456045/article/details/105554783</a><br><a href="https://juejin.cn/post/6844904069786517517#heading-1">https://juejin.cn/post/6844904069786517517#heading-1</a> (centos8安装mysql5.7看这个就行)</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Prometheus配置Alertmanager并实现邮箱告警</title>
    <url>/2019/10/12/Prometheus%E5%A2%9E%E5%8A%A0%E5%91%8A%E8%AD%A6%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%91%E6%8E%A7%E9%A1%B9/</url>
    <content><![CDATA[<h2 id="添加告警配置"><a href="#添加告警配置" class="headerlink" title="添加告警配置"></a>添加告警配置</h2><p>在<a href="https://rorschachchan.github.io/2019/10/08/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2Prometheus/">https://rorschachchan.github.io/2019/10/08/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2Prometheus/</a> 里已经搭建好了Prometheus，当时是把主配置文件<code>prometheus.yml</code>写在了<code>/mnt/promethues/server</code>，然后挂载到相关容器里。现在也在相同目录里编写一个<code>rules.yml</code>，如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">groups:</span><br><span class="line">- name: example</span><br><span class="line">  rules:</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Alert for any instance that is unreachable for &gt;5 minutes.</span></span><br><span class="line">  - alert: load15在告警!	<span class="comment"># 告警规则的名称	</span></span><br><span class="line">    expr: node_load15&#123;group=<span class="string">&quot;server&quot;</span>,instance=<span class="string">&quot;172.31.0.85:9100&quot;</span>,job=<span class="string">&quot;server&quot;</span>&#125; &gt; <span class="number">0</span>	<span class="comment">#给予PromQL的表达式的告警触发条件</span></span><br><span class="line">    <span class="keyword">for</span>: 1m		<span class="comment">#触发条件持续多久之后发送告警</span></span><br><span class="line">    labels:</span><br><span class="line">      severity: node_load	<span class="comment">#自定义标签</span></span><br><span class="line">    annotations:		<span class="comment">#描述，这段信息会作为参数发送给Alertmanager</span></span><br><span class="line">      summary: <span class="string">&quot;实例 &#123;&#123; $labels.instance &#125;&#125; 的load15大于 0&quot;</span></span><br><span class="line">      description: <span class="string">&quot;&#123;&#123; $labels.instance &#125;&#125; of job &#123;&#123; $labels.job &#125;&#125; 值大于 0.&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Alert for any instance that has a median request latency &gt;1s.</span></span><br><span class="line">  - alert: gothreads过多啊！</span><br><span class="line">    expr: go_threads&#123;group=<span class="string">&quot;server&quot;</span>,instance=<span class="string">&quot;172.31.0.85:9100&quot;</span>,job=<span class="string">&quot;server&quot;</span>&#125; &gt; <span class="number">5</span></span><br><span class="line">    <span class="keyword">for</span>: 1m</span><br><span class="line">    annotations:</span><br><span class="line">      summary: <span class="string">&quot;&#123;&#123; $labels.instance &#125;&#125;的gothreads过多&quot;</span></span><br><span class="line">      description: <span class="string">&quot;&#123;&#123; $labels.instance &#125;&#125; has a high gotheads: (current value: &#123;&#123; $value &#125;&#125;s).&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>保存退出之后，在<code>prometheus.yml</code>里的<code>rule_files</code>字段做一下修改：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rule_files:</span><br><span class="line">  - <span class="string">&#x27;rules.yml&#x27;</span>		<span class="comment">#将刚刚编写的rules.yml结合进去</span></span><br></pre></td></tr></table></figure></p>
<p>然后重启一下prometheus（如果不是容器部署的，就是<code>killall -HUP prometheus</code>），再去Prometheus的web界面，先是<code>Status--Rules</code>，看到我们的规则已经导入进去了，并且正常在运行：<br><img data-src="/images/prometheus11.png" alt="akb48"></p>
<p>再点击Alerts，就会看到目前告警处于<code>pending</code>，也就是说准备要告警了：<br><img data-src="/images/prometheus9.png" alt="akb48"></p>
<p>刷新一下，就看到状态已经变成了<code>Firing</code>，即告警了：<br><img data-src="/images/prometheus10.png" alt="akb48"></p>
<p>配置已经成功！不过不要过分激动，这个demo实在是太简单了，我们会在实际的工作里根据具体的场景增加一下难度。</p>
<h2 id="安装Alertmanager"><a href="#安装Alertmanager" class="headerlink" title="安装Alertmanager"></a>安装Alertmanager</h2><p>目前我们已经配置了告警但是还没有配置发送通知，而实现发送通知就需要靠<code>Alertmanager</code>来完成。正常来说<code>Alertmanager</code>没必要跟<code>Prometheus</code>装在一起，只要他俩能正常通讯即可。但是我资源紧张，就安装到一台服务器里了，具体安装方法如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cd /mnt/	<span class="comment">#我安装在mnt目录下</span></span><br><span class="line">wget https://github.com/prometheus/alertmanager/releases/download/v0<span class="number">.19</span><span class="number">.0</span>/alertmanager-<span class="number">0.19</span><span class="number">.0</span>.linux-amd64.tar.gz</span><br><span class="line">tar -zxvf alertmanager-<span class="number">0.19</span><span class="number">.0</span>.linux-amd64.tar.gz</span><br><span class="line">cd  alertmanager-<span class="number">0.19</span><span class="number">.0</span>.linux-amd64</span><br><span class="line">./alertmanager   <span class="comment">#这个是前台运行的</span></span><br></pre></td></tr></table></figure></p>
<p>启动之后，发现9093和9094这两个端口开启了。此时我们再回到<code>prometheus.yml</code>，在最后添加如下内容，把<code>Alertmanager</code>配置到<code>prometheus.yml</code>中：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alerting:</span><br><span class="line">  alertmanagers:</span><br><span class="line">  - scheme: http</span><br><span class="line">    static_configs:</span><br><span class="line">    - targets:</span><br><span class="line">      - <span class="string">&quot;172.31.0.85:9093&quot;</span>	<span class="comment">#这个是Alertmanager所在的服务器IP地址</span></span><br></pre></td></tr></table></figure></p>
<p>这个配置告诉Prometheus，当发生告警时，将告警信息发送到<code>Alertmanager</code>，<code>Alertmanager</code>的地址为<code>http://172.31.0.85:9093</code>。也可以使用命名行的方式指定<code>Alertmanager</code>：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">./prometheus -alertmanager.url=http://<span class="number">172.31</span><span class="number">.0</span><span class="number">.85</span>:<span class="number">9093</span></span><br></pre></td></tr></table></figure></p>
<p>此时我们登陆<code>http://Alertmanager公网IP:9093/#/alerts</code>，就会看到prometheus的alerts的内容出现在了<code>Alertmanager</code>里：<br><img data-src="/images/prometheus12.png" alt="akb48" title="左边是prometheus，右边是alertmanagers"></p>
<p>然后点击具体的告警项目，就会看到一些细节，比如我们在<code>rules.yml</code>里写的<code>description</code>和<code>summary</code>：<br><img data-src="/images/prometheus13.png" alt="akb48"></p>
<h2 id="配置Alertmanager实现邮箱告警"><a href="#配置Alertmanager实现邮箱告警" class="headerlink" title="配置Alertmanager实现邮箱告警"></a>配置Alertmanager实现邮箱告警</h2><p>编辑<code>alertmanager.yml</code>如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">global</span>:</span><br><span class="line">  resolve_timeout: 5m</span><br><span class="line">  smtp_smarthost: <span class="string">&#x27;smtp.163.com:465&#x27;</span></span><br><span class="line">  smtp_from: <span class="string">&#x27;chenx1242@163.com&#x27;</span></span><br><span class="line">  smtp_auth_username: <span class="string">&#x27;chenx1242@163.com&#x27;</span></span><br><span class="line">  smtp_auth_password: <span class="string">&#x27;这里邮箱的密码&#x27;</span></span><br><span class="line">  smtp_require_tls: false	<span class="comment">#注意这个一定要写false，默认是true，若不改成false会有require_tls&#x27; is true (default) but \&quot;smtp.qq.com:465\&quot; does not advertise the STARTTLS extension</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#templates:</span></span><br><span class="line"> 	<span class="comment">#  - &#x27;./template/*.tmpl&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有报警信息进入后的根路由，用来设置报警的分发策略</span></span><br><span class="line">route:</span><br><span class="line">  group_by: [<span class="string">&#x27;chentest&#x27;</span>]	<span class="comment"># 这里的标签列表是接收到报警信息后的重新分组标签</span></span><br><span class="line">  group_wait: 10s	<span class="comment"># 第一次等待多久时间发送一组警报的通知</span></span><br><span class="line">  group_interval: 10s	<span class="comment"># 在发送新警报前的等待时间</span></span><br><span class="line">  repeat_interval: 1m	<span class="comment"># 如果一个报警信息已经发送成功了，等待&#x27;repeat_interval&#x27;时间来重新发送他们</span></span><br><span class="line">  receiver: <span class="string">&#x27;GOOGLE-email&#x27;</span>	 <span class="comment"># 发送警报的接收者的名称，与receivers name的名称相同</span></span><br><span class="line"></span><br><span class="line">receivers:</span><br><span class="line">- name: <span class="string">&#x27;GOOGLE-email&#x27;</span></span><br><span class="line">  email_configs:	<span class="comment"># 邮箱配置</span></span><br><span class="line">  - send_resolved: true		<span class="comment"># 告警解决是否通知，默认是不通知</span></span><br><span class="line">    to: <span class="string">&#x27;chenshuo955@gmail.com&#x27;</span></span><br><span class="line">	<span class="comment">#html: &#x27;&#123;&#123; template &quot;email.html&quot; . &#125;&#125;&#x27;</span></span><br><span class="line">	<span class="comment">#headers: &#123; Subject: &quot;[WARN] 报警邮件&quot;&#125; # 接收邮件的标题</span></span><br><span class="line"></span><br><span class="line">inhibit_rules:</span><br><span class="line">  - source_match:</span><br><span class="line">      severity: <span class="string">&#x27;critical&#x27;</span></span><br><span class="line">    target_match:</span><br><span class="line">      severity: <span class="string">&#x27;warning&#x27;</span></span><br><span class="line">    equal: [<span class="string">&#x27;alertname&#x27;</span>, <span class="string">&#x27;dev&#x27;</span>, <span class="string">&#x27;instance&#x27;</span>]</span><br></pre></td></tr></table></figure></p>
<p>Alertmanager检查配置文件的语句：<code>./amtool check-config alertmanager.yml</code>。如果出现<code>SUCCESS</code>即文件OK！</p>
<p>默认Alertmanager的启动方式：<code>./alertmanager --config.file=alertmanager.yml</code>，不指定<code>config.file</code>则会去读取<code>alertmanager.yml</code>，不过我们还是用systemctl来启动，先编写<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=alertmanager</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Restart=on-failure</span><br><span class="line">ExecStart=/mnt/alertmanager-<span class="number">0.19</span><span class="number">.0</span>.linux-amd64/alertmanager --config.file=/mnt/alertmanager-<span class="number">0.19</span><span class="number">.0</span>.linux-amd64/alertmanager.yml</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></p>
<p>保存之后通过<code>systemctl start alertmanager</code>启动。既然是systemctl启动的进程，那么查看日志的方法就是<code>sudo journalctl _PID=alertmanager进程号</code>：<br><img data-src="/images/prometheus20.png" alt="akb48"></p>
<p>稍等一会，Gmail就会受到邮件，如图：<br><img data-src="/images/prometheus14.png" alt="akb48"></p>
<p>可见在告警邮件里是有在<code>rules.yml</code>配置的<code>summary</code>和<code>description</code>信息。</p>
<p>如果要用docker部署alertmanager的话，语句如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">docker run --name alertmanager --rm -d \</span><br><span class="line">-v /宿主机路径/alertmanager.yml:/etc/alertmanager/alertmanager.yml \</span><br><span class="line">--net=host \</span><br><span class="line">prom/alertmanager</span><br></pre></td></tr></table></figure></p>
<p>为了方便，我们会配置一个模板，这样告警邮件看起来会更加直观，那么就在<code>/mnt/alertmanager-0.19.0.linux-amd64</code>目录下新建一个template文件夹，然后创建一个<code>email.tmpl</code>如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123; define <span class="string">&quot;email.html&quot;</span> &#125;&#125;</span><br><span class="line">&lt;table border=<span class="string">&quot;1&quot;</span>&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;报警项&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;实例&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;报警阀值&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;开始时间&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &#123;&#123; <span class="built_in">range</span> $i, $alert := .Alerts &#125;&#125;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                        &lt;td&gt;&#123;&#123; index $alert.Labels <span class="string">&quot;alertname&quot;</span> &#125;&#125;&lt;/td&gt;</span><br><span class="line">                        &lt;td&gt;&#123;&#123; index $alert.Labels <span class="string">&quot;instance&quot;</span> &#125;&#125;&lt;/td&gt;</span><br><span class="line">                        &lt;td&gt;&#123;&#123; index $alert.Annotations <span class="string">&quot;value&quot;</span> &#125;&#125;&lt;/td&gt;</span><br><span class="line">                        &lt;td&gt;&#123;&#123; $alert.StartsAt &#125;&#125;&lt;/td&gt;</span><br><span class="line">                &lt;/tr&gt;</span><br><span class="line">        &#123;&#123; end &#125;&#125;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后把上面<code>alertmanager.yml</code>里那几个<code>#templates、#html、#headers</code>的注释放开，重新启动alertmanager，一会就可以看到告警了：<br><img data-src="/images/prometheus15.png" alt="akb48"></p>
<p>可见模板已经配置上了。</p>
<h2 id="故障排错"><a href="#故障排错" class="headerlink" title="故障排错"></a>故障排错</h2><p><code>Alertmanager</code>前台启动后，会不停的刷如下的日志：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">level=error ts=<span class="number">2019</span>-<span class="number">10</span>-25T06:<span class="number">50</span>:<span class="number">16.470</span>Z caller=dispatch.go:<span class="number">266</span> component=dispatcher msg=<span class="string">&quot;Notify for alerts failed&quot;</span> num_alerts=<span class="number">1</span> err=<span class="string">&quot;Post http://127.0.0.1:5001/: dial tcp 127.0.0.1:5001: connect: connection refused&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>这个的原因是<code>alertmanager.yml</code>默认情况下的配置是所有的告警都走一个叫<code>web.hook</code>的receiver，而这个receiver配置的就是本地5001端口，如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">receivers:</span><br><span class="line">- name: <span class="string">&#x27;web.hook&#x27;</span></span><br><span class="line">  webhook_configs:</span><br><span class="line">  - url: <span class="string">&#x27;http://127.0.0.1:5001/&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>所以这个报警可以无视掉，等你配置了正确的告警方式就解决掉这个问题了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.li-rui.top/2018/11/12/monitor/Prometheus%20Alertmanager%E4%BD%BF%E7%94%A8/">https://www.li-rui.top/2018/11/12/monitor/Prometheus%20Alertmanager%E4%BD%BF%E7%94%A8/</a><br><a href="https://www.qikqiak.com/post/alertmanager-of-prometheus-in-practice/">https://www.qikqiak.com/post/alertmanager-of-prometheus-in-practice/</a><br><a href="https://www.aneasystone.com/archives/2018/11/prometheus-in-action.html">https://www.aneasystone.com/archives/2018/11/prometheus-in-action.html</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>监控</tag>
        <tag>Prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx使用proxy_pass里的坑</title>
    <url>/2019/07/08/Nginx%E4%BD%BF%E7%94%A8proxy-pass%E9%87%8C%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<h2 id="第一坑"><a href="#第一坑" class="headerlink" title="第一坑"></a>第一坑</h2><p>我们有一个后台服务A，架构是这样：<br>	<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">管理员 ====&gt; nginx ====&gt; AWS的云服务器（服务A）</span><br></pre></td></tr></table></figure></p>
<p>此时在nginx上做了一个<code>proxy_pass</code>的转发，如下：<br>	<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">	server &#123;</span><br><span class="line">    listen <span class="number">8081</span>;</span><br><span class="line">    server_name xxx.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass aws云服务器的IP地址:对应端口;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一直用的挺好，但是后来这个服务业务量上来了，就扩了一台机器，也部署了A服务，然后在前面加上了一个ELB做最小连接数分配，如图：<br>	<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">								AWS的云服务器<span class="number">1</span>（服务A）</span><br><span class="line">管理员 ====&gt; nginx ===&gt; ELB  ===&gt;</span><br><span class="line">								AWS的云服务器<span class="number">2</span>（服务A）</span><br></pre></td></tr></table></figure></p>
<p>此时修改了一下<code>proxy_pass</code>的配置：<br>	<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">	server &#123;</span><br><span class="line">    listen <span class="number">8081</span>;</span><br><span class="line">    server_name xxx.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http:<span class="comment">//aws的ELB域名地址:对应端口;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当时是好使的，但是第二天就不好使了，nginx调用结果是502 Bad Gateway，当时是分别curl路径然后又抓包，一路十三招查下来也没什么头绪。后来发现原来<code>proxy_pass</code>后面如果接的是域名地址的话，那么Nginx会在每次启动和重载设置时，使用DNS将域名解析为IP地址缓存下来，并在之后<font color=red>一直使用这个IP！</font>只有通过<code>nginx -s reload</code>这样的重启才会强制刷新IP，所以当时在nginx上抓包发现跳转的IP其实并不存在。由于在AWS中ELB的内网域名对应的IP并不是一直不变的，这才导致了上面的问题。</p>
<p>新更改的配置如下：<br>	<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">80</span>;</span><br><span class="line">    server_name xxx.xxx.net;</span><br><span class="line"></span><br><span class="line">    resolver DNS服务器地址 valid=<span class="number">30</span>s;		#resolver 是 DNS 服务器地址, valid 设定 DNS 刷新频率</span><br><span class="line">    set $service_lb aws的ELB域名地址;		</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http:<span class="comment">//$service_lb;		#若有路径的必要，就加上$request_uri</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要特别注意的一点是set语句不能写到 location 里面，否则不会生效。</p>
<h2 id="第二坑"><a href="#第二坑" class="headerlink" title="第二坑"></a>第二坑</h2><p><code>proxy_pass</code>这个配置对相对路径和绝对路径也有很有讲究，比如：<br>	<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">location /proxy/ &#123;</span><br><span class="line">        proxy_pass http:<span class="comment">//10.0.0.1:8080/;		#这里以/结尾 </span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>当访问 <a href="http://127.0.0.1/proxy/a/b/c.txt">http://127.0.0.1/proxy/a/b/c.txt</a> 时，nginx匹配到<code>/proxy/</code>路径，把请求转发给10.0.0.1:8080服务，实际请求代理服务器的路径为<br><code>http://10.0.0.1:8080/a/b/c.txt</code>（不带location目录）。</p>
<p>如果是这么写的：<br>	<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">location /proxy/ &#123;</span><br><span class="line">         proxy_pass http:<span class="comment">//10.0.0.1:8080;	#这里没有以/结尾</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>当访问 <a href="http://127.0.0.1/proxy/a/b/c.txt">http://127.0.0.1/proxy/a/b/c.txt</a> 时，nginx匹配到<code>/proxy/</code>路径，把请求转发给10.0.0.1:8080服务，实际请求代理服务器的路径为<br><code>http://10.0.0.1:8080/proxy/a/b/c.txt</code>（带location目录），此时nginx会把匹配的proxy也代理给代理服务器。</p>
<p><code>proxy_pass</code>后面接多一级路径的情况跟上面一致。</p>
<h2 id="补充一个-host-400错误的故障"><a href="#补充一个-host-400错误的故障" class="headerlink" title="补充一个$host 400错误的故障"></a>补充一个$host 400错误的故障</h2><p>400这个状态码是<code>Bad Request</code>，基本上就是请求header或者是<code>cookie</code>有问题，而请求header的问题要么是头过大要么是头没有。在<code>HTTP/1.0</code>里不支持Host请求头的，而在<code>HTTP/1.1</code>中，Host请求头部必须存在,否则会返回<code>400 Bad Request</code>。如果请求的URI不包含所请求服务的主机名，则必须为Host头字段指定一个空值。</p>
<p>nginx如果配置了<code>$http_host</code>变量做反向代理时，后端真实的服务器是需要知道请求的host头，而<code>$http_host</code>的值是’’，所以会触发400这个错误。这个情况就需要用<code>$hosts</code>来替代<code>$http_host</code>。</p>
<p>也就是说：<code>proxy_set_header Host $host</code>这一行的作用是把原http请求的Header中的Host字段也放到转发的请求里。如果不加这一行的话，nginx转发的请求header里就不会有Host字段，而服务器是靠这个Host值来区分你请求的是哪个域名的资源的。</p>
<p>还有一种400的情况：如果是GET请求没问题，而POST请求返回400错误，那么可能是websocket配置成了全局单独配置websocket的地址即可。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jibing57.com/2018/11/27/nginx-with-dynamic-upstreams-to-ELB/">https://www.jibing57.com/2018/11/27/nginx-with-dynamic-upstreams-to-ELB/</a><br><a href="http://www.syyong.com/net/Using-nginx-s-proxy_pass-function-to-do-domain-name-forwarding-causes-an-accident.html">http://www.syyong.com/net/Using-nginx-s-proxy_pass-function-to-do-domain-name-forwarding-causes-an-accident.html</a><br><a href="https://blog.nswebfrog.com/2018/09/09/nginx-proxypass-dns/">https://blog.nswebfrog.com/2018/09/09/nginx-proxypass-dns/</a><br><a href="https://www.jianshu.com/p/b113bd14f584">https://www.jianshu.com/p/b113bd14f584</a><br><a href="https://www.cnblogs.com/woshimrf/p/nginx-proxy-rewrite-url.html">https://www.cnblogs.com/woshimrf/p/nginx-proxy-rewrite-url.html</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>proxy_pass</tag>
      </tags>
  </entry>
  <entry>
    <title>Pycharm项目的文件夹突然消失了</title>
    <url>/2022/04/21/Pycharm%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%E7%AA%81%E7%84%B6%E6%B6%88%E5%A4%B1%E4%BA%86/</url>
    <content><![CDATA[<h2 id="项目的文件夹都没了！"><a href="#项目的文件夹都没了！" class="headerlink" title="项目的文件夹都没了！"></a>项目的文件夹都没了！</h2><p>今天在搞pycharm的时候，打开了另一个项目，结果返回原来的项目的时候，意外的发现原来的项目里的文件夹都没了：<br><img data-src="/images/django%E6%96%87%E4%BB%B6%E5%A4%B9%E6%B2%A1%E4%BA%86.jpg"></p>
<p>不过文件夹并没丢，代码没丢是一个好消息。但是pycharm的Django也无法启动，在Preferences里的<code>语言与框架</code>里的Django也是空：<br><img data-src="/images/django%E6%96%87%E4%BB%B6%E5%A4%B9%E6%B2%A1%E4%BA%862.jpg"></p>
<p>查了很久，发现了解法：那就是退出pycharm，删除项目文件夹里的<code>.idea</code>文件夹，然后再打开pycharm就恢复原样了。这个文件夹的主要作用在于存放项目的控制信息，包括版本信息，历史记录等等。删除它是不会影响代码的正常使用的，但是如果删除就不能使用pycharm进行回溯和复原了。</p>
<p>不过为啥会让整个项目文件夹没变化却能让整个django的项目文件夹不展示以及让django的配置为空，那就不得而知了…</p>
<h2 id="启动Django后发现setting不对的问题"><a href="#启动Django后发现setting不对的问题" class="headerlink" title="启动Django后发现setting不对的问题"></a>启动Django后发现setting不对的问题</h2><p>我的Pycharm版本由原来的2021.3版本升级到2022.1版本，但是启动django的时候，爆这个错误<code>You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.</code>：<br><img data-src="/images/django%E6%96%87%E4%BB%B6%E5%A4%B9%E6%B2%A1%E4%BA%863.png"></p>
<p>这是因为你的片及配置里没有配置<code>settings</code>的路径，首先打开编辑配置：<br><img data-src="/images/django%E6%96%87%E4%BB%B6%E5%A4%B9%E6%B2%A1%E4%BA%864.png"></p>
<p>在如图的地方加上<code>djangoproject.settings</code>就行了：<br><img data-src="/images/django%E6%96%87%E4%BB%B6%E5%A4%B9%E6%B2%A1%E4%BA%865.png"></p>
<p>唉，这种稀奇古怪的问题竟然耽误了老子2个小时…<br><img data-src="/images/%E6%9D%8E%E6%B2%812.webp"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>PyCharm</tag>
      </tags>
  </entry>
  <entry>
    <title>Proxysql添加后端SSL加密</title>
    <url>/2019/06/28/Proxysql%E6%B7%BB%E5%8A%A0%E5%90%8E%E7%AB%AFSSL%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<h2 id="配置阿里云"><a href="#配置阿里云" class="headerlink" title="配置阿里云"></a>配置阿里云</h2><p>安全部门最近放出了新需求，要数据库流量实现内网加密。即<code>mysql&lt;-----&gt;proxysql</code>之间是加密的，这里记录整个配置过程，安装部分可以移步去看 <a href="https://rorschachchan.github.io/2019/05/31/%E8%AE%B0%E5%BD%95%E9%83%A8%E7%BD%B2ProxySql%E7%9A%84%E8%BF%87%E7%A8%8B/">https://rorschachchan.github.io/2019/05/31/%E8%AE%B0%E5%BD%95%E9%83%A8%E7%BD%B2ProxySql%E7%9A%84%E8%BF%87%E7%A8%8B/</a> 这篇文章。</p>
<p>首先登陆阿里云控制台RDS，选择对应的数据库—数据安全性—SSL，点击<code>开通</code>，如图：<br><img data-src="/images/proxy27.png" alt="akb48"></p>
<p><font color=red>注意！此项举动会重启数据库，所以线上环境请慎重！</font></p>
<p>在配置的时候，同时下载CA证书，上传到proxysql所在的服务器的<code>/var/lib/proxysql/</code>里。解压缩之，发现压缩包里是三个文件，如图：<br><img data-src="/images/proxy28.png" alt="akb48"></p>
<p>我们主要用的是<code>ApsaraDB-CA-Chain.pem</code>这个文件（如果是读写库，那么这个pem的文件是一模一样的）。</p>
<p>如果数据库开通ssl成功，那么在阿里云的控制台上是显示为“已开通”，在mysql命令行里使用<code>show global variables like &#39;%ssl%&#39;;</code>查看如下：<br><img data-src="/images/proxy30.png" alt="akb48"></p>
<p>登录proxysql，查看当前链接mysql情况，如图：<br><img data-src="/images/proxy29.png" alt="akb48"></p>
<p>发现里面的<code>use_ssl</code>是0，所以<code>update mysql_servers set use_ssl=1;</code>将他们改成1。</p>
<p>然后<code>set mysql-ssl_p2s_ca = &#39;/var/lib/proxysql/ApsaraDB-CA-Chain.pem&#39;;</code>设定CA证书所在路径。随后就是<code>load mysql variables to runtime;</code>和<code>save mysql variables to disk;</code>，保存之后使用<code>select * from runtime_global_variables;</code>查看：<br><img data-src="/images/proxy31.png" alt="akb48"></p>
<p>验证的方法也很简单，在对应数据库里操作的同时<code>tcpdump -s 0 -i any -v port 3306 -w /root/test.pcap</code> 抓一下包看一下里面的内容是否加密了就行。</p>
<p>补充：虽然SSL方式使得安全性提高了，但是相对地使得QPS也降低23%左右。所以要谨慎选择：</p>
<ol>
<li>对于非常敏感核心的数据，或者QPS本来就不高的核心数据，可以采用SSL方式保障数据安全性；</li>
<li>对于采用短链接、要求高性能的应用，或者不产生核心敏感数据的应用，性能和可用性才是首要，建议不要采用SSL方式；</li>
</ol>
<h2 id="配置AWS"><a href="#配置AWS" class="headerlink" title="配置AWS"></a>配置AWS</h2><p>首先去<a href="https://docs.aws.amazon.com/zh_cn/AmazonRDS/latest/UserGuide/UsingWithRDS.SSL.html">https://docs.aws.amazon.com/zh_cn/AmazonRDS/latest/UserGuide/UsingWithRDS.SSL.html</a> ，里下载 <a href="https://s3.amazonaws.com/rds-downloads/rds-combined-ca-bundle.pem">https://s3.amazonaws.com/rds-downloads/rds-combined-ca-bundle.pem</a> 这个文件，同样上传到服务器里，在proxysql添加路径和配置。</p>
<p>AWS与阿里云不同的地方是，AWS可以针对某个用户开启SSL的，这需要用命令行登录RDS数据库，使用命令<code>GRANT USAGE ON *.* TO &#39;对应用户名&#39;@&#39;%&#39; REQUIRE SSL;</code>（MYSQL 5.6）开启加密，如果想取消掉，就是<code>GRANT USAGE ON *.* TO &#39;对应用户名&#39;@&#39;%&#39; REQUIRE NONE;</code>。</p>
<p>更多信息可以去看：<a href="https://docs.aws.amazon.com/zh_cn/AmazonRDS/latest/UserGuide/CHAP_MySQL.html#MySQL.Concepts.SSLSupport">https://docs.aws.amazon.com/zh_cn/AmazonRDS/latest/UserGuide/CHAP_MySQL.html#MySQL.Concepts.SSLSupport</a> 。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/sysown/proxysql/wiki/SSL-Support">https://github.com/sysown/proxysql/wiki/SSL-Support</a><br><a href="https://googlebaba.io/mysqlcookbook/7.aboutssl.html">https://googlebaba.io/mysqlcookbook/7.aboutssl.html</a></p>
<p><img data-src="/images/DH12-2.gif" alt="akb48" title="2009年东部半决赛魔术VS骑士"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>读写分离</tag>
        <tag>proxysql</tag>
        <tag>ssl加密</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx配置防盗链</title>
    <url>/2018/06/27/Nginx%E9%85%8D%E7%BD%AE%E9%98%B2%E7%9B%97%E9%93%BE/</url>
    <content><![CDATA[<h2 id="为什么网站们都要限制流量？"><a href="#为什么网站们都要限制流量？" class="headerlink" title="为什么网站们都要限制流量？"></a>为什么网站们都要限制流量？</h2><p>无论是网站服务器亦或是游戏服务器还是邮件服务器，说穿了也是一台电脑，也有CPU和内存。只不过服务器的CPU功能比个人电脑的CPU功能强大，比如个人电脑的CPU一秒钟能算1亿个数，那么服务器的CPU一秒钟就能算十亿个数。毕竟个人电脑只针对个人，但是服务器是要“接客”的，有了强大的硬件做后盾，网页&#x2F;游戏&#x2F;邮箱才不会那么轻易的Down掉。</p>
<p>但是CPU不是人类大脑，人脑是越用越聪明，CPU是越用越磨损，毕竟始终在连电的环境下。于是乎，没有必要的运算能省就省，一个人省一次，十万个人就省十万次，一千万个人就省一千万次，这样达到积少成多的目的。</p>
<p>CPU计算的是各种数据，而这些数据也叫作流量。有用的流量、有价值的流量通过CPU计算无可厚非，但是出现了没有用的流量或者是别人盗用我们的资源，那么这种情况能避免都要避免。什么叫盗用我们的资源，比如自己网站（网站A）上的图片或者视频，被其他人直接复制网站然后粘贴到他们的主页（网站B）上，其他用户登录了B网站，然后点击了那个图片和视频，由于是网址重链接，里外里提供数据的还是我们的服务器。也就是说B网站就是一个中介，而真正提供服务的是网站A，但是广告费和点击率都要网站B赚走了，这事儿实在是叔可忍婶不可忍。</p>
<h2 id="什么是盗链？如何发现被盗链？"><a href="#什么是盗链？如何发现被盗链？" class="headerlink" title="什么是盗链？如何发现被盗链？"></a>什么是盗链？如何发现被盗链？</h2><p>什么叫盗链，上面已经说的差不多了，如果上面的文字没有看懂的话，举个例子，如果您看到了这两个图片，证明这个网站就是在盗链。<br><img data-src="/images/fangdaolian1.jpg" alt="paradin"></p>
<p><img data-src="/images/fangdaolian2.jpg" alt="paradin"></p>
<p>这两个就是一个盗取的是QQ空间的图片，另一个就是百度的图片。用其他网站的图片这事儿本身是无所谓的，只要不涉及版权问题，都希望自己的作品能广泛传播，但是请不要直接通过网址重定向，厚道一点的行为应该是：“图片另存为”，然后到目标网站上去重新上传一下。</p>
<p>这里再多说一点网站的基础知识。</p>
<ol>
<li><p>PV值：PV&#x3D;page view，网站是有少则一个网页多则N多网页组成的一个整体，PV值就是统计用户访问网站的总页数。比如<a href="http://www.jqk.com这个网站,今天有100个用户登录,平均每个用户翻阅了里面5个网页.那么这个网站的pv值就是500.若一个ip地址,对一个页面刷新10000次,pv值也是1.要查询网站的pv值登陆http//www.alexa.cn%E5%B0%B1%E8%A1%8C%E3%80%82">www.JQK.com这个网站，今天有100个用户登录，平均每个用户翻阅了里面5个网页。那么这个网站的PV值就是500。若一个IP地址，对一个页面刷新10000次，PV值也是1.要查询网站的PV值登陆http://www.alexa.cn就行。</a></p>
</li>
<li><p>Hit值：这个就是对网页里每个元素的点击量，一个网页里的图片就是一个元素，一个flv文件也是一个元素，一首歌曲也是一个元素。这些的总量就是hit值，hit值越高就证明这个网站被人查看的情况越高，那么也证明网站的高人气，那么自然广告也会卖出去很多钱。</p>
</li>
</ol>
<p>因为建网站这事儿关心到了金钱利益，网站越被人关注，自然价值也越大。于是会有一个公式来评判网站的“每日贡献”：<code>总流量=访问流量+下载流量= Page view值 x 页面大小+下载文件大小 x 下载次数</code>。</p>
<p>作为管理者，每天观察一下自己一亩三分地儿的网站数据情况是本职工作。但是有时候也会遇到网站流量很惊人的情况，一般来说，网站流量过大（CPU运转很多）的原因如下：</p>
<ol>
<li><p>网站是一个很大的网站：比如说淘宝，京东，网易，youtube，facebook那种大网站，里面成万上亿的网页，而且每天又有那么多人登陆，自然浏览量很大。虽然这些大集团的服务器也是少则几千，多则上万，甚至在不同地区也会有不少的服务器集群，但是这几万台服务器需要提供的数据会很多也是不争的事实。这种现象是正常的。</p>
</li>
<li><p>网页内容太大：可能本身网站是一个小网站，加起来也就十页二十页的内容，但是每一天的流量依旧很惊人，那么很有可能是单页或者某几页的字节太大。比如网页里有太多的图片，太多的视频，太多的其他链接，也有可能是前端码农们给这个网页的规划不合理。导致这个网页每一次被点击都要大费周折（hit值和PV值不高，但是日流量很高），长此以往不仅会耽误用户的整体体验，对服务器也是一个重大伤害。</p>
</li>
<li><p>搜索引擎产生了大量的数据流量：网站需要推广，于是就在各种搜索引擎上打广告，也有自己网站的很多图片用于外部调用。这样的结果就是本身来观摩网站的人很少，但是“借着引擎经过”的人很多，所以就会有PV值不高，但是Hit值和日流量很高的现象出现。</p>
</li>
<li><p>图片或者其他元素被盗链：第一部分就说过了，别人拿我们的图片去吸引别人关注，然后别人想要深入了解，还要来使用我们的服务器去提供详细数据。这种“用我们的牌子住我们的房，吃我们的饭却不给我们钱”的现象实在应该被弄死。这种现象的特征也是PV值不高（没人真正点击网站），但是Hit值和日流量很大（自己服务器的数据都给别的网站提供了）。</p>
</li>
<li><p>网站被DDos攻击了：被一些恶意的IP地址频繁登陆，来回的刷流量。这样迫使CPU做出运算的行为其实就是在远程的破坏服务器的硬件CPU，遇到这种现象，之前Nginx文章里有写，要么通过access.log找到这些IP封掉，要么就在配置文件里加上限制（<code>limit-rate</code>)。</p>
</li>
</ol>
<h2 id="服务器是如何知道图片是从站外而来的呢？"><a href="#服务器是如何知道图片是从站外而来的呢？" class="headerlink" title="服务器是如何知道图片是从站外而来的呢？"></a>服务器是如何知道图片是从站外而来的呢？</h2><p>在http协议里有一个重要的选项叫<code>refer</code>，这个选项的内容就是该元素的来源地址。如果这个元素是服务器自己提供的，那么头文件里是没有refer这个选项的。通过refer这个信息，我们也可以知道登陆网站的客户是从哪个网站点击链接而来的。这样方便进行一个统计和规划。</p>
<p>假如，我在QQ空间里面发现一个图，然后右键图片，选择<code>在新标签栏里打开图片</code>，这时候通过浏览器<code>审查元素</code>的功能，能查查看请求头信息和响应头信息，发现响应头信息里多了一个refer，里面的内容就是图片的源地址：<br><img data-src="/images/fangdaolian3.jpg" alt="paradin"></p>
<p>我在QQ空间里看腾讯的照片自然是可以的，但是如果我在别的网站里看腾讯的照片，加重了腾讯服务器的负担，自然腾讯公司会不满意。于是腾讯服务器发现当前要引用这个图片的地址与refer头信息不是一个来源之后，就不会把这个图片的数据传送过来，于是就看到那个<code>此图片来自QQ空间，未经准许不可饮用</code>的警告图片。</p>
<p>既然知道了服务器是如何判断文件是否盗链，那么只要伪装一个refer就可以欺骗服务器达到“反防盗链”的目的了。至于这部分，可以自己单独研究。</p>
<h2 id="如何使用Nginx反盗链？"><a href="#如何使用Nginx反盗链？" class="headerlink" title="如何使用Nginx反盗链？"></a>如何使用Nginx反盗链？</h2><p>同样的使用<code>Nginx.conf</code>，在http的大括号下面，新建一个<code>location</code>，加入如下信息：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location</span><br><span class="line"> ~ .*\.(wma|wmv|asf|mp3|mmf|zip|rar|jpg|gif|png|swf|flv)$ &#123;</span><br><span class="line">#指定对以上几种类型的文件建立防盗链</span><br><span class="line">     valid_referers</span><br><span class="line"> none blocked *.alala.com alala.com;</span><br><span class="line">#盗链的范围不包括alala.com和alala.com下的二级网站，</span><br><span class="line">     if</span><br><span class="line">($invalid_referer)</span><br><span class="line"> &#123;</span><br><span class="line">     #rewrite</span><br><span class="line"> ^/ http://www.alala.com/error.html;</span><br><span class="line">     return</span><br><span class="line">403;</span><br><span class="line">#如果发现有引用以上文件的地址与refer头信息不符的情况，直接重定向成error.html这个网页，服务器返回403，forbidden。</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者使用第三方模块<code>ngx_http_accesskey_module</code>实现Nginx防盗链。实现方法如下：</p>
<ol>
<li>下载<code>NginxHttpAccessKeyModule</code>模块文件：<a href="http://wiki.nginx.org/File:Nginx-accesskey-2.0.3.tar.gz%EF%BC%9B">http://wiki.nginx.org/File:Nginx-accesskey-2.0.3.tar.gz；</a></li>
<li>解压此文件后，找到<code>nginx-accesskey-2.0.3</code>下的config文件。编辑此文件：替换其中的<code>$HTTP_ACCESSKEY_MODULE</code>为<code>ngx_http_accesskey_module</code>；</li>
<li>用一下参数重新编译nginx：<code>./configure --add-module=Nginx目录/to/nginx-accesskey</code>,然后执行:<code>make &amp;&amp; make install</code>;</li>
<li>修改<code>nginx.conf</code>文件，添加以下几行： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /download &#123;</span><br><span class="line">  accesskey on;</span><br><span class="line">  accesskey_hashmethod md5;</span><br><span class="line">  accesskey_arg &quot;key&quot;;</span><br><span class="line">  accesskey_signature &quot;mypass$remote_addr&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>其中：<br>accesskey为模块开关；<br>accesskey_hashmethod为加密方式MD5或者SHA-1；<br>accesskey_arg为url中的关键字参数；<br>accesskey_signature为加密值，此处为mypass和访问IP构成的字符串。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>防盗链</tag>
      </tags>
  </entry>
  <entry>
    <title>Python3从jenkins爬取连接并且上传到文件服务器的脚本</title>
    <url>/2019/07/31/Python3%E4%BB%8Ejenkins%E7%88%AC%E5%8F%96%E8%BF%9E%E6%8E%A5%E5%B9%B6%E4%B8%94%E4%B8%8A%E4%BC%A0%E5%88%B0%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>以前部署的流程是这样的：开发给运维一个jenkins地址，运维在桌面打开jenkins页面下载zip包，然后Xftp传递到nfs共享挂载盘里。不过我们现在开发都把模块的名字取得特别长而且易混（天才一般的取名方式），最重要的是遇到大型上线，jenkins里会有N多个zip包，如图：<br><img data-src="/images/jenkins20.png" alt="抱光妹"></p>
<p>这样一个一个点下来，连点十多下然后再上传的行为不仅蠢还很容易遗漏，于是就写一个脚本来解决这个问题，实现“一键传包”。脚本如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python </span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># 作者：ChrisChan</span></span><br><span class="line"><span class="comment"># 用途：爬取jenkins网页的所有的zip连接，下载完毕之后上传到文件服务器里，脚本需要安装paramiko,tqdm和BeautifulSoup</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">zip_url = []</span><br><span class="line">zip_name = []</span><br><span class="line"></span><br><span class="line">folder_path = <span class="string">r&#x27;F:/Jenkins/&#x27;</span></span><br><span class="line"><span class="keyword">if</span> os.path.exists(folder_path) == <span class="literal">False</span>:  	<span class="comment"># 判断文件夹是否已经存在</span></span><br><span class="line">    os.makedirs(folder_path)   	 <span class="comment"># 创建文件夹</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;jenkins文件夹已经创建完毕！&quot;</span>)</span><br><span class="line"></span><br><span class="line">BASE_URL = <span class="built_in">input</span>(<span class="string">&quot;请输入jenkins网址：&quot;</span>)       <span class="comment"># 由于input输入http地址自带超链接，回车就直接弹开网页，所以url末尾是以 空格 结束</span></span><br><span class="line"><span class="keyword">if</span> BASE_URL.endswith(<span class="string">&#x27;/ &#x27;</span>):</span><br><span class="line">    url = <span class="built_in">str</span>.rstrip(BASE_URL) + <span class="string">&quot;artifact/artifacts/Modules/&quot;</span>   <span class="comment"># 去掉末尾空格</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    url = <span class="built_in">str</span>.rstrip(BASE_URL) + <span class="string">&quot;/artifact/artifacts/Modules/&quot;</span>  <span class="comment"># 补全</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;准备去&quot;</span>,url,<span class="string">&quot;里下载所有的zip文件&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 爬取页面所有的zip地址</span></span><br><span class="line">page = requests.get(url).text</span><br><span class="line">pagesoup = BeautifulSoup(page,<span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> link <span class="keyword">in</span> pagesoup.find_all(name=<span class="string">&#x27;a&#x27;</span>,attrs=&#123;<span class="string">&quot;href&quot;</span>:re.<span class="built_in">compile</span>(<span class="string">r&#x27;.zip$&#x27;</span>)&#125;):        <span class="comment"># 获取所有zip结尾的，如果是开头就是^</span></span><br><span class="line">    zipname = link.get(<span class="string">&#x27;href&#x27;</span>)</span><br><span class="line">    zip_url.append(url + zipname)</span><br><span class="line">    zip_name.append(zipname)</span><br><span class="line"><span class="comment">#print(zip_url)       # 得到完整的zip包下载链接</span></span><br><span class="line"></span><br><span class="line">zip_dict = <span class="built_in">dict</span>(<span class="built_in">zip</span>(zip_name, zip_url))     <span class="comment">#把下载包名和链接做成字典</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;./*zip*/Modules.zip&quot;</span>) <span class="keyword">in</span> zip_dict.keys(): <span class="comment"># 判断字典里是否存在这个元素</span></span><br><span class="line">    zip_dict.pop(<span class="string">&quot;./*zip*/Modules.zip&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;该页面有 %s 个zip文件：&quot;</span> % <span class="built_in">len</span>(zip_dict))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;该页面有 %s 个zip文件：&quot;</span> % <span class="built_in">len</span>(zip_dict))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载文件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">downloadFile</span>(<span class="params">name,file_url</span>):</span><br><span class="line">    resp = requests.get(url=file_url, stream=<span class="literal">True</span>)</span><br><span class="line">    content_size = <span class="built_in">int</span>(resp.headers[<span class="string">&#x27;Content-Length&#x27;</span>]) / <span class="number">1024</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(folder_path+name, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;安装包整个大小是：&quot;</span>, content_size, <span class="string">&#x27;k，开始下载...&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> tqdm(iterable=resp.iter_content(<span class="number">1024</span>), total=content_size, unit=<span class="string">&#x27;k&#x27;</span>, desc=name):	<span class="comment">#使用tqdm做了一个进度条</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                f.write(data)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="built_in">print</span>(<span class="built_in">repr</span>(e))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\r\n&#x27;</span> + name + <span class="string">&quot;已经下载完毕！&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传到share盘</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">uploadFile</span>(<span class="params">_localDir, _remoteDir</span>):</span><br><span class="line">    _localDir = folder_path</span><br><span class="line">    _remoteDir = remote_path</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        t = paramiko.Transport((hostIP, port))      <span class="comment"># 这里一定是双括号！</span></span><br><span class="line">        t.connect(username=username, password=password)</span><br><span class="line">        sftp = paramiko.SFTPClient.from_transport(t)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;现在开始上传文件到/share/bag %s &#x27;</span> % datetime.datetime.now())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(_localDir):</span><br><span class="line">            <span class="comment"># 相对与_localDir的路径</span></span><br><span class="line">            remoteRoot = root.replace(<span class="string">&quot;\\&quot;</span>, <span class="string">&quot;/&quot;</span>)</span><br><span class="line">            <span class="comment"># 文件名，不包括路径</span></span><br><span class="line">            <span class="keyword">for</span> filespath <span class="keyword">in</span> files:</span><br><span class="line">                local_file = os.path.join(root, filespath)</span><br><span class="line">                remote_file = remote_path + <span class="string">&quot;/&quot;</span> + filespath</span><br><span class="line">                remote_file = remote_file.replace(<span class="string">&quot;//&quot;</span>, <span class="string">&quot;/&quot;</span>)</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    sftp.put(local_file, remote_file)</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    sftp.mkdir(os.path.split(remote_file)[<span class="number">0</span>])</span><br><span class="line">                    sftp.put(local_file, remote_file)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;%s 上传成功！远程地址是 %s &quot;</span> % (local_file, remote_file))</span><br><span class="line">            <span class="keyword">for</span> name <span class="keyword">in</span> dirs:</span><br><span class="line">                remoteDir = _remoteDir + <span class="string">&quot;/&quot;</span> + remoteRoot + <span class="string">&quot;/&quot;</span> + name</span><br><span class="line">                remoteDir = remoteDir.replace(<span class="string">&quot;//&quot;</span>, <span class="string">&quot;/&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;remoteDir &quot;</span>, remoteDir)</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    sftp.mkdir(remoteDir)</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;mkdir path %s&quot;</span> % remoteDir)</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;文件已经全部上传完毕！ %s &#x27;</span> % datetime.datetime.now())</span><br><span class="line">        t.close()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> zip_dict:</span><br><span class="line">        <span class="keyword">if</span> item:</span><br><span class="line">             downloadFile(item, zip_dict[item])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;文件不存在，无法下载！&quot;</span>)</span><br><span class="line"></span><br><span class="line">    hostIP = <span class="string">&quot;文件服务器的外网IP&quot;</span></span><br><span class="line">    port = 目标端口</span><br><span class="line">    username = <span class="string">&quot;连接账号&quot;</span></span><br><span class="line">    password = <span class="string">&quot;连接密码&quot;</span></span><br><span class="line">    remote_path = <span class="string">&quot;远程路径&quot;</span>		<span class="comment"># 这里注意文件夹权限</span></span><br><span class="line">    uploadFile(folder_path, remote_path)</span><br></pre></td></tr></table></figure></p>
<p>执行效果如下：<br><img data-src="/images/jenkins21.png" alt="抱光妹"></p>
<p>脚本可以改进的几个地方：</p>
<ol>
<li>使用多进程，提高下载和上传效率；</li>
<li>不使用服务器，而是本地将文件上传到云存储，然后在部署的时候，模块服务器通过内网下载对应的zip包或者在dockerfile里就可以直接<code>ADD 云存储路径</code>；</li>
<li>服务器或者是oss信息，单独保存在配置文件里，然后使用<code>configparser</code>方法读取出来；</li>
</ol>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>python3</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx配置IP白名单</title>
    <url>/2018/10/31/Nginx%E9%85%8D%E7%BD%AEIP%E7%99%BD%E5%90%8D%E5%8D%95/</url>
    <content><![CDATA[<h2 id="环境交代"><a href="#环境交代" class="headerlink" title="环境交代"></a>环境交代</h2><p>Nginx配置IP白名单是非常基础的工作，这次试验就是配置某网页可以正常被部分IP访问，而其他网页访问将是403。目标网页地址是<code>http://xxdtq.lechange.com/test/test.html</code>，内容如下：<br><img data-src="/images/nginxV3.png" alt="akb48"></p>
<p>本机的外网IP地址是<code>115.205.2.28</code>，如图：<br><img data-src="/images/nginxV4.png" alt="akb48"></p>
<p>首先先<code>nginx.conf</code>里的日志配置格式如下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log_format  access &#x27;$http_x_forwarded_for - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                &#x27;&quot;$http_user_agent&quot; $remote_addr $request_time $upstream_response_time $http_host&#x27;;</span><br></pre></td></tr></table></figure></p>
<p>Nginx的转发文件<code>default.conf</code>如下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name xxdtq.lechange.com;		#如果浏览器输入的是xxdtq.lechange.com，那么就跳转到82端口</span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_pass http://localhost:82;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">       listen 80;</span><br><span class="line">       server_name xhssf.lechange.com;			#如果浏览器输入的是xhssf.lechange.com，那么就跳转到82端口</span><br><span class="line">       location / &#123;</span><br><span class="line">               proxy_pass http://localhost:83;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h2><p>现在配置<code>xxdtq.conf</code>文件内容如下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	server</span><br><span class="line">&#123; </span><br><span class="line">    listen       82 default;	#82端口</span><br><span class="line">    server_name  xxdtq.lechange.com;</span><br><span class="line">    root  /mnt/xiuxiudetiequan/;	#根目录是/mnet/xiuxiudetiequan/</span><br><span class="line">    index index.html index.htm index.php;</span><br><span class="line"></span><br><span class="line">    add_header                  Set-Cookie &quot;HttpOnly&quot;;</span><br><span class="line">    add_header                  Set-Cookie &quot;Secure&quot;;</span><br><span class="line">    add_header          X-Frame-Options &quot;SAMEORIGIN&quot;;</span><br><span class="line">    add_header Strict-Transport-Security &quot;max-age=31536000; includeSubDomains&quot; always;</span><br><span class="line"></span><br><span class="line">	location = /test/test.html &#123;		#如果remote_addr是125.205.2.28来访问/test/test.html，那么就返回403</span><br><span class="line">       if ($remote_addr = 115.205.2.28) &#123;</span><br><span class="line">               return 403;</span><br><span class="line">               &#125;</span><br><span class="line">       &#125;</span><br><span class="line">	</span><br><span class="line">	access_log /var/log/nginx/xxdtq/access.log access;</span><br><span class="line">    error_log /var/log/nginx/xxdtq/error.log error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行了<code>nginx -s reload</code>后，刷新一下界面，却发现页面没变，并不是预期中的403，打开nginx的日志一看，发现获取到的<code>$remote_addr</code>是<code>127.0.0.1</code>！如下：<br><img data-src="/images/nginxV5.png" alt="akb48"></p>
<p>为什么是127.0.0.1？因为我们这个nginx做了一个80到82端口的转发呀，所以到80的地址是真实的外界IP，而80转发到82就是本机IP了。那这样的情况怎么办？就需要在<code>default.conf</code>里添加一句<code>proxy_set_header x-forwarded-for  $remote_addr;</code>，如下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name xxdtq.lechange.com;</span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_pass http://localhost:82;</span><br><span class="line">                proxy_set_header x-forwarded-for  $remote_addr;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重启一波nginx，发现<code>http_x_forwarded_for</code>正是远程访问的IP地址<code>115.205.2.28</code>，于是将xxdtq.conf判断IP改成如下内容：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location = /test/test.html &#123;</span><br><span class="line">    if ($http_x_forwarded_for = 115.205.2.28) &#123;		#改用http_x_forwarded_for</span><br><span class="line">            return 403;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>重启nginx之后，果然页面是403，如图：<br><img data-src="/images/nginxV6.png" alt="akb48"></p>
<p>然后用其他的IP地址，比如用手机连接4G去打开<a href="http://xxdtq.lechange.com/test/test.html">http://xxdtq.lechange.com/test/test.html</a> ，发现是正常读取的，试验成功！<br><img data-src="/images/nginxV7.png" alt="akb48"></p>
<p>如果是要整个&#x2F;test&#x2F;目录都不让访问的话，就要改成如下内容：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location ^~ /test/ &#123;</span><br><span class="line">   if ($http_x_forwarded_for = 115.205.2.28) &#123;	# =是精确匹配</span><br><span class="line">           return 403;</span><br><span class="line">           &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果要配置多个IP地址，就要改成如下内容：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location ~ ^/shopadmin &#123;</span><br><span class="line">    if ($remote_addr ~* &quot;第一个IP|第二个IP|第三个IP&quot;) &#123;	#这里改成~*</span><br><span class="line">    	return  403;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="elk里提取http-x-forwarded-for"><a href="#elk里提取http-x-forwarded-for" class="headerlink" title="elk里提取http_x_forwarded_for"></a>elk里提取http_x_forwarded_for</h2><p>nginx日志中的<code>http_x_forwarded_for</code>字段会有多个IP。使用自定义的模板<code>，grok</code>常用表达式的IPORHOST匹配<code>http_x_forwarded_for</code>该字段，获取的IP值是最后一个，如何取第一个IP值？</p>
<p>答案是：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mutate &#123;</span><br><span class="line">      split =&gt; [&quot;http_x_forwarded_for&quot;,&quot;,&quot;]</span><br><span class="line">      add_field =&gt; [&quot;real_remote_addr&quot;,&quot;%&#123;http_x_forwarded_for[0]&#125;&quot;]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>IPORHOST这些变量匹配不到所有IP，只能通过自定义正则来匹配到所有IP；再通过以上方法截取第一个IP值。正则表达式写法是：<code>[\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\,\s]*</code></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://seanlook.com/2015/05/17/nginx-location-rewrite/">http://seanlook.com/2015/05/17/nginx-location-rewrite/</a><br><a href="https://zhuanlan.zhihu.com/p/21354318">https://zhuanlan.zhihu.com/p/21354318</a><br><a href="http://blog.pengqi.me/2013/04/20/remote-addr-and-x-forwarded-for/">http://blog.pengqi.me/2013/04/20/remote-addr-and-x-forwarded-for/</a><br><a href="http://gong1208.iteye.com/blog/1559835">http://gong1208.iteye.com/blog/1559835</a><br><a href="https://my.oschina.net/moooofly/blog/295853">https://my.oschina.net/moooofly/blog/295853</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Python从Mysql里获取值并且调用ansible批量执行的脚本</title>
    <url>/2019/11/20/Python%E4%BB%8EMysql%E9%87%8C%E8%8E%B7%E5%8F%96%E5%80%BC%E5%B9%B6%E4%B8%94%E8%B0%83%E7%94%A8ansible%E6%89%B9%E9%87%8F%E6%89%A7%E8%A1%8C%E7%9A%84%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>我们的服务器资产信息都是在购买的时候就记录在mysql里的，表结构如图：<br><img data-src="/images/ansibleip3.png" alt="akb48"></p>
<p>可见我们的服务器命名都是有标准的，即<code>Ez4IP_地域缩写_模块名</code>，如果有T就是测试环境没有T就是正式环境，现在就是要从mysql里取出来对应的值然后再由ansible 2.7批量执行命令，脚本如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># 作者：ChrisChan</span></span><br><span class="line"><span class="comment"># 用途：海外模块获取IP脚本，首先先从mysql数据库里获取对应IP，然后写上对应的命令，批量操作</span></span><br><span class="line"><span class="comment"># 注意！这里写死了Ez4ip_XX_xx的格式，如果有需要则自己手动更改</span></span><br><span class="line"><span class="keyword">import</span> pymysql, argparse, os, json, shutil</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="keyword">from</span> ansible.parsing.dataloader <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> ansible.<span class="built_in">vars</span>.manager <span class="keyword">import</span> VariableManager</span><br><span class="line"><span class="keyword">from</span> ansible.inventory.manager <span class="keyword">import</span> InventoryManager</span><br><span class="line"><span class="keyword">from</span> ansible.playbook.play <span class="keyword">import</span> Play</span><br><span class="line"><span class="keyword">from</span> ansible.executor.playbook_executor <span class="keyword">import</span> PlaybookExecutor</span><br><span class="line"><span class="keyword">from</span> ansible.executor.task_queue_manager <span class="keyword">import</span> TaskQueueManager</span><br><span class="line"><span class="keyword">from</span> ansible.plugins.callback <span class="keyword">import</span> CallbackBase</span><br><span class="line"><span class="keyword">import</span> ansible.constants <span class="keyword">as</span> C</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令行参数</span></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&#x27;本脚本先从mysql获取内网IP地址，然后回滚&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-i&#x27;</span>, <span class="string">&#x27;--iii&#x27;</span>, metavar=<span class="string">&#x27;目标模块名,如Ez4ip_FK_messagepushservice&#x27;</span>, required=<span class="literal">True</span>, dest=<span class="string">&#x27;hosts&#x27;</span>, nargs=<span class="string">&#x27;+&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;请必须输入一个模块名，不然无法执行数据库查询&#x27;</span>)  <span class="comment"># required表示此字段一定需要,nargs=’+’ 表示至少一个参数</span></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">checkSQL</span>(<span class="params">i</span>):</span><br><span class="line">    <span class="comment"># 使用cursor()方法获取操作游标</span></span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    <span class="comment"># SQL 查询语句</span></span><br><span class="line">    sql = <span class="string">&quot;select * from cloudresource_aws_instance where instance_name regexp &#x27;&quot;</span> + i +<span class="string">&quot;&#x27; and project_name regexp &#x27;ez4ip&#x27;;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">        results = cursor.fetchall()</span><br><span class="line">        <span class="comment"># 获取所有记录写到文件里，这个文件将来给ansible用</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> results:</span><br><span class="line">            instance_name = row[<span class="number">3</span>]</span><br><span class="line">            instance_innerip = row[<span class="number">4</span>]</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;instance_name=%s,instance_innerip=%s&quot;</span> % (instance_name, instance_innerip))</span><br><span class="line">            f.write(<span class="string">&#x27;\n&#x27;</span>+instance_innerip)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;出现错误，mysql无法获取到数据！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ResultCallback</span>(<span class="title class_ inherited__">CallbackBase</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    重构ansible输出</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(ResultCallback, <span class="variable language_">self</span>).__init__(*args, **kwargs)</span><br><span class="line">        <span class="variable language_">self</span>.host_ok = &#123;&#125;</span><br><span class="line">        <span class="variable language_">self</span>.host_unreachable = &#123;&#125;</span><br><span class="line">        <span class="variable language_">self</span>.host_failed = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">v2_runner_on_ok</span>(<span class="params">self, result, **kwargs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;成功&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.host_ok[result._host.name] = result._result[<span class="string">&quot;stdout&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">v2_runner_on_unreachable</span>(<span class="params">self, result, **kwargs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;不可达&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.host_unreachable[result._host.name] = result._result[<span class="string">&quot;msg&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">v2_runner_on_failed</span>(<span class="params">self, result, ignore_errors=<span class="literal">False</span>, **kwargs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;失败&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.host_failed[result._host.name] = result._result[<span class="string">&quot;stderr&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">runner</span>(<span class="params">ansible_host_path, module, args</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    类似Ad-Hoc命令</span></span><br><span class="line"><span class="string">    :param ansible_host_path: 一个清单文件，一行一个ip就行</span></span><br><span class="line"><span class="string">    :param module:</span></span><br><span class="line"><span class="string">    :param args:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    Options = namedtuple(<span class="string">&#x27;Options&#x27;</span>,</span><br><span class="line">                         [<span class="string">&#x27;connection&#x27;</span>,</span><br><span class="line">                          <span class="string">&#x27;module_path&#x27;</span>,</span><br><span class="line">                          <span class="string">&#x27;forks&#x27;</span>,</span><br><span class="line">                          <span class="string">&#x27;private_key_file&#x27;</span>,</span><br><span class="line">                          <span class="string">&#x27;remote_user&#x27;</span>,</span><br><span class="line">                          <span class="string">&#x27;become&#x27;</span>,</span><br><span class="line">                          <span class="string">&#x27;become_method&#x27;</span>,</span><br><span class="line">                          <span class="string">&#x27;become_user&#x27;</span>,</span><br><span class="line">                          <span class="string">&#x27;check&#x27;</span>,</span><br><span class="line">                          <span class="string">&#x27;diff&#x27;</span>])</span><br><span class="line">    options = Options(connection=<span class="string">&#x27;smart&#x27;</span>,</span><br><span class="line">                      module_path=<span class="literal">None</span>,</span><br><span class="line">                      forks=<span class="number">10</span>,</span><br><span class="line">                      private_key_file=<span class="string">&quot;/root/.ssh/id_rsa&quot;</span>, <span class="comment"># 你的私钥</span></span><br><span class="line">                      remote_user=<span class="string">&quot;guest&quot;</span>,      <span class="comment"># 远程用户</span></span><br><span class="line">                      become=<span class="literal">True</span>,</span><br><span class="line">                      become_method=<span class="string">&quot;sudo&quot;</span>,</span><br><span class="line">                      become_user=<span class="string">&quot;root&quot;</span>,	<span class="comment"># sudo的用户</span></span><br><span class="line">                      check=<span class="literal">False</span>,</span><br><span class="line">                      diff=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment"># 主要加载设置的变量</span></span><br><span class="line">    loader = DataLoader()</span><br><span class="line">    <span class="comment"># 一个密码参数，可以设置为None，默认即可，没什么影响，我用的是秘钥登录</span></span><br><span class="line">    passwords = <span class="built_in">dict</span>(vault_pass=<span class="string">&#x27;secret&#x27;</span>)</span><br><span class="line">    <span class="comment"># 结果回调</span></span><br><span class="line">    callback = ResultCallback()</span><br><span class="line">    <span class="comment"># 设置传入的机器清单</span></span><br><span class="line">    inventory = InventoryManager(loader=loader, sources=[ansible_host_path])</span><br><span class="line">    <span class="comment"># 加载之前的变量</span></span><br><span class="line">    variable_manager = VariableManager(loader=loader, inventory=inventory)</span><br><span class="line">    play_source = <span class="built_in">dict</span>(</span><br><span class="line">            name=<span class="string">&quot;Ansible Play&quot;</span>,</span><br><span class="line">            hosts=<span class="string">&quot;all&quot;</span>,           <span class="comment"># all表示匹配清单所有机器，看源码发现的</span></span><br><span class="line">            gather_facts=<span class="string">&quot;no&quot;</span>,</span><br><span class="line">            tasks=[</span><br><span class="line">                <span class="built_in">dict</span>(action=<span class="built_in">dict</span>(module=module, args=args), register=<span class="string">&#x27;shell_out&#x27;</span>),</span><br><span class="line">             ]</span><br><span class="line">        )</span><br><span class="line">    play = Play().load(play_source, variable_manager=variable_manager, loader=loader)</span><br><span class="line"></span><br><span class="line">    tqm = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        tqm = TaskQueueManager(</span><br><span class="line">                  inventory=inventory,</span><br><span class="line">                  variable_manager=variable_manager,</span><br><span class="line">                  loader=loader,</span><br><span class="line">                  options=options,</span><br><span class="line">                  passwords=passwords,</span><br><span class="line">                  stdout_callback=callback,</span><br><span class="line">              )</span><br><span class="line">        result = tqm.run(play)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> tqm <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            tqm.cleanup()</span><br><span class="line">        shutil.rmtree(C.DEFAULT_LOCAL_TMP, <span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 重构输出</span></span><br><span class="line">    result_raw = &#123;<span class="string">&#x27;success&#x27;</span>: &#123;&#125;, <span class="string">&#x27;failed&#x27;</span>: &#123;&#125;, <span class="string">&#x27;unreachable&#x27;</span>: &#123;&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> host, result <span class="keyword">in</span> callback.host_ok.items():</span><br><span class="line">        result_raw[<span class="string">&quot;success&quot;</span>][host] = result</span><br><span class="line">    <span class="keyword">for</span> host, result <span class="keyword">in</span> callback.host_unreachable.items():</span><br><span class="line">        result_raw[<span class="string">&#x27;failed&#x27;</span>][host] = result</span><br><span class="line">    <span class="keyword">for</span> host, result <span class="keyword">in</span> callback.host_failed.items():</span><br><span class="line">        result_raw[<span class="string">&#x27;unreachable&#x27;</span>][host] = result</span><br><span class="line">    <span class="keyword">return</span> json.dumps(result_raw, indent=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接mysql</span></span><br><span class="line">db = pymysql.connect(<span class="string">&quot;mysql连接地址&quot;</span>, <span class="string">&quot;mysql账号&quot;</span>, <span class="string">&quot;mysql密码&quot;</span>, <span class="string">&quot;database名称&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开文件                    </span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;/home/chens/instance.txt&#x27;</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ansible文件所在的路径</span></span><br><span class="line">ansible_host_path = os.path.join(os.getcwd(), <span class="string">&quot;instance.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">for</span> host <span class="keyword">in</span> args.hosts:</span><br><span class="line">		command = <span class="string">&quot;hostname &amp;&amp; date &amp;&amp; whoami&quot;</span></span><br><span class="line">        module = host.split(<span class="string">&quot;_&quot;</span>,<span class="number">2</span>)[<span class="number">2</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;输入的参数是：&quot;</span> + host)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;对应的模块是：&quot;</span> + module)</span><br><span class="line">        chenchenchen = <span class="string">&quot;cd /opt/&quot;</span> + module +<span class="string">&quot;/ &amp;&amp; ./stop.sh &amp;&amp; ./start.sh&quot;</span></span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;重启命令是：&quot;</span> +chenchenchen)</span><br><span class="line">        checkSQL(host)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ansible批量执行出现错误，请检查！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭文件                              </span></span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭数据库连接                        </span></span><br><span class="line">db.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行ansible</span></span><br><span class="line">data = runner(ansible_host_path, <span class="string">&quot;shell&quot;</span>, command)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line">os.remove(ansible_host_path)</span><br></pre></td></tr></table></figure></p>
<p>执行效果如下：<br><img data-src="/images/ansibleip4.png" alt="akb48" title="本脚本是可以执行多个组"></p>
<p>上面的脚本里执行的是ansible语句，如果想要执行playbook，可以看一下<a href="https://blog.csdn.net/CCjedweat/article/details/88683152">https://blog.csdn.net/CCjedweat/article/details/88683152</a> 这位大神的文章。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>python2</tag>
        <tag>ansible api</tag>
      </tags>
  </entry>
  <entry>
    <title>Python3写文件的几个例子</title>
    <url>/2019/01/04/Python3%E5%86%99%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E4%B8%AA%E4%BE%8B%E5%AD%90/</url>
    <content><![CDATA[<h2 id="拷贝一个文件的全部内容到另一个文件"><a href="#拷贝一个文件的全部内容到另一个文件" class="headerlink" title="拷贝一个文件的全部内容到另一个文件"></a>拷贝一个文件的全部内容到另一个文件</h2><p>复制<code>aaa.txt</code>内容到另一个<code>bbb.txt</code><br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fp = <span class="built_in">open</span>(<span class="string">&#x27;aaa.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> fp:</span><br><span class="line">        fq = <span class="built_in">open</span>(<span class="string">&#x27;bbb.txt&#x27;</span>,<span class="string">&#x27;a&#x27;</span>)	<span class="comment">#这里用追加模式，这里不能用w</span></span><br><span class="line">        fq.write(line)</span><br><span class="line">    fp.close()</span><br></pre></td></tr></table></figure></p>
<h2 id="在文件头部插入数据"><a href="#在文件头部插入数据" class="headerlink" title="在文件头部插入数据"></a>在文件头部插入数据</h2><p>读出原有文件内容<code>aaa.txt</code>，移动索引到开始，写入新的数据data，然后再写入旧的数据。<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;aaa.txt&#x27;</span>, <span class="string">&quot;r+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">     old = f.read()		<span class="comment">#将原来的内容取出</span></span><br><span class="line">     f.seek(<span class="number">0</span>)		<span class="comment">#索引移动到头</span></span><br><span class="line">     f.write(data)</span><br><span class="line">     f.write(old)</span><br></pre></td></tr></table></figure></p>
<h2 id="清空文件的内容"><a href="#清空文件的内容" class="headerlink" title="清空文件的内容"></a>清空文件的内容</h2><p>当已存在一个文件对象，且这个文件对象可以对文件进行写<code>write</code>操作(注意不是追加<code>append</code>操作),则可以通过如下语句来清空一个文件的内容:<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;file.txt&#x27;</span>,<span class="string">&#x27;r+&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.truncate()     <span class="comment">#使用文件对象的成员函数truncate()来清空一个文件</span></span><br></pre></td></tr></table></figure></p>
<h2 id="如何让html文件识别换行符？"><a href="#如何让html文件识别换行符？" class="headerlink" title="如何让html文件识别换行符？"></a>如何让html文件识别换行符？</h2><p>如果使用替换方法把<code>\r\n</code>替换成<code>&lt;br&gt;</code>的话太蠢了，其实这种需求可以一句话解决：头尾加<code>&lt;pre&gt;&lt;/pre&gt;</code>。</p>
<p><img data-src="/images/hardenkill.gif" alt="akb48" title="哈登加时绝杀勇士"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>文件读写</tag>
      </tags>
  </entry>
  <entry>
    <title>Python3使用AES-ECS方法加密</title>
    <url>/2020/11/18/Python3%E4%BD%BF%E7%94%A8AES-ECS%E6%96%B9%E6%B3%95%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<p>突然发现好久没有更新了，主要是前段时间忙双十一太忙了，通宵压测几乎15次，可以说从国庆放假回来不是在压测就是在补觉，然后公司的夜宵吃几次也就腻了，所以全链路压测的新鲜感一消失就会很迷茫。不过每次看到那些大佬们也都熬夜压测，心里还多少平衡一点…</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在公司的一部分产品的API中，有接口是使用AES对称加解密方法来实现，并且采用ECB模式，是链接内部工具的，但是这个API的demo是用python2来写的，由于我的Django是python3.8，于是就要自己手改。代码如下，这里没有加上加解密的部分。</p>
<pre><code><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#引入依赖包</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line">appname = <span class="string">&quot;这里是应用名称&quot;</span></span><br><span class="line">timestamp = <span class="built_in">int</span>(time.time() * <span class="number">1000</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前时间戳是:&quot;</span> + <span class="built_in">str</span>(timestamp))</span><br><span class="line"></span><br><span class="line"><span class="comment">#封装AECS</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">prpcrypt</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="variable language_">self</span>.key = key</span><br><span class="line">        <span class="variable language_">self</span>.mode = AES.MODE_ECB</span><br><span class="line">        <span class="variable language_">self</span>.BS = <span class="built_in">len</span>(key)</span><br><span class="line">        <span class="comment"># 如果刚好是s是BS的倍数，那么补一组</span></span><br><span class="line">        <span class="variable language_">self</span>.pad = <span class="keyword">lambda</span> s: s + (<span class="variable language_">self</span>.BS - <span class="built_in">len</span>(s) % <span class="variable language_">self</span>.BS) * <span class="built_in">chr</span>(<span class="variable language_">self</span>.BS - <span class="built_in">len</span>(s) % <span class="variable language_">self</span>.BS).encode()</span><br><span class="line">        <span class="comment"># python3这里多了一个encode，python2的写法是self.pad = lambda s: s + (self.BS - len(s) % self.BS) * chr(self.BS - len(s) % self.BS)</span></span><br><span class="line">        <span class="variable language_">self</span>.unpad = <span class="keyword">lambda</span> s: s[<span class="number">0</span>:-s[-<span class="number">1</span>]]  <span class="comment"># python2的写法是：self.unpad = lambda s : s[0:-ord(s[-1])]，这里把ord去掉了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#  加密</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Encrypt</span>(<span class="params">self,text</span>):</span><br><span class="line">        text = <span class="variable language_">self</span>.pad(text)</span><br><span class="line">        cryptor = AES.new(<span class="variable language_">self</span>.key,<span class="variable language_">self</span>.mode, <span class="string">b&#x27;0000000000000000&#x27;</span>) <span class="comment">#必须16位</span></span><br><span class="line">        ciphertext = cryptor.encrypt(text)</span><br><span class="line">        <span class="keyword">return</span> ciphertext</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#签名计算</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sign</span>(<span class="params">timestamp</span>):</span><br><span class="line">    content = <span class="built_in">format</span>(<span class="string">&quot;appName=%s;timestamp=%s&quot;</span> % (appname, timestamp))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;传入的动态值：&quot;</span>, content)</span><br><span class="line">    key = base64.decodebytes(<span class="string">b&#x27;1234567890abcdefghijkl==&#x27;</span>)       <span class="comment"># 这里是secret，我这里是24位</span></span><br><span class="line">    ciphertext = prpcrypt(key).Encrypt(content.encode(<span class="string">&#x27;utf-8&#x27;</span>))  <span class="comment"># utf8编码</span></span><br><span class="line">    endata = base64.urlsafe_b64encode(ciphertext).decode().rstrip(<span class="string">&#x27;=&#x27;</span>)  <span class="comment"># 必须urlsafe格式后，tstrip掉&quot;=&quot;，这里python3，需要添加一个decode()，这样就可以由bytes转str了</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;加密签名是：&#x27;</span>,endata)</span><br><span class="line">    <span class="keyword">return</span> endata</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    signature = sign(timestamp)  <span class="comment"># 这里通过时间戳的变化和不同的appname，来得到加密签名</span></span><br></pre></td></tr></table></figure>
</code></pre>
<p>其实这比较恶心的地方就是Python3.x和Python2.x在一些类型上不同，比如长类型和bytes的用法上，总结一下，Python3.x和Python2.x在套接字返回值解码上有区别:<br>python bytes和str两种类型可以通过函数<code>encode()</code>和<code>decode()</code>相互转换，<br><code>str→bytes</code>：<code>encode()</code>方法。<code>str</code>通过<code>encode()</code>方法可以转换为<code>bytes</code>。<br><code>bytes→str</code>：<code>decode()</code>方法。如果我们从网络或磁盘上读取了字节流，那么读到的数据就是<code>bytes</code>。要把<code>bytes</code>变为<code>str</code>，就需要用<code>decode()</code>方法。</p>
<h2 id="hex加密的python2-3"><a href="#hex加密的python2-3" class="headerlink" title="hex加密的python2-&gt;3"></a>hex加密的python2-&gt;3</h2><p>python2的脚本是这样的：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#根据你申请的账号和对应的key,加上当前的时间戳,得到一个秘钥</span><br><span class="line">import md5</span><br><span class="line"></span><br><span class="line">account=&quot;test-skyline&quot;;</span><br><span class="line">key = &quot;myPrivateKey&quot;;</span><br><span class="line">timeStamp = 1531310369L;</span><br><span class="line">toEncrypt = account+key+str(timeStamp);</span><br><span class="line">signature=md5.new(toEncrypt).digest().encode(&#x27;hex&#x27;)</span><br><span class="line"># 结果: (&#x27;5fbd62ee4cf62c503ec8e417d7289816&#x27;, &lt;type &#x27;str&#x27;&gt;)</span><br></pre></td></tr></table></figure></p>
<p>而python3的版本就是这样了:<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 原脚本是python2的，现在要转成python3版本,https://yuque.antfin-inc.com/at7ocb/qbn0oy/cahbgn</span><br><span class="line"></span><br><span class="line">from hashlib import md5</span><br><span class="line">import binascii</span><br><span class="line"></span><br><span class="line">account = &quot;test-skyline&quot;</span><br><span class="line">key = &quot;myPrivateKey&quot;</span><br><span class="line"></span><br><span class="line">timeStamp = 1531310369  # python3直接这么写就行，不用带L</span><br><span class="line">en_data = account+key+str(timeStamp)</span><br><span class="line">toEncrypt = md5(en_data.encode(&quot;utf-8&quot;))  # python3的写法</span><br><span class="line">signature = binascii.b2a_hex(toEncrypt.digest())</span><br><span class="line"></span><br><span class="line">print(signature,type(signature))</span><br><span class="line"># 结果：b&#x27;5fbd62ee4cf62c503ec8e417d7289816&#x27; &lt;class &#x27;bytes&#x27;&gt;</span><br></pre></td></tr></table></figure><br><img data-src="/images/%E8%AF%BA%E4%BC%8A%E5%B0%94%E8%A2%AB%E8%B8%A2%E5%82%BB%E4%BA%86.JPG" alt="akb48" title="输了0比6，看看勒夫啥时候下课"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>平台搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Python端口探测脚本</title>
    <url>/2019/06/25/Python%E7%AB%AF%E5%8F%A3%E6%8E%A2%E6%B5%8B%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>有一个模块最近总是假死，假死的现象就是进程还在但是端口（9030端口）已经不工作了。于是就需要写一个端口探测脚本，发现该端口一旦无法正常收到信息，就重启此模块。</p>
<p>由于此模块是一个五台机器的集群，我这次没有在五台机器都跑一样的脚本，而是在一个可以免密码ssh到他们的机器上写了一个脚本，让这个机器去探测对应的端口。模式如图：<br><img data-src="/images/yum5.png" alt="akb48"></p>
<p>先创建一个<code>detect.conf</code>如下，他的格式是yaml，所以不要用tab用空格：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">    Name: localhost</span><br><span class="line">    IP: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    Port: <span class="number">9030</span></span><br><span class="line">---</span><br><span class="line">    Name: mrs-05</span><br><span class="line">    IP: <span class="number">10.0</span><span class="number">.1</span><span class="number">.14</span></span><br><span class="line">    Port: <span class="number">9030</span></span><br><span class="line">---</span><br><span class="line">    Name: mrs-04</span><br><span class="line">    IP: <span class="number">10.0</span><span class="number">.1</span><span class="number">.13</span></span><br><span class="line">    Port: <span class="number">9030</span></span><br><span class="line">---</span><br><span class="line">    Name: mrs-03</span><br><span class="line">    IP: <span class="number">10.0</span><span class="number">.1</span><span class="number">.12</span></span><br><span class="line">    Port: <span class="number">9030</span></span><br><span class="line">---</span><br><span class="line">    Name: mrs-02</span><br><span class="line">    IP: <span class="number">10.0</span><span class="number">.1</span><span class="number">.11</span></span><br><span class="line">    Port: <span class="number">9030</span></span><br></pre></td></tr></table></figure></p>
<p>脚本<code>detect.py</code>内容如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python </span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># 作者：ChrisChan</span></span><br><span class="line"><span class="comment"># 用途：Python3.6脚本，检测IP端口连接是否正常,建议放在单独的机器里进行端口扫描，此脚本需要搭配同目录下的detect.conf使用。</span></span><br><span class="line"><span class="comment"># 请先pip install PyYaml,pip install paramiko</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># ssh秘钥地址</span></span><br><span class="line">key_filename = <span class="string">&quot;秘钥地址,即id_rsa&quot;</span></span><br><span class="line"><span class="comment"># 重启进程命令</span></span><br><span class="line">command = <span class="string">&quot;具体的进程启动命令&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_open</span>(<span class="params">ip, port</span>):</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s.connect((ip, <span class="built_in">int</span>(port)))</span><br><span class="line">        s.shutdown(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ssh</span>(<span class="params">ip</span>):</span><br><span class="line">    ssh = paramiko.SSHClient()</span><br><span class="line">    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ssh.connect(ip, <span class="number">22</span>, <span class="string">&quot;appuser&quot;</span>, key_filename=key_filename)	<span class="comment">#这里写死了22端口和appuser用户</span></span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;私钥文件不存在！&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> AuthenticationException <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;私钥不正确，请检查对应用户或私钥内容！&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        stdin, stdout, stderr = ssh.exec_command(command)</span><br><span class="line">        <span class="built_in">print</span>(stdout.readlines())</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        ssh.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">input</span> = <span class="built_in">open</span>(<span class="string">&#x27;detect.conf&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)    <span class="comment"># 这里是pyyaml 5.1的新格式</span></span><br><span class="line">    ys = yaml.load_all(<span class="built_in">input</span>, Loader=yaml.FullLoader)</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> ys:</span><br><span class="line">        host = y[<span class="string">&quot;IP&quot;</span>]		<span class="comment">#从yaml里取值</span></span><br><span class="line">        port = y[<span class="string">&quot;Port&quot;</span>]</span><br><span class="line">        <span class="keyword">if</span> is_open(host, port):</span><br><span class="line">            <span class="built_in">print</span>(y[<span class="string">&quot;Name&quot;</span>] + <span class="string">&quot; is OK&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(y[<span class="string">&quot;Name&quot;</span>] + <span class="string">&quot; is NO&quot;</span>)</span><br><span class="line">            ssh(host)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Process is started!&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>内网探测效果还不错，如果时间耗时比较长，就放弃for循环，走多进程路线更佳！<br><img data-src="/images/yum6.png" alt="akb48"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title>Python应用内存排查工具</title>
    <url>/2022/11/28/Python%E5%BA%94%E7%94%A8%E5%86%85%E5%AD%98%E6%8E%92%E6%9F%A5%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>近期遇到Python内存泄露的问题，记录一下排查工具。</p>
<h2 id="tracemalloc"><a href="#tracemalloc" class="headerlink" title="tracemalloc"></a>tracemalloc</h2><p>tracemalloc是Python3.4起在标准库中默认加入的模块，可以用作内存分配跟踪。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tracemalloc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动内存跟踪</span></span><br><span class="line">tracemalloc.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">allocate_memory</span>():</span><br><span class="line">    <span class="comment"># 创建一些占用内存的数据结构</span></span><br><span class="line">    a = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>)]</span><br><span class="line">    b = &#123;<span class="built_in">str</span>(i): i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>)&#125;</span><br><span class="line">    c = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>))</span><br><span class="line">    <span class="keyword">return</span> a, b, c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分配内存</span></span><br><span class="line">a, b, c = allocate_memory()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前的内存分配情况</span></span><br><span class="line">snapshot = tracemalloc.take_snapshot()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取内存分配最多的前10个地方</span></span><br><span class="line">top_stats = snapshot.statistics(<span class="string">&#x27;lineno&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Top 10 lines with the most memory usage:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> stat <span class="keyword">in</span> top_stats[:<span class="number">10</span>]:</span><br><span class="line">    <span class="built_in">print</span>(stat)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(top_stats)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止内存跟踪</span></span><br><span class="line">tracemalloc.stop()</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Top <span class="number">10</span> lines <span class="keyword">with</span> the most memory usage:</span><br><span class="line">/Users/taoxi/Desktop/动手<span class="number">1.</span>py:<span class="number">201</span>: size=<span class="number">11.1</span> MiB, count=<span class="number">199744</span>, average=<span class="number">58</span> B</span><br><span class="line">/Users/taoxi/Desktop/动手<span class="number">1.</span>py:<span class="number">200</span>: size=<span class="number">3899</span> KiB, count=<span class="number">99744</span>, average=<span class="number">40</span> B</span><br><span class="line">/Users/taoxi/Desktop/动手<span class="number">1.</span>py:<span class="number">202</span>: size=<span class="number">392</span> B, count=<span class="number">3</span>, average=<span class="number">131</span> B</span><br><span class="line">/Users/taoxi/Desktop/动手<span class="number">1.</span>py:<span class="number">198</span>: size=<span class="number">232</span> B, count=<span class="number">2</span>, average=<span class="number">116</span> B</span><br><span class="line">/Library/Frameworks/Python.framework/Versions/<span class="number">3.12</span>/lib/python3<span class="number">.12</span>/tracemalloc.py:<span class="number">551</span>: size=<span class="number">72</span> B, count=<span class="number">1</span>, average=<span class="number">72</span> B</span><br><span class="line">[&lt;Statistic traceback=&lt;Traceback (&lt;Frame filename=<span class="string">&#x27;/Users/taoxi/Desktop/动手1.py&#x27;</span> lineno=<span class="number">201</span>&gt;,)&gt; size=<span class="number">11625466</span> count=<span class="number">199744</span>&gt;, &lt;Statistic traceback=&lt;Traceback (&lt;Frame filename=<span class="string">&#x27;/Users/taoxi/Desktop/动手1.py&#x27;</span> lineno=<span class="number">200</span>&gt;,)&gt; size=<span class="number">3992704</span> count=<span class="number">99744</span>&gt;, &lt;Statistic traceback=&lt;Traceback (&lt;Frame filename=<span class="string">&#x27;/Users/taoxi/Desktop/动手1.py&#x27;</span> lineno=<span class="number">202</span>&gt;,)&gt; size=<span class="number">392</span> count=<span class="number">3</span>&gt;, &lt;Statistic traceback=&lt;Traceback (&lt;Frame filename=<span class="string">&#x27;/Users/taoxi/Desktop/动手1.py&#x27;</span> lineno=<span class="number">198</span>&gt;,)&gt; size=<span class="number">232</span> count=<span class="number">2</span>&gt;, &lt;Statistic traceback=&lt;Traceback (&lt;Frame filename=<span class="string">&#x27;/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/tracemalloc.py&#x27;</span> lineno=<span class="number">551</span>&gt;,)&gt; size=<span class="number">72</span> count=<span class="number">1</span>&gt;]</span><br></pre></td></tr></table></figure>


<p>其中：<br>● size代表该行实际使用的内存<br>● count代表内存块分配次数<br>● average代表每个内存块的平均大小</p>
<h2 id="objgraph"><a href="#objgraph" class="headerlink" title="objgraph"></a>objgraph</h2><p>objgraph是pypi三方库，需要额外安装,pip install objgraph。</p>
<p>使用方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pympler.tracker <span class="keyword">import</span> SummaryTracker</span><br><span class="line"></span><br><span class="line">tracker = SummaryTracker()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一些占用内存的数据结构</span></span><br><span class="line">a = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>)]</span><br><span class="line">b = &#123;<span class="built_in">str</span>(i): i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>)&#125;</span><br><span class="line">c = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>))</span><br><span class="line"></span><br><span class="line">tracker.print_diff()</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">                  types |   <span class="comment"># objects |     total size</span></span><br><span class="line">======================= | =========== | ==============</span><br><span class="line">                   <span class="built_in">dict</span> |           <span class="number">5</span> |        <span class="number">5.00</span> MB</span><br><span class="line">                    <span class="built_in">int</span> |      <span class="number">101749</span> |        <span class="number">2.72</span> MB</span><br><span class="line">                   <span class="built_in">list</span> |        <span class="number">9308</span> |        <span class="number">1.54</span> MB</span><br><span class="line">                    <span class="built_in">str</span> |        <span class="number">9307</span> |      <span class="number">665.85</span> KB</span><br><span class="line">      method_descriptor |          <span class="number">13</span> |      <span class="number">936</span>     B</span><br><span class="line">                weakref |           <span class="number">2</span> |      <span class="number">144</span>     B</span><br><span class="line">  function (store_info) |           <span class="number">1</span> |      <span class="number">136</span>     B</span><br><span class="line">                   code |          -<span class="number">2</span> |       <span class="number">86</span>     B</span><br><span class="line">     wrapper_descriptor |           <span class="number">1</span> |       <span class="number">72</span>     B</span><br><span class="line">      member_descriptor |           <span class="number">1</span> |       <span class="number">64</span>     B</span><br><span class="line">                 method |           <span class="number">1</span> |       <span class="number">64</span>     B</span><br><span class="line">          list_iterator |          -<span class="number">2</span> |      -<span class="number">96</span>     B</span><br><span class="line">              generator |          -<span class="number">1</span> |     -<span class="number">112</span>     B</span><br><span class="line">                   cell |        -<span class="number">156</span> |    -<span class="number">6240</span>     B</span><br><span class="line">                  <span class="built_in">tuple</span> |        -<span class="number">142</span> |   -<span class="number">10288</span>     B</span><br></pre></td></tr></table></figure>
<p>可见，主要展示了各数据类型的数量及总大小，可用于辅助排查。</p>
<h2 id="memory-profiler"><a href="#memory-profiler" class="headerlink" title="memory_profiler"></a>memory_profiler</h2><p>memory_profiler是pypi三方库，需要额外安装,pip install memory_profiler。</p>
<p>使用方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> memory_profiler <span class="keyword">import</span> profile</span><br><span class="line"></span><br><span class="line"><span class="meta">@profile</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fake_func</span>(<span class="params">n</span>):</span><br><span class="line">    lst = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">return</span> lst</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    fake_func(<span class="number">1000000</span>)</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Line <span class="comment">#    Mem usage    Increment  Occurrences   Line Contents</span></span><br><span class="line">=============================================================</span><br><span class="line">     <span class="number">3</span>     <span class="number">76.4</span> MiB     <span class="number">76.4</span> MiB           <span class="number">1</span>   @profile</span><br><span class="line">     <span class="number">4</span>                                         <span class="keyword">def</span> <span class="title function_">fake_func</span>(<span class="params">n</span>):</span><br><span class="line">     <span class="number">5</span>    <span class="number">115.0</span> MiB     <span class="number">38.5</span> MiB     <span class="number">1000003</span>       lst = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">     <span class="number">6</span>    <span class="number">115.0</span> MiB      <span class="number">0.0</span> MiB           <span class="number">1</span>       <span class="keyword">return</span> lst</span><br></pre></td></tr></table></figure>

<p>这个感觉更骚一点，定位效果更好。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Python调用另一个py变量失败的问题</title>
    <url>/2019/12/31/Python%E8%B0%83%E7%94%A8%E5%8F%A6%E4%B8%80%E4%B8%AApy%E5%8F%98%E9%87%8F%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>我有两个文件，第一个文件<code>a.py</code>的内容如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line">CHOOSE = <span class="built_in">input</span> (<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">         \033[1;35m choose 1 or 2:\033[0m</span></span><br><span class="line"><span class="string">         1)tom</span></span><br><span class="line"><span class="string">         2)jack</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">a = <span class="number">666</span></span><br><span class="line">b = <span class="string">&quot;bbb&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;this is a test&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;function&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> CHOOSE == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">        username = <span class="string">&#x27;tom&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(username)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> CHOOSE == <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">        username = <span class="string">&#x27;jack&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(username)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;wrong choice,script is exit...&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>拎一个脚本，<code>b.py</code>的内容如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> a</span><br><span class="line"><span class="keyword">from</span> a <span class="keyword">import</span> b,f,CHOOSE,username</span><br><span class="line"></span><br><span class="line">a = a.a</span><br><span class="line">f()</span><br><span class="line"><span class="built_in">print</span>(b,a,CHOOSE,username)</span><br></pre></td></tr></table></figure></p>
<p>可以看出<code>b.py</code>的内容就是调用同目录下<code>a.py</code>的变量，但是执行<code>b.py</code>是会报错的。<br><img data-src="/images/pyredis4.png" alt="akb48"></p>
<p>可见<code>b.py</code>已经成功读取到了<code>b,f,CHOOSE</code>这些变量，但是<code>username</code>却引入失败，为啥呢？</p>
<p>因为<code>a.py</code>里有一个<code>if __name__ == &#39;__main__&#39;</code>，他的意思是<font color=red>当.py文件被直接运行时，if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘之下的代码块将被运行；当.py文件以模块形式被导入时，if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘之下的代码块不被运行。</font></p>
<p>举个例子解释一下：假设你是<code>小明.py</code>，在朋友眼中你是小明(<strong>name</strong> &#x3D;&#x3D; ‘小明’), 你自己眼中你是你自己(<strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘)。</p>
<p>你编程很好, 朋友调你去帮他写程序(import 小明, 这时你在朋友眼中: <strong>name</strong> &#x3D;&#x3D; ‘小明’),但你晚上也会打开xx网站, 做一些自己的事情(直接运行小明.py, <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘)—摘自知乎网友回答。</p>
<p>既然知道了原因，解决方法也很简单：把<code>a.py</code>里的<code>if __name__ == &#39;__main__&#39;</code>段落拆掉，把相应内容改成一个函数，比如<code>a.py</code>改成如下的样子：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">上面内容略</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">CHOOSE</span>):</span><br><span class="line">    <span class="keyword">if</span> CHOOSE == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">        username = <span class="string">&#x27;tom&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> CHOOSE == <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">        username = <span class="string">&#x27;jack&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        username = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> username</span><br></pre></td></tr></table></figure></p>
<p><code>b.py</code>改成如下样子(其他可读取的变量不考虑)：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> a <span class="keyword">import</span> foo</span><br><span class="line">CHOOSE = <span class="built_in">input</span> (<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">         \033[1;35m choose 1 or 2:\033[0m</span></span><br><span class="line"><span class="string">         1)tom</span></span><br><span class="line"><span class="string">         2)jack</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">username = foo(CHOOSE)</span><br><span class="line"><span class="keyword">if</span> username:</span><br><span class="line">    <span class="built_in">print</span>(username)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Wrong choice&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>这样问题就解决了，记住<code>if __name__ == &#39;__main__&#39;</code>更适合放在脚本的入口点。</p>
<p>上面说了，<code>if __name__ == &#39;__main__&#39;</code>更适合放在脚本的入口点，到底哪个程序入口被选中，这取决于<code>__name__</code>的值，<code>__name__</code>是内置变量，可用于表示当前模块的名字。如果一个<code>.py</code>文件（模块）被直接运行时，则其没有包结构，其<code>__name__</code>值为<code>__main__</code>，即模块名为<code>__main__</code>。</p>
<p>所以，<code>if __name__ == &#39;__main__&#39;</code>的意思是：当<code>.py</code>文件被直接运行时，<code>if __name__ == &#39;__main__&#39;</code>之下的代码块将被运行；当<code>.py</code>文件以模块形式被导入时，<code>if __name__ == &#39;__main__&#39;</code>之下的代码块不被运行。</p>
<p>上面的话，可以做一个小实验来理解，我们在<code>a.py</code>里<code>if __name__ == &#39;__main__&#39;</code>之前加入<code>print __name__</code>，即将<code>__name__</code>打印出来，那么执行<code>a.py</code>会看到<code>__name__</code>输出是<code>__main__</code>。<br><img data-src="/images/pyredis5.png" alt="akb48"></p>
<p>但是此时<code>a.py</code>不动，直接执行<code>b.py</code>，会发现<code>__name__</code>变量值为b,不满足<code>__name__==&quot;__main__&quot;</code>的条件，因此，无法执行其后的代码:<br><img data-src="/images/pyredis6.png" alt="akb48"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/34112508">https://zhuanlan.zhihu.com/p/34112508</a><br><a href="http://blog.konghy.cn/2017/04/24/python-entry-program/">http://blog.konghy.cn/2017/04/24/python-entry-program/</a><br><a href="https://stackoverflow.com/questions/419163/what-does-if-name-main-do">https://stackoverflow.com/questions/419163/what-does-if-name-main-do</a><br><a href="https://www.zhihu.com/question/49136398">https://www.zhihu.com/question/49136398</a> （里面有很多例子）<br><a href="https://blog.csdn.net/liao392781/article/details/80496060">https://blog.csdn.net/liao392781/article/details/80496060</a> （跨文件夹引用PY文件的方法）</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python里调用redis的方法</title>
    <url>/2018/01/29/Python%E9%87%8C%E8%B0%83%E7%94%A8redis%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>Python 2.7里不是自带<code>redis</code>模块的，那么在调用redis的时候自然也会报错，比如：<br><img data-src="/images/pyredis1.png"></p>
<p>遇到这种情况怎么办？</p>
<p>第一种方法：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pip install redis</span><br></pre></td></tr></table></figure></p>
<p>第二种方法：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">easy_install redis</span><br></pre></td></tr></table></figure></p>
<p>第三种方法：<br>去登录<code>https://github.com/andymccurdy/redis-py</code>，下载包上传到linux里之后，<code>python setup.py install</code>。<br><img data-src="/images/pyredis2.png"></p>
<p>flask模块的安装也是同理。</p>
<p>注意！这里只有<code>Redis</code>，如果使用<code>StrictRedis</code>会报错：<code>AttributeError: &#39;Redis&#39; object has no attribute &#39;StrictRedis&#39;</code>。这个是版本的问题。见<br><a href="https://github.com/andymccurdy/redis-py/issues/188">https://github.com/andymccurdy/redis-py/issues/188</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://debugo.com/python-redis/">http://debugo.com/python-redis/</a></p>
<p><img data-src="/images/%E6%AC%A7%E6%96%87%E9%AA%9A%E8%84%9A%E6%AD%A5.gif" title="这脚步把我看高潮了..."></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>SFTP不能连接服务器怎么办？</title>
    <url>/2018/01/27/SFTP%E4%B8%8D%E8%83%BD%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/</url>
    <content><![CDATA[<p>今天在跳板机上传送文件，发现使用<code>SFTP</code>连接的时候，出现了这样的一个拒绝情况：<br><img data-src="/images/sftp1.png"></p>
<p>登陆到这个跳板机里，使用<code>tail /var/log/secure</code>，看到了拒绝的具体信息，如下：<br><img data-src="/images/sftp2.png"></p>
<p>这个时候，我就需要<code>locate sftp-server</code>，用<code>locate</code>定位一下<code>sftp</code>文件，但是发现服务器竟然回答我<code>-bash: locate: command not found</code>。</p>
<p>于是就<code>yum -y install mlocate</code>，安装<code>mlocate</code>之后执行<code>updatedb</code>，需要等待一小会，然后再次执行<code>locate sftp-server</code>，就可以得到sftp-server的文件路径了，如下图：<br><img data-src="/images/sftp3.png"></p>
<p>打开sshd的配置文件，<code>vi /etc/ssh/sshd_config</code>，把<code>Subsystem</code>这一行前面的<code>#</code>去掉：<br><img data-src="/images/sftp4.png"></p>
<p>然后重启启动ssh服务，语句是<code>/etc/init.d/sshd reload</code>，重新连接一下，发现就恢复正常了。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>sftp</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ的安装、配置与启动</title>
    <url>/2018/03/19/RabbitMQ%E7%9A%84%E5%AE%89%E8%A3%85%E3%80%81%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>环境介绍：<code>Centos 7</code> + <code>RabbitMQ：3.6.12</code> + <code>Erlang：20.0</code></p>
<h2 id="安装erlang"><a href="#安装erlang" class="headerlink" title="安装erlang"></a>安装erlang</h2><p>由于RabbitMQ使用erlang语言编写的，所以要先安装erlang语言环境。但是yum源里的erlang版本太老了，于是这里选择手动安装，使用Erlang官方推荐的<code>Erlang Solutions</code>安装方法如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yum install gcc gcc-c++ glibc-devel make ncurses-devel openssl-devel autoconf java-<span class="number">1.8</span><span class="number">.0</span>-openjdk-devel git wget wxBase.<span class="property">x86_64</span>		#先把其他模块准备好</span><br><span class="line">wget <span class="attr">https</span>:<span class="comment">//packages.erlang-solutions.com/erlang-solutions-1.0-1.noarch.rpm</span></span><br><span class="line">rpm -<span class="title class_">Uvh</span> erlang-solutions-<span class="number">1.0</span>-<span class="number">1.</span>noarch.<span class="property">rpm</span></span><br><span class="line">rpm --<span class="keyword">import</span> <span class="attr">https</span>:<span class="comment">//packages.erlang-solutions.com/rpm/erlang_solutions.asc</span></span><br></pre></td></tr></table></figure></p>
<p>此时，查看<code>/etc/yum.repos.d/erlang_solutions.repo</code>，应该是这个样子：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[erlang-solutions]</span><br><span class="line">name=<span class="title class_">CentOS</span> $releasever - $basearch - <span class="title class_">Erlang</span> <span class="title class_">Solutions</span></span><br><span class="line">baseurl=<span class="attr">https</span>:<span class="comment">//packages.erlang-solutions.com/rpm/centos/$releasever/$basearch</span></span><br><span class="line">gpgcheck=<span class="number">1</span></span><br><span class="line">gpgkey=<span class="attr">https</span>:<span class="comment">//packages.erlang-solutions.com/rpm/erlang_solutions.asc</span></span><br><span class="line">enabled=<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>这个时候可以yum安装了：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yum install -y esl-erlang</span><br></pre></td></tr></table></figure></p>
<p>此时得到的erlang就是20.0版本的了，如图：<br><img data-src="/images/rabbitmq1.png" alt="paradin"></p>
<p>如果不想使用这个办法，可以使用源码安装的方式，<a href="https://packages.erlang-solutions.com/erlang/">https://packages.erlang-solutions.com/erlang/</a> 这里面有Erlang官方的下载包，拆包解压缩然后<code>make &amp;&amp; make install</code>即可。</p>
<h2 id="安装RabbitMQ"><a href="#安装RabbitMQ" class="headerlink" title="安装RabbitMQ"></a>安装RabbitMQ</h2><p>安装RabbitMQ跟其他普通软件差不多，先去官网下载目前较稳定的rpm包，然后安装，步骤如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wget <span class="attr">https</span>:<span class="comment">//dl.bintray.com/rabbitmq/all/rabbitmq-server/3.7.4/rabbitmq-server-3.7.4-1.el7.noarch.rpm</span></span><br><span class="line">yum install -y rabbitmq-server-<span class="number">3.7</span><span class="number">.4</span>-<span class="number">1.</span>el7.<span class="property">noarch</span>.<span class="property">rpm</span></span><br></pre></td></tr></table></figure></p>
<p>如果出现了<code>Transaction Check Error</code>的错误：<br><img data-src="/images/rabbitmq2.png" alt="paradin"></p>
<p>可见是要安装的包与已有的包相冲突，此时需要<code>yum list|grep erlang</code>，如图：</p>
<p><img data-src="/images/rabbitmq3.png" alt="paradin"><br>再<code>yum remove esl-erlang.x86_64</code>，然后重新执行yum install那一步即可。</p>
<p>如果出现<code>Requires: socat</code>的错误，如图：<br><img data-src="/images/rabbitmq6.png" alt="paradin"></p>
<p>此时需要执行如下命令即可：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yum -y install epel-release</span><br><span class="line">yum -y install socat</span><br></pre></td></tr></table></figure></p>
<h2 id="配置RabbitMQ"><a href="#配置RabbitMQ" class="headerlink" title="配置RabbitMQ"></a>配置RabbitMQ</h2><p>RabbitMQ安装完毕，先<code>chkconfig rabbitmq-server on</code>设置开机启动。然后，配置一下用户名。我这个机器的用户名不规范，需要把hostname里的中文去掉，比如改成：<code>3-dvl-hlsproxy-001</code>，那么就要在&#x2F;etc&#x2F;hosts里添加一句：</p>
<pre><code>内网IP地址 3-dvl-hlsproxy-001
</code></pre>
<p>然后执行<code>rabbitmq-plugins enable rabbitmq_management</code>来安装WEB图形界面，然后拷贝<code>rabbitmq.config.example</code>到<code>/etc/rabbitmq/</code>里，并且改名叫<code>rabbitmq.config</code>，命令如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cp /usr/share/doc/rabbitmq-server-<span class="number">3.7</span><span class="number">.4</span>/rabbitmq.<span class="property">config</span>.<span class="property">example</span> /etc/rabbitmq/</span><br><span class="line">cd /etc/rabbitmq/</span><br><span class="line">mv rabbitmq.<span class="property">config</span>.<span class="property">example</span> rabbitmq.<span class="property">config</span></span><br></pre></td></tr></table></figure></p>
<p>编辑<code>rabbitmq.config</code>这个文件，把<code>%%{loopback_users, []}.</code>改成<code>{loopback_users, []}</code>，保存之后，执行<code>service rabbitmq-server restart</code>来启动RabbitMQ。</p>
<p>如果启动之后，执行<code>rabbitmqctl status</code>不断的刷<code>Error when reading /var/lib/rabbitmq/.erlang.cookie: eacces</code>的错误的话，执行<code>chown rabbitmq:rabbitmq /var/lib/rabbitmq/.erlang.cookie</code>。</p>
<p>在浏览器里登录<code>外网IP:15672</code>就会看到RabbitMQ的WEB配置界面了，<br><img data-src="/images/rabbitmq4.png" alt="paradin"></p>
<p>账号和密码都是guest，输入之后就会看到如下的界面，可以在界面里看到<code>3-dvl-hlsproxy-001</code>的情况了，如图：<br><img data-src="/images/rabbitmq5.png" alt="paradin"></p>
<p>RabbitMQ 3.0以后版本的WEB端口是<code>15672</code>,服务的端口是<code>5672</code>,这俩都可以在配置文件里面更改。至此RabbitMQ的安装与配置结束了，但是这个仅仅是最简单的配置，RabbitMQ自身有一套很详细的用户管理规则以及它支持Python等很多语言的管理，这些内容以后再详细说明。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://packages.erlang-solutions.com/erlang/">https://packages.erlang-solutions.com/erlang/</a><br><a href="https://laucyun.com/9849587ce75f31d534d52f906c94368f.html">https://laucyun.com/9849587ce75f31d534d52f906c94368f.html</a><br><a href="https://www.rabbitmq.com/access-control.html">https://www.rabbitmq.com/access-control.html</a></p>
<p><img data-src="/images/salahe.gif" alt="paradin" title="大四喜的萨拉赫"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Root用户删除文件爆Permission denied</title>
    <url>/2019/07/11/Root%E7%94%A8%E6%88%B7%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E7%88%86Permission-denied/</url>
    <content><![CDATA[<p>今天在一台服务器上使用<code>useradd</code>创建用户，竟然爆<code>Permission denied</code>，我靠，我明明是root，竟然没有权限增加新用户，如图：<br><img data-src="/images/lsattr5.png" alt="抱光妹"></p>
<p>此时注意到下面还有一句话：<code>useradd: cannot lock /etc/passwd; try again later</code>。于是怀疑到可能在&#x2F;etc&#x2F;下有一个文件把passwd锁住了。搜索一番，发现了<code>.pwd.lock</code>这个文件，但是发现这个文件不能删除和改名，如图：<br><img data-src="/images/lsattr1.png" alt="抱光妹"><br><img data-src="/images/lsattr2.png" alt="抱光妹"></p>
<p>此时的我觉得root身份受到了很大的冒犯，怎么还有这种鬼现象？突然想到，可能这个锁文件被人给<code>chattr</code>修改了，于是使用<code>lsattr</code>查看这个文件，发现就剩下一个e属性了：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[root@ip-<span class="number">172</span>-<span class="number">31</span>-<span class="number">7</span>-<span class="number">167</span> etc]<span class="comment"># lsattr .pwd.lock </span></span><br><span class="line">-------------e- .pwd.lock</span><br></pre></td></tr></table></figure></p>
<p>e属性是不能用<code>chattr -e</code>删除的，而且也是一个很普通的属性，那么问题出在哪呢？</p>
<p>在<code>/etc/</code>下执行<code>lsattr -R -a</code>递归的查看所有文件（包含隐藏文件），发现原来当初是把整个<code>/etc/</code>文件夹加了i，如图：<br><img data-src="/images/lsattr3.png" alt="抱光妹"></p>
<p>于是就在<code>/etc/</code>路径下使用<code>chattr -i .</code>破掉了i属性，此时再次尝试删除lock锁文件，终于删除掉，并且成功创建了用户，如图：<br><img data-src="/images/lsattr4.png" alt="抱光妹"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>lsattr</tag>
      </tags>
  </entry>
  <entry>
    <title>Query String跟Arg的差异</title>
    <url>/2018/01/09/Query-String%E8%B7%9Farg%E7%9A%84%E5%BC%82%E5%90%8C/</url>
    <content><![CDATA[<h2 id="前言与需求"><a href="#前言与需求" class="headerlink" title="前言与需求"></a>前言与需求</h2><p>在<a href="https://rorschachchan.github.io/2018/01/09/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%85%8D%E7%BD%AErewrite%E5%92%8Creturn%E7%9A%84%E7%BB%8F%E5%8E%86/">https://rorschachchan.github.io/2018/01/09/记一次配置rewrite和return的经历/</a> 里记录了一次rewrite和return的故事，不过我当时在最后的return里是把域名给写死了：<code>rewrite ^.*$ http://dvlshop.lechange.com/index.php/wap/$id$query last;</code>。</p>
<p>现在新的需求又来了，说域名不要写死，<code>http://dvlshop.lechange.com/index.php/</code>这部分要跟整个uri的state部分保持一致。</p>
<p>于是我这里再把整个uri贴出来，辣一下各位的眼睛：<br><a href="http://dvlshop.lechange.com/index.php/wap/">http://dvlshop.lechange.com/index.php/wap/</a>?<br><em>client_id</em>&#x3D;lc_mall_m&amp;<br><em>redirect_uri</em>&#x3D;https%3A%2F%2Fdvlshop.lechange.com%2Fopenapi%2Ftrustlogin_api%2Fparse%2Fwap_trustlogin_lecheng%2Fcallback&amp;<br><em>response_type</em>&#x3D;code&amp;	<code>#满足条件的话把这个改成+auto+</code><br><em>scope</em>&#x3D;read&amp;<br><em>state</em>&#x3D;http%3A%2F%2Fdvlshop.lechange.com%2Findex.php%2Fwap&amp;<br><em>user</em>&#x3D;token%2Flcid_9f9lmo2u6i7hkl6t6eaodn2blmg5jbsg&amp;<br><em>expire</em>&#x3D;1514191636&amp;<br><em>source_type</em>&#x3D;lc_app&amp;<br><em>nonce</em>&#x3D;cdizHO6uvSx5JK79Kmtz5RBpSi0ROhpF&amp;signature&#x3D;VeCceYCWDE6BZjIdni&#x2F;68YCmhqc&#x3D;%27 </p>
<p>也就是说现在只需要变量state那点部分，那么这个时候就不能再使用$query_string了，要使用$arg。</p>
<p>$arg可以精确匹配变量，比如说我有一个参数（uri里？后面的那部分全叫参数）：&amp;p&#x3D;你大爷&amp;q&#x3D;你大娘，用$query_string和$arg就是获取所有，而使用$arg_p就是可以获取“你大爷”。</p>
<p>于是说动手就动手，把nginx.conf改成了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">location ~ .*\.<span class="property">php</span>.*</span><br><span class="line">&#123;</span><br><span class="line">    include php_fcgi.<span class="property">conf</span>;</span><br><span class="line">    include pathinfo.<span class="property">conf</span>;</span><br><span class="line">    set $flag <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ( $args ~ <span class="string">&quot;source_type=lc_app&quot;</span> ) &#123;</span><br><span class="line">       set $flag  <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( $args ~ <span class="string">&quot;(.*)response_type(.*)&quot;</span> )&#123;</span><br><span class="line">       set $Flag  <span class="string">&quot;$flag$flag&quot;</span>;</span><br><span class="line">       set $id $1;</span><br><span class="line">       set $query $2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ($Flag = <span class="string">&quot;11&quot;</span>)&#123;</span><br><span class="line">        set $flag <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">301</span>  $arg_state$id+auto+$query;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是通过日志查看，发现$arg_state得到的是<code>/http%3A%2F%2Fdvlshop.lechange.com%2Fproduct-79.html</code>,这就很囧了，我希望获取<code>http%3A%2F%2Fdvlshop.lechange.com%2Fproduct-79.html</code>（不要前面的反斜杠）或者是<code>/product-79.html</code>（不要中间的网站）。这可怎么办？</p>
<p>答案是，**原生的nginx是做不到这一点，因为nginx不参与业务层逻辑方面的业务。**如果说要达到改写的目的，就要搭配lua或者把nginx换成openresty。于是乎就让开发修改一下传递的state来达到目的。</p>
<h2 id="扩展与补充"><a href="#扩展与补充" class="headerlink" title="扩展与补充"></a>扩展与补充</h2><p>看到这个结果突然让我想起来一道面试题，说开发有一个模块，同时这个模块会给nginx提供几个状态码，比如状态码是111，那就是代表OK，状态码不是111，那就是代表不OK，现在想写一个语句，如果nginx获得的状态码不是111，返回一个404的页面，怎么写？</p>
<p>没错，答案也是“原生nginx写不了”，原因跟上面的一样，应用模块状态码是业务层的，nginx是http层的，不在一层压根就无法交流。</p>
<p>在这里也顺道补充一下“在浏览器中输入一个URL后都发生了什么？”，以下是一个大概流程：</p>
<ol>
<li>浏览器向DNS服务器查找输入URL对应的IP地址；</li>
<li>DNS服务器返回网站的IP地址；</li>
<li>浏览器根据IP地址与目标web服务器建立TCP连接；</li>
<li>发送HTTP请求；</li>
<li>服务器处理请求；</li>
<li>返回响应结果；</li>
<li>关闭TCP连接；</li>
<li>浏览器解析HTML；</li>
<li>浏览器布局渲染；</li>
</ol>
<p><img data-src="/images/%E5%AE%B6%E6%9C%89%E5%96%9C%E4%BA%8B.gif" alt="星爷、李丽珍、张曼玉" title="《家有喜事》"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell生成日期变量的json</title>
    <url>/2022/01/18/Shell%E7%94%9F%E6%88%90%E6%97%A5%E6%9C%9F%E5%8F%98%E9%87%8F%E7%9A%84json/</url>
    <content><![CDATA[<p>有一些场合，对应的json文件里有datetime这样的字段，但是这个datetime需要每天取到对应的变量值，但是要知道json本身就是一个文本，是没有逻辑而言的。那么就需要写一个脚本，每天可以crontab生成一个含有对应日期的json文档，于是我就搞了一个shell脚本，内容如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line">date_str=$(date -d <span class="string">&quot;yesterday&quot;</span> +%F)	<span class="comment"># 取昨天的日期2022-01-17</span></span><br><span class="line">year=<span class="string">&quot;$&#123;date_str%%-*&#125;&quot;</span></span><br><span class="line">yuebian=<span class="string">&quot;$&#123;date_str#*-&#125;&quot;</span></span><br><span class="line">month=<span class="string">&quot;$&#123;yuebian%%-*&#125;&quot;</span></span><br><span class="line">day=<span class="string">&quot;$&#123;date_str##*-&#125;&quot;</span></span><br><span class="line">format_date=<span class="string">&quot;$year$month$day&quot;</span></span><br><span class="line"><span class="comment">## 重定向 eg:message=`echo &quot;输出项为：$&#123;abc&#125;&quot; |sed s/[[:space:]]//g`</span></span><br><span class="line">filename=<span class="string">&quot;pouch-odps2mysql.json&quot;</span>		<span class="comment"># 这里就是想要的文件输出名</span></span><br><span class="line"><span class="built_in">format</span>=`echo <span class="string">&quot;$format_date&quot;</span>|sed s/[[:space:]]//g`</span><br><span class="line">echo <span class="string">&quot;$format&quot;</span></span><br><span class="line"><span class="comment"># 下面是真实的json文件产出,这里用了一个dataX的json例子</span></span><br><span class="line">echo <span class="string">&quot;&#123;</span></span><br><span class="line"><span class="string">    &#x27;job&#x27;: &#123;</span></span><br><span class="line"><span class="string">        &#x27;content&#x27;: [</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">                &#x27;reader&#x27;: &#123;</span></span><br><span class="line"><span class="string">                    &#x27;name&#x27;: &#x27;odpsreader&#x27;,</span></span><br><span class="line"><span class="string">                    &#x27;parameter&#x27;: &#123;</span></span><br><span class="line"><span class="string">                        &#x27;accessId&#x27;: &#x27;***&#x27;,</span></span><br><span class="line"><span class="string">                        &#x27;accessKey&#x27;: &#x27;***&#x27;,</span></span><br><span class="line"><span class="string">                        &#x27;column&#x27;: [</span></span><br><span class="line"><span class="string">                            &#x27;dept_name&#x27;,</span></span><br><span class="line"><span class="string">                            &#x27;zone&#x27;,</span></span><br><span class="line"><span class="string">                            &#x27;labels&#x27;,</span></span><br><span class="line"><span class="string">                            &#x27;vcpu&#x27;,</span></span><br><span class="line"><span class="string">                            &#x27;memory&#x27;,</span></span><br><span class="line"><span class="string">                            &#x27;disk&#x27;</span></span><br><span class="line"><span class="string">                            ],</span></span><br><span class="line"><span class="string">                        &#x27;odpsServer&#x27;: &#x27;http://service-corp.odps.aliyun-inc.com/api&#x27;,</span></span><br><span class="line"><span class="string">                        &#x27;packageAuthorizedProject&#x27;: &#x27;&#x27;,</span></span><br><span class="line"><span class="string">                        &#x27;partition&#x27;: [</span></span><br><span class="line"><span class="string">                            &#x27;ds=$&#123;format_date&#125;&#x27;</span></span><br><span class="line"><span class="string">                        ],</span></span><br><span class="line"><span class="string">                        &#x27;project&#x27;: &#x27;这里是工程名&#x27;,</span></span><br><span class="line"><span class="string">                        &#x27;splitMode&#x27;: &#x27;record&#x27;,</span></span><br><span class="line"><span class="string">                        &#x27;table&#x27;: &#x27;这里是表名&#x27;</span></span><br><span class="line"><span class="string">                    &#125;</span></span><br><span class="line"><span class="string">                &#125;,</span></span><br><span class="line"><span class="string">                &#x27;writer&#x27;: &#123;</span></span><br><span class="line"><span class="string">                    &#x27;name&#x27;: &#x27;mysqlwriter&#x27;,</span></span><br><span class="line"><span class="string">                    &#x27;parameter&#x27;: &#123;</span></span><br><span class="line"><span class="string">                        &#x27;column&#x27;: [</span></span><br><span class="line"><span class="string">                            &#x27;dept_name&#x27;,</span></span><br><span class="line"><span class="string">                            &#x27;zone&#x27;,</span></span><br><span class="line"><span class="string">                            &#x27;labels&#x27;,</span></span><br><span class="line"><span class="string">                            &#x27;vcpu&#x27;,</span></span><br><span class="line"><span class="string">                            &#x27;memory&#x27;,</span></span><br><span class="line"><span class="string">                            &#x27;disk&#x27;</span></span><br><span class="line"><span class="string">                            ],</span></span><br><span class="line"><span class="string">                        &#x27;connection&#x27;: [</span></span><br><span class="line"><span class="string">                            &#123;</span></span><br><span class="line"><span class="string">                                &#x27;jdbcUrl&#x27;: &#x27;jdbc:mysql://数据库IP地址:3306/AAA?useUnicode=true&amp;characterEncoding=UTF-8&#x27;,</span></span><br><span class="line"><span class="string">                                &#x27;table&#x27;: [&#x27;MYSQL表名&#x27;]</span></span><br><span class="line"><span class="string">                            &#125;</span></span><br><span class="line"><span class="string">                        ],</span></span><br><span class="line"><span class="string">                        &#x27;password&#x27;: &#x27;密码&#x27;,</span></span><br><span class="line"><span class="string">                        &#x27;preSql&#x27;: [&#x27;DELETE FROM MYSQL表名;&#x27;],	# 先删除后insert</span></span><br><span class="line"><span class="string">                        &#x27;session&#x27;: [],</span></span><br><span class="line"><span class="string">                        &#x27;username&#x27;: &#x27;用户名&#x27;,</span></span><br><span class="line"><span class="string">                        &#x27;writeMode&#x27;: &#x27;insert&#x27;</span></span><br><span class="line"><span class="string">                    &#125;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">         ],</span></span><br><span class="line"><span class="string">        &#x27;setting&#x27;: &#123;</span></span><br><span class="line"><span class="string">            &#x27;speed&#x27;: &#123;</span></span><br><span class="line"><span class="string">                &#x27;channel&#x27;: &#x27;1&#x27;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&quot;</span> &gt;$filename</span><br></pre></td></tr></table></figure></p>
<p>执行这个shell文档后，就会生成一个文件，里面的<code>ds=${format_date}</code>就会被顺利解析成<code>20220117</code>(本文时间是2022年1月18日)。这里注意一下，最后写入文档的echo搭配的是双括号，因为用了单括号的话，变量将不会被识别，所有内容都会原封不对的输出，而双引号才是不会屏蔽对变量和某些特殊符号的转义的。</p>
<p>还要注意，如果搭配crontab做定时任务使用的话，需要加上环境变量:<code>cd /文件目录/ &amp;&amp; /bin/sh 脚本.sh</code>。 不然的话，可能会执行失败。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Shell</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>Ssh连接port 22: Connection refused</title>
    <url>/2018/01/29/Ssh%E8%BF%9E%E6%8E%A5port-22-Connection-refused/</url>
    <content><![CDATA[<p>金山云有一个服务器需要连接到数据库但是总是失败，检查之后发现它的VPC配错了，更改VPC之后，这台服务器也会更换一个新的内网IP地址，但是问题来了，更换了内网IP之后，从跳板机连接，提示<code>port 22: Connection refused</code>。</p>
<p><code>ssh -v 新的ip地址</code>发现根本没有到<code>Connection established</code>。直接就提示<code>port 22: Connection refused</code>。这基本可以断定不是跳板机的问题了，那么就需要在远程机器里看配置。</p>
<p>但是远程机器是无法连接的啊，怎么办？从金山控制台“连接实例”。<br><img data-src="/images/ksssh1.png"></p>
<p>然后键盘随便按一下，就会看到linux界面，输入账号名和密码，这里密码不支持复制粘贴，需要手动输入。然后就会看到如下界面。<br><img data-src="/images/ksssh2.png"></p>
<p>这样，我们就可以登陆这台机器了，然后<code>vim /etc/ssh/sshd_config</code>，看到最上面有这样的内容。<br><img data-src="/images/ksssh3.png"></p>
<p>这个<code>listenaddress</code>后面就是跳板机ssh的地址，但是这个地址还是老的，而不是更改过后的内网ip地址，所以ssh的连接自然就是<code>refuse</code>。所以我们只需要手动更改成新的内网ip地址就好了。</p>
<p>更改完之后，重启一下服务器或者<code>/etc/init.d/sshd restart</code>就可以从跳板机上正常连接了。</p>
<p>如果在<code>/etc/init.d/sshd restart</code>的时候爆出“address family must be specified before ListenAddress”的错误，那么就把<code>AddressFamily</code>移到<code>ListenAddress</code>上面就可以了，如图：<br><img data-src="/images/ksssh4.png"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Ssh时出现Connection closed by remote host的问题</title>
    <url>/2019/11/21/Ssh%E6%97%B6%E5%87%BA%E7%8E%B0Bad-protocol-version-identification%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<p>今天遇到一个超奇怪的现象：同一台服务器，有的可以ssh通，有的不可以ssh通。故障机器的ssh细节如下：<br><img data-src="/images/ssh.png" alt="akb48" title="左边是可以连接的，右边是失败的"></p>
<p>发现成功的服务器会持续到：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">debug1: Remote protocol version <span class="number">2.0</span>, remote software version OpenSSH_7<span class="number">.4</span></span><br><span class="line">debug1: <span class="keyword">match</span>: OpenSSH_7<span class="number">.4</span> pat OpenSSH*</span><br></pre></td></tr></table></figure></p>
<p>这一步，而失败的服务器会直接断开，并且爆<code>ssh_exchange_identification: Connection closed by remote host</code>的错误。</p>
<p>来到要连接的服务器上，查看<code>/var/log/secure</code>，发现每次失败的服务器每次发起ssh连接请求的时候，会有如下日志：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Nov <span class="number">19</span> <span class="number">15</span>:<span class="number">56</span>:<span class="number">26</span> iZuf6h1kfgutxc3el68z2lZ sshd[<span class="number">15096</span>]: Bad protocol version identification <span class="string">&#x27;\026\003\001&#x27;</span> <span class="keyword">from</span> X.X.X.X port <span class="number">38966</span></span><br><span class="line">Nov <span class="number">19</span> <span class="number">15</span>:<span class="number">56</span>:<span class="number">27</span> iZuf6h1kfgutxc3el68z2lZ sshd[<span class="number">15097</span>]: Bad protocol version identification <span class="string">&#x27;\026\003\001&#x27;</span> <span class="keyword">from</span> X.X.X.X port <span class="number">38990</span></span><br></pre></td></tr></table></figure></p>
<p>查了很多资料，基本都说请检查<code>/etc/ssh/sshd_config</code>、<code>/etc/hosts.allow</code>、<code>/etc/hosts.deny</code>、安全组和iptables。我把上面的文件在两台服务器都进行了对比，发现没有什么不同。</p>
<p>后来才发现这里有一个很深的坑，<code>iptables -L</code>的结果其实不一定是真的！最重要的是要看<code>iptables-save</code>的结果：<br><img data-src="/images/ssh2.png" alt="akb48"></p>
<p>上面可见<code>iptables -L</code>返回的结果虽然是空的，但是<code>iptables-save</code>却是有内容的，怪不得连接不上。</p>
<p>如果要删除<code>iptables-save</code>这里的规则，直接<code>service iptables stop</code>即可。但是如果在启动iptables时有<code>No config file</code>的警告错误的话，任意添加一条策略，然后保存就能正常启动了：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">iptables -P OUTPUT ACCEPT</span><br><span class="line">service iptables save</span><br></pre></td></tr></table></figure></p>
<p><img data-src="/images/ssh3.png" alt="akb48"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>ssh</tag>
        <tag>itables</tag>
      </tags>
  </entry>
  <entry>
    <title>Uwsgi+nginx运行Django并且解决跨域</title>
    <url>/2020/06/01/Uwsgi-nginx%E8%BF%90%E8%A1%8CDjango%E5%B9%B6%E4%B8%94%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<h2 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h2><p>Django &#x3D;&#x3D; 2.1.8<br>python &#x3D;&#x3D; 3.6.4<br>Django project &#x3D; naxx<br>Django App &#x3D; naxxramas</p>
<h2 id="配置uwsgi和NGINX"><a href="#配置uwsgi和NGINX" class="headerlink" title="配置uwsgi和NGINX"></a>配置uwsgi和NGINX</h2><p>为啥要引入uwsgi?使用<code>python manage.py runserver</code> 来运行服务器。这只适用测试环境中使用。而uWSGI以客户端-服务端模式运行。Web 服务器（例如 nginx，Apache）与一个 django-uwsgi “worker” 进程交互，提供动态内容。</p>
<p>首先<code>pip install uwsgi</code>安装uwsgi，我这里安装的是<code>2.0.18</code>，然后来到django的项目根目录，即<code>manage.py</code>同级的文件夹里，编写一个叫<code>naxx.ini</code>的文件，内容如下：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line">chdir = /opt/naxx</span><br><span class="line">master = True   #主进程</span><br><span class="line">processes = 4</span><br><span class="line">threads = 2</span><br><span class="line">socket = 127.0.0.1:8001   #这里指定Django是8001端口</span><br><span class="line"># chmod-socket    = 664</span><br><span class="line">vacuum = true</span><br><span class="line">wsgi-file = naxx/wsgi.py</span><br><span class="line">pidfile = uwsgi.pid   #PID文件</span><br><span class="line">daemonize = uwsgi.log</span><br><span class="line">#停止：uwsgi --stop uwsgi.pid</span><br><span class="line">(venv)</span><br></pre></td></tr></table></figure></p>
<p>然后<code>uwsgi --ini naxx.ini</code>启动uwsgi即可。</p>
<p>安装nginx很简单，我这里直接<code>yum install -y nginx</code>，首先去<code>/etc/nginx</code>里添加一个ssl文件夹，把你的HTTPS证书文件们都放进去。然后在<code>/etc/nginx/conf.d</code>里新创建一个<code>naxx.conf</code>，内容如下：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream django &#123;</span><br><span class="line">  server 127.0.0.1:8001 # 这里跟naxx.ini的配置一样</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen      8000;</span><br><span class="line">  listen      443 ssl;    #这里配置了HTTPS</span><br><span class="line">  server_name 按实际写你的域名; </span><br><span class="line">  charset     utf-8;</span><br><span class="line">  </span><br><span class="line">  ssl_certificate ssl/你的HTTPS证书.crt;</span><br><span class="line">  ssl_certificate_key ssl/你的HTTPS证书.key;</span><br><span class="line">  ssl_session_timeout 5m;</span><br><span class="line">  ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置</span><br><span class="line">  ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置</span><br><span class="line">  ssl_prefer_server_ciphers on;</span><br><span class="line">  # max upload size</span><br><span class="line">  client_max_body_size 75M;   # adjust to taste</span><br><span class="line">  </span><br><span class="line">  # Django media</span><br><span class="line"></span><br><span class="line">location /static &#123;</span><br><span class="line">    alias /opt/naxx/static; # 这里是Django静态文件的地址，与Django的setting.py文件配置相同</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Finally, send all non-media requests to the Django server.</span><br><span class="line">location / &#123;</span><br><span class="line">    uwsgi_pass  django;</span><br><span class="line">    include   /Django路径/uwsgi_params; # 这里是要填写Django的全路径</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>保存退出后，<code>systemctl enable nginx</code>和<code>systemctl start nginx</code>，这样启动NGINX并且保证开机自启动NGINX。</p>
<p>此时如果你已经绑定好了域名，那么在浏览器里就能正常的通过<code>https://域名</code>的方式访问Django了，如图：<br><img data-src="/images/Django%E8%B7%A8%E5%9F%9F2.jpg" alt="akb48"></p>
<h2 id="解决跨域问题"><a href="#解决跨域问题" class="headerlink" title="解决跨域问题"></a>解决跨域问题</h2><p>虽然上面已经用uwsgi+NGINX实现了Django的稳定而持续的展示，但是如果有跨域来访问是会报错的，如图：<br><img data-src="/images/Django%E8%B7%A8%E5%9F%9F.jpg" alt="akb48"></p>
<p>那么就需要把几个相信的域名添加到cros跨域白名单里。</p>
<p>首先先<code>pip install django-cors-headers</code>，我这里安装的版本是3.3.0。然后编辑Django project下的<code>settings.py</code>文件：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">  ···</span><br><span class="line">  &#x27;corsheaders&#x27;,  #这个最好加在中间</span><br><span class="line">  ···</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">CORS_ORIGIN_WHITELIST = [</span><br><span class="line">  &#x27;https://cors白名单域名&#x27;,</span><br><span class="line">  &#x27;https://cors白名单域名&#x27;</span><br><span class="line">  ···</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># CORS_ORIGIN_ALLOW_ALL = True  #如果希望所有人都来访问，就放开这个</span><br><span class="line"></span><br><span class="line">MIDDLEWARE = [</span><br><span class="line">  ...</span><br><span class="line">  &#x27;corsheaders.middleware.CorsMiddleware&#x27;,</span><br><span class="line">  &#x27;django.middleware.common.CommonMiddleware&#x27;,</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>重启uwsgi，让目标的域名来访问，如果此时出现了“The value of the ‘Access-Control-Allow-Credentials’ header in the response is ‘’ which must be ‘true’ when the request’s credentials mode is ‘include’”的话，那么需要在naxx.conf里添加如下的配置：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    uwsgi_pass  django;</span><br><span class="line">    include     /opt/naxx/uwsgi_params; # the uwsgi_params file you installed</span><br><span class="line">    add_header &#x27;Access-Control-Allow-Credentials&#x27; &#x27;true&#x27;;  #这句话</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>sudo nginx -s reload</code>一下，就可以解决问题了！</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://uwsgi-docs.readthedocs.io/en/latest/tutorials/Django_and_nginx.html">https://uwsgi-docs.readthedocs.io/en/latest/tutorials/Django_and_nginx.html</a><br><a href="https://pypi.org/project/django-cors-headers/">https://pypi.org/project/django-cors-headers/</a><br><a href="https://www.hi-linux.com/posts/60405.html">https://www.hi-linux.com/posts/60405.html</a><br><a href="https://docs.djangoproject.com/zh-hans/2.2/howto/deployment/wsgi/uwsgi/">https://docs.djangoproject.com/zh-hans/2.2/howto/deployment/wsgi/uwsgi/</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>nginx</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>Uwsgi的安装和简单使用</title>
    <url>/2018/02/02/Uwsgi%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>运维平台的搭建已经提上日程，而我选用了大家比较常用的<code>Uwsgi+nginx+django</code>的架构，这里先记录一下安装Uwsgi的过程。</p>
<p>这里解释一下<code>Uwsgi+nginx+django</code>，我们整个流程如下图：<br><img data-src="/images/uwsgi1.png" alt="paradin"></p>
<p>这里我们可以看出，web server是无法与我们的app（django等等）进行直接对话，他需要通过uwsgi这个桥梁，这个桥梁很重要，虽然我们使用django的<code>runserver</code>功能也会打开一个页面，但是这个页面是很脆弱的，小规模使用还好，要是放在网络上供很多人点击的话，根本就是脆不经风。</p>
<p>uwsgi是啥，请查看文末的参考资料，写的已经非常好了。我这里就简单说下：</p>
<blockquote>
<p>uwsgi 实际上也是一个http服务器，只不过它只面向python网络应用程序。虽然uwsgi也是http服务器，但是却不能直接使用它部署python web应用程序，否则会出错。</p>
</blockquote>
<blockquote>
<p>在本文中，uwsgi所扮演的的角色是后端http服务器，nginx扮演的角色是前端http服务器，<code>hello.py</code>是客户端应用程序。用户从网页浏览器中发出请求，nginx服务器收到请求后，会通过它的uwsgi模块将用户的请求转发给uwsgi服务器，uwsgi服务器处理完毕后将结果返回给 nginx，浏览器将最终的结果展现给用户。</p>
</blockquote>
<p>Uwsgi的安装比较简单，推荐使用<code>yum install Uwsgi</code>直接下载使用，而不推荐用<code>pip install uwsgi</code>，因为pip安装的话，虽然也能成功（如下图红框），是没有<code>uwsgi.ini</code>文件的，其实没有这个<code>uwsgi.ini</code>是无足轻重的，因为这个文件可以自己写，但是对于生手来说，没有这个文件可能会心里发毛，就无法按照攻略继续下去，所以我更推荐用yum安装，如图：<br><img data-src="/images/uwsgi2.png" alt="paradin"></p>
<p>为了纪念我们的金刚狼同志，我们就写一个叫<code>logan.py</code>，里面的内容是这样的：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">def <span class="title function_">application</span>(env, start_response):</span><br><span class="line">       <span class="title function_">start_response</span>(<span class="string">&#x27;200 OK&#x27;</span>, [(<span class="string">&#x27;Content-Type&#x27;</span>,<span class="string">&#x27;text/html&#x27;</span>)])</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;good bye,Logan...&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>然后我们就可以启动这个<code>uwsgi</code>看看效果，使用<code>uwsgi --http :8001 --wsgi-file logan.py</code>，把端口设定为<code>8001</code>，同时指定协议是<code>http</code>，然后加载的文件就是<code>logan.py</code>，启动之后，如图：<br><img data-src="/images/uwsgi3.png" alt="paradin"></p>
<p>遇到这种情况，你就<code>yum install uwsgi-plugin-python</code>，然后把命令做一点点修改，改成：<code>uwsgi --plugin python --http-socket :8001 --wsgi-file logan.py</code>。</p>
<p>屏幕会出现一大堆文字，然后提示，uwsgi已经启动成功了。在浏览器输入<code>服务器外网地址:8001</code>看一下效果，如图：<br><img data-src="/images/uwsgi4.png" alt="paradin"></p>
<p>我们在root目录下再写一个测试的文件，这次我们写一个比较老实的python脚本来测试，这个脚本就叫<code>test.py</code>，里面的内容如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/usr/</span>bin/python</span><br><span class="line">#coding=utf-<span class="number">8</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">def <span class="title function_">application</span>(environ, start_response):</span><br><span class="line">       status = <span class="string">&#x27;200&#x27;</span></span><br><span class="line">       output = <span class="string">&#x27;this is a test for uwsgi,HOHO~&#x27;</span></span><br><span class="line">       response_headers = [(<span class="string">&#x27;Content-type&#x27;</span>, <span class="string">&#x27;text/plain&#x27;</span>),(<span class="string">&#x27;Content-Length&#x27;</span>, <span class="title function_">str</span>(<span class="title function_">len</span>(output)))]</span><br><span class="line">       <span class="title function_">start_response</span>(status, response_headers)</span><br><span class="line">       <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure></p>
<p>还是用刚才的方法，依旧可以打开网页，其实上面这个简单的<code>uWSGI</code>程序更好理解整个套路，只需要实现一个名为<code>application</code>的函数就可以了，该函数有两个参数，<code>environ</code>为包含有<code>http</code>请求的环境变量，<code>start_response</code>为一个函数，用来设置http头。在这个函数里，我们只需要调用一次<code>start_response</code>函数，设置一下<code>HTTP</code>返回头，再<code>return</code>一个<code>HTTP body</code>即可。</p>
<p>至此，整个uwsgi就安装成功了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://xiaorui.cc/2017/02/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3uwsgi%E5%92%8Cgunicorn%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E4%B8%8A/">http://xiaorui.cc/2017/02/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3uwsgi%E5%92%8Cgunicorn%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E4%B8%8A/</a><br><a href="http://uwsgi-docs.readthedocs.io/en/latest/tutorials/Django_and_nginx.html">http://uwsgi-docs.readthedocs.io/en/latest/tutorials/Django_and_nginx.html</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>python</tag>
        <tag>uwsgi</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat8配置apr</title>
    <url>/2019/09/30/Tomcat8%E9%85%8D%E7%BD%AEapr/</url>
    <content><![CDATA[<h2 id="基础知识开场"><a href="#基础知识开场" class="headerlink" title="基础知识开场"></a>基础知识开场</h2><p>先以一个面试题作为本文的开场白：tomcat与nginx都是<code>Seb Server</code>，他们有什么区别？<br>首先先说明一下Tomcat更应该被叫做<code>Web Container</code>，当然它可以被认为是HTTP服务器，它的主要内容是处理<code>动态请求</code>，而nginx主要是用来处理<code>静态请求</code>。所以一般的设计都是把Nginx放在前端处理静态资源，如果有对应的Java编写的服务器端程序请求，则通过AJP转给后面的Tomcat、Jetty进行处理。</p>
<h2 id="tomcat的部署"><a href="#tomcat的部署" class="headerlink" title="tomcat的部署"></a>tomcat的部署</h2><p>首先先确认服务器是否有java，没有的话就<code>yum install java-1.8.0-openjdk* -y</code>，然后在&#x2F;etc&#x2F;profile最下面添加：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/lib/jvm/java-<span class="number">1.8</span><span class="number">.0</span>-openjdk-<span class="number">1.8</span><span class="number">.0</span><span class="number">.222</span>.b10-<span class="number">1.</span>el7_7.x86_64</span><br><span class="line">export JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">export CLASSPATH=$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH</span><br><span class="line">export PATH=$JAVA_HOME/<span class="built_in">bin</span>:$JRE_HOME/<span class="built_in">bin</span>:$PATH </span><br></pre></td></tr></table></figure></p>
<p>然后<code>source /etc/profile</code>配置环境变量，然后开始安装。<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mkdir /usr/local/tomcat	<span class="comment">#创建文件夹</span></span><br><span class="line">wget http://apache.fayea.com/tomcat/tomcat-<span class="number">8</span>/v8<span class="number">.5</span><span class="number">.46</span>/<span class="built_in">bin</span>/apache-tomcat-<span class="number">8.5</span><span class="number">.46</span>.tar.gz -P /usr/local/tomcat	<span class="comment">#直接下载tomcat8到目标文件夹</span></span><br><span class="line">cd /usr/local/tomcat</span><br><span class="line">tar -zxvf apache-tomcat-<span class="number">8.5</span><span class="number">.46</span>.tar.gz</span><br><span class="line">   cd apache-tomcat-<span class="number">8.5</span><span class="number">.46</span>/<span class="built_in">bin</span></span><br><span class="line">./catalina.sh start  <span class="comment">#.启动tomcat。使用./catalina.sh stop停止tomcat。</span></span><br></pre></td></tr></table></figure></p>
<p>为了安全我们都会更改一下默认的8080端口，那么就修改<code>apache-tomcat-8.5.46/conf/server.xml</code>：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;Connector port=<span class="string">&quot;33664&quot;</span> protocol=<span class="string">&quot;HTTP/1.1&quot;</span></span><br><span class="line">           connectionTimeout=<span class="string">&quot;20000&quot;</span></span><br><span class="line">           redirectPort=<span class="string">&quot;8443&quot;</span> </span><br><span class="line">           server=<span class="string">&quot;kan ni daye a kan&quot;</span>/&gt;		<span class="comment"># 服务器信息，可以通过curl -I来查看</span></span><br></pre></td></tr></table></figure></p>
<p>确保iptables和安全组放行33664端口之后，既可以在页面查看情况。<br><img data-src="/images/tomcat1.png" alt="akb48"></p>
<p>虽然现在程序已经正常启动了，但是还需要配置开机自启动和service控制开启关闭等其他工作。</p>
<p>首先要使用service命令控制tomcat启停，新编辑<code>/etc/init.d/tomcat</code>文件：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment"># description: Tomcat8 Start Stop Restart</span></span><br><span class="line"><span class="comment"># processname: tomcat8</span></span><br><span class="line"><span class="comment"># chkconfig: 234 20 80</span></span><br><span class="line"></span><br><span class="line">CATALINA_HOME=/usr/local/tomcat/apache-tomcat-<span class="number">8.5</span><span class="number">.46</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> $<span class="number">1</span> <span class="keyword">in</span></span><br><span class="line">        start)</span><br><span class="line">                sh $CATALINA_HOME/<span class="built_in">bin</span>/startup.sh</span><br><span class="line">                ;;</span><br><span class="line">        stop)</span><br><span class="line">                sh $CATALINA_HOME/<span class="built_in">bin</span>/shutdown.sh</span><br><span class="line">                ;;</span><br><span class="line">        restart)</span><br><span class="line">                sh $CATALINA_HOME/<span class="built_in">bin</span>/shutdown.sh</span><br><span class="line">                sh $CATALINA_HOME/<span class="built_in">bin</span>/startup.sh</span><br><span class="line">                ;;</span><br><span class="line">        *)</span><br><span class="line">                echo <span class="string">&#x27;please use : tomcat &#123;start | stop | restart&#125;&#x27;</span></span><br><span class="line">        ;;</span><br><span class="line">esac</span><br><span class="line">exit <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>保存之后给予这个tomcat文件可执行权限，就可以通过<code>service tomcat restart/stop/start</code>来控制程序启停了。</p>
<p>开启自启动比较简单了：<code>chkconfig --add tomcat &amp;&amp; chkconfig tomcat on</code>。</p>
<p>基本上准备工作就到此为止了。</p>
<h2 id="配置apr"><a href="#配置apr" class="headerlink" title="配置apr"></a>配置apr</h2><p>Tomcat支持三种接收请求的处理方式：<code>BIO（阻塞式）</code>、<code>NIO（非阻塞式）</code>、<code>APR（基于本地库）</code>。采用APR是比较符合更高要求的场景，连接建立的速度会有50%～100%的提升。直接调用操作系统层果然神速啊，所以强烈推荐使用apr方式！而tomcat8默认情况下使用的是nio模式：<br><img data-src="/images/tomcat2.png" alt="akb48"></p>
<p>apr模式本质是使用JNI技术调用操作系统IO接口，需要用到相关API的头文件，先<code>yum install apr-devel openssl-devel gcc make -y</code>安装相关依赖库。</p>
<p>然后在tomcat的bin文件夹下，会看到一个<code>tomcat-native.tar.gz</code>，解压之。然后在<code>tomcat-native-1.2.23-src/native</code>下执行<code>./configure &amp;&amp; make &amp;&amp; make install</code>安装。</p>
<p>安装完毕之后，返回到Tomcat的bin里编辑<code>catalina.sh</code>，在虚拟机启动参数<code>JAVA_OPTS</code>中添加<code>java.library.path</code>参数，指定apr库的路径：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">JAVA_OPTS=<span class="string">&quot;$JAVA_OPTS -Djava.library.path=/usr/local/apr/lib&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>再去tomcat的conf里<code>server.xml</code>修改一下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;Connector port=<span class="string">&quot;33664&quot;</span> protocol=<span class="string">&quot;org.apache.coyote.http11.Http11AprProtocol&quot;</span></span><br><span class="line">           connectionTimeout=<span class="string">&quot;20000&quot;</span></span><br><span class="line">           redirectPort=<span class="string">&quot;8443&quot;</span></span><br><span class="line">  maxThreads=<span class="string">&quot;800&quot;</span> acceptCount=<span class="string">&quot;1000&quot;</span>	<span class="comment">#这两个数在下面细说</span></span><br><span class="line">           server=<span class="string">&quot;kan ni daye a kan&quot;</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<p>重启一下tomcat，就会看到现在使用的是apr模式了：<br><img data-src="/images/tomcat3.png" alt="akb48"></p>
<h2 id="多tomcat负载均衡"><a href="#多tomcat负载均衡" class="headerlink" title="多tomcat负载均衡"></a>多tomcat负载均衡</h2><p>复制tomcat成多份，然后修改<code>tomcat路径下/webapps/ROOT/index.jsp</code>的内容作为标识，然后分别启动不同的端口，如：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="number">1</span> 默认<span class="number">8005</span>改成<span class="number">8008</span> --&gt;</span><br><span class="line">&lt;Server port=<span class="string">&quot;8008&quot;</span> shutdown=<span class="string">&quot;SHUTDOWN&quot;</span>&gt;</span><br><span class="line">    &lt;!-- <span class="number">2</span> Http默认<span class="number">8080</span> 改成自己喜欢的端口 --&gt;</span><br><span class="line">    &lt;Connector port=<span class="string">&quot;第三个端口&quot;</span> protocol=<span class="string">&quot;HTTP/1.1&quot;</span></span><br><span class="line">               connectionTimeout=<span class="string">&quot;20000&quot;</span></span><br><span class="line">               redirectPort=<span class="string">&quot;8443&quot;</span> /&gt;</span><br><span class="line">     &lt;!-- <span class="number">3</span> AJP默认<span class="number">8009</span> 改成<span class="number">8011</span> --&gt;         </span><br><span class="line">    &lt;Connector port=<span class="string">&quot;8011&quot;</span> protocol=<span class="string">&quot;AJP/1.3&quot;</span> redirectPort=<span class="string">&quot;8443&quot;</span> /&gt;  </span><br></pre></td></tr></table></figure></p>
<p>启动之后，一个服务器里就运行了多个tomcat。然后修改<code>nginx.conf</code>：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    <span class="comment"># 省略代码....</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment"># 增加  upstream, 名称为 serverlist</span></span><br><span class="line">    upstream serverlist&#123;</span><br><span class="line">        server localhost:第一个端口 weight=<span class="number">1</span>;  <span class="comment"># weigh表示权重，越大访问的机率越多</span></span><br><span class="line">        server localhost:第二个端口 weight=<span class="number">1</span>;</span><br><span class="line">        server localhost:第三个端口 weight=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 编辑</span></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       <span class="number">80</span>;</span><br><span class="line">        server_name  www.yourdomian.com;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            <span class="comment"># 这里使用定义 serverlist</span></span><br><span class="line">            proxy_pass http://serverlist;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>重新nginx就能通过你的域名进行访问了，多次刷新就可以看到网站显示是哪个tomcat的内容。</p>
<p><font color=red>注意！</font>强烈建议不要使用 Tomcat 的虚拟主机，推荐每个站点使用一个实例。即，可以启动多个 Tomcat，而不是启动一个 Tomcat 里面包含多个虚拟主机。因为 Tomcat是多线程，共享内存，任何一个虚拟主机中的应用崩溃，都会影响到所有应用程序。虽然采用多实例的方式会产生过多的开销，但至少保障了应用程序的隔离和安全。</p>
<h2 id="运维注意点"><a href="#运维注意点" class="headerlink" title="运维注意点"></a>运维注意点</h2><ol>
<li><p>不要使用root用户启动tomcat，Java程序与C程序不同。你使用什么用户启动Tomcat，那么Tomcat就会继承该所有者的权限。那么解决这个问题的办法：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">groupadd -g <span class="number">80</span> daemon</span><br><span class="line">adduser -o --home /daemon --shell /sbin/nologin --uid <span class="number">80</span> --gid <span class="number">80</span> -c <span class="string">&quot;Web Server&quot;</span> daemon	<span class="comment">#注意/sbin/nologin,意味着该用户不能登录，同时我也没有给它指定密码，这个用户只能用于启动tomcat</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改tomcat的conf里<code>server.xml</code>：关闭war自动部署<code>unpackWARs=&quot;false&quot; autoDeploy=&quot;false&quot;</code>，防止被植入木马等恶意程序；</p>
</li>
<li><p><code>maxThreads</code>：tomcat起动的最大线程数，即同时处理的任务个数，默认值为200；<code>acceptCount</code>：当tomcat起动的线程数达到最大时，接受排队的请求个数，默认值为100。这俩个值要根据业务合理分配，不是越大越好。一般来说<code>acceptCount</code>的配置是设置的跟<code>maxThreads</code>一样大；</p>
</li>
<li><p><code>server.xml</code>中定义了可以直接关闭Tomcat实例的管理端口。我们通过telnet连接上该端口之后，输入SHUTDOWN（此为默认关闭指令）即可关闭Tomcat实例（注意，此时虽然实例关闭了，但是进程还是存在的）。所以为了避免这样的情景，就把SHUTDOWN改成乱码：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;Server port=<span class="string">&quot;8005&quot;</span> shutdown=<span class="string">&quot;9SDKJ29jksjf23sjf0LSDF92JKS9DKkjsd&quot;</span>&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://lanjingling.github.io/2015/12/15/tomcat-redis-session/">https://lanjingling.github.io/2015/12/15/tomcat-redis-session/</a><br><a href="https://qq343509740.gitee.io/2018/07/24/Linux/CentOS/CentOS%207%20&%20Tomcat%208%20%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/#%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE">https://qq343509740.gitee.io/2018/07/24/Linux/CentOS/CentOS%207%20&amp;%20Tomcat%208%20%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/#%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE</a><br><a href="https://www.cnblogs.com/meetrice/p/5695127.html">https://www.cnblogs.com/meetrice/p/5695127.html</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql里UNION ALL要注意的地方</title>
    <url>/2021/12/03/UNION-ALL%E9%87%8C%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>比如我有一个表A：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+------+--------+-------+</span><br><span class="line">| name | code   | num   |</span><br><span class="line">+------+--------+-------+</span><br><span class="line">| A    | no1    | 300   |</span><br><span class="line">| A    | no2    | 100   |</span><br><span class="line">+------+--------+-------+</span><br></pre></td></tr></table></figure></p>
<p>我还有一个表B：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+------+--------+-------+</span><br><span class="line">| name | code   | num   |</span><br><span class="line">+------+--------+-------+</span><br><span class="line">| A    | no1    | -100  |</span><br><span class="line">| A    | no5    | 77    |</span><br><span class="line">| B    | no7    | 2     |</span><br><span class="line">+------+--------+-------+</span><br></pre></td></tr></table></figure></p>
<p>现在我想要两个表的<code>num</code>相加，不存在的列补全，得到一个表C：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+------+--------+-------+</span><br><span class="line">| name | code   | num   |</span><br><span class="line">+------+--------+-------+</span><br><span class="line">| A    | no1    | 200   |</span><br><span class="line">| A    | no2    | 100   |</span><br><span class="line">| A    | no5    | 77    |</span><br><span class="line">| B    | no7    | 2     |</span><br><span class="line">+------+--------+-------+</span><br></pre></td></tr></table></figure><br>请问怎么做？</p>
<p>答案是：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">u.name,</span><br><span class="line">u.code,</span><br><span class="line">SUM(u.num),</span><br><span class="line">FROM</span><br><span class="line">(</span><br><span class="line">SELECT name, code, num FROM tableA</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT name, code, num FROM tableB</span><br><span class="line">) u</span><br><span class="line">GROUP BY u.name, u.code;</span><br></pre></td></tr></table></figure></p>
<p>因为表A，表B的列是一模一样的，所以可以通过<code>UNION ALL</code>来整合成一个大表，然后去重再求和达到这个目的，而不是死磕join。</p>
<h2 id="实际例子"><a href="#实际例子" class="headerlink" title="实际例子"></a>实际例子</h2><p>上面那个只是一个引子,这几天我在做一个订正功能,设计思路是这样的:原来有一个各部门的当前<code>空余容器额度表A</code>，这个表每日有crontab定时任务与集团的<code>容器额度转移表</code>同步。但是集团的表有一些实际的缺陷，所以我们还要有订正能力，于是我就按照A表的结构造了一模一样的订正表B，这样A表与B表的差不就是正确的数值了么？</p>
<p>但是这里面有一个很坑的事情，那就是作为标准的集团的总额度表，一次容器额度的转移是要产生三条记录，分别是cpu,memory和disk,如图:<br><img data-src="/images/unionall.png" title="前台页面操作ascp-asles-order给app-arch-ms转移一次,后面就会记录三条"></p>
<p>那么我对集团的这个额度转移原表要进行二次加工，由行转列，把cpu、memory、disk按字段的方式展示出来，那么SQL语句的想法就是：先获取到每个部门的收取CPU额度表、MEMORY额度表、DISK额度表减掉他们转出的各自额度，再以部门为基准left join做出来一个大表，这样就有cpu列、memory列和disk列了。</p>
<p>为了防止有重复的，这里各部门的CPU表、memory表、disk表我都分别做了<code>group by</code>，先<code>group by</code>后<code>left join</code>，效果是OK的，就是SQL语句比较复杂，好几十行。</p>
<p>但是现在引入了这个订正表，而这个订正表也是“一条变更三条记录”的模式，那么我天真的认为就是<code>cpu收入表 left join 减掉cpu转出表 UNION ALL 订正cpu表 group by 去重列</code> left join <code>memory收入表 left join 减掉memory转出表 UNION ALL 订正memory表 group by 去重列</code> on 条件 left join <code>disk收入表 left join 减掉disk转出表 UNION ALL 订正disk表 group by 去重列 on 条件</code>就是答案。</p>
<p>但是如果这么写的话，你会发现，CPU减的是对的，MEMORY减的多了一倍，DISK减的多了两倍…</p>
<p>这就是UNION ALL的问题，它在CPU表去拼接MEMORY表的时候，会多出一倍，也就是笛卡尔积的时候，这个临时表里有一遍CPU的记录二遍memory的记录，所以memory就会多出来一倍的值，同理，disk就会多出来两倍的值。订正的结果自然不正确。</p>
<p>正确的做法就是上面那个引子那样：<code>cpu收入表 union all 减掉cpu转出表 UNION ALL 订正cpu表 group by 去重列</code> left join <code>memory收入表 union all 减掉memory转出表 UNION ALL 订正memory表 group by 去重列</code> on 条件 left join <code>disk收入表 union all 减掉disk转出表 UNION ALL 订正disk表 group by 去重列 on 条件</code>。</p>
<p>这样各自的元素表通过两个union all链接成一个大表，通过group by去重在SUM取和，就会得到很干净的底表，如此将三张表再通过<code>LEFT JOIN</code>链接起来就大功告成了！</p>
<h2 id="Django执行复杂SQL"><a href="#Django执行复杂SQL" class="headerlink" title="Django执行复杂SQL"></a>Django执行复杂SQL</h2><p>上面这个SQL后来写出来非常的复杂，如果用django自带的orm来写会特别的累，所以最省事的方法就直接用SQL原生句来在Django里执行，执行方法如下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.db import connection, transaction</span><br><span class="line"></span><br><span class="line">   cursor = connection.cursor()		# 它会直接拿到django的数据库链接信息</span><br><span class="line">   sql = &#x27;&#x27;&#x27; </span><br><span class="line">   	那个非常复杂的语句 </span><br><span class="line">   	&#x27;&#x27;&#x27;</span><br><span class="line">   cursor.execute(sql)</span><br><span class="line">   transaction.commit()  # 执行到数据库里</span><br></pre></td></tr></table></figure></p>
<p><img data-src="/images/%E7%BD%97%E6%96%AF%E7%A7%92%E4%BC%A0.webp" title="曾经风之子玫瑰的滞空秒传"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>多表合并</tag>
        <tag>联合查询</tag>
      </tags>
  </entry>
  <entry>
    <title>两个Zabbix_get问题记录</title>
    <url>/2018/10/30/Zabbix-get%E5%8F%8D%E9%A6%88%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AFcontacting/</url>
    <content><![CDATA[<h2 id="Zabbix-get的结果是contacting"><a href="#Zabbix-get的结果是contacting" class="headerlink" title="Zabbix_get的结果是contacting"></a>Zabbix_get的结果是contacting</h2><p>在监控zookeeper的时候，我写了一个简单的脚本<code>checkZKrole.sh</code>来获取当前的角色，如下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@zookeeper1 ~]# cat checkZKrole.sh </span><br><span class="line">#!/bin/bash</span><br><span class="line">role=$(sh /usr/zookeeper/bin/zkServer.sh status| cut -d&quot; &quot; -f2)</span><br><span class="line">echo $role</span><br></pre></td></tr></table></figure></p>
<p>执行效果如下：<br><img data-src="/images/monitorzk.png" alt="akb48"></p>
<p>本地执行没问题，然后在<code>zabbix-agentd.conf</code>里也把这个脚本添加到自定义监控项里：<br><img data-src="/images/monitorzk2.png" alt="akb48"></p>
<p>重启了<code>zabbix-agent</code>后，发现一个很奇怪的现象，在zabbix-server里使用<code>zabbix-get</code>去拿值的时候拿到的是<code>contacting</code>，如图：<br><img data-src="/images/monitorzk3.png" alt="akb48"></p>
<p>从上图可见，同样在127.1.1.28里取值，<code>proc.num</code>没问题，而且是秒取，但是这个自定义项就取不到。</p>
<p>我怀疑是脚本的问题，于是我改成一个单纯的<code>echo</code>，如下:<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@zookeeper1 ~]# cat checkZKrole.sh </span><br><span class="line">#!/bin/bash</span><br><span class="line">role=$(sh /usr/zookeeper/bin/zkServer.sh status| cut -d&quot; &quot; -f2)</span><br><span class="line">#echo $role</span><br><span class="line">echo woshinibaba</span><br></pre></td></tr></table></figure></p>
<p>这一次的返回值是正常的，可见不是脚本的问题：<br><img data-src="/images/monitorzk4.png" alt="akb48"></p>
<p>那是他妈的什么问题，真是见了鬼了…后来想干脆写一个crontab，让crontab把角色写到本地，然后再用cut命令切开把结果当做zabbix_get的目标。但是在这里发现了问题所在，当我的crontab是<code>* * * * * cd /usr/zookeeper/bin/; ./zkServer.sh status &gt; /tmp/role.txt &gt; /dev/null 2&gt;&amp;1</code>，发现<code>/tmp/role.txt</code>里根本没有值，应该是crontab在执行有参数的命令的时候出现了问题。</p>
<p>后来发现了，原来是sudo搞得鬼，如果是由于zookeeper是root用户启动的，所以只有root用户能成功访问，如果是sudo的话，那么就会返回“Error contacting service. It is probably not running.”，所以截取出来的部分就是contacting，如图：<br><img data-src="/images/monitorzk8.png" alt="akb48"></p>
<h2 id="zabbix-get执行脚本超时"><a href="#zabbix-get执行脚本超时" class="headerlink" title="zabbix_get执行脚本超时"></a>zabbix_get执行脚本超时</h2><p>在监控mq队列时候，同样也需要到了自定义监控项，我写了几个简单的脚本如下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@dahuatech zabbix]# cat monitor_mq.sh </span><br><span class="line">#!/bin/sh</span><br><span class="line">ip=$1</span><br><span class="line">queuename=$2</span><br><span class="line">type=$3</span><br><span class="line"></span><br><span class="line">case $&#123;type&#125; in</span><br><span class="line">	Pending)</span><br><span class="line">	curl -s -u &#x27;admin:admin&#x27;  &quot;http://$&#123;ip&#125;:8161/admin/queues.jsp&quot;|grep &quot;$&#123;queuename&#125;&lt;/a&gt;&lt;/td&gt;&quot; -A 5|sed -n &#x27;2p&#x27;|egrep -o &#x27;[0-9]+&#x27;</span><br><span class="line">	;;</span><br><span class="line">	Enqueued)</span><br><span class="line">	curl -s -u &#x27;admin:admin&#x27;  &quot;http://$&#123;ip&#125;:8161/admin/queues.jsp&quot;|grep &quot;$&#123;queuename&#125;&lt;/a&gt;&lt;/td&gt;&quot; -A 5|sed -n &#x27;4p&#x27;|egrep -o &#x27;[0-9]+&#x27;</span><br><span class="line">	;;</span><br><span class="line">	Dequeued)</span><br><span class="line">	curl -s -u &#x27;admin:admin&#x27;  &quot;http://$&#123;ip&#125;:8161/admin/queues.jsp&quot;|grep &quot;$&#123;queuename&#125;&lt;/a&gt;&lt;/td&gt;&quot; -A 5|sed -n &#x27;5p&#x27;|egrep -o &#x27;[0-9]+&#x27;</span><br><span class="line">	;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></p>
<p>配置了<code>UserParameter=activemq.check[*],sh /etc/zabbix/monitor_mq.sh $1 $2 $3</code>放到<code>zabbix-agentd.conf</code>里，重启了zabbix-agent。在zabbix-server配置了对应的item，如图：<br><img data-src="/images/monitorzk5.png" alt="akb48"></p>
<p>然后在本地执行这个脚本，发现回值秒取，但是同样在zabbix-get里使用，就是timeout：<br><img data-src="/images/monitorzk6.png" alt="akb48"></p>
<p>后来发现原来自己摆了一个乌龙，在zabbix-get的时候不能使用<code>{HOST.IP}</code>，因为<code>zabbix-get</code>不识别他，但是<code>zabbix-server</code>是识别的，所以在脚本里把<code>ip=$1</code>改成ip&#x3D;真实的IP地址即可。<br><img data-src="/images/monitorzk7.png" alt="akb48"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Zabbix-proxy的搭建和配置全过程</title>
    <url>/2018/01/26/Zabbix-proxy%E7%9A%84%E6%90%AD%E5%BB%BA%E5%92%8C%E9%85%8D%E7%BD%AE%E5%85%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Zabbix-proxy的用途和构建图"><a href="#Zabbix-proxy的用途和构建图" class="headerlink" title="Zabbix-proxy的用途和构建图"></a>Zabbix-proxy的用途和构建图</h1><p>Zabbix-server是建立在金山云的，现在需要监控阿里云的redis，但是阿里云跟金山云之间通信是无法走内网的，如果直接让zabbix-server与redis直接联系，一旦公网的信息被截获的话，整个金山区的zabbix可能都会遭殃，那么既然有这种“远程监控+当监控的位置通信不便”的需求，就搭建一个zabbix-proxy来解决问题。</p>
<p>Zabbix-proxy是一个监控代理服务器，它收集监控到的数据，先存放在缓冲区，保存的时间可以通过配置文件设定，然后再传送到zabbix-server，这样也大大减缓了zabbix-server的压力，<font color=red>注意！监控代理需要一个单独的数据库，因为它的数据库表名与zabbix-server的数据库表名是一样的，如果不单独分开，后果就是数据错乱。</font></p>
<p>有人看到这里可能问了，说来说去你的zabbix-proxy跟阿里的redis依旧是走公网的啊！虽然这样也是走公网，我现在只需要配置一个防火墙规则来让他俩保证通信即可，通过防火墙来提升安全系数。架构如图：<br><img data-src="/images/proxy1.png"></p>
<h1 id="安装Mysql-5-5"><a href="#安装Mysql-5-5" class="headerlink" title="安装Mysql 5.5"></a>安装Mysql 5.5</h1><p>Zabbix-proxy机器情况：金山云<code>centos 6.5</code>，安装zabbix版本：<code>3.0.8</code><br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@js-online-cjhmq-<span class="number">002</span> opt]yum list installed | grep mysql    #列出已经安装过的mysql情况</span><br><span class="line">[root@js-online-cjhmq-<span class="number">002</span> opt]yum -y remove mysql-libs.<span class="property">x86_64</span>      #把之前的mysql连根拔起</span><br><span class="line">[root@js-online-cjhmq-<span class="number">002</span> opt]# rpm -ivh <span class="attr">http</span>:<span class="comment">//repo.mysql.com/yum/mysql-5.5-community/el/6/x86_64/mysql-community-release-el6-5.noarch.rpm</span></span><br><span class="line"><span class="title class_">Retrieving</span> <span class="attr">http</span>:<span class="comment">//repo.mysql.com/yum/mysql-5.5-community/el/6/x86_64/mysql-community-release-el6-5.noarch.rpm</span></span><br><span class="line"><span class="title class_">Preparing</span>...                ########################################### [<span class="number">100</span>%]</span><br><span class="line">  	<span class="number">1</span>:mysql-community-release########################################### [<span class="number">100</span>%]</span><br><span class="line">[root@js-online-cjhmq-<span class="number">002</span> opt]groupadd zabbix                       #新建用户组zabbix</span><br><span class="line">[root@js-online-cjhmq-<span class="number">002</span> opt]useradd -g zabbix -u <span class="number">808</span> -m zabbix</span><br><span class="line">#-g：指定用户所属的群组；</span><br><span class="line">#-u：指定用户id。</span><br><span class="line">#-m：自动建立用户的登入目录；</span><br></pre></td></tr></table></figure></p>
<p>现在要修改一下<code>/etc/yum.repos.d/mysql-community.repo</code>这个文件，将5.5的enabled改为1,5.6的enabled改为0：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># <span class="title class_">Enable</span> to use <span class="title class_">MySQL</span> <span class="number">5.5</span></span><br><span class="line">[mysql55-community]</span><br><span class="line">name=<span class="title class_">MySQL</span> <span class="number">5.5</span> <span class="title class_">Community</span> <span class="title class_">Server</span></span><br><span class="line">baseurl=<span class="attr">http</span>:<span class="comment">//repo.mysql.com/yum/mysql-5.5-community/el/6/$basearch/</span></span><br><span class="line">enabled=<span class="number">1</span>    #这里改成<span class="number">1</span></span><br><span class="line">gpgcheck=<span class="number">1</span></span><br><span class="line"> </span><br><span class="line">gpgkey=<span class="attr">file</span>:<span class="regexp">/etc/</span>pki/rpm-gpg/<span class="variable constant_">RPM</span>-<span class="variable constant_">GPG</span>-<span class="variable constant_">KEY</span>-mysql</span><br><span class="line"># <span class="title class_">Enable</span> to use <span class="title class_">MySQL</span> <span class="number">5.6</span></span><br><span class="line">[mysql56-community]</span><br><span class="line">name=<span class="title class_">MySQL</span> <span class="number">5.6</span> <span class="title class_">Community</span> <span class="title class_">Server</span></span><br><span class="line">baseurl=<span class="attr">http</span>:<span class="comment">//repo.mysql.com/yum/mysql-5.6-community/el/6/$basearch/</span></span><br><span class="line">enabled=<span class="number">0</span>    #这里改成<span class="number">0</span></span><br><span class="line">gpgcheck=<span class="number">1</span></span><br><span class="line">gpgkey=<span class="attr">file</span>:<span class="regexp">/etc/</span>pki/rpm-gpg/<span class="variable constant_">RPM</span>-<span class="variable constant_">GPG</span>-<span class="variable constant_">KEY</span>-mysql</span><br></pre></td></tr></table></figure></p>
<p>然后执行<code>yum install mysql-community-client mysql-community-devel mysql-community-server php-mysql</code>， 安装服务端和客户端，安装完毕之后可以<code>mysql -h127.0.0.1</code>看一下。<br><img data-src="/images/proxy2.png"></p>
<p>安装完毕之后，修改一下<code>/etc/my.cnf</code>，如图：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">innodb_buffer_pool_size = 512M        #这个根据服务器性能填写，这个机器是<span class="number">2</span>核2G的，所以我拿出半个G给mysql</span><br><span class="line">innodb_file_per_table=<span class="number">1</span>               #这个是新增的字段，设置<span class="title class_">InnoDB</span>为独立表空间模式，每个数据库的每个表都会生成一个数据目录</span><br></pre></td></tr></table></figure></p>
<p>mysql安装完毕之后，我们还要导表进去，如图：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">service mysqld start</span><br><span class="line">mysqladmin -uroot password <span class="string">&#x27;123456&#x27;</span></span><br><span class="line">mysql -uroot -p123456 -e <span class="string">&#x27;create database zabbix_proxy character set utf8;&#x27;</span></span><br><span class="line">mysql -uroot -p123456 -e <span class="string">&quot;grant all privileges on zabbix_proxy.* to zabbix@localhost identified by &#x27;zabbix&#x27;;&quot;</span></span><br><span class="line">mysql -uroot -p123456 -e <span class="string">&quot;flush privileges;&quot;</span></span><br><span class="line">mysql -uzabbix -pzabbix zabbix_proxy &lt;<span class="regexp">/解压路径/</span>zabbix-<span class="number">3.0</span><span class="number">.8</span>/database/mysql/schema.<span class="property">sql</span></span><br></pre></td></tr></table></figure></p>
<p>至此，mysql部分已经全部搞定。</p>
<h1 id="安装Zabbix-proxy"><a href="#安装Zabbix-proxy" class="headerlink" title="安装Zabbix-proxy"></a>安装Zabbix-proxy</h1><p>先去<code>https://sourceforge.net/projects/zabbix/files/ZABBIX%20Latest%20Stable/3.0.8/</code>下载<code>zabbix-3.0.8.tar.gz</code>，上传到proxy服务器里。<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">tar -zxvf zabbix-<span class="number">3.0</span><span class="number">.8</span>.<span class="property">tar</span>.<span class="property">gz</span></span><br><span class="line">./configure --prefix=<span class="regexp">/usr/</span>local/zabbix-<span class="number">3.0</span><span class="number">.8</span>  --sysconfdir=<span class="regexp">/etc/</span>zabbix  --enable-proxy  --enable-agent  --enable-ipv6  --<span class="keyword">with</span>-mysql=<span class="regexp">/usr/</span>bin/mysql_config  --<span class="keyword">with</span>-net-snmp  --<span class="keyword">with</span>-libcurl  --<span class="keyword">with</span>-openipmi  --<span class="keyword">with</span>-unixodbc  --<span class="keyword">with</span>-ldap  --<span class="keyword">with</span>-ssh2  --enable-java</span><br></pre></td></tr></table></figure></p>
<p>如果出现了<code>configure: error: Invalid LDAP directory - unable to find ldap.h</code>，解决方法就是：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yum -y install openldap*</span><br></pre></td></tr></table></figure></p>
<h1 id="Zabbix-proxy的配置"><a href="#Zabbix-proxy的配置" class="headerlink" title="Zabbix-proxy的配置"></a>Zabbix-proxy的配置</h1><p>打开<code>/etc/zabbix/zabbix_proxy.conf</code>，需要修改几个地方：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">ProxyMode</span>=<span class="number">0</span>                                   #<span class="number">0</span>是主动模式，<span class="number">1</span>是被动模式</span><br><span class="line"><span class="title class_">Server</span>=A.<span class="property">B</span>.<span class="property">C</span>.<span class="property">D</span>                #这里填写zabbix-server的内网<span class="variable constant_">IP</span></span><br><span class="line"><span class="title class_">Hostname</span>=J.<span class="property">Q</span>.<span class="property">K</span>.<span class="property">A</span>              #这里要与/etc/hosts下的名字一模一样</span><br><span class="line"><span class="title class_">LogFile</span>=<span class="regexp">/tmp/</span>zabbix_proxy.<span class="property">log</span></span><br><span class="line"><span class="title class_">DBHost</span>=localhost</span><br><span class="line"><span class="title class_">DBName</span>=zabbix_proxy</span><br><span class="line"><span class="title class_">DBUser</span>=zabbix</span><br><span class="line"><span class="title class_">DBPassword</span>=zabbix</span><br><span class="line"><span class="title class_">ConfigFrequency</span>=<span class="number">120</span>              #主动去server端去拉去配置更新的频率<span class="number">120</span>秒一次</span><br><span class="line"><span class="title class_">DataSenderFrequency</span>=<span class="number">60</span>              #发送采集的监控数据到服务器端，默认是<span class="number">1</span>秒，我们一分钟发送一次</span><br><span class="line">#<span class="title class_">ProxyLocalBuffer</span>=<span class="number">0</span>                #<span class="title class_">ProxyLocalBuffer</span>表示数据传递给server之后还要在proxy里保存多久（单位为小时）。如果注释就是代表不删除。</span><br><span class="line">#<span class="title class_">ProxyOfflineBuffer</span>=<span class="number">1</span>               #<span class="title class_">ProxyOfflineBuffer</span>表示数据没有传递给server的话还要在proxy里保存多久（单位为小时）。如果注释就是代表不删除。</span><br></pre></td></tr></table></figure></p>
<p>然后就是启动proxy:<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># /usr/local/zabbix_proxy/sbin/zabbix_proxy</span><br></pre></td></tr></table></figure></p>
<p>用netstat查看一下端口和进程是否都OK：<br><img data-src="/images/proxy3.png"></p>
<h1 id="Zabbix-server端的配置"><a href="#Zabbix-server端的配置" class="headerlink" title="Zabbix-server端的配置"></a>Zabbix-server端的配置</h1><p>登入zabbix-server的网页，如图添加proxy：<br><img data-src="/images/proxy4.png"></p>
<p>点击“create proxy”之后，就对应填写资料吧：<br><img data-src="/images/proxy5.png"></p>
<p><img data-src="/images/proxy6.png"></p>
<p>这里对上面的几个选项多说几句：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Connections</span> to proxy：服务器如何连接到被动代理：无加密（默认），使用<span class="variable constant_">PSK</span>（预共享密钥）或证书。</span><br><span class="line"><span class="title class_">Connections</span> <span class="keyword">from</span> proxy：从活动代理中选择允许的连接类型。 可以同时选择几种连接类型（用于测试和切换到其他连接类型）。 默认为“无加密”。</span><br><span class="line">#点击<span class="title class_">Certificate</span>之后又两个参数：</span><br><span class="line"><span class="title class_">Issuer</span>：允许颁发证书。 证书首先通过<span class="variable constant_">CA</span>（认证机构）验证。 如果<span class="variable constant_">CA</span>有效，则由<span class="variable constant_">CA</span>签名，则可以使用<span class="title class_">Issuer</span>字段来进一步限制允许的<span class="variable constant_">CA</span>。 该字段是可选的，如果您的<span class="title class_">Zabbix</span>安装使用多个<span class="variable constant_">CA</span>的证书，则使用该字段。</span><br><span class="line"><span class="title class_">Subject</span>：允许的证书。 证书首先通过<span class="variable constant_">CA</span>验证。 如果它有效，由<span class="variable constant_">CA</span>签名，则主题字段可用于仅允许<span class="title class_">Subject</span>字符串的一个值。 如果此字段为空，则接受由配置的<span class="variable constant_">CA</span>签名的任何有效证书。	</span><br><span class="line">#点击<span class="variable constant_">PSK</span>之后又两个参数：</span><br><span class="line"><span class="variable constant_">PSK</span> identity：预共享密钥身份字符串。</span><br><span class="line"><span class="variable constant_">PSK</span> ： 预共享密钥（hex-string）。 如果<span class="title class_">Zabbix</span>使用mbed <span class="variable constant_">TLS</span>（<span class="title class_">PolarSSL</span>）库，<span class="title class_">Zabbix</span>将使用<span class="title class_">GnuTLS</span>或<span class="title class_">OpenSSL</span>库，<span class="number">64</span>位十六进制（<span class="number">32</span>字节<span class="variable constant_">PSK</span>），最大长度为<span class="number">512</span>位十六进制数（<span class="number">256</span>字节<span class="variable constant_">PSK</span>）。 示例：1f87b595725ac58dd977beef14b97461a7c1045b9a1c963065002c5473194952</span><br></pre></td></tr></table></figure></p>
<p>保存之后，就在zabbix-server用<code>zabbix-get</code>去ping一下proxy，看看返回值是否是1，如果是<code>zabbix_get [18290]: Check access restrictions in Zabbix agent configuration</code>，就检查一下刚才的hostname等值是否正确。<br><img data-src="/images/proxy7.png"></p>
<h1 id="被监控机器的配置"><a href="#被监控机器的配置" class="headerlink" title="被监控机器的配置"></a>被监控机器的配置</h1><p>在被监控的阿里云redis里安装<code>zabbix-agent</code>，在<code>agentd.conf</code>里把<code>hostname</code>写成自己在<code>/etc/hosts</code>里的<code>hostname</code>，<code>Server</code>地址和<code>ServerActive</code>的地址都要写成proxy的外网IP地址。保存之后启动agent进程，这个时候在proxy端是可以通过<code>zabbix_get</code>得到这台被监控机器的值，如图：<br><img data-src="/images/proxy8.png"></p>
<p>在Zabbix-Server的WEB界面里，为阿里云的redis新建一个host，<code>Agent interface</code>那里填写被监控的机器IP，端口是10050，<code>Monitored by proxy</code>的地方要写成刚刚添加的proxy。如图：<br><img data-src="/images/proxy9.png"></p>
<p>上面已经提到过，用proxy模式并且zabbix的客户端也是主动模式提交数据，这样能大大提高采集效率，降低zabbix服务器端和proxy端的压力。现在我们希望添加的还是使用zabbix_agent的方式，新加到zabbix_proxy里面的主机使用<code>zabbix_agent（active）</code>的方式。注意在模板的克隆要选择<code>full clone</code>，不要选“clone”，那样的话就仅仅是把iterm的名字克隆过去而已，如图：<br><img data-src="/images/proxy10.png"></p>
<p>然后在items选择具体的类型，根据需要，想改那个改哪个，如图，注意！我图里写的是<code>Zabbix agent</code>，但是type这里选择<code>Zabbix agent (active)</code>。<br><img data-src="/images/proxy11.png"></p>
<p>改完之后，保存一下，就会看到type都是<code>zabbix agent（active）</code>了。<br><img data-src="/images/proxy12.png"></p>
<p>最后在host里把这个机器添加到proxy的模板里，如图：<br><img data-src="/images/proxy13.png"></p>
<p>在Administration的Proxies也看到效果了，如果server与proxy没有正确连接的话，last seen的地方会是<code>--</code>，如果连接的话就会显示具体时间，如图:<br><img data-src="/images/proxy15.png"></p>
<p>返回到hosts里，查看那个被监控的redis机器也成功被监控到了，<code>ZBX</code>已经变绿。如图：<br><img data-src="/images/proxy14.png"></p>
<p>因为我们线上环境基本都是用的zabbix_proxy方式是active方式，然后客户端也是active方式，既然都是active方式，那么zabbix_agent的Hostname就很重要，打个比方如果再zabbix_server端把一个主机的Hostname改了，然后客户端那边也改了，服务端和客户端的Hostname是统一的，但是proxy那里还记录的是旧Hostname，然后就会在proxy日志里面看到下面一条：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cannot send list <span class="keyword">of</span> active checks to <span class="string">&quot;proxy内网IP地址&quot;</span>: host [virt_proxy内网<span class="variable constant_">IP</span>地址] not found</span><br></pre></td></tr></table></figure></p>
<p>proxy主动模式下，<code>ConfigFrequency</code>默认的是3600秒一小时，显然有点大了，可以适当的调低一下，如10分钟或者几分钟什么的。然后出现问题多看看zabbix服务端和proxy的日志，对症下药。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.51niux.com/?id=156">http://www.51niux.com/?id=156</a><br><a href="http://www.cnblogs.com/wangxiaoqiangs/p/5336630.html">http://www.cnblogs.com/wangxiaoqiangs/p/5336630.html</a> </p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
        <tag>监控技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Zabbix用户密码忘记怎么办</title>
    <url>/2018/01/17/Zabbix%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E5%BF%98%E8%AE%B0%E6%80%8E%E4%B9%88%E5%8A%9E/</url>
    <content><![CDATA[<p>zabbix的超级用户也是人，人就难免会忘记密码（或者清除了当前浏览器的缓存），忘记密码不要怕，因为zabbix所有的用户数据都是保存在server机器上的mysql里，只要打开<code>zabbix_server.conf</code>，就会查得到mysql的登录账号密码以及zabbix对应的数据库。（这里多说一句，zabbix自带的guest基本就是一个废物，forget it~）</p>
<p>在zabbix_server机器上输入mysql的账号密码来到mysql里，<code>USE zabbix</code>，然后<code>SELECT * FROM users</code>,就会看到笔者的画面。<br><img data-src="/images/zabbix_user1.png" alt="akb48"></p>
<p>这个时候就可以使用数据库的update命令去更改密码，比如说新的密码是“woshitiancai”，就可以写<code>update  users set passwd=md5(&quot;woshitiancai&quot;) where userid=&#39;1&#39;;</code><br>然后就可以用woshitiancai来登陆啦~</p>
<p>但是！！！你以为这就结束了吗？nononono！！！</p>
<p>很多人即使更改了密码还是登陆不上去，很简单，那就是你连用户名都忘记了！或者是用户名你记得但是你手贱在zabbix的administration里的users对原来的设定增加了新东西，而且这些东西还特么的是中文！！！于是就像我上面图那样出现了???的字样。</p>
<p>那些？？？很重要吗？当然了！！！因为那些才是zabbix的登录用户名！！！看见了吗，zabbix使用蛋疼的alias作为真正的登录名而不是用name or surname，这真是一个蛋疼的事儿！</p>
<p>那么剩下的问题很简单了，就是把???改变成中文，使用语句<code>set names utf8;</code> 然后界面就成了这样：<br><img data-src="/images/zabbix_user2.png" alt="akb48"></p>
<p>这次再使用“主管理员”搭配新的密码就可以华丽的登录了！~~我他妈当时都差点要把这个user表格删掉然后重拽一个表格进来，但是终于还是被我识破了，啊哈哈哈哈，我真是个天才！！！</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>XtraBackup的安装和使用</title>
    <url>/2019/06/17/XtraBackup%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>XtraBackup是数据库物理备份工具，是阿里云RDS备份数据库的组件。它的优点是热备而且速度快，效率比mysqldump不知道高到哪里去了。它的备份原理如下:</p>
<ol>
<li>innobackupex首先会启动一个xtrabackup_log后台检测的进程，实时检测mysql的redo log的变化，一旦发现redo有新的日志写入，立刻将日志写入到日志文件xtrabackup_log中。</li>
<li>物理拷贝innodb的数据文件和系统表空间文件idbdata1到对应的以默认时间戳为备份目录的地方</li>
<li>复制结束后，执行<code>flush table with read lock</code>操作进行全库锁表准备备份非InnoDB文件</li>
<li>复制.frm .myd .myi等非InnoDB引擎文件</li>
<li>查看binary log 的位置</li>
<li>解锁unlock tables</li>
<li>停止xtrabackup_log进程</li>
</ol>
<p><img data-src="/images/xtrabackup2.png" alt="akb48"></p>
<h2 id="安装与全量备份"><a href="#安装与全量备份" class="headerlink" title="安装与全量备份"></a>安装与全量备份</h2><p>先去<a href="https://www.percona.com/downloads/Percona-XtraBackup-2.4/LATEST/">https://www.percona.com/downloads/Percona-XtraBackup-2.4/LATEST/</a> 下载2.4版本的XtraBackup，虽然最新的版本是<code>8.0.6</code>，但是据说它只支持mysql8.0和percona8.0…<br><img data-src="/images/xtrabackup.png" alt="akb48"></p>
<p>安装步骤如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[root@share ~]<span class="comment">#	yum install -y cmake libaio-devel</span></span><br><span class="line">[root@share ~]<span class="comment">#	yum install glibc glibc-devel glibc-static perl-Digest-MD5 perl-DBD-MySQL -y</span></span><br><span class="line">   [root@share ~]<span class="comment"># wget ftp://rpmfind.net/linux/atrpms/el6-x86_64/atrpms/stable/libev-4.04-2.el6.x86_64.rpm</span></span><br><span class="line">   [root@share ~]<span class="comment"># rpm -ivh libev-4.04-2.el6.x86_64.rpm			#xtrabackup安装依赖libev.so.4()(64bit) </span></span><br><span class="line">[root@share ~]<span class="comment"># rpm -ivh percona-xtrabackup-24-2.4.14-1.el6.x86_64.rpm </span></span><br><span class="line">warning: percona-xtrabackup-<span class="number">24</span>-<span class="number">2.4</span><span class="number">.14</span>-<span class="number">1.</span>el6.x86_64.rpm: Header V4 RSA/SHA256 Signature, key ID 8507efa5: NOKEY</span><br><span class="line">Preparing...                          <span class="comment">################################# [100%]</span></span><br><span class="line">Updating / installing...</span><br><span class="line">   <span class="number">1</span>:percona-xtrabackup-<span class="number">24</span>-<span class="number">2.4</span><span class="number">.14</span>-<span class="number">1.</span>el<span class="comment">################################# [100%]</span></span><br><span class="line">[root@share ~]<span class="comment"># </span></span><br></pre></td></tr></table></figure></p>
<p>安装完毕之后，就可以<code>innobackupex --host=127.0.0.1 --user=root --password=数据库密码 --defaults-file=/etc/mysql/my.cnf /备份的文件夹名</code>来备份数据库。同时备份结束之后会生成一个LSN号，在增量备份时候，就只备份大于此号的数据页。</p>
<p>如果有了备份文件想要全量恢复的话，就是如下操作：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scp -r /backup/备份文件夹/ 另一个mysqlIP:/backup/	<span class="comment">#先将本机的备份文件夹拷贝到其他服务器里去</span></span><br><span class="line">innobackupex --apply-log --use-memory=1G /backup/备份文件夹/	<span class="comment">#在新的mysql里进行数据的准备工作，这一步用来合成可用的数据，--use-memory根据实际情况指定</span></span><br><span class="line">systemctl stop mariadb</span><br><span class="line">rm -rf /var/lib/mysql/*		<span class="comment">#停止当前进程，并且删除数据目录和对应日志</span></span><br><span class="line">innobackupex --datadir=/var/lib/mysql --copy-back /backup/备份文件夹/		<span class="comment">#将准备好的数据还原到对应目录里</span></span><br><span class="line">chown -R mysql: /var/lib/mysql/		<span class="comment">#将文件夹属主和组都更改成mysql</span></span><br><span class="line">systemctl start mariadb		<span class="comment">#重启进程</span></span><br></pre></td></tr></table></figure>
	</p>
<h2 id="增量备份与恢复"><a href="#增量备份与恢复" class="headerlink" title="增量备份与恢复"></a>增量备份与恢复</h2><p>增量备份的前提是全量备份，假设我们已经进行了全量备份。增量备份过程如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">innobackupex -p数据库密码 --incremental /全量备份文件夹 --incremental-basedir=/backup/增量备份文件夹<span class="number">1</span>/	<span class="comment">#与全量备份文件夹相比，进行增量备份</span></span><br><span class="line">scp -r /backup/* 另一个mysqlIP:/backup/		<span class="comment">#传递给另个mysql里</span></span><br><span class="line">innobackupex --apply-log --redo-only --use-memory=1G /backup/全量备份文件夹/	<span class="comment">#先对最早的全量备份进行恢复</span></span><br><span class="line">innobackupex --apply-log --redo-only --use-memory=1G /backup/全量备份文件夹/ --incremental-<span class="built_in">dir</span>=/backup/增量备份文件夹<span class="number">1</span>		</span><br><span class="line"><span class="comment">#在之前全量备份的基础上合并一波增量备份</span></span><br><span class="line">systemctl stop mariadb</span><br><span class="line">rm -rf /var/lib/mysql/*		<span class="comment">#停止当前进程，并且删除数据目录和对应日志</span></span><br><span class="line">innobackupex --datadir=/var/lib/mysql --copy-back /backup/备份文件夹/		<span class="comment">#将准备好的数据还原到对应目录里</span></span><br><span class="line">chown -R mysql: /var/lib/mysql/		<span class="comment">#将文件夹属主和组都更改成mysql</span></span><br><span class="line">systemctl start mariadb		<span class="comment">#重启进程</span></span><br></pre></td></tr></table></figure></p>
<p>查看是否是增量备份还是全量备份，可以通过<code>xtrabackup_checkpoints</code>文件里的<code>backup_type</code>字段：<code>full-prepared</code>是全量备份、<code>incremental</code>是增量备份。</p>
<p>这里有一个坑，就是<code>备份和恢复的时候使用的xtrabackup的版本要保持一致</code>，如果不一致，就会有<code>Failed to connect to MySQL server to detect version.</code>的错误。如果出现了错误，就要根据mysql版本在原有命令后添加<code>--ibbackup xtrabackup_版本号</code>，比如我的mysql是5.6版本的，那么语句就是<code>innobackupex --use-memory=1G --apply-log /data/back --ibbackup xtrabackup_56</code> 。</p>
<h2 id="Mysql如何恢复到任意时间点"><a href="#Mysql如何恢复到任意时间点" class="headerlink" title="Mysql如何恢复到任意时间点"></a>Mysql如何恢复到任意时间点</h2><p>众所周知，mysql的更新操作（UPDATE）是“先备份再覆盖”的一个过程，那备份在哪里呢?<code>buffer</code>。</p>
<p>但是这个瞬间就会出现buffer的数据页与磁盘的数据页内容不一致，这时的buffer的数据页叫<code>dirty page</code>。如果此时出现了mysql非正常宕机，就会出现“数据并没有同步到磁盘文件中，而且已经从内存里出来了”的现象，即数据丢失。</p>
<p>为了解决这个现象，就在buffer的<code>dirty page</code>变更结束之后，把相应修改记录记录到<code>redo log</code>里。如果在发现有数据丢失的现象，可以通过<code>redo log</code>回溯。更多内容可以看<a href="https://mp.weixin.qq.com/s?__biz=MjM5NjMyMjUzNg==&mid=2448131616&idx=1&sn=5af80b03adef5846b7dc51015d99f7e7&scene=0#wechat_redirect&rd2werd=1#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MjM5NjMyMjUzNg==&amp;mid=2448131616&amp;idx=1&amp;sn=5af80b03adef5846b7dc51015d99f7e7&amp;scene=0#wechat_redirect&amp;rd2werd=1#wechat_redirect</a> 这篇文章。</p>
<p>整理一下mysql里更新语句的内幕：</p>
<p>系统当取到一个UPDATE语句的时候，会先通过主键找到该行，判断此行是否在buffer里，如果在就直接返回给执行器，如果不在就先从磁盘拷贝一份到内存里，在内存里对数据进行修改，此时生成了<code>dirty page</code>，同时也将这个操作记录更新到<code>redo log</code>里，<code>redo log</code>处于<code>prepare</code>状态（mysql生成<code>xid</code>)，通知执行器可以提交覆盖磁盘（这是一个事务）。然后执行器先生成这个操作的bin log（mysql是<code>日志先行</code>的设计），然后再执行覆盖的操作（将<code>xid</code>写进<code>bin log</code>)，至此更新完成。</p>
<p>假设此时mysql出现了非正常宕机，那么先找一下有没有之前的xtrabackup等工具保留的备份，如果有当日的备份，再结合<code>bin log</code>可以恢复一个临时表。然后扫描最后一个<code>bin log</code>，提取出xid。重做检查点以后的<code>redo log</code>，搜集处于<code>prepare</code>阶段的事务链表，将事务的<code>xid</code>与<code>bin log</code>中的<code>xid</code>对比。若存在，说明事务记录到<code>bin log</code>成功，只是最终未<code>commit</code>成功，可以直接提交，否则就回滚。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="http://mysql.taobao.org/monthly/2016/03/07/">http://mysql.taobao.org/monthly/2016/03/07/</a><br><a href="http://mysql.taobao.org/monthly/2018/02/05/">http://mysql.taobao.org/monthly/2018/02/05/</a><br><a href="https://mp.weixin.qq.com/s?__biz=MjM5NjMyMjUzNg==&mid=2448131616&idx=1&sn=5af80b03adef5846b7dc51015d99f7e7&scene=0#wechat_redirect&rd2werd=1#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MjM5NjMyMjUzNg==&amp;mid=2448131616&amp;idx=1&amp;sn=5af80b03adef5846b7dc51015d99f7e7&amp;scene=0#wechat_redirect&amp;rd2werd=1#wechat_redirect</a><br><a href="https://help.aliyun.com/knowledge_detail/41738.html?spm=a2c4g.11186631.2.4.2b9d6998v5nwaK">https://help.aliyun.com/knowledge_detail/41738.html?spm=a2c4g.11186631.2.4.2b9d6998v5nwaK</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据备份</tag>
      </tags>
  </entry>
  <entry>
    <title>Zabbix3.0搭配微信企业号报警</title>
    <url>/2018/01/10/Zabbix3-0%E6%90%AD%E9%85%8D%E5%BE%AE%E4%BF%A1%E4%BC%81%E4%B8%9A%E5%8F%B7%E6%8A%A5%E8%AD%A6/</url>
    <content><![CDATA[<p>Zabbix搭配微信企业号报警是一个很流行的手段，这里说一下如何配置。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>建立一个企业号以及具体应用的链接在此：<a href="http://chenx1242.blog.51cto.com/10430133/1954634%EF%BC%8C%E9%87%8C%E9%9D%A2%E5%86%99%E7%9A%84%E9%83%BD%E5%BE%88%E6%98%8E%E7%99%BD%E4%BA%86%E3%80%82">http://chenx1242.blog.51cto.com/10430133/1954634，里面写的都很明白了。</a></p>
<p>现在打开微信企业号的官方网站<a href="https://work.weixin.qq.com,然后扫描一下微信二维码登录到企业号的控制台./">https://work.weixin.qq.com，然后扫描一下微信二维码登录到企业号的控制台。</a></p>
<p>在控制台网页里，需要查找几个元素，分别是<code>CorpID</code>、<code>应用AgentId</code>、<code>应用Secret</code>还有<code>用户账号</code>。</p>
<p>首先，在控制台里选择“我的企业”，然后就可以看见<code>CorpID</code>，如图：<br><img data-src="/images/corpid.png" alt="抱光妹" title="获取CorpID"></p>
<p>然后点击“企业应用”，如果没有应用，那么就新建立一个应用。比如我已经建立了一个应用叫“zabbix告警”，那么应用AgentId和应用Secret就在如图的位置：<br><img data-src="/images/aksk1.png" alt="抱光妹" title="应用AgentId和应用Secret"></p>
<p>有了上面的CropID和Secret，就可以去验证一下accesstoken，登录<a href="http://qydev.weixin.qq.com/debug">http://qydev.weixin.qq.com/debug</a> ，后在填入对应的CropID和Secret，看一下返回结果是否是“HTTP&#x2F;1.0 200 OK”，如图：<br><img data-src="/images/checkaksk.png" alt="抱光妹" title="验证AgentId和Secret"></p>
<p>在这个“zabbix告警”的应用里可见范围里添加对应需要通知的人，然后在“通讯录”里，找到对应的人，记录他们的账号，如图：<br><img data-src="/images/content.png" alt="抱光妹" title="通讯录联系人"></p>
<p>材料已经俱备完毕，现在需要做的是更改zabbix-server配置。</p>
<p>首先，在zabbix-server.conf里添加一句<code>AlertScriptsPath=/usr/lib/zabbix/alertscripts</code>，这是为了说明一下脚本所在的路径。当然，这个路径你可以自己更改，然后重启一下zabbix-server。</p>
<h2 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h2><p><code>cd /usr/lib/zabbix/alertscripts</code>，在这个目录下我们要新写一个微信脚本，比如脚本名称叫<code>wechat.py</code>。</p>
<p>这个python脚本是需要requests模块的，所以需要先安装这个模块，安装方法如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pip install requests</span><br><span class="line">pip install --upgrade requests</span><br></pre></td></tr></table></figure></p>
<p>而python脚本内容如下，<strong>感谢<a href="https://github.com/X-Mars/Zabbix-Alert-WeChat/%E7%9A%84%E8%84%9A%E6%9C%AC">https://github.com/X-Mars/Zabbix-Alert-WeChat/的脚本</a></strong>：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/usr/</span>bin/python2<span class="number">.7</span></span><br><span class="line">#_*<span class="attr">_coding</span>:utf-<span class="number">8</span> _*_</span><br><span class="line">#<span class="variable language_">this</span> script is used <span class="keyword">for</span> alarm by <span class="variable constant_">WECHAT</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests,sys,json</span><br><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line"></span><br><span class="line">urllib3.<span class="title function_">disable_warnings</span>()</span><br><span class="line"><span class="title function_">reload</span>(sys)</span><br><span class="line">sys.<span class="title function_">setdefaultencoding</span>(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">def <span class="title class_">GetToken</span>(<span class="title class_">Corpid</span>,<span class="title class_">Secret</span>):</span><br><span class="line">   	<span class="title class_">Url</span> = <span class="string">&quot;https://qyapi.weixin.qq.com/cgi-bin/gettoken&quot;</span></span><br><span class="line">   	<span class="title class_">Data</span> = &#123;</span><br><span class="line">   	    <span class="string">&quot;corpid&quot;</span>:<span class="title class_">Corpid</span>,</span><br><span class="line">   	    <span class="string">&quot;corpsecret&quot;</span>:<span class="title class_">Secret</span></span><br><span class="line">   	&#125;</span><br><span class="line">   	r = requests.<span class="title function_">get</span>(url=<span class="title class_">Url</span>,params=<span class="title class_">Data</span>,verify=<span class="title class_">False</span>)</span><br><span class="line">   	<span class="title class_">Token</span> = r.<span class="title function_">json</span>()[<span class="string">&#x27;access_token&#x27;</span>]</span><br><span class="line">   	<span class="keyword">return</span> <span class="title class_">Token</span></span><br><span class="line">   	 </span><br><span class="line">def <span class="title class_">SendMessage</span>(<span class="title class_">Token</span>,<span class="title class_">User</span>,<span class="title class_">Agentid</span>,<span class="title class_">Subject</span>,<span class="title class_">Content</span>):</span><br><span class="line">   	<span class="title class_">Url</span> = <span class="string">&quot;https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token=%s&quot;</span> % <span class="title class_">Token</span></span><br><span class="line">   	<span class="title class_">Data</span> = &#123;</span><br><span class="line">   	    <span class="string">&quot;touser&quot;</span>: <span class="title class_">User</span>,                                 # 企业号中的用户帐号，在zabbix用户<span class="title class_">Media</span>中配置，如果配置不正常，将按部门发送。</span><br><span class="line">   	    #<span class="string">&quot;totag&quot;</span>: <span class="title class_">Tagid</span>,                                # 企业号中的部门id，群发时使用。</span><br><span class="line">   	    <span class="string">&quot;msgtype&quot;</span>: <span class="string">&quot;text&quot;</span>,                              # 消息类型。</span><br><span class="line">   	    <span class="string">&quot;agentid&quot;</span>: <span class="title class_">Agentid</span>,                             # 企业号中的应用id。</span><br><span class="line">   	    <span class="string">&quot;text&quot;</span>: &#123;</span><br><span class="line">   	        <span class="string">&quot;content&quot;</span>: <span class="title class_">Subject</span> + <span class="string">&#x27;\n&#x27;</span> + <span class="title class_">Content</span></span><br><span class="line">   	    &#125;,</span><br><span class="line">   	    <span class="string">&quot;safe&quot;</span>: <span class="string">&quot;0&quot;</span></span><br><span class="line">   	&#125;</span><br><span class="line">   	r = requests.<span class="title function_">post</span>(url=<span class="title class_">Url</span>,data=json.<span class="title function_">dumps</span>(<span class="title class_">Data</span>),verify=<span class="title class_">False</span>)</span><br><span class="line">   	<span class="keyword">return</span> r.<span class="property">text</span></span><br><span class="line">   	 </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   	<span class="title class_">User</span> = sys.<span class="property">argv</span>[<span class="number">1</span>]                                                              # zabbix传过来的第一个参数</span><br><span class="line">   	<span class="title class_">Subject</span> = sys.<span class="property">argv</span>[<span class="number">2</span>]                                                           # zabbix传过来的第二个参数</span><br><span class="line">   	<span class="title class_">Content</span> = sys.<span class="property">argv</span>[<span class="number">3</span>]                                                           # zabbix传过来的第三个参数</span><br><span class="line">   	<span class="title class_">Corpid</span> = <span class="string">&quot;这里填写Corpid&quot;</span>                                                   </span><br><span class="line">   	<span class="title class_">Secret</span> = <span class="string">&quot;这里填写Secret&quot;</span>                           </span><br><span class="line">   	<span class="title class_">Agentid</span> = <span class="string">&quot;这里填写应用的agentid&quot;</span>                                                        </span><br><span class="line">   	<span class="title class_">Token</span> = <span class="title class_">GetToken</span>(<span class="title class_">Corpid</span>, <span class="title class_">Secret</span>)</span><br><span class="line">   	<span class="title class_">Status</span> = <span class="title class_">SendMessage</span>(<span class="title class_">Token</span>,<span class="title class_">User</span>,<span class="title class_">Agentid</span>,<span class="title class_">Subject</span>,<span class="title class_">Content</span>)</span><br><span class="line">   	print <span class="title class_">Status</span></span><br></pre></td></tr></table></figure><br>脚本保存后，<code>chown -R zabbix:zabbix wechat.py</code>，然后小试一下，上面看到“Zabbix告警”这个微信应用里有一个用户账号叫ChenShuo，那么wechat.py执行语句是：<code>python wechat.py ChenShuo 这个是标题  这里是正文！！</code></p>
<p>然后看一下微信，如图：<br><img data-src="/images/checkpy.jpg" alt="抱光妹" title="脚本验证成功"></p>
<p>正确出现了微信提示，可见这个脚本是OK的了。</p>
<h2 id="配置zabbix"><a href="#配置zabbix" class="headerlink" title="配置zabbix"></a>配置zabbix</h2><p>现在我们要登录到zabbix网站，最上面的“Administration”里选择“Media types”，新建立一个Media type，如图：<br><img data-src="/images/mediatype.png" alt="抱光妹" title="新建立Media type"></p>
<p>保存之后，在“Administration”里选择“Users”，在Admin用户里点击“media”,把刚刚新增的“微信告警”这个media type添加进去，如图：<br><img data-src="/images/addpy.png" alt="抱光妹" title="添加Media type"></p>
<p>通知手段配置完毕，现在就是要在具体的Trigger上把微信告警这个新手段添加到active里。首先打开Configuration里的actions界面。此时假设现在有一个告警Trigger叫“模块发生了重启”，判断模块是否重启的依据就是pid值是否发生了变化。那么点击这个Trigger，在action里把“微信告警”添加到报警手段里，如图：<br><img data-src="/images/addtrigger.png" alt="抱光妹" title="配置trigger"></p>
<p>保存之后，整个的微信告警配置就完成了。为了验证配置是否生效，我冒死重启了一台生产环境的服务器，当然啦，好孩子千万不要效仿。</p>
<p>收到微信提示如图：<br><img data-src="/images/checkpy2.jpg" alt="抱光妹" title="脚本验证成功"><br>不过考虑到微信告警可能会有所延迟，所以在这建议大家把告警阈值配置稍微早一点，避免“孩子死了奶来了”这种尴尬的情况。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.yfshare.vip/2017/04/13/Zabbix%E4%B9%8B%E5%BE%AE%E4%BF%A1-Wechat-%E5%91%8A%E8%AD%A6/">http://www.yfshare.vip/2017/04/13/Zabbix%E4%B9%8B%E5%BE%AE%E4%BF%A1-Wechat-%E5%91%8A%E8%AD%A6/</a><br><a href="https://github.com/X-Mars/Zabbix-Alert-WeChat/">https://github.com/X-Mars/Zabbix-Alert-WeChat/</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>Zabbix添加网卡内外流量监控</title>
    <url>/2018/01/23/Zabbix%E6%B7%BB%E5%8A%A0%E7%BD%91%E5%8D%A1%E5%86%85%E5%A4%96%E6%B5%81%E9%87%8F%E7%9B%91%E6%8E%A7/</url>
    <content><![CDATA[<p>现在笔者想对host名单里面的<code>zabbix_server</code>进行网卡的内外流量情况的一个监控，首先登录zabbix之后，<code>configuration</code>—<code>hosts</code>，出现如下的菜单：<br><img data-src="/images/zabbixnet1.png" alt="akb48"></p>
<p>现在可以看到这个zabbix_server后面link了很多个模板，正是因为link了很多的模板，所以导致它的items非常多，42个。现在是要在zabbix_server里添加两个新的监控项，这一步跟模板其实没有什么关系，只需要在items里直接添加items即可。</p>
<p>我们先添加网卡外流量的items，整个配置如图所示：<br><img data-src="/images/zabbixnet2.png" alt="akb48"></p>
<p>里面具体的数值可以自己更换，比如<code>Applications</code>什么的，<code>key\units\Use custom multiplier</code>这些是固定的，全部写完之后就可以save。</p>
<p>找葫芦画瓢，我们可以再添加一个网卡的内流量监控，也是一样的套路，如图所示：<br><img data-src="/images/zabbixnet3.png" alt="akb48"></p>
<p>有了<code>items</code>，就要有<code>trigger</code>，有了items里的<code>key</code>，那么<code>trigger</code>也很简单，这里的<code>expression</code>多时候各位都是从网上ctrl+c下来，却不能ctrl+v，因为会红字报错—-<code>Incorrect item key &quot;net.if.in[eth0,bytes]&quot; provided for trigger expression on &quot;服务器名称&quot;</code>，于是就有很多不明真相的吃瓜群众就走“add”路线，然后发现要走add路线还要先把服务器添加到对应的模板上去。其实大可不必，这个expression是可以自己写的，但是一定要确定trigger跟items是配对的。以外网流量所示：<br><img data-src="/images/zabbixnet4.png" alt="akb48"></p>
<p>在这里我添加成了1K，这样是为了方便监控，具体数值因情况而异，而且重要性我选择了无。</p>
<p>最后就是要形成图表来糊弄领导，让领导感受一下什么叫做高大上，在graph的界面里选择<code>create graph</code>，然后就如图所示的填写：<br><img data-src="/images/zabbixnet5.png" alt="akb48"></p>
<p>一个是红色线，一个是绿色线，双龙戏珠，<code>save</code>。</p>
<p>最后来到<code>Monitoring</code>—<code>Graphs</code>里，找到正确的host,group和graph，就会看到激动人心的图表了：<br><img data-src="/images/zabbixnet6.png" alt="akb48"></p>
<p>这里要注意几点，有时候zabbix反应较慢，可能写好的key会出现<code>not support</code>的情况，这个时候可以先登录zabbix_server去<code>zabbix_get</code>一下，<code>zabbix_get</code>的方法之前有讲过，请见<a href="http://chenx1242.blog.51cto.com/10430133/1738820">http://chenx1242.blog.51cto.com/10430133/1738820</a> ，如果<code>zabbix_get</code>是成功返回值的，先检查对应的单位（结果是浮点值，但是units设定是一个整数值肯定会<code>not support</code>）,如果单位检查正确，就修改zabbix重新check的时间，实在不行就重新建立一个items。 </p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
        <tag>服务器监控</tag>
      </tags>
  </entry>
  <entry>
    <title>Zabbix-api获取值在Django页面展示</title>
    <url>/2019/04/02/Zabbix-api%E8%8E%B7%E5%8F%96%E5%80%BC%E5%9C%A8Django%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA/</url>
    <content><![CDATA[<h2 id="背景交代"><a href="#背景交代" class="headerlink" title="背景交代"></a>背景交代</h2><p>私有云的同学要求把几个涉及录像的模块带宽每小时从zabbix获取一次，然后在django页面展示出来。由于django跟zabbix并不在一个服务器，那么就采取“zabbix上跑脚本，脚本将实时的带宽值存储到某个数据库里，然后django去数据库取值并且展示”这样的思路来解决问题。</p>
<p>python3 + Django 2.1.1<br>APP：accessgateway</p>
<h2 id="建立数据库"><a href="#建立数据库" class="headerlink" title="建立数据库"></a>建立数据库</h2><p>首先需要先建立数据模型，在app下的<code>models.py</code>里添加如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#这里是数据模型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lbmrs</span>(models.Model):</span><br><span class="line">    host = models.CharField(verbose_name=<span class="string">&#x27;MRS服务器名称&#x27;</span>,max_length=<span class="number">50</span>)</span><br><span class="line">    inbandwidth = models.FloatField(verbose_name=<span class="string">&#x27;入网带宽&#x27;</span>)</span><br><span class="line">    outbandwidth = models.FloatField(verbose_name=<span class="string">&#x27;出网带宽&#x27;</span>)</span><br><span class="line">	date = models.DateField(auto_now_add=<span class="literal">True</span>)</span><br><span class="line">    time = models.TimeField(auto_now_add=<span class="literal">False</span>, auto_now=<span class="literal">True</span>)	<span class="comment">#获取录入时间，而且有新录入就会覆盖</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__unicode__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.host</span><br></pre></td></tr></table></figure></p>
<p><code>admin.py</code>里添加对应的值：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> lbmrs</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lbmrsAdmin</span>(admin.ModelAdmin):</span><br><span class="line">    list_display = (<span class="string">&#x27;host&#x27;</span>,<span class="string">&#x27;inbandwidth&#x27;</span>,<span class="string">&#x27;outbandwidth&#x27;</span>,<span class="string">&#x27;date&#x27;</span>,<span class="string">&#x27;time&#x27;</span>)</span><br><span class="line">admin.site.register(lbmrs,lbmrsAdmin)</span><br></pre></td></tr></table></figure></p>
<p>注意!由于我们使用了<code>TimeField</code>，所以要修改一下<code>setting.py</code>:<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">TIME_ZONE = <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line">USE_TZ = <span class="literal">False</span></span><br></pre></td></tr></table></figure></p>
<p>这样就能输入准确的时间，不然就是UTC时间。然后就是<code>python manage.py makemigrations</code>和<code>python manage.py migrate</code>，如果在<code>python manage.py migrate</code>的时候出现如下<code>MySQL Strict Mode is not set for database connection &#39;default&#39;</code>的提示，如图：<br><img data-src="/images/gateone6.png" alt="akb48"></p>
<p>这提示其实不重要，主要是说当前连接mysql的方式不严谨，如果要避免还是修改一下<code>setting.py</code>，新加一个<code>OPTIONS</code>:<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line"><span class="comment">#        &#x27;ENGINE&#x27;: &#x27;django.db.backends.sqlite3&#x27;,</span></span><br><span class="line"><span class="comment">#        &#x27;NAME&#x27;: os.path.join(BASE_DIR, &#x27;db.sqlite3&#x27;),</span></span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.mysql&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>: <span class="string">&#x27;这里是database名&#x27;</span>,  </span><br><span class="line">        <span class="string">&#x27;USER&#x27;</span>: <span class="string">&#x27;这里是用户名&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;PASSWORD&#x27;</span>: <span class="string">&#x27;这里是密码&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;HOST&#x27;</span>: <span class="string">&#x27;这里是数据库地址&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;OPTIONS&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;init_command&quot;</span>: <span class="string">&quot;SET sql_mode=&#x27;STRICT_TRANS_TABLES&#x27;&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>数据库方面完成，在后台界面里随便添加一个值，如下：<br><img data-src="/images/gateone7.png" alt="akb48"></p>
<p>然后在mysql命令行看一下效果：<br><img data-src="/images/gateone8.png" alt="akb48"></p>
<h2 id="将值录入数据库"><a href="#将值录入数据库" class="headerlink" title="将值录入数据库"></a>将值录入数据库</h2><p>由于我使用的是阿里云数据库，所以要现在阿里云数据库里对django服务器和zabbix服务器同时开放白名单。</p>
<p>使用zabbix-api获取zabbix数值的脚本以前在 <a href="https://rorschachchan.github.io/2019/01/09/%E4%BD%BF%E7%94%A8Zabbix%E7%9A%84python-api%E5%8E%BB%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%9B%91%E6%8E%A7%E5%80%BC/">https://rorschachchan.github.io/2019/01/09/%E4%BD%BF%E7%94%A8Zabbix%E7%9A%84python-api%E5%8E%BB%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%9B%91%E6%8E%A7%E5%80%BC/</a> 里面说过了，要把获取的值保存到mysql里，只需要添加下面的代码：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将值保存到mysql</span></span><br><span class="line">connection = pymysql.connect(host=<span class="string">&#x27;Mysql地址&#x27;</span>, port=<span class="number">3306</span>, user=<span class="string">&#x27;账号&#x27;</span>, passwd=<span class="string">&#x27;密码&#x27;</span>, db=<span class="string">&#x27;databases名称&#x27;</span>)</span><br><span class="line">cursor = connection.cursor()        <span class="comment"># 创建游标</span></span><br><span class="line"><span class="comment"># 执行SQL,插入多行数据并返回受影响行数</span></span><br><span class="line">sql = cursor.executemany(<span class="string">&quot;insert into accessgateway_ldmrs (host,inbandwidth,outbandwidth,time,date) values (%s,%s,%s,now(),curdate()))&quot;</span>,[(<span class="string">&quot;第一台机器&quot;</span>,firstin,firstout),(<span class="string">&quot;第二台机器&quot;</span>,secondin,secondout),(<span class="string">&quot;第三台机器&quot;</span>,thirdin,thirdout), (<span class="string">&quot;第四台机器&quot;</span>,fourthin,fourthout),(<span class="string">&quot;第五台机器&quot;</span>,fivethin,fivethout)])</span><br><span class="line">connection.commit() <span class="comment"># 提交,不然无法保存修改</span></span><br><span class="line">cursor.close()      <span class="comment"># 关闭游标</span></span><br><span class="line">connection.close()  <span class="comment"># 关闭连接</span></span><br></pre></td></tr></table></figure></p>
<p>依旧是每小时执行一次，看见mysql能成功存储到值，如图：<br><img data-src="/images/gateone9.png" alt="akb48"></p>
<h2 id="将数据库的值反馈到页面上"><a href="#将数据库的值反馈到页面上" class="headerlink" title="将数据库的值反馈到页面上"></a>将数据库的值反馈到页面上</h2><p>数据库现在已经取到了值，那么思路就很简单了：在<code>views.py</code>里设定变量，让变量可以去数据库里通过<code>objects.values</code>取到相应的值，然后再把这个变量通过<code>render</code>反应到前端页面。<code>url.py</code>很简单：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#前略</span></span><br><span class="line">path(<span class="string">r&#x27;lb_mrs_flow.html&#x27;</span>,views.lb_mrs_flow,name=<span class="string">&quot;lb_mrs_flow&quot;</span>),</span><br></pre></td></tr></table></figure></p>
<p>这次需求要取到以下几个值，分别是“此时的带宽”，“前一小时的带宽”，“昨天此时的带宽”。在数据库里我们也设定了date和time这两个列，所以通过限制条件就能获取到对应的值了！<code>views.py</code>如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="comment">#展示服务器1.1.1.1当前流量</span></span><br><span class="line"><span class="meta">@login_required	</span><span class="comment">#需要登陆才能访问</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lb_mrs_flow</span>(<span class="params">request</span>):</span><br><span class="line">    today = <span class="built_in">str</span>(datetime.date.today())	<span class="comment">#获取当前日期</span></span><br><span class="line">    yesterday = <span class="built_in">str</span>(datetime.date.today() - datetime.timedelta(days=<span class="number">1</span>))	<span class="comment">#获取昨天日期</span></span><br><span class="line">    hour = <span class="built_in">str</span>(datetime.datetime.now().hour)	<span class="comment">#获取现在小时</span></span><br><span class="line">	lasthour = <span class="built_in">str</span>((datetime.datetime.now() - datetime.timedelta(hours=<span class="number">1</span>)).hour)		<span class="comment">#获取前一小时</span></span><br><span class="line">    <span class="built_in">print</span> (today,yesterday,hour)</span><br><span class="line">    firstin = lbmrs.objects.values(<span class="string">&quot;inbandwidth&quot;</span>).<span class="built_in">filter</span>(host=<span class="string">&#x27;1.1.1.1&#x27;</span>,date=today,time__istartswith=hour))	<span class="comment">#当前值</span></span><br><span class="line">	firstin_last = lbmrs.objects.values(<span class="string">&quot;inbandwidth&quot;</span>).<span class="built_in">filter</span>(host=<span class="string">&#x27;1.1.1.1&#x27;</span>,date=today,time__istartswith=lasthour)	<span class="comment">#前一个小时值</span></span><br><span class="line">	firstin_yes = lbmrs.objects.values(<span class="string">&quot;inbandwidth&quot;</span>).<span class="built_in">filter</span>(host=<span class="string">&#x27;1.1.1.1&#x27;</span>,date=yesterday,time__istartswith=hour)	<span class="comment">#昨天的值</span></span><br><span class="line">    <span class="built_in">print</span> (firstin，firstin_last，firstin_yes)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;lb_mrs_flow.html&#x27;</span>,&#123;<span class="string">&#x27;firstin&#x27;</span>:firstin,<span class="string">&#x27;firstin_last&#x27;</span>:firstin_last,<span class="string">&#x27;firstin_yes&#x27;</span>:firstin_yes,&#125;)	<span class="comment">#传递到前端</span></span><br></pre></td></tr></table></figure></p>
<p>数据库里我们只需要<code>inbandwidth</code>这一列的值，所以这里就不用<code>get()</code>方法了，改用<code>vales()</code>方法，同时搭配<code>filter()</code>添加条件筛选。但是这样获取到的结果是一个<code>QuerySet</code>（查询集），元素为字典，如果要获得里面具体的值，那么就是<code>QuerySet[0][&#39;inbandwidth&#39;]</code>,用上面的<code>firstin</code>为例子，如果想要得到具体的值就要改成下面：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">firstin = lbmrs.objects.values(<span class="string">&quot;inbandwidth&quot;</span>).<span class="built_in">filter</span>(host=<span class="string">&#x27;172.1.1.19&#x27;</span>,date=today,time__istartswith=hour)[<span class="number">0</span>][<span class="string">&#x27;inbandwidth&#x27;</span>]</span><br></pre></td></tr></table></figure></p>
<p><code>value</code>和<code>value_list</code>都可以获取指定的字段，但是<code>value_list</code>获得是元素是元组。<code>value_list</code>和<code>value</code>返回的并不是真正的<code>列表</code>或<code>字典</code>，通俗地说，就是用的时候才真正的去数据库查，如果查询后没有使用，在数据库更新后再使用，得到的是新内容。</p>
<p>然后就是前端html文件<code>lb_mrs_flow.html</code>里写一个简单的表格，前端内容就略过不表了，直接来看结果：<br><img data-src="/images/gateone10.png" alt="akb48" title="由于数据库刚启动，还没有昨天和前一个小时的值，就随机编几个值"></p>
<p>可以看到如果<code>value()</code>方法得不到值的话，返回一个<code>&lt;QuerySet []&gt;</code>，如果是<code>get()</code>的话，返回就是一个错误，所以从友好度来说，还是<code>value()</code>更佳。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/geerniya/article/details/78549182">https://blog.csdn.net/geerniya/article/details/78549182</a><br><a href="http://yshblog.com/blog/157">http://yshblog.com/blog/157</a><br><a href="https://www.kancloud.cn/hiyang/py/348229">https://www.kancloud.cn/hiyang/py/348229</a> （跨表取字段的方法）</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Zabbix监控ActiveMQ队列数以及结合Grafana展示</title>
    <url>/2018/01/11/Zabbix%E7%9B%91%E6%8E%A7ActiveMQ%E9%98%9F%E5%88%97%E6%95%B0%E4%BB%A5%E5%8F%8A%E7%BB%93%E5%90%88Grafana%E5%B1%95%E7%A4%BA/</url>
    <content><![CDATA[<h2 id="在ZABBIX上监控MQ队列"><a href="#在ZABBIX上监控MQ队列" class="headerlink" title="在ZABBIX上监控MQ队列"></a>在ZABBIX上监控MQ队列</h2><p>众所周知，Zabbix是可以自定义监控项的，那么就代表只要能获得到的数字都可以进入Zabbix的监控范围内。作为消息队列，Activemq里的“消息堆积数”是监控的重点项目之一。</p>
<p>获取消息堆积数并不是一个很难的事儿，浏览器里登陆MQ的web网页控制台，输入账号密码之后，在Queues的网页里就能看到如下的界面：<br><img data-src="/images/mqinfo.png" alt="akb48" title="MQ的界面"></p>
<p>其中Pending Messages就是“等待消息”，Consumers是“消费者”，Enqueued是“入队”，Dequeued是“出队”。<code>入队数=出队数+等待数</code>。</p>
<p>现在我们要获取到图中的队列叫AggregateQueue里的那个23596，很简单，shell语句是：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">curl -s -u网站用户名:网站密码 <span class="attr">http</span>:<span class="comment">//网站外网IP地址:8161/admin/queues.jsp | grep -A 5 &quot;具体的队列名&lt;/a&gt;&lt;/td&gt;&quot;|awk -F &#x27;&lt;&#x27; &#x27;&#123;print $2&#125;&#x27;|sed &#x27;s/td&gt;//g&#x27;|head -2|tail -1</span></span><br></pre></td></tr></table></figure></p>
<p>这里curl有一个<code>-s</code>的参数，不然会显示curl的状态。如图：<br><img data-src="/images/curl+s.png" alt="akb48" title="curl -s的效果"></p>
<p>语句在此，写脚本就很easy了。不过我这里就直接监控具体数字了，没有写脚本，如果要写python脚本的话，我推荐各位移步：<a href="http://blog.51cto.com/sfzhang88/1316789">http://blog.51cto.com/sfzhang88/1316789</a> ，看一下这篇文章。</p>
<p>现在把这个监控项添加到具体的<code>zabbix_agentd.conf</code>里吧，具体添加过程可以参看 <a href="http://blog.51cto.com/chenx1242/1839829">http://blog.51cto.com/chenx1242/1839829</a> ，由于是curl网站，那么直接把这个监控项加到Zabbix-server里就好，然后使用<code>zabbix_get</code>检查一下。有的zabbix 3.x里没有<code>zabbix_get</code>，安装zabbix_get方法：<code>yum install zabbix-get.x86_64 </code>。</p>
<p>zabbix_get检查情况和具体的trigger情况如下：<br><img data-src="/images/getMQ.png" alt="akb48" title="zabbix_get检查情况"><br><img data-src="/images/mqtrigger.png" alt="akb48" title="zabbix_get检查情况"></p>
<h2 id="配置Zabbix结合Grafana"><a href="#配置Zabbix结合Grafana" class="headerlink" title="配置Zabbix结合Grafana"></a>配置Zabbix结合Grafana</h2><p>我使用的Grafana版本是4.3.2，下载地址：<a href="https://s3-us-west-2.amazonaws.com/grafana-releases/release/grafana-4.3.2-1.x86_64.rpm">https://s3-us-west-2.amazonaws.com/grafana-releases/release/grafana-4.3.2-1.x86_64.rpm</a> ，下载完毕之后，直接<code>yum install /路径/grafana-4.3.2-1.x86_64.rpm</code>，由于Grafana使用的是AWS的云存储，可能在墙内的下载会比较吃力，有断开的情况就多试几次。话说Grafana的升级是比较频繁的，半年不到的时间升级了三次，现在最新版本已经是4.6.2。所以说这玩意，其实选择一个稳定的就好。</p>
<p>启动grafana的方法就是：<code>systemctl start grafana-server.service</code>，配置开机自启动的方法：<code>chkconfig grafana-server on</code>。然后在浏览器里输入<code>grafana外网ip地址：3000</code>就能看到grafana的界面，默认密码：<code>admin/admin</code>，grafana默认的日志存储路径是<code>/var/log/grafana/</code>。</p>
<p>Grafana与ZABBIX联系的插件下载方式：<code>grafana-cli plugins install alexanderzobnin-zabbix-app</code>，安装之后，重启一下grafana-server，在web界面就会看到插件已经成功安装，如图：<br><img data-src="/images/grafana1.png" alt="akb48" title="grafana插件web界面"></p>
<p>其他更多的插件下载可以在grafana的官方网站查看到：<a href="https://grafana.com/plugins">https://grafana.com/plugins</a> ，用<code>grafana-cli</code>都能搞定，还是那话，墙里的同学速度要慢一点。</p>
<p>现在配置Zabbix作为Grafana的数据源，首选点击网站上面的红色漩涡标志，选择<code>zabbix</code>，点击<code>Plugin Config</code>，点击<code>Enable</code>，启动Zabbix插件。如图：<br><img data-src="/images/grafana2.png" alt="akb48" title="启动Zabbix插件"></p>
<p>再次点击红色漩涡，这次选择<code>Data Sources</code>，点击<code>Add data source</code>，如果插件启动成功，那么在Type里是可以选择<code>zabbix</code>的，然后就是填各种东西，如图：<br><img data-src="/images/grafana3.png" alt="akb48" title="添加数据源"></p>
<p>这里有一些要额外说明：<br>1）url这个是zabbix的API地址<code>http://ip/zabbix/api_jsonrpc.php</code>，这个可以在zabbix服务端上可查找<code>find / -name api_*.php</code>；<br>2）username和passwd是zabbix WEB界面的登录用户名和密码，有读的权限即可；<br>3）alerting选择启动，<code>min severity</code>选择high；</p>
<p>然后点击<code>save &amp; test</code>，如果都正确的话，就会出现success，如图：<br><img data-src="/images/grafana4.png" alt="akb48" title="保存zabbix资料"></p>
<h2 id="在Grafana展示趋势图"><a href="#在Grafana展示趋势图" class="headerlink" title="在Grafana展示趋势图"></a>在Grafana展示趋势图</h2><p>点击左上方红色漩涡，<code>Dashboards</code>的地方点击<code>+new</code>，然后在小齿轮的地方选择<code>Templating</code>,如图：<br><img data-src="/images/grafana5.png" alt="akb48" title="趋势图"></p>
<p>在Templating里要建立4个模板，其中group的添加方法如下，如果Query正确的话，在点击<code>Include All option</code>的时候，就会有“组”显示出，而且和zabbix里完全一致：<br><img data-src="/images/grafana6.png" alt="akb48" title="添加模板"></p>
<p>group添加完了，还有host、application、iteams，添加的大同小异，需要注意的是Query的不同：<br>host的Query：<code>$group.*</code><br>application的Query: <code>$group.$host.*</code><br>iterm的Query:<code> $group.$host.$application.*</code></p>
<p>以上四个template都搞定之后，应该是这个样子：<br><img data-src="/images/grafana7.png" alt="akb48" title="搞定templage"></p>
<p>模板搞定了，下面就是图形展示，选择对应的hosts、application和items就自动有图像生成了！<br><img data-src="/images/grafana8.png" alt="akb48" title="大功告成！"></p>
<p>最后说一下页面自动刷新，点击右上角“Last 6 hours”, 在弹出的下拉框中，选择<code>Time range</code>下的<code>Refreshing every</code>选项，点击下拉框按钮，默认应该有“off”和“1m”两个选项。点击“1m” 然后<code>Apply</code>设置，即为每一分钟刷新一次数据的意思。设置成功后，在原来<code>Last 6 hours</code>的后面会出现<code>Refresh every 1m</code>的橙色文字！</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《实践MQ的小demo》<a href="http://www.jianshu.com/p/3a39c8dd4f29">http://www.jianshu.com/p/3a39c8dd4f29</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
        <tag>grafana</tag>
      </tags>
  </entry>
  <entry>
    <title>Zabbix添加多个微信告警渠道</title>
    <url>/2019/11/27/Zabbix%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AA%E5%BE%AE%E4%BF%A1%E5%91%8A%E8%AD%A6%E6%B8%A0%E9%81%93/</url>
    <content><![CDATA[<p>我们的zabbix监控项好几千个，这些告警都是使用同一个微信公众号的应用去报警，这样很多告警刷来刷去，就会把一些重要告警淹没。于是我们一方面做了更加详细的告警分级，而且也增加多个微信应用。让每个应用更加有针对性的告警，就不再大杂烩了，避免重要报警遗漏。</p>
<p>本文目的就是创建一个新的微信应用，专门用来告警这个Templates下的情况：<br><img data-src="/images/proxy33.png" alt="akb48"></p>
<p>首先，先去微信企业号里创建一个新的应用，如图：<br><img data-src="/images/proxy32.png" alt="akb48"></p>
<p>然后将原来<code>zabbix-server</code>上的<code>wechat.py</code>复制一份，比如叫<code>proxysql-wechat.py</code>，修改对应的<code>corpsecret</code>和<code>agentid</code>，改成新应用的。这个脚本可以去看<a href="https://rorschachchan.github.io/2018/01/10/Zabbix3-0%E6%90%AD%E9%85%8D%E5%BE%AE%E4%BF%A1%E4%BC%81%E4%B8%9A%E5%8F%B7%E6%8A%A5%E8%AD%A6/">https://rorschachchan.github.io/2018/01/10/Zabbix3-0%E6%90%AD%E9%85%8D%E5%BE%AE%E4%BF%A1%E4%BC%81%E4%B8%9A%E5%8F%B7%E6%8A%A5%E8%AD%A6/</a> 。</p>
<p>下面就来到zabbix server的Web端，首先<code>Administrain---Media Types</code>，增加一个新的告警媒介<code>Proxysql-wechat</code>，使用的脚本就是刚刚复制出来的<code>proxysql-wechat.py</code>：<br><img data-src="/images/proxy34.png" alt="akb48"></p>
<p>然后再去<code>Users</code>里创建一个新的用户，因为原来的<code>Administrator</code>已经有了微信告警，所以要创建一个新的用户来专门接收<code>proxysql-wechat.py</code>的告警：<br><img data-src="/images/proxy35.png" alt="akb48"></p>
<p>把它的<code>media</code>改成<code>Proxysql-wechat</code>：<br><img data-src="/images/proxy36.png" alt="akb48"></p>
<p>下一步很容易遗忘，就是在<code>Permissions</code>里给这个用户对应的Templates下所涉及用户组的全部权限，当然，如果你胆子大（比如我），可以给这个用户Super权限：<br><img data-src="/images/proxy37.png" alt="akb48"></p>
<p>告警人和告警路径已经搞定，下面就是要配置“什么样的告警才可以触发此微信应用，同时其他应用不要重复发信”。</p>
<p>来到<code>Configuration---Actions</code>，新创建一个triggers的action：<br><img data-src="/images/proxy38.png" alt="akb48"></p>
<p>这里声明此action只会关注templates为”proxysql单独监控”的triggers情况。</p>
<p>在<code>Operation details</code>别忘了配置各个环节的<code>Send to Users</code>和<code>Send only to</code>：<br><img data-src="/images/proxy39.png" alt="akb48"></p>
<p>保存之后，我们还要把原有的微信应用告警更改一下，如果不该的话，”proxysql单独监控”这个Templates触发了告警，两个微信应用都会告警，于是就把老的action改成如下：<br><img data-src="/images/proxy40.png" alt="akb48"></p>
<p>此时触发一下”proxysql单独监控”这个Templates涉及的告警项，就会看到只发送了<code>proxysql-wechat</code>，而老的wechat媒介没有被触发。<br><img data-src="/images/proxy41.png" alt="akb48"></p>
<p>微信也能正常收到信息：<br><img data-src="/images/proxy42.png" alt="akb48"></p>
<p>总结一下：如果希望新增加一个报警途径，那么就新在后台创建脚本，然后在前台创建媒介，创建连接此媒介的用户，最后在告警action上配置正确的规则就OK了！</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>Zabbix配置discovery主动发现ActiveMQ队列</title>
    <url>/2019/12/19/Zabbix%E9%85%8D%E7%BD%AEdiscovery%E4%B8%BB%E5%8A%A8%E5%8F%91%E7%8E%B0ActiveMQ%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>快到年关了，领导大手一挥，要把线上环境切换新的VPC。既然要切VPC，就要与原有的VPC决裂，也要重新搭一套zabbix了，搭建activemq监控项就难免要监控各种队列，但是每个activemq里面的队列名又不同，一个一个特殊配置太头疼，于是就尝试使用<code>主动发现</code>来做，系统自己匹配队列。</p>
<h2 id="后端脚本"><a href="#后端脚本" class="headerlink" title="后端脚本"></a>后端脚本</h2><p>首先要先准备一个<code>discover_mq.py</code>，如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python </span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># 用来获取当前mq的队列名</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  <span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">  <span class="keyword">import</span> simplejson <span class="keyword">as</span> json</span><br><span class="line"><span class="keyword">import</span> commands</span><br><span class="line"></span><br><span class="line">(status, output) = commands.getstatusoutput(<span class="string">&quot;&quot;&quot;curl -s -u &#x27;mq前端页面账号:mq前端页面密码&#x27; http://127.0.0.1:8161/admin/queues.jsp|grep &#x27;&lt;/a&gt;&lt;/td&gt;&#x27;|awk -F&#x27;&lt;&#x27; &#x27;&#123;print $1&#125;&#x27;&quot;&quot;&quot;</span>)</span><br><span class="line">outputs = output.split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> one <span class="keyword">in</span>  outputs:</span><br><span class="line">	result.append(&#123;<span class="string">&#x27;&#123;#RESULT&#125;&#x27;</span>: one&#125;)</span><br><span class="line"><span class="built_in">print</span>(json.dumps(&#123;<span class="string">&#x27;data&#x27;</span>:result&#125;,sort_keys=<span class="literal">True</span>,indent=<span class="number">4</span>))</span><br></pre></td></tr></table></figure></p>
<p>这个脚本执行就可以获取当前所有的队列名，如图：<br><img data-src="/images/zabbix7.png" alt="akb48"></p>
<p>然后再准备一个<code>monitor_mq.sh</code>，如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"><span class="comment"># 获取每一个队列的入队、出队和积压量</span></span><br><span class="line">username=mq前端页面账号</span><br><span class="line">password=mq前端页面密码</span><br><span class="line">myip=$<span class="number">1</span></span><br><span class="line">queuename=$<span class="number">2</span></span><br><span class="line">mytype=$<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> $&#123;mytype&#125; <span class="keyword">in</span></span><br><span class="line">	Pending)</span><br><span class="line">	curl -s -u <span class="string">&quot;$username:$password&quot;</span>  <span class="string">&quot;http://$&#123;myip&#125;:8161/admin/queues.jsp&quot;</span>|grep <span class="string">&quot;^$&#123;queuename&#125;&lt;/a&gt;&lt;/td&gt;&quot;</span> -A <span class="number">5</span>|sed -n <span class="string">&#x27;2p&#x27;</span>|egrep -o <span class="string">&#x27;[0-9]+&#x27;</span></span><br><span class="line">	;;</span><br><span class="line">	Enqueued)</span><br><span class="line">	curl -s -u <span class="string">&quot;$username:$password&quot;</span>  <span class="string">&quot;http://$&#123;myip&#125;:8161/admin/queues.jsp&quot;</span>|grep <span class="string">&quot;^$&#123;queuename&#125;&lt;/a&gt;&lt;/td&gt;&quot;</span> -A <span class="number">5</span>|sed -n <span class="string">&#x27;4p&#x27;</span>|egrep -o <span class="string">&#x27;[0-9]+&#x27;</span></span><br><span class="line">	;;</span><br><span class="line">	Dequeued)</span><br><span class="line">	curl -s -u <span class="string">&quot;$username:$password&quot;</span>  <span class="string">&quot;http://$&#123;myip&#125;:8161/admin/queues.jsp&quot;</span>|grep <span class="string">&quot;^$&#123;queuename&#125;&lt;/a&gt;&lt;/td&gt;&quot;</span> -A <span class="number">5</span>|sed -n <span class="string">&#x27;5p&#x27;</span>|egrep -o <span class="string">&#x27;[0-9]+&#x27;</span></span><br><span class="line">	;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></p>
<p>然后就是准备zabbix的自定义监控项：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">UserParameter=activemq.discover, python /mnt/discover_mq.py		<span class="comment">#我放到/mnt目录下了</span></span><br><span class="line">UserParameter=activemq.check[*],sh /mnt/monitor_mq.sh $<span class="number">1</span> $<span class="number">2</span> $<span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>重启<code>zabbix-agent</code>，此时别忘了在<code>/etc/sudoers</code>添加上<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">zabbix  ALL=(root) NOPASSWD: /usr/<span class="built_in">bin</span>/python</span><br><span class="line">Defaults:zabbix   !requiretty</span><br></pre></td></tr></table></figure></p>
<h2 id="前端配置"><a href="#前端配置" class="headerlink" title="前端配置"></a>前端配置</h2><p>来到zabbix-server前端页面，先在对应的templates添加Discovery，如图：<br><img data-src="/images/zabbix8.png" alt="akb48"></p>
<p>点击<code>Create discovery rule</code>，创建一个规则：<br><img data-src="/images/zabbix9.png" alt="akb48"></p>
<p>然后创建3个<code>item prototypes</code>，每一个对应入队、出队、积压量，如图：<br><img data-src="/images/zabbix10.png" alt="akb48"></p>
<p>还可以针对积压量做一个<code>Trigger prototypes</code>的告警。</p>
<p>保存之后，整个主动发现就配置到整个Templates，我们可以抽查一个机器，看一下是否自动匹配到所有的队列：<br><img data-src="/images/zabbix11.png" alt="akb48"></p>
<p>大功告成，收工回家！</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>监控技术</tag>
        <tag>Zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper的选举原理</title>
    <url>/2018/03/05/Zookeeper%E7%9A%84%E9%80%89%E4%B8%BE%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Zookeeper</code>是一款比较常见的式应用程序协调服务软件，如果配置了多台<code>zookeeper</code>自然要选择一个头头，这个头头就是<code>leader</code>，很明显不能所有的<code>zookeeper</code>都是<code>leader</code>，那样就失控了；也不能所有的<code>zookeeper</code>都是<code>follower</code>，那就群龙无首无法协调。</p>
<p>插播一句，这种<code>一老大N跟班</code>的模式是过去分布式软件里很常见的工作模式，而最近比较火热的区块链不同，它是一种<code>去中心化</code>的工作模式，大家人人都当节点，然后放在一起整合，有点原始社会的意思。所以说，算法有时候来自于人类学，也会在一定程度反过来上影响人类。</p>
<p>选举<code>leader</code>的方式是一种叫<code>FastLeaderELection</code>的算法，以<code>3.4.6</code>版本为例，它被保存在<code>/usr/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/</code>这个文件夹下。</p>
<h2 id="选举的中心思想"><a href="#选举的中心思想" class="headerlink" title="选举的中心思想"></a>选举的中心思想</h2><p>实际上<code>FastLeaderELection</code>说的中心思想无外乎以下几个关键点：</p>
<ol>
<li><p>全天下我最牛！在我没有发现比我牛的推荐人的情况下，我就一直推举我当<code>leader</code>，第一次投票那必须推举我自己当<code>leader</code>。</p>
</li>
<li><p>每当我接收到其它的被推举者，我都要回馈一个信息，表明我还是不是推举我自己。如果被推举者没我大，我就一直推举我当<code>leader</code>，是我是我还是我！</p>
</li>
<li><p>我有一个票箱， 和我属于同一轮的投票情况都在这个票箱里面。一人一票重复的或者过期的票，我都不接受。</p>
</li>
<li><p>一旦我不再推举我自己了（这时我发现别人推举的人比我推荐的更牛），我就把我的票箱清空，重新发起一轮投票（这时我的票箱一定有两票了，都是选的我认为最牛的人）。</p>
</li>
<li><p>一旦我发现收到的推举信息中投票轮要高于我的投票轮，我也要清空我的票箱。并且还是投当初我觉得最牛的那个人（除非当前的人比我最初的推荐牛，我就顺带更新我的推荐）。</p>
</li>
<li><p>不断的重复上面的过程，不断的告诉别人“我的投票是第几轮”、“我推举的人是谁”。直到我的票箱中“我推举的最牛的人”收到了不少于<code>N/2 + 1</code>的推举投票。这也回答了为什么<code>zookeeper</code>在少于<code>N/2 + 1</code>的节点处于工作状态的情况下会崩溃了。因为，无论怎么选也没有任何节点能够获得<code>N/2 + 1</code>的票数。</p>
</li>
<li><p>这时我就可以决定我是<code>flower</code>还是<code>leader</code>了（如果至始至终都是我最牛，那我就是<code>leader</code>咯，其它情况就是<code>follower</code>咯）。并且不论随后收到谁的投票，都向它直接反馈“我的结果”。</p>
</li>
</ol>
<h2 id="判断依据"><a href="#判断依据" class="headerlink" title="判断依据"></a>判断依据</h2><p>上面第二步里说了，如果接收到其他被推举者的消息，而且判断出这个被推举者比我牛，我就要推举他，那么判断依据是啥呢？答案是依次比较<code>epoch</code>、<code>zxid</code>、<code>serverid</code>。</p>
<p>先说说啥是<code>epoch</code>、<code>zxid</code>、<code>serverid</code>：</p>
<ul>
<li><code>epoch</code>: 表示选举轮数。</li>
<li><code>zxid</code>: 事务zxid包含了本地数据的最后更新时间相关的信息。</li>
<li><code>serverid</code>: 当前<code>server</code>的 ID, 通过配置文件指定(<code>echo &#39;1&#39; &gt; myid</code>)。</li>
</ul>
<p>具体的判断过程是：接收到的消息中，有<code>epoch</code>比我大的，则选<code>epoch</code>大的消息中确定的<code>server</code>；如果<code>epoch</code>相等，则选<code>zxid</code>最大的<code>server</code>；如果<code>zxid</code>也相等，则选<code>serverid</code>最大的<code>server</code>(有的节点生来就是当<code>leader</code>的）。</p>
<p>为什么要有<code>epoch</code>呢？这样是为了防止中途有选举者掉线，他们错过了选举，再次连上来的时候，他们发现自己的投票轮已经小于现有的投票轮了，那么他们比如要清空自己的投票箱然后无条件的改为推荐接收到的最新选举中大家推荐的最牛的那个人（如果没有人比我牛，那还是推荐我自己）。由于有最后一条<code>serverid</code>大的最后压阵，而且<code>serverid</code>又不能重复，所以基本上都能最后选出一台作为<code>leader</code>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.csdn.net/yinwenjie/article/details/47613309">http://blog.csdn.net/yinwenjie/article/details/47613309</a><br><a href="https://mozillazg.com/2017/03/zookeeper-fastleader-elect-leader.html">https://mozillazg.com/2017/03/zookeeper-fastleader-elect-leader.html</a></p>
<p><img data-src="/images/messifreekick.gif" alt="paradin" title="八倍镜狙击模式开启"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>运维技术</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper集群的搭建与配置</title>
    <url>/2018/02/05/Zookeeper%E9%9B%86%E7%BE%A4%E7%9A%84%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>Zookeeper的下载地址：<code>https://github.com/apache/zookeeper/archive/master.zip</code><br>zkclient的下载地址：<code>https://github.com/sgroschupf/zkclient</code></p>
<p>至于zookeeper的作用和原理我这里就不多赘述了，大家有兴趣可以去查查，这里主要就是动手操作。</p>
<h2 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h2><p>首先先看一下本次zk实验服务器的名称和IP情况，这里我们选择了三台服务器作zkserver，因为三台是标配，一台的话就只有leader没有follower，不是很稳定的结构，当然啦如果你的公司土豪的话是可以玩三十台：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dvl-mrszk-<span class="number">001</span>	<span class="number">10.117</span><span class="number">.0</span><span class="number">.125</span></span><br><span class="line">dvl-mrszk-<span class="number">002</span>	<span class="number">10.117</span><span class="number">.1</span><span class="number">.158</span></span><br><span class="line">dvl-mrszk-<span class="number">003</span>	<span class="number">10.168</span><span class="number">.152</span><span class="number">.227</span></span><br></pre></td></tr></table></figure></p>
<p>对这三台服务器都要进行如下的步骤:</p>
<p>1)先把zookeeper.zip传到linux里，然后解压到<code>/usr</code>文件夹下；</p>
<p>2)进入<code>/usr/zookeeper/conf</code>文件夹，<code>vim zoo.cfg</code>，在最下面补充上面的三个zkserver，见图：<br><img data-src="/images/zook1.png" alt="paradin"></p>
<p>3)再来到<code>/usr/zookeeper/data</code>文件夹，如果里面有文件就清空所有文件，如果是1号zkserver就<code>echo 1 &gt; myid</code>，如果当前机器是2号zkserver就<code>echo 2 &gt; myid</code>，依次类推，这里一定要注意，不可以都写一样。</p>
<p>4)<code>vim /etc/hosts</code>，还要把这三台机器的ip地址和名字都写进去，如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> localhost</span><br><span class="line">::<span class="number">1</span>         localhost localhost.<span class="property">localdomain</span> localhost6 localhost6.<span class="property">localdomain6</span></span><br><span class="line"><span class="number">10.117</span><span class="number">.0</span><span class="number">.125</span> dvl-mrszk-<span class="number">001</span></span><br><span class="line"><span class="number">10.117</span><span class="number">.1</span><span class="number">.158</span> dvl-mrszk-<span class="number">002</span></span><br><span class="line"><span class="number">10.168</span><span class="number">.152</span><span class="number">.227</span> dvl-mrszk-<span class="number">003</span></span><br></pre></td></tr></table></figure></p>
<p>5)再来<code>/usr/zookeeper/bin</code>文件夹，<code>./zkServer.sh start</code>启动zk，然后再<code>./zkServer.sh status</code>查看进程情况，如图看见第一台和第三台zkserver的身份是<code>follower</code>，第二台是<code>leader</code>：<br><img data-src="/images/zook2.png" alt="paradin"></p>
<p><img data-src="/images/zook3.png" alt="paradin"></p>
<p><img data-src="/images/zook4.png" alt="paradin"></p>
<p>至此整个zk集群就搭建并且启动完成了。<font color=red>注意：zookeeper集群时，zookeeper要求半数以上的机器可用，zookeeper才能提供服务。</font></p>
<h2 id="故障排除"><a href="#故障排除" class="headerlink" title="故障排除"></a>故障排除</h2><p>如果这里有启动失败的情况，比如<code>Error contacting service. It is probably not running.</code>这样的字样，那么有这么几种可能：<br>1）data文件夹下的<code>myid</code>有数字重复或者是数字漏写的情况；<br>2）<code>zoo.cfg</code>里的指定日志文件夹没有手动创建；<br>3）<code>/etc/hosts</code>下的名字与zoo.cfg里的server字段不相符，注意一下，&#x2F;etc&#x2F;hosts里的127.0.0.1的名字不要与本ip后面的名字一模一样，不然zk也无法识别！<br>4）<code>/etc/hosts</code>名字使用了中文，java系对中文是很不友好的。</p>
<p>如果出现的<code>Cannot open channel to X at election address /A.B.C.D:3888</code>的日志报错，检查一下<code>zoo.cfg</code>里的123与<code>myid</code>的123是否一致。</p>
<h2 id="配置文件详解"><a href="#配置文件详解" class="headerlink" title="配置文件详解"></a>配置文件详解</h2><p>1.<code>tickTime</code>：这个时间是作为 Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。<br>2.<code>dataDir</code>：顾名思义就是 Zookeeper 保存数据的目录，默认情况下，Zookeeper 将写数据的日志文件也保存在这个目录里。<br>3.<code>clientPort</code>：这个端口就是客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。<br>4.<code>initLimit</code>：这个配置项是用来配置 Zookeeper 接受 客户端（这里所说的客户端不是用户连接 Zookeeper 服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过 5个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 5<em>2000&#x3D;10秒。<br>5.<code>syncLimit</code>：这个配置项标识 Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是2</em>2000&#x3D;4秒。<br>6.<code>server.A=B：C：D</code>：其中 A 是一个数字，表示这个是第几号服务器；B 是这个服务器的 ip 地址；C 表示的是这个服务器与集群中的 Leader 服务器交换信息的端口；D 表示的是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。如果是伪集群的配置方式，由于 B 都是一样，所以不同的 Zookeeper 实例通信端口号不能一样，所以要给它们分配不同的端口号。</p>
<h2 id="验证成果"><a href="#验证成果" class="headerlink" title="验证成果"></a>验证成果</h2><p>Zookeeper的配置工具叫<code>Zooinspector</code>，下载地址是：<code>https://issues.apache.org/jira/secure/attachment/12436620/ZooInspector.zip</code>，下载完直接解压缩就可以在windows里使用。</p>
<p>我们实验的这三台服务器只有内网，但是如果要连接zooinspector，还是需要通过外网权限连接的，这里可以配一个iptables转发规则，配iptables的步骤在这里：<a href="http://chenx1242.blog.51cto.com/10430133/1875950">http://chenx1242.blog.51cto.com/10430133/1875950</a> ，照葫芦画瓢即可，但是要注意，zk的端口是<code>2181</code>。</p>
<p>当然，如果不想费事的话，就直接给zkserver配一个外网IP，直接连接。</p>
<p>成功连接到<code>zooinspector</code>，就会看到这样的内容，这里的lcconfig是手动添加的，右击鼠标，选择<code>add node</code>，然后直接写上<code>lcconfig</code>就行，这个名字是根据实际需要填写的：</p>
<p><img data-src="/images/zook5.png" alt="paradin"></p>
<p>上面我们已经配置了zkserver集群而且还启动zkserver进程，现在还需要zkclient，zkclient就是请求发起的一方，然后我们可以在各个的模块服务器上部署zkclient服务，通过启动zkclient服务，来让这些模块统一从zooinspector里取值，这样就达到了批量配置，同时保证一致性的效果。</p>
<p>zk的模板文件是<code>_tpl.properties</code>为结尾的文件，我这里模块的名字叫mrs，那么在实验里这个模板文件就是<code>mrs_tpl.properties</code>，这个<code>mrs_tpl.properties</code>里有这样的一个字段，如图：</p>
<p><img data-src="/images/zook6.png" alt="paradin"></p>
<p>而我们在zooinspector里对应就这么填写：</p>
<p><img data-src="/images/zook7.png" alt="paradin"></p>
<p>保存zooinspector，然后从windows返回到linux，启动zkclient服务和对应的模块进程，如果配置都正常的话，那么程序就会正常启动，<code>ps -ef|grep java</code>就会看到一个叫<code>lczk.AppServerDaemon</code>的进程。这个时候在去看一下mrs的配置文件：</p>
<p><img data-src="/images/zook8.png" alt="paradin"></p>
<p>可以看到areaAk取得值就是zk里面<code>data_center</code>里面<code>access_key</code>里面的ak的值，其他的几个值也是同理。可见整个zk已经配置成功，模块都进行了统一配置，而且这些配置既然能被一个接受，同时也会被其他相同的模块服务器所接受。这样就达到了批量配置的效果。</p>
<h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><p><a href="http://ibruce.info/2014/10/23/zookeeper/">http://ibruce.info/2014/10/23/zookeeper/</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>运维技术</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Zabbix里item取值超时怎么办？</title>
    <url>/2018/02/08/Zabbix%E9%87%8Citem%E5%8F%96%E5%80%BC%E8%B6%85%E6%97%B6%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>开发同学新开发了一个模块，需要运维监控一下<code>8683\8682\9002</code>这三个端口，于是我就在zabbix里把这三个端口进行了监控，但是却无法返回值，如图：<br><img data-src="/images/item1.png" alt="paradin"></p>
<p>可见其他的自定义监控项是好使的，偏偏三个监控端口的项都是<code>not-supported</code>。我就进去到item里看看，<code>type of information</code>和<code>data type</code>都是正常的，而且每三十秒一次更新，应该是没有什么问题的。<br><img data-src="/images/item2.png" alt="paradin"></p>
<p>于是我就去zabbix的server使用<code>zabbix-get</code>去试试，到底是怎么回事儿，使用结果如图：<br><img data-src="/images/item3.png" alt="paradin"></p>
<p>可见使用<code>zabbix_get</code>是可以取到值的，而且取值都正确，三个正常的端口反馈都是1，而不存在的端口（9002）的反馈是0。可是,我发现使用<code>zabbix_ge</code>t取值pid是结果秒出，而取值<code>net.tcp.listen</code>则是等了几乎5秒钟才获得结果。那么问题就出在这里了。</p>
<p>调整<code>zabbix_agentd.conf</code>里的<code>Timeout</code>值，把其设定为10，然后重启zabbix进程就OK了。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>1）<a href="https://www.xiaomastack.com/2015/07/03/zabbix_net-tcp-listen/comment-page-1/#comment-319%EF%BC%8C%E5%BE%88%E5%A4%9A%E6%97%B6%E5%80%99%E7%AB%AF%E5%8F%A3%E7%9B%91%E5%90%AC%E4%BC%9A%E5%87%BA%E9%94%99%EF%BC%8C%E4%BA%8E%E6%98%AF%E5%B0%B1%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%AE%E5%80%BC%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E4%BD%86%E6%98%AF%E5%B0%8F%E9%A9%AC%E5%93%A5%E5%8D%9A%E5%AE%A2%E9%87%8C%E7%9A%84%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%E5%9C%A8centos%E9%87%8C%E6%98%AF%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%EF%BC%8Czabbix%E4%BC%9A%E6%8A%A5%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF%E3%80%82%E7%94%B1%E4%BA%8E%E5%85%AC%E5%8F%B8%E7%9A%84zabbix%E6%98%AF2.2%E7%89%88%E6%9C%AC%EF%BC%8C%E7%AD%89%E6%88%91%E6%9C%89%E6%97%B6%E9%97%B4%E9%9C%80%E8%A6%81%E7%BB%86%E5%8C%96%E4%B8%80%E4%B8%8B%E8%BF%99%E4%B8%AA%E8%AF%AD%E6%B3%95%E3%80%82">https://www.xiaomastack.com/2015/07/03/zabbix_net-tcp-listen/comment-page-1/#comment-319，很多时候端口监听会出错，于是就用自定义键值的方法，但是小马哥博客里的这个方法在centos里是无法启动，zabbix会报语法错误。由于公司的zabbix是2.2版本，等我有时间需要细化一下这个语法。</a></p>
<p>2）调整<code>unsupport items</code>检查时间的方法是：在<code>Adiministration</code>里选择<code>General</code>然后在右侧下拉菜单里选择<code>Other</code>，然后修改<code>Refresh unsupported items (in sec)</code>的值，这个值得意思是“每多少秒去重新检查一下那些<code>not_supported</code>的值”。<br><img data-src="/images/item4.png" alt="paradin"></p>
<p>3)这种长时间获取key的行为，很容易导致<code>zabbix unreachable poller processes more than 75 busy</code>这个错误，所以尽可能的不要添加这样的监控，而换用其它的方式。导致<code>zabbix unreachable poller processes more than 75 busy</code>这个错误的另一个原因就是可能有某台<code>zabbix-agent</code>死机了。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
        <tag>运维监控</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos6.5升级最新内核4.18的坑</title>
    <url>/2018/08/25/centos6-5%E5%8D%87%E7%BA%A7%E6%9C%80%E6%96%B0%E5%86%85%E6%A0%B84-18%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<h2 id="升级流程"><a href="#升级流程" class="headerlink" title="升级流程"></a>升级流程</h2><p>开发童鞋要搞BBR，然后让我在他的阿里云服务器上升级一下内核。我登进去一看，centos 6.5，内核还是2.6的。</p>
<p>之前我曾经搞过centos 7升级内核到最新版，文章在此：<a href="https://rorschachchan.github.io/2018/06/11/%E9%98%BF%E9%87%8C%E4%BA%91centos7%E5%8D%87%E7%BA%A7%E5%86%85%E6%A0%B8%E8%BF%87%E7%A8%8B/">https://rorschachchan.github.io/2018/06/11/阿里云centos7升级内核过程/</a> 。centos6升级内核有几个地方不太一样，但是过程差不多。整个升级内核步骤如下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先备份镜像，很重要！！！  而且备份镜像成功之前，云服务器不可以重启。</span><br><span class="line">yum update -y</span><br><span class="line">rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org 	#导入ELRepo GPG key</span><br><span class="line">rpm -Uvh https://www.elrepo.org/elrepo-release-6-8.el6.elrepo.noarch.rpm 	#安装 6版本的ELRepo</span><br><span class="line">yum --enablerepo=elrepo-kernel install kernel-ml	 -y	#截至本文，最新的是4.18，lt版本是4.4</span><br></pre></td></tr></table></figure></p>
<p>如果yum的时候有提示<code>Warning: RPMDB altered outside of yum</code>，只需要删除一下yum的历史记录即可：<code>rm -rf /var/lib/yum/history/*.sqlite</code> 。 </p>
<p>安装完毕之后，<code>vim /etc/grub.conf</code>，把default改成0，即指定使用第一个内核启动，如图：<br><img data-src="/images/centos6updatecore1.png" alt="akb48"></p>
<p>然后在阿里云控制台重启一下这个服务器即可。</p>
<h2 id="无法启动？"><a href="#无法启动？" class="headerlink" title="无法启动？"></a>无法启动？</h2><p>可能有的人直接就启动成功了，因为网络上很多文章到此就结束了。但是我这台服务器，很不幸，出现了问题。在控制台上看服务器是“运行中”，但是无法ssh连接，而且ping也是失败。不一会，控制台的服务器就显示“已停止”，可见是内核出了问题。</p>
<p>联系了阿里的后台，他们反馈这个机器现在的状态是<code>Module scsi_wait_scan not found</code>，那知道了原因就对症下药吧，这个问题解决方法不止一个，我亲测以下的方法好使。</p>
<p>首先先用刚刚做的那个磁盘快照回滚到之前正常的状态，重新执行上面整个安装4.18的内核的所有操作，然后还要补充如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">echo <span class="string">&#x27;add_drivers+=&quot;virtio_blk&quot;&#x27;</span> &gt;<span class="regexp">/etc/</span>dracut.<span class="property">conf</span>.<span class="property">d</span>/force-vitio_blk-to-ensure-boot.<span class="property">conf</span></span><br><span class="line">cp /boot/initramfs-<span class="number">4.18</span><span class="number">.5</span>-<span class="number">1.</span>el6.<span class="property">elrepo</span>.<span class="property">x86_64</span>.<span class="property">img</span> /boot/initramfs-<span class="number">4.18</span><span class="number">.5</span>-<span class="number">1.</span>el6.<span class="property">elrepo</span>.<span class="property">x86_64</span>.<span class="property">img</span>-bak		#把新下载的<span class="number">4.18</span>的img文件备份</span><br><span class="line">dracut -f initramfs-<span class="number">4.18</span><span class="number">.5</span>-<span class="number">1.</span>el6.<span class="property">elrepo</span>.<span class="property">x86_64</span>.<span class="property">img</span> <span class="number">4.18</span><span class="number">.5</span>-<span class="number">1.</span>el6.<span class="property">elrepo</span>.<span class="property">x86_64</span>	#编译生成新的img，<span class="number">4.18</span><span class="number">.5</span>-<span class="number">1.</span>el6.<span class="property">elrepo</span>.<span class="property">x86_64</span>这个文件在/lib/modules/下</span><br></pre></td></tr></table></figure></p>
<p>重新在阿里云控制台重启一下这个服务器，这一次就OK了。<br><img data-src="/images/centos6updatecore2.png" alt="akb48"></p>
<p>发生异常的原因是：更新内核后,在写dracut程序时无法检测<code>KVM&#39;s virtual disk driver &quot;virtio_blk&quot;</code>，此驱动被用于访问KVM虚拟磁盘,dracut没有正常添加新的<code>initramfs module</code>,导致系统没有磁盘访问驱动无法正常启动。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://bugzilla.kernel.org/show_bug.cgi?id=60758">https://bugzilla.kernel.org/show_bug.cgi?id=60758</a><br><a href="https://opengers.github.io/linux/linux-source-code-compile-kernel-rpm/">https://opengers.github.io/linux/linux-source-code-compile-kernel-rpm/</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>内核</tag>
        <tag>BBR</tag>
      </tags>
  </entry>
  <entry>
    <title>Zabbix出现数据库IIllegal mix of collations的报错</title>
    <url>/2019/03/05/Zabbix%E5%87%BA%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93IIllegal-mix-of-collations%E7%9A%84%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>接到新的私有云工作，登录到甲方爸爸的服务器一看是centos6.1，上面安装了zabbix-server但是仅仅做了<code>auto-discovery</code>，于是我就做<code>templates</code>，可见名称是中文的。但是发现在保存的时候，出现了这样的错误：<br><img data-src="/images/zabbix4.png" alt="akb48"></p>
<p>定眼一看，这是数据库的编码问题，整个database都是拉丁编码而不是utf8编码，所以无法输入中文。</p>
<p>要解决这个问题比较简单，毕竟zabbix刚启动而已，数据库里还没有数据。于是我就干脆把整个zabbix的database干掉，重建一个新的：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mysql -hlocalhost -uzabbix -p	<span class="comment">#登录数据库</span></span><br><span class="line">drop databases zabbix;	<span class="comment">#暴力全部删光</span></span><br></pre></td></tr></table></figure></p>
<p>此时的zabbix-server的web界面是如下的：<br><img data-src="/images/zabbix5.png" alt="akb48"></p>
<p>然后返回到mysql里：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">create database zabbix character <span class="built_in">set</span> utf8;	</span><br><span class="line"><span class="comment"># ctrl+c 退出数据库</span></span><br><span class="line">zcat /usr/share/doc/zabbix-server-mysql-<span class="number">3.4</span><span class="number">.15</span>/create.sql.gz  |mysql -uzabbix -p26e9p69r zabbix		<span class="comment">#重新导入初始化表</span></span><br></pre></td></tr></table></figure></p>
<p>然后在web界面点击<code>retry</code>，然后重新登陆一下zabbix-server。再次尝试编辑带有中文的监控项，就能顺利保存了！</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7编码安装php7.2和node.js8.11</title>
    <url>/2018/07/17/centos7%E7%BC%96%E7%A0%81%E5%AE%89%E8%A3%85php7-2-7/</url>
    <content><![CDATA[<h2 id="安装php7-2"><a href="#安装php7-2" class="headerlink" title="安装php7.2"></a>安装php7.2</h2><p>首先先做准备工作：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yum install -y libpng libpng-devel</span><br><span class="line">yum install -y bzip2 bzip2-devel</span><br><span class="line">yum install -y curl curl-devel</span><br></pre></td></tr></table></figure></p>
<p>编译安装步骤在此：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cd /root/</span><br><span class="line">wget <span class="attr">http</span>:<span class="comment">//101.96.10.64/cn2.php.net/distributions/php-7.2.7.tar.gz</span></span><br><span class="line">tar -zxvf php-<span class="number">7.2</span><span class="number">.7</span>.<span class="property">tar</span>.<span class="property">gz</span></span><br><span class="line">cd  php-<span class="number">7.2</span><span class="number">.7</span></span><br><span class="line">sudo ./configure /</span><br><span class="line">--prefix=<span class="regexp">/usr/</span>local/php727 /		#<span class="title class_">PHP7</span>安装的根目录</span><br><span class="line">--<span class="keyword">with</span>-config-file-path=<span class="regexp">/usr/</span>local/php727/etc /		#<span class="title class_">PHP7</span>的配置目录</span><br><span class="line">--<span class="keyword">with</span>-apxs2=<span class="regexp">/usr/</span>bin/apxs		#如果用的是nginx就不要这句话</span><br><span class="line">--<span class="keyword">with</span>-gd /	#<span class="variable constant_">PHP</span> gd模块</span><br><span class="line">--<span class="keyword">with</span>-bz2 /		#包含<span class="title class_">BZip2</span>支持</span><br><span class="line">--<span class="keyword">with</span>-zlib /	#包含<span class="variable constant_">ZLIB</span>支持</span><br><span class="line">--<span class="keyword">with</span>-curl /	#包含cURL支持</span><br><span class="line">--enable-mbstring / 	#启用多字节字符串支持</span><br><span class="line">--enable-zip /	 #包含<span class="title class_">Zip</span>读写支持</span><br><span class="line">--enable-fpm /	 #启用<span class="variable constant_">PHP</span>-<span class="variable constant_">FPM</span>进程管理</span><br><span class="line">--enable-mysqlnd /	#<span class="title class_">Enable</span> mysqlnd explicitly</span><br><span class="line">--<span class="keyword">with</span>-mysqli /	 #包含mysql支持</span><br><span class="line">--<span class="keyword">with</span>-pdo-mysql/	#包含mysql支持</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p>
<p>如果出现了<code>configure error xml2-config not found. please check your libxml2 installation </code>错误，要执行如下两个：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yum install libxml2</span><br><span class="line">yum install libxml2-devel -y</span><br></pre></td></tr></table></figure></p>
<p>重新去执行<code>./configure</code>那步和<code>make &amp;&amp; make install</code>，整个编译完成之后，再把原带的<code>php.ini</code>拷贝到源码安装的文件夹里：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cp /root/php-<span class="number">7.2</span><span class="number">.7</span>/php.<span class="property">ini</span>-development /usr/local/php727/lib/php.<span class="property">ini</span></span><br></pre></td></tr></table></figure></p>
<p>设置环境变量，修改<code>/etc/profile</code>文件使其永久性生效，并对所有系统用户生效，在文件末尾加上如下两行代码：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">PATH</span>=<span class="attr">$PATH</span>:<span class="regexp">/usr/</span>local/php/bin</span><br><span class="line"><span class="keyword">export</span> <span class="variable constant_">PATH</span></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></p>
<p>设置<code>php-fpm</code>开机自动启动<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chmod +x /etc/init.<span class="property">d</span>/php-fpm</span><br><span class="line">chkconfig php-fpm on</span><br><span class="line">cp /usr/local/php727/etc/php-fpm.<span class="property">conf</span>.<span class="property">default</span> /usr/local/php727/etc/php-fpm.<span class="property">conf</span></span><br><span class="line">service php-fpm start</span><br></pre></td></tr></table></figure></p>
<h2 id="安装gcc-8-1-0"><a href="#安装gcc-8-1-0" class="headerlink" title="安装gcc 8.1.0"></a>安装gcc 8.1.0</h2><p>安装node.js需要先安装gcc，但是这个gcc不能用<code>yum install gcc-c++</code>装，因为centos7的gcc版本太低（4.8.5）不满足，在node.js编译的时候会报错：<code>WARNING: C++ compiler too old, need g++ 4.9.4 or clang++ 3.4.2 (CXX=g++)</code>。所以要去<a href="https://ftp.gnu.org/gnu/gcc/">https://ftp.gnu.org/gnu/gcc/</a> 下载一个高版本的，我选择了目前最牛逼的<code>8.1.0</code>。<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sudo yum install glibc-headers gcc-c++	#编译软件装上，少很多麻烦</span><br><span class="line">wget <span class="attr">https</span>:<span class="comment">//ftp.gnu.org/gnu/gcc/gcc-8.1.0/gcc-8.1.0.tar.gz</span></span><br><span class="line">tar -zxvf gcc-<span class="number">8.1</span><span class="number">.0</span>.<span class="property">tar</span>.<span class="property">gz</span></span><br><span class="line">cd gcc-<span class="number">8.1</span><span class="number">.0</span></span><br><span class="line">./contrib/download_prerequisites	#如果<span class="title function_">tar</span> (child): <span class="attr">lbzip2</span>: <span class="title class_">Cannot</span> <span class="attr">exec</span>: <span class="title class_">No</span> such file or directory，就yum -y install bzip2</span><br></pre></td></tr></table></figure></p>
<p>此时进入漫长的等待，一会就会出现如下的字样，代表成功安装了!<br><img data-src="/images/gcc1.png" alt="办公室"></p>
<p>此时进行编译安装：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">./configure --enable-checking=release --enable-languages=c,c++ --disable-multilib  #执行这一步之前系统是有gcc的，虽然版本很低</span><br><span class="line">make &amp;&amp;　make install</span><br></pre></td></tr></table></figure></p>
<p>又要进行漫长的等待…这一次非常非常漫长，我当时几乎用了大约2个小时…<br><img data-src="/images/gcc2.png" alt="办公室"></p>
<p>然后使用<code>gcc -v</code>检查一下版本：<br><img data-src="/images/gcc3.png" alt="办公室"></p>
<h2 id="安装node-js-8-11"><a href="#安装node-js-8-11" class="headerlink" title="安装node.js 8.11"></a>安装node.js 8.11</h2><p>先去<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a> 下载新的版本包:<br><img data-src="/images/gcc4.png" alt="办公室"></p>
<p>直接下载到linux里解压缩，如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wget <span class="attr">https</span>:<span class="comment">//ftp.gnu.org/gnu/gcc/gcc-8.1.0/gcc-8.1.0.tar.gz</span></span><br><span class="line">tar zxvf node-v8<span class="number">.11</span><span class="number">.3</span>.<span class="property">tar</span>.<span class="property">gz</span></span><br><span class="line">cd node-v8<span class="number">.11</span><span class="number">.3</span></span><br><span class="line">./configure --prefix=<span class="regexp">/usr/</span>local/node/<span class="number">8.11</span><span class="number">.3</span></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p>
<p>此时在make这一步可能会有这样的错误：<br><img data-src="/images/gcc5.png" alt="办公室"></p>
<p>这个原因是“升级gcc时，生成的动态库没有替换老版本gcc动态库”，所以要将gcc最新版本的动态库替换系统中老版本的动态库。</p>
<p>使用<code>find / -name &quot;libstdc++.so*&quot;</code>查找编译gcc时生成的最新动态库，发现最近的动态库是这个：<br><img data-src="/images/gcc6.png" alt="办公室"></p>
<p>于是就进行替换并作一个软连接:<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cp /root/gcc-<span class="number">8.1</span><span class="number">.0</span>/stage1-x86_64-pc-linux-gnu/libstdc++-v3/src/.<span class="property">libs</span>/libstdc++.<span class="property">so</span><span class="number">.6</span><span class="number">.0</span><span class="number">.25</span> /usr/lib64</span><br><span class="line">cd /usr/lib64</span><br><span class="line">ll libstdc++.<span class="property">so</span><span class="number">.6</span></span><br><span class="line">lrwxrwxrwx <span class="number">1</span> root root <span class="number">19</span> <span class="title class_">Jul</span> <span class="number">17</span> <span class="number">09</span>:<span class="number">59</span> libstdc++.<span class="property">so</span><span class="number">.6</span> -&gt; libstdc++.<span class="property">so</span><span class="number">.6</span><span class="number">.0</span><span class="number">.19</span>		#把原来的记住，防止有回滚的现象</span><br><span class="line">rm -rf  libstdc++.<span class="property">so</span><span class="number">.6</span></span><br><span class="line">ln -s libstdc++.<span class="property">so</span><span class="number">.6</span><span class="number">.0</span><span class="number">.25</span> libstdc++.<span class="property">so</span><span class="number">.6</span></span><br></pre></td></tr></table></figure></p>
<p>然后重新返回到<code>node-v8.11.3</code>文件夹里去<code>make</code>就OK了！</p>
<p>设定环境变量，<code>vim /etc/profile</code>，在<code>export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL</code>一行的上面添加如下内容：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#set <span class="keyword">for</span> nodejs</span><br><span class="line"><span class="keyword">export</span> <span class="variable constant_">NODE_HOME</span>=<span class="regexp">/usr/</span>local/node/<span class="number">8.11</span><span class="number">.3</span></span><br><span class="line"><span class="keyword">export</span> <span class="variable constant_">PATH</span>=$NODE_HOME/<span class="attr">bin</span>:$PATH</span><br></pre></td></tr></table></figure></p>
<p>保存退出之后，<code>source /etc/profile</code>，再<code>node --version</code>看一下版本是<code>v8.11.3</code>就是OK了！
	</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>nodejs</tag>
        <tag>gc++</tag>
      </tags>
  </entry>
  <entry>
    <title>django新增class的时候数据库格式出错</title>
    <url>/2018/01/10/django%E6%96%B0%E5%A2%9Eclass%E7%9A%84%E6%97%B6%E5%80%99%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A0%BC%E5%BC%8F%E5%87%BA%E9%94%99/</url>
    <content><![CDATA[<p>这几天开发频繁要求查看生产环境zookeeper的配置，于是就想在django里添加一个新的栏，以文本的形式随时更新zookeeper的情况。</p>
<p>于是我就登陆了django，在<code>model.py</code>里添加一个新的class，如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#建立杭州测试<span class="variable constant_">ZK</span>配置</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HZfunczk</span>(models.<span class="property">Model</span>):</span><br><span class="line">   	hzfunczk_remark = models.<span class="title class_">CharField</span>(verbose_name=<span class="string">&#x27;杭州测试ZK配置&#x27;</span>,max_length=<span class="number">50000</span>,blank=<span class="literal">true</span>)</span><br><span class="line">   	hzfunczk_signer = models.<span class="title class_">CharField</span>(verbose_name=<span class="string">&#x27;登记人&#x27;</span>,max_length=<span class="number">30</span>,<span class="keyword">default</span>=<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">   	hzfunczk_signtime = models.<span class="title class_">DateField</span>(auto_now_add=<span class="title class_">True</span>)</span><br><span class="line"></span><br><span class="line">   	def <span class="title function_">__unicode__</span>(self):</span><br><span class="line">       	<span class="keyword">return</span> self.<span class="property">domain_name</span></span><br></pre></td></tr></table></figure></p>
<p>然后在django的目录下执行<code>python manage.py makemigrations</code>，这一步没问题，但是在执行<code>python manage.py migrate</code>的时候，就出现了下面的错误：<br><img data-src="/images/django1.png" alt="akb48" title="数据库格式不对"></p>
<p>我开始认为是charfield写错了，应该写Textfield，于是更改了一下，但是保存之后，再执行<code>python manage.py migrate</code>还是出错。其实这个错误主要原因就是因为我那个50000设置错了，因为字段hzfunczk_remark定义的长度50000超出了mysql的varchar的最大长度21845（在utf8编码情况下）。于是我就在<code>model.py</code>里把这个长度改成20000，保存之后，还是执行到<code>python manage.py migrate</code>这一步，依旧爆上面的错误。于是我就干脆把这个class先删除掉，没想到都删除光了，还是在<code>make</code>的时候会爆错。</p>
<p>这就很奇怪了，我已经删掉了为啥还有这样的事儿？于是就干脆进入到数据库去看，由于我现在只知道列名叫hzfunczk_remark，所以我要根据这个列名去查它所在的表，maria反馈如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">MariaDB</span> [abccs]&gt; select <span class="variable constant_">TABLE_SCHEMA</span>, <span class="variable constant_">TABLE_NAME</span> <span class="keyword">from</span> information_schema.<span class="property">columns</span> where <span class="variable constant_">COLUMN_NAME</span> = <span class="string">&#x27;hzfunczk_remark&#x27;</span>; </span><br><span class="line"><span class="title class_">Empty</span> <span class="title function_">set</span> (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>好尴尬呀，数据库里压根就没有列名为“hzfunczk_remark”的表。然后由于<code>python manage.py migrate</code>报错，现在无法启动django。怎么办？</p>
<p>遇到这种状况，就去django里的migrations文件夹，这个文件夹里有很多的以时间命名的py文件，它们记录着数据库的每一步操作，不过这里面的py还没有真正执行到数据库里，我找到当时添加class那个时间段的py文件，里面是这样的：<br><img data-src="/images/django2.png" alt="akb48" title="记录数据库操作的PY细节"></p>
<p>先把里面CharField改成TextField，然后把50000改成小于21845的就行了。如果你性子比较烈，那就干脆把这个文件以及之后产生的所有文件都删除掉。重新的去<code>make</code>。</p>
<p>如果还是实在不行，还有一个万不得已的办法，几乎所有的数据库错误都可以用这个方法解决：<font color=red>将migrations文件夹下的文件除了__init__.py全部删掉，然后将数据库drop掉，重新建数据库。然后make和migrate，就可以使用一个新的数据库</font>（但愿你永远用不到这个方法）。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>H5界面实现桌面推送通知</title>
    <url>/2019/03/01/h5%E7%95%8C%E9%9D%A2%E5%AE%9E%E7%8E%B0%E6%A1%8C%E9%9D%A2%E6%8E%A8%E9%80%81%E9%80%9A%E7%9F%A5/</url>
    <content><![CDATA[<p>我们产品线的服务器告警模式是：“每十分钟执行一次脚本，脚本会使用zkclient获取当前服务器的CPU、内存、带宽、服务负载，然后以邮件的形式发送到运维人员的邮箱里”，每十分钟一次的频率可想而知，一天下来邮箱要有几百几千封邮件，看着就心烦。于是我就冒出了一个大胆的想法，重构这套土了吧唧的告警模式。</p>
<p>思路是这样的：“依旧是通过后台脚本结合crontab定时获取服务器的相关采集值，然后将值传入到Django的views.py里，呈现到某个页面上，这个页面也会定时自动刷新，每次刷新的时候也就顺便取到了新的采集值，如果有告警，那么页面对应的告警值红色标注，同时弹出通知。”</p>
<p>这么一看感觉高大上了很多，至少不用天天去outlook里清理垃圾邮件。</p>
<h2 id="实现自动刷新"><a href="#实现自动刷新" class="headerlink" title="实现自动刷新"></a>实现自动刷新</h2><p>页面自动刷新的方法很简单，有如下2种：<br>1.页面自动刷新：把如下代码加入<code>&lt;head&gt;</code>区域中<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">&quot;refresh&quot;</span> content=<span class="string">&quot;20&quot;</span>&gt;	<span class="comment">//其中20指每隔20秒刷新一次页面.</span></span><br></pre></td></tr></table></figure></p>
<p>这个功能也能结合页面自动跳转：把如下代码加入<code>&lt;head&gt;</code>区域中<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">&quot;refresh&quot;</span> content=<span class="string">&quot;20;url=http://www.webjx.com&quot;</span>&gt;	<span class="comment">//其中20指隔20秒后跳转到http://www.webjx.com页面</span></span><br></pre></td></tr></table></figure></p>
<p>我想，QQ好友生日祝福功能里10秒钟自动关闭就应该是这么做出来的。</p>
<p>2.页面自动刷新之js版<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script language=<span class="string">&quot;JavaScript&quot;</span>&gt;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myrefresh</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">reload</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="string">&#x27;myrefresh()&#x27;</span>,<span class="number">1000</span>); <span class="comment">//指定1秒刷新一次</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>这里多说一下<code>http-equiv</code>，<code>http-equiv</code>是响应头报文。它只能出现在<code>meta</code>标签里，用来代替<code>name</code>，它的值使用<code>content</code>属性描述，HTTP服务器通过此属性收集HTTP协议的响应头报文。</p>
<p>比如：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> <span class="title class_">Content</span>=<span class="string">&quot;text/html; Charset=gb2312″ /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码告诉浏览器等设备，文件为html文件，且使用了utf8编码;<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">&quot;Content-Language&quot;</span> <span class="title class_">Content</span>=<span class="string">&quot;zh-CN&quot;</span> /&gt;</span><br></pre></td></tr></table></figure></p>
<p>上面代码告诉浏览器等设备，语言使用了中文;<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">&quot;Expires&quot;</span> <span class="title class_">Content</span>=<span class="string">&quot;Wed, 26 Feb 1997 08:21:57 GMT&quot;</span> /&gt;</span><br></pre></td></tr></table></figure></p>
<p>上面代码指定网页在缓存中的过期时间，一旦网页过期，必须到服务器上重新调阅。<font color=red>注意：必须使用GMT的时间格式，或直接设为0(数字表示多少时间后过期)。</font></p>
<h2 id="实现桌面通知"><a href="#实现桌面通知" class="headerlink" title="实现桌面通知"></a>实现桌面通知</h2><p>桌面通知是一个比较优雅的功能，只要你后台打开网页，那么一旦网页里触发了通知，就会在windows桌面上弹出一个小窗口告诉我们页面发生了，如图：<br><img data-src="/images/notify1.png" alt="办公室"></p>
<p>它的实现关键词就是<code>Notification API</code>，这个动作的js代码如下：<br>	<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"> <span class="comment">//判断浏览器是否支持Notification</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">Notification</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">	<span class="keyword">var</span> title;</span></span><br><span class="line"><span class="language-javascript">	<span class="keyword">var</span> options;</span></span><br><span class="line"><span class="language-javascript">	title = <span class="string">&#x27;服务器告警提醒&#x27;</span>;			<span class="comment">//通知的标题</span></span></span><br><span class="line"><span class="language-javascript">	options = &#123;			<span class="comment">//通知的所有内容</span></span></span><br><span class="line"><span class="language-javascript">		<span class="attr">body</span>: <span class="string">&quot;机器千万台，稳定第一条，服务一瘫痪，运维泪两行。&quot;</span>,		<span class="comment">//通知主体内容</span></span></span><br><span class="line"><span class="language-javascript">		<span class="attr">tag</span>: <span class="string">&quot;custom&quot;</span>,		<span class="comment">//代表通知的一个识别标签，相同tag时只会打开同一个通知窗口</span></span></span><br><span class="line"><span class="language-javascript">		<span class="attr">icon</span>: <span class="string">&quot;http://img.mp.itc.cn/upload/20160723/a5953dc52c484834ab1ce924bb344da8_th.jpg&quot;</span>,	<span class="comment">//要在通知中显示的图标的URL</span></span></span><br><span class="line"><span class="language-javascript">		<span class="comment">// images: &quot;https://xxx.jpg&quot; //要在通知中显示的图像的URL</span></span></span><br><span class="line"><span class="language-javascript">		<span class="attr">requireInteraction</span>: <span class="literal">false</span>	<span class="comment">//通知保持自动关闭</span></span></span><br><span class="line"><span class="language-javascript">		&#125;;</span></span><br><span class="line"><span class="language-javascript">	<span class="title class_">Notification</span>.<span class="title function_">requestPermission</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">var</span> notification = <span class="keyword">new</span> <span class="title class_">Notification</span>(title, options);</span></span><br><span class="line"><span class="language-javascript">		notificationEvents.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">eventName</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">			notification[eventName] = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">		&#125;;</span></span><br><span class="line"><span class="language-javascript">		&#125;);</span></span><br><span class="line"><span class="language-javascript">	&#125;);</span></span><br><span class="line"><span class="language-javascript">	&#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">		<span class="title function_">alert</span>(<span class="string">&quot;你使用的浏览器不支持弹出提示，请更换Chrome内核浏览器！&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">	&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>再结合上面的自动刷新语句，在浏览器打开的时候，首先会询问是够接受“通知”，如图：<br><img data-src="/images/notify2.png" alt="办公室"></p>
<p>同意了之后，浏览器每10秒钟自动刷新，同时弹出上面那个加菲猫弹窗。</p>
<p>而且<code>Notification API</code>只能对https的网站可用，详情可见： <a href="https://stackoverflow.com/questions/30542287/are-push-notifications-possible-in-html5-without-fully-https-site">https://stackoverflow.com/questions/30542287/are-push-notifications-possible-in-html5-without-fully-https-site</a> 。</p>
<h2 id="全部整合"><a href="#全部整合" class="headerlink" title="全部整合"></a>全部整合</h2><p>现在就需要把上面两个功能全部整合到一起，实现<code>每10分钟自动刷新，同时判断传入数值，如果数值超标就发送桌面通知</code>。</p>
<p>首先，先在django的<code>url.py</code>里设定访问的路径和对应的函数:<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views </span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">	<span class="comment"># 前面略</span></span><br><span class="line">	path(<span class="string">r&#x27;test222/&#x27;</span>,views.ttt),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>然后在<code>views.py</code>里简单设置一下这个<code>ttt</code>函数：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ttt</span>(<span class="params">request</span>):</span><br><span class="line">    cpu = <span class="number">6.66</span></span><br><span class="line">    mem = <span class="number">66.6</span></span><br><span class="line">    disk = <span class="number">26</span></span><br><span class="line">    <span class="keyword">return</span> render_to_response(<span class="string">&#x27;test222.html&#x27;</span>,&#123;<span class="string">&#x27;CPU&#x27;</span>:cpu,<span class="string">&#x27;MEMORY&#x27;</span>:mem,<span class="string">&#x27;DISKUSED&#x27;</span>:disk&#125;)</span><br></pre></td></tr></table></figure></p>
<p>现在已经传入了三个数值，然后我们加工一下<code>test222.html</code>页面，如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">        &lt;head&gt;</span><br><span class="line">                &lt;meta http-equiv=<span class="string">&quot;refresh&quot;</span> content=<span class="string">&quot;60&quot;</span>&gt;</span><br><span class="line">                &lt;title&gt;服务器监控页面&lt;/title&gt;</span><br><span class="line">                &lt;script <span class="built_in">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">                        var cpu=<span class="string">&quot;&#123;&#123;CPU&#125;&#125;&quot;</span>,mem=<span class="string">&quot;&#123;&#123;MEMORY&#125;&#125;&quot;</span>,disk=<span class="string">&quot;&#123;&#123;DISKUSED&#125;&#125;&quot;</span></span><br><span class="line">                                // alert(cpu+<span class="string">&#x27; &#x27;</span>+mem+<span class="string">&#x27; &#x27;</span>+disk)</span><br><span class="line">                        <span class="keyword">if</span> ( cpu &gt; <span class="number">80</span> || mem &gt; <span class="number">80</span> || disk &gt; <span class="number">80</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (window.Notification) &#123;</span><br><span class="line">                                        var title;</span><br><span class="line">                                        var options;</span><br><span class="line">                                        title = <span class="string">&#x27;服务器告警提醒&#x27;</span>;                       //通知的标题</span><br><span class="line">                                        options = &#123;                     //通知的所有内容</span><br><span class="line">                                                body: <span class="string">&quot;机器千万台，稳定第一条，服务一瘫痪，运维泪两行。&quot;</span>,               //通知主体内容                                                tag: <span class="string">&quot;custom&quot;</span>,          //代表通知的一个识别标签，相同tag时只会打开同一个通知窗口</span><br><span class="line">                                                icon: <span class="string">&quot;http://img.mp.itc.cn/upload/20160723/a5953dc52c484834ab1ce924bb344da8_th.jpg&quot;</span>    //要在通知中显示的图标的URL</span><br><span class="line">                                        &#125;;</span><br><span class="line">                                        Notification.requestPermission(function() &#123;</span><br><span class="line">                                                var notification = new Notification(title, options);</span><br><span class="line">                                                notificationEvents.forEach(function(eventName) &#123;</span><br><span class="line">                                                        notification[eventName] = function(event) &#123;</span><br><span class="line">                                                        &#125;;</span><br><span class="line">                                                &#125;);</span><br><span class="line">                                        &#125;);</span><br><span class="line">                                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                                alert(<span class="string">&quot;你使用的浏览器不支持弹出提示，请更换Chrome内核浏览器！&quot;</span>);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                &lt;/script&gt;</span><br><span class="line">        &lt;/head&gt;</span><br><span class="line"></span><br><span class="line">        &lt;body&gt;</span><br><span class="line">                &lt;h3&gt;服务器名称是test-ooxx-001&lt;/h3&gt;</span><br><span class="line">                &lt;hr&gt;</span><br><span class="line">                &lt;h4&gt;CPU情况是：&#123;&#123; CPU &#125;&#125;&lt;/h4&gt;</span><br><span class="line">                &lt;h4&gt;内存情况是：&#123;&#123; MEMORY &#125;&#125;&lt;/h4&gt;</span><br><span class="line">                &lt;h4&gt;磁盘容量情况是：&#123;&#123; DISKUSED &#125;&#125;&lt;/h4&gt;</span><br><span class="line">        &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>界面如下：<br><img data-src="/images/notify3.png" alt="办公室"></p>
<p>现在修改一下<code>views.py</code>里的三个值，只要有一个大于设定的标准值，就会触发桌面推送。</p>
<p>js里“a&#x3D;空就判断b，b如果也是空再判断C，然后执行func()”的语句是：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( a != null || b != null || c != null ) &#123;</span><br><span class="line">    fun();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/notification">https://developer.mozilla.org/zh-CN/docs/Web/API/notification</a><br><a href="http://www.ptbird.cn/html5-notification-browser.html">http://www.ptbird.cn/html5-notification-browser.html</a><br><a href="https://segmentfault.com/a/1190000011670082">https://segmentfault.com/a/1190000011670082</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title>m1芯片的Macos系统安装java 8</title>
    <url>/2024/04/03/macos-m1%E8%8A%AF%E7%89%87%E5%AE%89%E8%A3%85java-8/</url>
    <content><![CDATA[<p>我日常工作里经常要把odps上的数据拉到桌面上在钉钉上发来发去，因为公司的数据安全政策，odps默认结果一次只能最多复制100行，如果是1000行的数据就要点击10遍，很烦人，不然就要走download审批，也很烦人。于是我忘了从哪里搞来了一个叫odps_clt_release_64 这么个工具，它可以用命令行直接通过内网把需要的数据拉到macos上。</p>
<p>但是我现在换了一个新的苹果，换了m1芯片很高档，当我在odps_clt_release_64路径里执行熟悉的<code>odpscmd</code>命令时，报错：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">The operation couldn’t be completed. Unable to locate a Java Runtime.</span><br><span class="line">Please visit http://www.java.com <span class="keyword">for</span> information on installing Java.</span><br></pre></td></tr></table></figure>

<p>发现系统里面没有java了，于是我就直接跑去<a href="https://www.oracle.com/java/technologies/downloads/">https://www.oracle.com/java/technologies/downloads/</a> 里，下载最新的香喷喷的jdk 22，由于我是M1芯片，所以下载的是<code>ARM64 DMG Installer</code>，一顿操作安装之后，再执行<code>odpscmd</code>命令时，换了一个报错：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Error occurred during initialization of boot layer</span><br><span class="line">java.lang.module.FindException: Module java.xml.bind <span class="keyword">not</span> found</span><br></pre></td></tr></table></figure>

<p>google了一下发现，原来 <code>java.xml.bind</code> 在JDK 11及以上的版本里被干掉了。原来python2升级python3后，因为功能调整而无法启动的痛苦在java也有。于是我就只能去下载一个java8，于是来到 <a href="https://www.oracle.com/java/technologies/downloads/#java8-mac">https://www.oracle.com/java/technologies/downloads/#java8-mac</a> 里，下载对应的<code>ARM64 DMG Installer</code>，这里比较恶心，要下载老java必须要注册，于是耐着性子注册了一下，顺利下载并安装。然后这次启动<code>odpscmd</code>就好了：</p>
<p><img data-src="/images/odpscmd.png" alt="paradin" title="终于好了"></p>
<p>然后就是要删除之前下载的jdk-22，删除的方法很简单，在<code>/Library/Java/JavaVirtualMachines/</code> 里找到对应的jdk-22.jdk，然后直接<code>rm -rf</code>删除就好了。</p>
<p>如果执行<code>java -version</code>的时候，出现了 <code>java.lang.Error:Properties init:Could not determine current working directory</code>，那是因为你当前的目录已经不存在了，换一个目录，重新执行<code>java -version</code>这个命令就行。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>odps</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql查看实时语句和慢sql</title>
    <url>/2018/01/30/mysql%E6%9F%A5%E7%9C%8B%E5%AE%9E%E6%97%B6%E8%AF%AD%E5%8F%A5%E5%92%8C%E6%85%A2sql/</url>
    <content><![CDATA[<h2 id="查看实时语句"><a href="#查看实时语句" class="headerlink" title="查看实时语句"></a>查看实时语句</h2><p>Mysql除了手动执行的语句，还有很多在后台由其他模块执行的语句，按理来说，那些由其他模块执行的语句是不能实时查看的，因为这个资源消耗特别的大，但是当我们实在需要查看实时sql语句的时候也不是做不到，需要手动开启一个日志开关<code>general_log</code>。</p>
<p>首先登陆mysql，然后执行<code>show variables like &quot;general_log%&quot;;</code>，看一下反馈的结果，如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">&quot;general_log%&quot;</span>;</span><br><span class="line">+------------------+-------+</span><br><span class="line">| <span class="title class_">Variable</span>_name    | <span class="title class_">Value</span> |</span><br><span class="line">+------------------+-------+</span><br><span class="line">| general_log      | <span class="variable constant_">OFF</span>   |</span><br><span class="line">| general_log_file |       |</span><br><span class="line">+------------------+-------+</span><br><span class="line"><span class="number">2</span> rows <span class="keyword">in</span> <span class="title function_">set</span> (<span class="number">0.04</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>发现这个Value是<code>off</code>，那么就说明实时记录<code>general_log</code>没有开启，如果我们要开启它很简单，如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mysql&gt; set <span class="variable language_">global</span> log_output = file;</span><br><span class="line">mysql&gt; set <span class="variable language_">global</span> general_log = <span class="string">&#x27;ON&#x27;</span>;</span><br><span class="line">mysql&gt; set <span class="variable language_">global</span> general_log_file = <span class="string">&#x27;/tmp/mysql/general_log.log&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<p>可见我们不仅打开了<code>general_log</code>的开关，而且设置日志输出方式为文件（如果设置<code>log_output=table</code>的话，则日志结果会记录到名为<code>gengera_log</code>的表中，这表的默认引擎都是<code>CSV</code>）。同时规定它的保存位置是<code>/tmp/mysql/general_log.log</code>。</p>
<p>但是这个是临时方法，如果mysql重启了那么就会失效，如果想要永久有效的话，就要编辑<code>my.cnf</code>，添加下面两句话：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">general_log = <span class="number">1</span></span><br><span class="line">general_log_file = <span class="regexp">/tmp/my</span>sql/general_sql.<span class="property">log</span></span><br></pre></td></tr></table></figure></p>
<p>这里要注意！<font color=red>开启general_log会影响性能，谨慎使用!正式系统用完要关闭!!!</font>关闭的语句<code>SET GLOBAL general_log = &#39;OFF&#39;;</code>。</p>
<h2 id="查看慢sql"><a href="#查看慢sql" class="headerlink" title="查看慢sql"></a>查看慢sql</h2><p>慢sql的意思就是那些执行很慢的sql，这些sql拖慢进程的执行效率而且有很大的优化空间。默认的来说，执行时间超过1秒就算慢sql了，在mysql里输入<code>show variables like &#39;long%&#39;</code>，就会看到如下的内容：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">&#x27;long%&#x27;</span>;</span><br><span class="line">+-----------------+----------+</span><br><span class="line">| <span class="title class_">Variable</span>_name   | <span class="title class_">Value</span>    |</span><br><span class="line">+-----------------+----------+</span><br><span class="line">| long_query_time | <span class="number">1.000000</span> |</span><br><span class="line">+-----------------+----------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="title function_">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>这个<code>long_query_time</code>是可以更改的，这里是1，那就是代表查询时间大于(不是大于等于)1秒的都是记录到日志，最大值是10。如果写的是0，那么就是输出所有的语句。</p>
<p>这里多说一句，使用命令<code>set global long_query_time=4</code>修改慢查询阈值为4秒后，需要重新连接或新开一个会话才能看到修改值。你用<code>show variables like &#39;long_query_time&#39;</code>查看是当前会话的变量值，你也可以不用重新连接会话，而是用<code>show global variables like &#39;long_query_time&#39;;</code>。</p>
<p>那么记录这些慢日志的地方在哪呢？使用<code>show variables  like &#39;%slow_query_log%&#39;;</code>看看：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables  like <span class="string">&#x27;%slow_query_log%&#x27;</span>;</span><br><span class="line">+---------------------+-----------------------------------------------+</span><br><span class="line">| <span class="title class_">Variable</span>_name       | <span class="title class_">Value</span>                                         |</span><br><span class="line">+---------------------+-----------------------------------------------+</span><br><span class="line">| slow_query_log      | <span class="variable constant_">OFF</span>                                           |</span><br><span class="line">| slow_query_log_file | <span class="regexp">/tmp/my</span>sql/<span class="variable constant_">DB</span>-<span class="title class_">Server</span>-slow.<span class="property">log</span> 				  |</span><br><span class="line">+---------------------+-----------------------------------------------+</span><br><span class="line"><span class="number">2</span> rows <span class="keyword">in</span> <span class="title function_">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>这里说明慢日志的地址是<code>/tmp/mysql/DB-Server-slow.log</code>，但是慢日志记录的功能没有启动。如果要启动，语句是：<code>set global slow_query_log=1;</code>，跟上面开启实时日志<code>general_log</code>一样，这个方法仅仅是一个临时方法，重启了mysql就会失效，如果要长期生效，还是在<code>my.cnf</code>文件里添加如下两句话：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">slow_query_log =<span class="number">1</span></span><br><span class="line">slow_query_log_file=<span class="regexp">/tmp/my</span>sql/<span class="variable constant_">DB</span>-<span class="title class_">Server</span>-slow.<span class="property">log</span></span><br></pre></td></tr></table></figure></p>
<p>慢日志还有一个系统变量叫<code>log-queries-not-using-indexes</code>，它的意思是未使用索引的查询也被记录到慢查询日志中，哪怕他可能执行的非常快（可选项）。如果调优的话，建议开启这个选项。另外，开启了这个参数，其实使用<code>full index scan</code>的sql也会被记录到慢查询日志。如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">&#x27;log_queries_not_using_indexes&#x27;</span>;</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">| <span class="title class_">Variable</span>_name                 | <span class="title class_">Value</span> |</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">| log_queries_not_using_indexes | <span class="variable constant_">OFF</span>   |</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="title function_">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set <span class="variable language_">global</span> log_queries_not_using_indexes=<span class="number">1</span>;</span><br><span class="line"><span class="title class_">Query</span> <span class="variable constant_">OK</span>, <span class="number">0</span> rows <span class="title function_">affected</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>如果你想自己试试慢sql是否被记录，那么可以使用<code>select sleep(5);</code>这样的语句，执行效果如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mysql&gt; select <span class="title function_">sleep</span>(<span class="number">5</span>) ;</span><br><span class="line">+----------+</span><br><span class="line">| <span class="title function_">sleep</span>(<span class="number">5</span>) |</span><br><span class="line">+----------+</span><br><span class="line">|        <span class="number">0</span> |</span><br><span class="line">+----------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="title function_">set</span> (<span class="number">5.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * <span class="keyword">from</span> mysql.<span class="property">slow_log</span>;</span><br><span class="line">+---------------------+---------------------------+------------+-----------+-----------+---------------+----+----------------+-----------+-----------+-----------------+-----------+</span><br><span class="line">| start_time          | user_host                 | query_time | lock_time | rows_sent | rows_examined | db | last_insert_id | insert_id | server_id | sql_text        | thread_id |</span><br><span class="line">+---------------------+---------------------------+------------+-----------+-----------+---------------+----+----------------+-----------+-----------+-----------------+-----------+</span><br><span class="line">| <span class="number">2018</span>-<span class="number">01</span>-<span class="number">30</span> <span class="number">21</span>:<span class="number">45</span>:<span class="number">23</span> | root[root] @ localhost [] | <span class="number">00</span>:<span class="number">00</span>:<span class="number">05</span>   | <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>  |         <span class="number">1</span> |             <span class="number">0</span> |    |              <span class="number">0</span> |         <span class="number">0</span> |         <span class="number">1</span> | select <span class="title function_">sleep</span>(<span class="number">5</span>) |         <span class="number">2</span> |</span><br><span class="line">+---------------------+---------------------------+------------+-----------+-----------+---------------+----+----------------+-----------+-----------+-----------------+-----------+</span><br><span class="line"><span class="number">1</span> rows <span class="keyword">in</span> <span class="title function_">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.cnblogs.com/kerrycode/p/5593204.html">http://www.cnblogs.com/kerrycode/p/5593204.html</a><br><a href="https://www.cnblogs.com/qmfsun/p/4844472.html">https://www.cnblogs.com/qmfsun/p/4844472.html</a><br><a href="http://www.cnblogs.com/jasondan/p/3491258.html">http://www.cnblogs.com/jasondan/p/3491258.html</a></p>
<p><img data-src="/images/curry3p.gif" alt="库里三分" title="神射手萌库"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>centos 7里安装zsh来提升shell的高逼格</title>
    <url>/2018/03/15/centos-7%E9%87%8C%E5%AE%89%E8%A3%85zsh%E6%9D%A5%E6%8F%90%E5%8D%87shell%E7%9A%84%E9%AB%98%E9%80%BC%E6%A0%BC/</url>
    <content><![CDATA[<h2 id="zsh本体的安装"><a href="#zsh本体的安装" class="headerlink" title="zsh本体的安装"></a>zsh本体的安装</h2><p>先用<code>chsh -l</code>查看当前的bash情况，如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">   [root@zabbix ~]# chsh -l</span><br><span class="line">/bin/sh</span><br><span class="line">/bin/bash</span><br><span class="line">/sbin/nologin</span><br><span class="line">/bin/dash</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/csh</span><br><span class="line">/usr/bin/tmux</span><br><span class="line">[root@zabbix ~]#</span><br></pre></td></tr></table></figure></p>
<p>如果是centos的话，使用<code>yum install -y zsh</code>来安装zsh，装完了zsh然后就是装<code>oh my zsh</code>，使用<code>wget</code>方法安装：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wget <span class="attr">https</span>:<span class="comment">//github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</span></span><br></pre></td></tr></table></figure></p>
<p>再使用<code>which zsh</code>查看安装的zsh在<code>/usr/bin/zsh</code>，这个时候使用<code>chsh -s /usr/bin/zsh</code>，出现了<code>Shell changed.</code>这样就切换到了zsh界面，需要logout退出连接重进。</p>
<p>重新连接就会发现bash界面就变了，原本是路径的地方变成了一个小图标。界面主题是可以变化的，比如我个人比较喜欢<code>af-magic</code>这个模板，于是乎就把&#x2F;root&#x2F;.zshrc里的<code>ZSH_THEME=&quot;robbyrussell&quot;</code>改成<code>ZSH_THEME=&quot;af-magic&quot;</code>，保存文件，再一次退出连接重新进入就能看见模板变化了。</p>
<p>如果在使用vim的时候发现了tab键的补全爆错_arguments:451: _vim_files: function definition file not found，如下图：<br><img data-src="/images/zsh2.png" alt="paradin"></p>
<p>这个时候需要把&#x2F;root&#x2F;.zcompdump改一个名字，比如叫.zcompdump-bak，然后重新ssh连接即可。</p>
<h2 id="autojump插件安装"><a href="#autojump插件安装" class="headerlink" title="autojump插件安装"></a>autojump插件安装</h2><p>autojump这个插件安装之后，zsh会自动记录你访问过的目录，通过<code>j + 目录名</code>可以直接进行目录跳转，而且目录名支持模糊匹配和自动补全，例如你访问过<code>hadoop-1.0.0</code>目录，输入<code>j hado</code>即可正确跳转。<code>j –s</code>可以看你的历史路径库，安装方法如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git clone <span class="attr">git</span>:<span class="comment">//github.com/joelthelion/autojump.git</span></span><br></pre></td></tr></table></figure></p>
<p>然后在autojump目录里执行<code>./install.sh</code>，此时屏幕会出现如下的显示：<br><img data-src="/images/zshautojump.png" alt="paradin"></p>
<p>把上面那个<code>[[ -s /root/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; source /root/.autojump/etc/profile.d/autojump.sh autoload -U compinit &amp;&amp; compinit -u复</code>制到<code>/root/.zshrc</code>的文件里，最好复制在<code>source $ZSH/oh-my-zsh.sh</code>这句话上面，保存之后<code>source ~/.zshrc</code>即可。</p>
<h2 id="zsh-syntax-highlighting插件安装"><a href="#zsh-syntax-highlighting插件安装" class="headerlink" title="zsh-syntax-highlighting插件安装"></a>zsh-syntax-highlighting插件安装</h2><p>这个插件安装之后主要效果就是命令高亮，如果是错误的命令，颜色是红色，正确的命令是绿色的，安装方法如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cd .<span class="property">oh</span>-my-zsh/plugins</span><br><span class="line">yum install -y git  #如果已经安装了git就不用执行的</span><br><span class="line">git clone <span class="attr">git</span>:<span class="comment">//github.com/zsh-users/zsh-syntax-highlighting.git</span></span><br><span class="line">source /root/.<span class="property">oh</span>-my-zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.<span class="property">zsh</span>添加到 .<span class="property">zshrc</span> 的最后面</span><br><span class="line">source ~/.<span class="property">zshrc</span></span><br></pre></td></tr></table></figure></p>
<p>效果立竿见影。</p>
<h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>至此，你现在的zsh应该具备如下几个特性：<br>1、各种补全：路径补全、命令补全，命令参数补全，插件内容补全等等。触发补全只需要按一下或两下tab键，补全项可以使用ctrl+n&#x2F;p&#x2F;f&#x2F;b上下左右切换。比如你想杀掉java的进程，只需要输入kill java + tab键，如果只有一个java进程，zsh会自动替换为进程的pid，如果有多个则会出现选择项供你选择。ssh + 空格 + 两个tab键，zsh会列出所有访问过的主机和用户名进行补全；<br>2、即使你没有安装autojump，只要输入d，就会列出你在这个回话中访问的目录，输入前面的序号，就可以直接跳转；<br>3、可以忽略cd命令, 输入..或者…和当前目录名都可以跳转；<br>当然，除了上面几点，zsh还有很多丰富的插件可以使用，这就需要继续的探索了…</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/robbyrussell/oh-my-zsh">https://github.com/robbyrussell/oh-my-zsh</a><br><a href="http://macshuo.com/?p=676">http://macshuo.com/?p=676</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>运维技术</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo推送爆send-pack错误</title>
    <url>/2020/06/24/hexo%E6%8E%A8%E9%80%81%E7%88%86send-pack%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>前几天手贱，为了匹配公司内部的gitlab的<code>public-key</code>，脑子一抽把github上这个博客的<code>public-key</code>的<code>id_sra.pub</code>文件给删除了，结果<code>hexo d -g</code>推送文章的时候，发现报错:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights and the repository exists.</span><br></pre></td></tr></table></figure>

<p>然后就去<code>cd ~/.ssh </code>，使用<code>ssh-keygen -t ed25519 -C &quot;我的邮箱地址&quot;</code>创建一个新的公钥。在<br>Enter file in which to save the key (&#x2F;home&#x2F;我的id&#x2F;.ssh&#x2F;id_ed25519)时，输入<code>/home/我的id/.ssh/id_github</code>这样生成了一个<code>id_github.pub</code>的文件用于github。</p>
<p>然后还是在<code>~/.ssh</code>下创建<code>config</code>文件，里面内容是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># GitHub</span><br><span class="line">Host github.com</span><br><span class="line">  IdentityFile ~/.ssh/id_github		# 指定对应的密钥</span><br><span class="line">  User git</span><br><span class="line"></span><br><span class="line"># GitLab</span><br><span class="line">Host code.my-company.com</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa		# 指定对应的密钥</span><br><span class="line">  User git</span><br></pre></td></tr></table></figure>

<p>测试一下<code>ssh -T git@github.com</code>，验证通过。</p>
<p>但是再次<code>hexo d -g</code>推送的时候，发现报错<code>send-pack: unexpected disconnect while reading sideband packet</code>:<br><img data-src="/images/sendpack%E9%97%AE%E9%A2%98.png" alt="paradin" title="就很神奇"></p>
<p>查了一下说是我缓存区设置小了，使用命令<code>git config --global http.postBuffer 524288000</code>，放大到500mb，问题解决：<br><img data-src="/images/sendpack%E9%97%AE%E9%A2%982.png" alt="paradin" title="恢复正常"></p>
<p>但是我就改了一个public-key啊，为啥会说我缓存设置不足了呢，我又没加什么新的东西，这个问题还要深挖一下。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>http返回码是000...</title>
    <url>/2018/02/11/http%E8%BF%94%E5%9B%9E%E7%A0%81%E6%98%AF000/</url>
    <content><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>今天开发童鞋在测试往一个网站发请求的时候，发现返回码是000，如图：<br><img data-src="/images/http0001.png" alt="paradin"></p>
<p>众所周知，常见的返回码是以下四种：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">2XX 成功；</span><br><span class="line">3XX 重定向；</span><br><span class="line">4XX 客户端错误；</span><br><span class="line">5XX 服务器端错误；</span><br></pre></td></tr></table></figure></p>
<p>但是000是啥玩意？简单的说就是没有有效的http状态码，比如连接被拒绝，连接超时等。</p>
<p>使用<code>curl -w &quot;%{http_code}\n&quot; -m 5 https://60.191.94.115:38303/cloudSignalling/events/deviceState ; echo &quot;Exit code: $?</code>看一下详细的code，显示如图：<br><img data-src="/images/http0002.png" alt="paradin"></p>
<p>可以看到提示：<code>curl: (60) Peer certificate cannot be authenticated with known CA certificates</code>，翻译过来就是<code>对方的证书不能用已知的CA证书验证</code>。但是下面也说了可以用<code>-k</code>或者<code>--insecure</code>来跳过这一步。</p>
<p>于是我又使用<code>curl -I -k https://60.191.94.115:38303/cloudSignalling/events/deviceState</code>这个命令，效果如图：<br><img data-src="/images/http0003.png" alt="paradin"></p>
<p>里面这一下说的就很明白了，405，方法不正确，再搭配一下<code>curl -k -w &quot;%{http_code}\n&quot; -m 5 https://60.191.94.115:38303/cloudSignalling/events/deviceState</code>，看一下：<br><img data-src="/images/http0004.png" alt="paradin"></p>
<p>这么上下一结合，明白了GET是不准许的，准许POST。于是反馈给60.191.94.115告诉他们把前后台接口请求方式、参数传递方式都拿回去整改。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.1987.name/365.html">http://www.1987.name/365.html</a><br><a href="https://superuser.com/questions/501690/curl-http-code-of-000">https://superuser.com/questions/501690/curl-http-code-of-000</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql清除磁盘碎片</title>
    <url>/2018/01/23/mysql%E6%B8%85%E9%99%A4%E7%A3%81%E7%9B%98%E7%A2%8E%E7%89%87/</url>
    <content><![CDATA[<h2 id="任务背景"><a href="#任务背景" class="headerlink" title="任务背景"></a>任务背景</h2><p>接到金山云报警短信，说某数据库的容量已经达到了90%的水位线，于是登陆控制台查看详细情况。</p>
<p>在控制台首先发现，每一天的磁盘容量的确有所波动，那么就证明开发人员写的“资源回收”模块是在正常运行的，如图：<br><img data-src="/images/suipian3.png" alt="paradin"></p>
<p>那么就说明没有什么数据是可以删的，既然删不掉多余的数据又不想多掏钱扩磁盘容量，只能从“磁盘碎片”下手了。而<code>InnoDB</code>引擎清理磁盘碎片的命令就是<code>OPTIMIZE</code>。</p>
<h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><p>首先我先查询一下所有的“磁盘碎片情况”，使用语句如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">select <span class="title function_">CONCAT</span>(<span class="variable constant_">TABLE_SCHEMA</span>,<span class="string">&#x27;.&#x27;</span>,<span class="variable constant_">TABLE_NAME</span>) <span class="keyword">as</span> 数据表名,<span class="title function_">concat</span>(<span class="title function_">truncate</span>(<span class="title function_">sum</span>(<span class="variable constant_">DATA_LENGTH</span>+<span class="variable constant_">DATA_FREE</span>+<span class="variable constant_">INDEX_LENGTH</span>)/<span class="number">1024</span>/<span class="number">1024</span>,<span class="number">2</span>),<span class="string">&#x27; MB&#x27;</span>) <span class="keyword">as</span> total_size, <span class="title function_">concat</span>(<span class="title function_">truncate</span>(<span class="title function_">sum</span>(<span class="variable constant_">DATA_LENGTH</span>)/<span class="number">1024</span>/<span class="number">1024</span>,<span class="number">2</span>),<span class="string">&#x27; MB&#x27;</span>) <span class="keyword">as</span> data_size,<span class="title function_">concat</span>(<span class="title function_">truncate</span>(<span class="title function_">sum</span>(<span class="variable constant_">DATA_FREE</span>)/<span class="number">1024</span>/<span class="number">1024</span>,<span class="number">2</span>),<span class="string">&#x27; MB&#x27;</span>) <span class="keyword">as</span> data_free, <span class="title function_">concat</span>(<span class="title function_">truncate</span>(<span class="title function_">sum</span>(<span class="variable constant_">INDEX_LENGTH</span>)/<span class="number">1024</span>/<span class="number">1024</span>,<span class="number">2</span>),<span class="string">&#x27;MB&#x27;</span>) <span class="keyword">as</span> index_size <span class="keyword">from</span> information_schema.<span class="property">tables</span> group by <span class="variable constant_">TABLE_NAME</span> order by data_length desc; </span><br></pre></td></tr></table></figure></p>
<p>或者使用<code>select table_schema, table_name, data_free, engine from information_schema.tables where table_schema not in (&#39;information_schema&#39;, &#39;mysql&#39;) and data_free &gt; 0;</code>也可以，这个是查询<code>data_free</code>大于0的所有表。</p>
<p>然后看到我这个叫<code>history_device_flow_day</code>的表里情况如下：<br><img data-src="/images/suipian1.png" alt="paradin"></p>
<p>表里的<code>data_free</code>就是磁盘碎片的量，比如我现在要干掉<code>history_device_flow_day</code>里所有的磁盘碎片，是975MB，于是先查询一下这个<code>history_device_flow_day</code>的存储引擎，使用语句如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">show table status <span class="keyword">from</span> jsonlinefssrds where name=<span class="string">&#x27;history_device_flow_day&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<p>上面语句里的<code>jsonlinefssrds</code>是对应的数据库，看到的效果如下：<br><img data-src="/images/suipian4.png" alt="paradin"></p>
<p>存储引擎是<code>InnoDB</code>，那么就可以启动清除碎片的语句了：<code>OPTIMIZE TABLE 数据表表名;</code>，因为<code>OPTIMIZE TABLE</code>只对<code>MyISAM</code>、<code>BDB</code>和<code>InnoDB</code>表起作用。</p>
<p>再执行了<code>OPTIMIZE TABLE history_device_flow_day;</code>之后，大约9分钟，就会看到“OK”的字样：<br><img data-src="/images/suipian5.png" alt="paradin"></p>
<p>估计有的朋友会问，那上面不是明明写了“Table does not support optimize, doing recreate + analyze instead”吗？这个其实无妨，实际上磁盘碎片已经被清除掉了。我们可以再用一次查询磁盘碎片的命令看一下，如图：<br><img data-src="/images/suipian2.png" alt="paradin"></p>
<p>的确释放了900多M。</p>
<p>或者使用<code>ALTER TABLE 表名 ENGINE = Innodb;</code>（只是<code>InnoDB</code>的表可以这么做，而且据说这么做更友好）来达到清理磁盘碎片的目的，这个命令表面上看什么也不做,实际上是重新整理碎片了。当执行优化操作时,实际执行的是一个空的<code>ALTER</code>命令,但是这个命令也会起到优化的作用,它会重建整个表,删掉未使用的空白空间。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>为什么会产生磁盘碎片？那是因为某一个表如果经常插入数据和删除数据，必然会产生很多未使用的空白空间，这些空白空间就是不连续的碎片，这样久而久之，这个表就会占用很大空间，但实际上表里面的记录数却很少，这样不但会浪费空间，并且查询速度也更慢。</p>
<p><font color=red>注意！<code>OPTIMIZE</code>操作会暂时锁住表,而且数据量越大,耗费的时间也越长,它毕竟不是简单查询操作。</font>所以把<code>OPTIMIZE</code>命令放在程序中是不妥当的,不管设置的命中率多低,当访问量增大的时候,整体命中率也会上升,这样肯定会对程序的运行效率造成很大影响。比较好的方式就是做个shell,定期检查mysql中 <code>information_schema</code>.<code>TABLES</code>字段,查看<code>DATA_FREE</code>字段,大于0的话,就表示有碎片，然后启动脚本。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://pengbotao.cn/mysql-suipian-youhua.html">http://pengbotao.cn/mysql-suipian-youhua.html</a><br><a href="http://irfen.me/mysql-data-fragmentation-appear-and-optimization/">http://irfen.me/mysql-data-fragmentation-appear-and-optimization/</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Optimize的小意外</title>
    <url>/2022/09/16/optimize%E7%9A%84%E5%B0%8F%E6%84%8F%E5%A4%96/</url>
    <content><![CDATA[<p>阿里云的数据库的带宽是分档次的，默认是PL1，如果降级改使用PL0会从磁盘存储费用上节约大约45%的金额，由于目前“要把寒气传给每个人”，公司开始关注现金流，所以要求节流降本，于是很多的数据库都开始评估是否可以从PL1降配成PL0：<br><img data-src="/images/PL1PL0.png" title="PL1的吞吐量比PL0的吞吐量要多了几乎一倍"></p>
<p>我们有一个数据库集群，里面有8个实例，先降了其中一个实例为PL0，观察了几天，发现日常没啥问题，于是又降了3个实例，灰度达到了50%。又平稳的走了几天，观察磁盘的吞吐都非常稳定，于是晚上11点把全部的实例都降了PL0。但是第二天早上突然系统开始告警，从日志来看是大量的数据库update超时，很多的SQL的耗时高：<br><img data-src="/images/PL1PL02.png" title="几乎所有的语句都无法正常运行了"></p>
<p>二话不说，赶紧回滚成PL1，发现数据库的带宽也开始激增，CPU开始激增：<br><img data-src="/images/PL1PL03.png" title="带宽几乎达到了PL1的极限"></p>
<p>最后在DBA的提示下发现这个库当时是在optimize，原来是optimize把所有的磁盘带宽都占据了，导致正常的业务请求90%都会卡住，因为卡住而失败的请求又不断地重试，这样分母越来越大，请求成功率就暴跌。于是紧急KILL掉optimize语句和堆积的业务语句（堆积太多了，如果要消费掉要好久，这样就耽误其他正常的业务了），系统侧开始恢复正常，剩下的就是业务侧的手动补数据止血…</p>
<p>optimize的原理其实很简单：<br>	1.创建一张新的临时表 tmp<br>	2.把旧表锁住，禁止插入删除，只允许读写 （alisql已经优化了，它不会被锁住）<br>	3.把数据不断的从旧表，copy到新的临时表<br>	4.等表拷贝完后，进行瞬间的rename操作<br>	5.旧表删除掉</p>
<p>由此可见，optimize是一个特别消耗磁盘带宽的操作，而且如果数据库delete的内容很多，optimize会执行很久，难免会跟正常业务请求重合，进而造成业务抖动。</p>
<p>这个事情之后，optimize就成了一个高危的操作（MYSQL官方也不建议很频繁的optimize），首先要一定避开业务时间，如果做成定时任务的话，到了业务时间一定要暂停，过了时间后再跑。</p>
<p>从这个故障里，我们也要重新的分析一下业务链路，出现告警的系统是结算的系统，他们一早更新账目状态，发现数据库update失败而请求失败。但是由于处理时间过长，而且这个数据库还有货品出仓的信息，结果影响了货品的出仓。所以我们要审视一下，结算的链路不应该影响出库这个发货链路，所以后期打算把结算做成异步链路弱依赖，这样强保出仓链路的稳定。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>optimize</tag>
      </tags>
  </entry>
  <entry>
    <title>Next主题添加音乐和将侧栏移动到左边</title>
    <url>/2018/01/12/next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90%E5%92%8C%E4%BE%A7%E6%A0%8F%E5%B7%A6%E7%A7%BB/</url>
    <content><![CDATA[<p>玩Github博客也有一个多月的时间了，现在这个博客也被我折腾的有点样子了，目前博客里添加了如下功能：<br>1.支持头像图片旋转，同时点击头像可以返回主页；<br>2.背景图片随机出现，而且墙内用户也可以顺利访问；<br>3.增加文章打分系统，觉得好可以给五星好评；<br>4.开放评论系统，无需注册直接评论；<br>5.添加了可视加载栏和公益404页面；<br>6.添加桌面小宠物和访客统计；<br>7.添加博客运行时间和代码橙色高亮；</p>
<p>目前欠缺的功能一个是“相册”，还有一个就是博客标题的加载方式希望更加高逼格。至于SEO和单独域名，我暂时还没有想去做，等将来再加上吧。而这篇文章里主要说的就是“博客添加音乐”和“侧栏左移”这两个事儿。</p>
<h2 id="博客添加音乐"><a href="#博客添加音乐" class="headerlink" title="博客添加音乐"></a>博客添加音乐</h2><p>Next主题添加网易云音乐不是一个很难的事儿，但是我发现对于非大陆的IP地址（比如我用的是公司VPN，香港IP），侧栏的网易云音乐就无法播放，而且打开博客页面就自动播放音乐这点对来访的用户来说，体验感觉是见仁见智。所以我打算把侧栏的网易云音乐撤掉，在“关于我”里单独放进音乐歌单。</p>
<p>若单独配置音乐同时不想被IP地址打扰的话可以使用由DIYgod所制作的APlayer。官方材料在这里：<a href="https://aplayer.js.org/docs/#/?id=options">https://aplayer.js.org/docs/#/?id=options</a> 。</p>
<p>要使用APlayer需要先在hexo根目录里安装插件：<code>npm install aplayer --save</code></p>
<p>安装插件OK了后，具体在文章里添加的语法就是：<br><img data-src="/images/aplayer2.png" alt="7牛云存储" title="好像跟aplayer的语句都会引发错误啊"></p>
<p>注意：如果lrc用的是这种URL形式，<code>hexo g</code>时请保持网络通畅，如果没有歌词，可以不用添加。</p>
<p>现在的世面上很少有在线提供歌曲MP3地址的网站了，很多都是下载mp3到本地，这里我推荐一个免费下载MP3的网站：<a href="https://www.tikitiki.cn/">https://www.tikitiki.cn</a> 。里面有QQ音乐、网易云音乐和酷狗的资源，基本上大陆没有被封杀的艺人作品都能在里面找到（抱歉了，陈升先生和黄耀明先生）。然后再搭配七牛云，把下载的MP3和封面图片上传到七牛云存储里，然后搭配提供的外网域名就可以填写MP3地址和封面地址了。如图：<br><img data-src="/images/7cow.png" alt="7牛云存储" title="MP3上传到七牛云存储"></p>
<p>如果想做一个歌单，也很简单，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;% aplayerlist %&#125;</span><br><span class="line">  &#123;</span><br><span class="line">   	<span class="string">&quot;autoplay&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  		<span class="string">&quot;showlrc&quot;</span>: <span class="number">3</span>,</span><br><span class="line">   	<span class="string">&quot;mutex&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">   	<span class="string">&quot;music&quot;</span>: [</span><br><span class="line">   	    &#123;</span><br><span class="line">   	        <span class="string">&quot;title&quot;</span>: <span class="string">&quot;歌曲名&quot;</span>,</span><br><span class="line">   	        <span class="string">&quot;author&quot;</span>: <span class="string">&quot;歌手名&quot;</span>,</span><br><span class="line">   	        <span class="string">&quot;url&quot;</span>: <span class="string">&quot;https://具体地址.mp3&quot;</span>,</span><br><span class="line">   	        <span class="string">&quot;pic&quot;</span>: <span class="string">&quot;https://封面图.jpg&quot;</span>,</span><br><span class="line">  		        <span class="string">&quot;lrc&quot;</span>: <span class="string">&quot;https://歌词.lrc&quot;</span>	#不愿意加歌词可以不写，注意逗号</span><br><span class="line">        &#125;,</span><br><span class="line">   	    &#123;</span><br><span class="line">    	        <span class="string">&quot;title&quot;</span>: <span class="string">&quot;歌曲名&quot;</span>,</span><br><span class="line">        	    <span class="string">&quot;author&quot;</span>: <span class="string">&quot;歌手名&quot;</span>,</span><br><span class="line">        	    <span class="string">&quot;url&quot;</span>: <span class="string">&quot;https://具体地址.mp3&quot;</span>,</span><br><span class="line">        	    <span class="string">&quot;pic&quot;</span>: <span class="string">&quot;https://封面图.jpg&quot;</span>,</span><br><span class="line">           	<span class="string">&quot;lrc&quot;</span>: <span class="string">&quot;https://歌词.lrc&quot;</span>		</span><br><span class="line">       	&#125;</span><br><span class="line">   	]</span><br><span class="line">  &#125;</span><br><span class="line">&#123;% endaplayerlist %&#125;</span><br></pre></td></tr></table></figure>

<p>不过我这个七牛云的账号比较挫，没有做https，只好用http了…</p>
<h2 id="把侧栏移动到左边"><a href="#把侧栏移动到左边" class="headerlink" title="把侧栏移动到左边"></a>把侧栏移动到左边</h2><p>博客自从安装了宠物之后，发现小宠物与侧栏重叠，看上去感觉很不友好，但是很奇怪，默认的宠物即使调整了botton依旧无法移动，所以我就想那就把整个侧栏移动到了左边，但是发现更改next主题的<code>_config.xml</code>里的“sidebar的position属性”发现并没有效果，后来经过一顿查找，找到了改成左侧栏的方法(适用于next 5.1.3版本)。</p>
<p>首先，先更改<code>\themes\next\source\css\_common\components\sidebar\sidebar.styl</code>，把第三行的<code>right</code>改成<code>left</code>,如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.<span class="property">sidebar</span> &#123;</span><br><span class="line">  <span class="attr">position</span>: fixed;</span><br><span class="line">  <span class="attr">left</span>: <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>保存之后，打开<code>\themes\next\source\js\src\motion.js</code>，把101行和167行的<code>paddingRight</code>全改成<code>paddingLeft</code>,同时找到类似如下的代码，并替换成如下代码:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sidebarToggleLine1st = <span class="keyword">new</span> <span class="title class_">SidebarToggleLine</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;.sidebar-toggle-line-first&#x27;</span>,</span><br><span class="line"> 	<span class="attr">status</span>: &#123;</span><br><span class="line">   	<span class="attr">arrow</span>: &#123;<span class="attr">width</span>: <span class="string">&#x27;50%&#x27;</span>, <span class="attr">rotateZ</span>: <span class="string">&#x27;45deg&#x27;</span>, <span class="attr">top</span>: <span class="string">&#x27;2px&#x27;</span>, <span class="attr">left</span>: <span class="string">&#x27;5px&#x27;</span>&#125;,</span><br><span class="line">   	<span class="attr">close</span>: &#123;<span class="attr">width</span>: <span class="string">&#x27;100%&#x27;</span>, <span class="attr">rotateZ</span>: <span class="string">&#x27;45deg&#x27;</span>, <span class="attr">top</span>: <span class="string">&#x27;5px&#x27;</span>, <span class="attr">left</span>: <span class="number">0</span>&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> sidebarToggleLine2nd = <span class="keyword">new</span> <span class="title class_">SidebarToggleLine</span>(&#123;</span><br><span class="line"> 	  <span class="attr">el</span>: <span class="string">&#x27;.sidebar-toggle-line-middle&#x27;</span>,</span><br><span class="line"> 	<span class="attr">status</span>: &#123;</span><br><span class="line">   	<span class="attr">arrow</span>: &#123;<span class="attr">width</span>: <span class="string">&#x27;90%&#x27;</span>&#125;,</span><br><span class="line">   	<span class="attr">close</span>: &#123;<span class="attr">opacity</span>: <span class="number">0</span>&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> sidebarToggleLine3rd = <span class="keyword">new</span> <span class="title class_">SidebarToggleLine</span>(&#123;</span><br><span class="line"> 	  <span class="attr">el</span>: <span class="string">&#x27;.sidebar-toggle-line-last&#x27;</span>,</span><br><span class="line"> 	<span class="attr">status</span>: &#123;</span><br><span class="line">   	<span class="attr">arrow</span>: &#123;<span class="attr">width</span>: <span class="string">&#x27;50%&#x27;</span>, <span class="attr">rotateZ</span>: <span class="string">&#x27;-45deg&#x27;</span>, <span class="attr">top</span>: <span class="string">&#x27;-2px&#x27;</span>, <span class="attr">left</span>: <span class="string">&#x27;5px&#x27;</span>&#125;,</span><br><span class="line">   	<span class="attr">close</span>: &#123;<span class="attr">width</span>: <span class="string">&#x27;100%&#x27;</span>, <span class="attr">rotateZ</span>: <span class="string">&#x27;-45deg&#x27;</span>, <span class="attr">top</span>: <span class="string">&#x27;-5px&#x27;</span>, <span class="attr">left</span>: <span class="number">0</span>&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>保存完毕之后，<code>hexo clean</code>和<code>hexo d -g</code>。刷新一下页面，就大功告成了！</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html#hcm=1515719347596232">https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html#hcm=1515719347596232</a> （这篇文章强烈推荐！）<br><a href="http://www.lmnsyunhao.cn/2017/03/29/hexo-next-themes-left-sidebar/">http://www.lmnsyunhao.cn/2017/03/29/hexo-next-themes-left-sidebar/</a><br><a href="http://mashirosorata.vicp.io/HEXO-NEXT%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE.html">http://mashirosorata.vicp.io/HEXO-NEXT主题个性化配置.html</a></p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>博客美化</tag>
      </tags>
  </entry>
  <entry>
    <title>order by limit走错了索引</title>
    <url>/2024/12/21/order-by-limit%E8%B5%B0%E9%94%99%E4%BA%86%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h2 id="问题和解决"><a href="#问题和解决" class="headerlink" title="问题和解决"></a>问题和解决</h2><p>今天看到这么一个sql：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select *</span><br><span class="line">from</span><br><span class="line">  restaurant_restaurant_unit this_</span><br><span class="line">where</span><br><span class="line">  this_.name LIKE &#x27;张三%&#x27;</span><br><span class="line">  and this_.restaurant_unit_type &lt;&gt; 2</span><br><span class="line">  and this_.is_valid = 1</span><br><span class="line">  and this_.status = 1</span><br><span class="line">order by</span><br><span class="line">  this_.created_at DESC </span><br><span class="line">limit</span><br><span class="line">  15;</span><br></pre></td></tr></table></figure>

<p>这个sql的执行时间竟然达到了令人发指的9s，这里补充一下前提知识：</p>
<ol>
<li>数据表有name的索引、<code>created_at</code>的索引，主建是id</li>
<li><code>is_valid</code>和<code>status</code>都可以视为有效状态</li>
<li><code>restaurant_unit_type</code>是节点类型，一共就3种:1是中间节点，2是叶子节点（绑定的门店），3是根节点。数据分布规模来说，2的数据远大于1和3.</li>
<li>sql查出来结果只有14条</li>
</ol>
<p>打开这个慢sql的工单，映入眼帘的第一个字符就是&lt;&gt;，果然数据库执行计划执行一下，结果如下：<br><img data-src="/images/%E6%85%A2sql1.png" title="走的是create_at的索引"></p>
<p>果然，走的是<code>create_at</code>的索引。开心的打开左边数据库信息，索引信息打开：<br><img data-src="/images/%E6%85%A2sql2.png"></p>
<p>结果<code>restaurant_unit_type</code>没有索引，<code>name</code>有索引，理论上是不会影响走<code>name</code>索引的呀。</p>
<p>既然不是&lt;&gt;导致的慢sql问题，那么到底是啥呢？凭借“菜就多练”的原则，我执行了下面几个和慢sql类似的执行计划:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sql1：去掉order by limit</span><br><span class="line">	select</span><br><span class="line">	  *</span><br><span class="line">	from</span><br><span class="line">	  restaurant_restaurant_unit this_</span><br><span class="line">	where </span><br><span class="line">	  this_.name &lt;&gt; &#x27;张三%&#x27;</span><br><span class="line">	  and this_.restaurant_unit_type &lt;&gt; 2</span><br><span class="line">	  and this_.is_valid = 1</span><br><span class="line">	  and this_.status = 1;</span><br></pre></td></tr></table></figure>

<p>执行计划：<br><img data-src="/images/%E6%85%A2sql3.png" title="这次走的是name的索引"></p>
<p>这次执行时间只有8ms，快了很多。比加上<code>order by limit</code>的有了重大提高。 看来是<code>order by limit</code>导致的？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sql2：去掉&lt;&gt;</span><br><span class="line">	select</span><br><span class="line">	  *</span><br><span class="line">	from</span><br><span class="line">	  restaurant_restaurant_unit this_</span><br><span class="line">	where </span><br><span class="line">	  this_.name like &#x27;张三%&#x27;</span><br><span class="line">	  -- and this_.restaurant_unit_type &lt;&gt; 2  //把这个条件注释掉</span><br><span class="line">	  and this_.is_valid = 1</span><br><span class="line">	  and this_.status = 1</span><br><span class="line">	order by</span><br><span class="line">	  this_.created_at DESC</span><br><span class="line">	limit</span><br><span class="line">	  15;</span><br></pre></td></tr></table></figure>
<p>执行计划：<br><img data-src="/images/%E6%85%A2sql4.png" title="这次走的是name的索引"><br>可以看到此时并不会走<code>name</code>索引，走了<code>create_at</code>的索引，执行时间虽然有所增加，但是也远远达不到9m的程度。最后只能咨询dba的同学,dba说：<code>where语句和order by limit语句中都包含了索引列时，mysql优化器可能会选择错误的索引导致更加慢</code>。</p>
<p>从上面的sql也能看出，加入<code>order by limit </code>后，索引从<code>name</code>变成了<code>create_at</code>。注意的是，只是可能慢，具体慢不慢得看数据的分布情况。</p>
<p>分析下上面的慢sql为啥是慢sql:</p>
<p>首先不带<code>order by limit</code>的sql执行计划如下：<br><img data-src="/images/%E6%85%A2sql3.png" title="这里关注row这一列"></p>
<p>之前更多关注走索引，其实还有一个关键量，扫描行数：<code>16810</code>。</p>
<p>这个值是mysql优化器认为走name索引需要扫描的行数，这个是正经索引下探方法得到的值，相对准确。</p>
<p>但是加入<code>order by limit A </code>后，此时存在了两个索引<code>create_at</code> 和 <code>name。 </code>对于优化器来说，其目标是选择扫描行数最少的索引是最佳的，所以需要计算<code>create_at</code>的扫描行数。 而这就是问题的关键：<code>order by limit A</code> 是如何计算扫描行的。计算公式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">统计信息里面的表行数/where语句索引的扫描行数 * limit的值A = 扫描行数</span><br></pre></td></tr></table></figure>
<p>根据这个公式：原理就是<code>统计信息里面的表行数/where语句索引的扫描行数</code> 就是mysql认为平均扫描一条数据的成本，再乘A就是A条数据的扫描成本。</p>
<p>首先获得统计信息里面的表行数：<code>2564001</code><br><img data-src="/images/%E6%85%A2sql5.png" title="这个表有250多万记录"></p>
<p>刚刚上面得到name索引的扫描行数：16810，而limit值为15，则计算得到：<code>2564001/16810*15 = 2287.9</code>。<br><img data-src="/images/%E6%85%A2sql1.png" title="这里关注row这一列"></p>
<p>这个值是远小于name索引的行，所以会走<code>create_at</code>索引。</p>
<p>但是为啥会慢呢？？？</p>
<p>原因就是因为前提说的，<code>restaurant_unit_type</code>是分布极其不均匀的。2是叶子节点为绑定的门店，都是先有叶子节点再有门店，所以叶子节点的<code>create_at</code>普遍较大，又是逆序遍历，所以基本上遍历到后面，甚至全表后才找到足够的数据。这也是为啥<code>restaurant_unit_type</code>去掉后能够较快返回的原因。</p>
<p>说了这么一大堆，咋解决呢？</p>
<p>其实问题分析下来，根本原因就是因为优化器错误的选择了<code>order by </code>后的索引嘛，那就不让他选嘛，所以就有如下的解决方案:</p>
<p>● 直接强force index 指定要走的索引  -》这个太粗暴了<br>● limit值扩大到上面的计算结果远大于where语句后的扫描 -》 开发阶段难以评估，且limit值大多数业务固定<br>● 不让order by 后面有索引。 –比较合理（实测有效）<br>	○	order by create DESC&#x2F;Asc —》order by create DESC&#x2F;ASC， id asc&#x2F;desc<br>	○	order by id  -》 order by id + 0</p>
<h2 id="另外一个参考文章"><a href="#另外一个参考文章" class="headerlink" title="另外一个参考文章"></a>另外一个参考文章</h2><p><code>order by limit</code>易走错索引，发生在<code>5.6/5.7/XDB</code>版本，这个是MYSQL设计时优化器不严谨的地方，原因如下:</p>
<ol>
<li><p>首先sql执行计划会把sql分成2部分，<code>select ...from...where...</code>作为第一部分，<code>order by...limit...</code>作为第二部分。先对<code>select ...from...where...</code>做分析，得出最佳路径<code>best_access_path</code>的索引<code>best_index</code>、扫描量<code>row_estimate_first</code>、pk的选择度<code>Cardinality_pk</code>。</p>
</li>
<li><p>当sql有<code>order by limit</code>，同时<code>limit的值&lt; best_access_path的row_estimate</code>，同时<code>order by</code>字段有单列索引或在联合索引最左列，触发执行计划<code>recheck(&quot;recheck_reason&quot;: &quot;low_limit&quot;)</code>。</p>
</li>
<li><p><code>recheck</code>后有可能选择<code>order by</code>字段的索引，如果选择了<code>order by</code>索引，同时数据分布不均匀或者实际符合条件的记录条数（即返回行数）小于limit值的话，那么就需要通过索引扫描所有的行回表，访问效率将比全表扫描还慢几倍。</p>
</li>
</ol>
<p>order by触发recheck具体算法如下：</p>
<ol>
<li><code>Cardinality_pk/row_estimate_first </code>获得<code>best_index</code>字段所选值平均每条记录的间距（扫描量）row_estimate_second（这里是优化器不严谨的地方，因为优化器直接认为数据是均匀分布的）</li>
<li>如果<code>row_estimate_second * limit值 &lt; row_estimate_first</code>,则选择<code>order by</code>字段索引，反之选择<code>best_access_path</code>索引<code>best_index</code></li>
</ol>
<p>怎么确认哪些<code>order by limit sql</code>会走错索引：</p>
<ol>
<li>对where条件的列数据量<code>group by</code>分析，确认记录最多的列值，这里记为value_a；记录limit的值，这里记为limit_b</li>
<li>去掉<code>order by limit</code>字段执行explain获取访问value_a的<code>best_access_path</code>索引的扫描量，这里记为<code>row_estimate_c</code></li>
<li>通过<code>show index from table_name</code>获取pk的选择度，这里记为Cardinality_d</li>
<li>如果<code>Cardinality_d/row_estimate_c*limit_b&lt;row_estimate_c</code>,即<code>Cardinality_d*limit_b&lt;row_estimate_c*row_estimate_c </code>就会触发走错索引。这里可以看出如果<code>best_access_path</code>索引访问的某个列值记录越多，即数据越不均匀，越容易触发走错索引。</li>
</ol>
<p>更快捷方式：因为value_a约等于row_estimate_c（有误差，一般2 * value_a &gt;&#x3D; row_estimate_c），方程式可以转换为：表记录数 * limit值 &lt; value_a * value_a，即只要知道表记录数，记录最多的列值，limit值，即可计算是否会走错索引（考虑误差和数据增长，建议当表记录数 * limit值 &lt; 4 * value_a * value_a即可认为会可能走错索引）。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>SRE</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>python3监控https证书过期时间</title>
    <url>/2019/07/17/python3%E7%9B%91%E6%8E%A7https%E8%AF%81%E4%B9%A6%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<p>上周日，我们的一个https证书到期了，结果运维没有事前检查到，导致服务中断，于是赶紧亡羊补牢一个python3的脚本：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python </span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># 作者：ChrisChan</span></span><br><span class="line"><span class="comment"># 用途：获取https证书的过期时间，需要先执行pip3 install pyopenssl</span></span><br><span class="line"><span class="keyword">from</span> urllib3.contrib <span class="keyword">import</span> pyopenssl <span class="keyword">as</span> reqs</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 公网验证</span></span><br><span class="line">cert = reqs.OpenSSL.crypto.load_certificate(reqs.OpenSSL.crypto.FILETYPE_PEM, reqs.ssl.get_server_certificate((<span class="string">&#x27;cn.imoulife.com&#x27;</span>, <span class="number">443</span>)))</span><br><span class="line"></span><br><span class="line">notafter = datetime.strptime(cert.get_notAfter().decode()[<span class="number">0</span>:-<span class="number">1</span>], <span class="string">&#x27;%Y%m%d%H%M%S&#x27;</span>)	<span class="comment">#获取到的时间戳格式是ans.1的，需要转换</span></span><br><span class="line">remain_days = notafter - datetime.now()	<span class="comment"># 用证书到期时间减去当前时间</span></span><br><span class="line"><span class="built_in">print</span>(remain_days.days)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 离线验证</span></span><br><span class="line"><span class="keyword">from</span> OpenSSL <span class="keyword">import</span> crypto</span><br><span class="line"></span><br><span class="line">cert_file = <span class="string">&#x27;F:\\crt文件的路径\\mycert.crt&#x27;</span></span><br><span class="line">cert2 = crypto.load_certificate(crypto.FILETYPE_PEM, <span class="built_in">open</span>(cert_file).read())</span><br><span class="line">cert2.get_version()</span><br><span class="line">subject = cert2.get_subject()</span><br><span class="line">subject.get_components()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;域名是：&quot;</span>,subject.CN)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;终止的时间戳是：&quot;</span>,cert2.get_notAfter())</span><br></pre></td></tr></table></figure></p>
<p>pyopenssl可以给与我们的https信息非常的丰富，除了到期时间之外，还有如下几个常用项：</p>
<ol>
<li>get_subject()：返回证书域名</li>
<li>get_version()：返回证书版本</li>
<li>get_issuer()：证书颁发机构</li>
</ol>
<p>更多信息可以去看 <a href="https://www.pyopenssl.org/en/stable/index.html">https://www.pyopenssl.org/en/stable/index.html</a> 官网介绍。</p>
<p>进一步加工后的脚本是:<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python </span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">from</span> urllib3.contrib <span class="keyword">import</span> pyopenssl <span class="keyword">as</span> reqs</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令行参数</span></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&#x27;本脚本获取https证书到期时间&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-w&#x27;</span>, <span class="string">&#x27;--www&#x27;</span>, metavar=<span class="string">&#x27;https网站,如cn.imoulife.com&#x27;</span>, required=<span class="literal">True</span>, dest=<span class="string">&#x27;sites&#x27;</span>,  nargs=<span class="string">&#x27;+&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;请一定要输入监控的https网站&#x27;</span>)  <span class="comment"># required表示此字段一定需要,nargs=’+’ 表&gt;示至少一个参数</span></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 公网验证</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_notafter</span>(<span class="params">www</span>):</span><br><span class="line">    cert = reqs.OpenSSL.crypto.load_certificate(reqs.OpenSSL.crypto.FILETYPE_PEM, reqs.ssl.get_server_certificate((www, <span class="number">443</span>)))</span><br><span class="line"></span><br><span class="line">    notafter = datetime.strptime(cert.get_notAfter().decode()[<span class="number">0</span>:-<span class="number">1</span>], <span class="string">&#x27;%Y%m%d%H%M%S&#x27;</span>)</span><br><span class="line">    remain_days = notafter - datetime.now()         <span class="comment"># 用证书到期时间减去当前时间</span></span><br><span class="line">    <span class="built_in">print</span>(www,<span class="string">&quot;证书到期天数是：&quot;</span>,remain_days.days)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">for</span> site <span class="keyword">in</span> args.sites:</span><br><span class="line">        get_notafter(site)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;出现错误，请检查域名是否正确或者可达性！&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>执行效果如下：<br><img data-src="/images/pyredis3.png" alt="抱光妹"></p>
<h2 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h2><p><a href="http://noops.me/?p=945">http://noops.me/?p=945</a> 这个小米的运维网站分享一个非常不错的shell脚本来监控证书，脚本如下：<br>	<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/sh</span></span><br><span class="line"> </span><br><span class="line">host=$1</span><br><span class="line">port=$2</span><br><span class="line">end_date=`openssl s_client -host $host -port $port -showcerts &lt;/dev/null 2&gt;/dev/null |</span><br><span class="line">          sed -n &#x27;/BEGIN CERTIFICATE/,/END CERT/p&#x27; |</span><br><span class="line">      openssl x509 -text 2&gt;/dev/null |</span><br><span class="line">      sed -n &#x27;s/ *Not After : *//p&#x27;`</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">openssl 检验和验证SSL证书。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt;/dev/null 定向标准输入，防止交互式程序Hang。从/dev/null 读时，直接读出0 。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sed -n 和p 一起使用，仅显示匹配到的部分。 //,// 区间匹配。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">openssl x509 -text 解码证书信息，包含证书的有效期。</span></span><br><span class="line"> </span><br><span class="line">if [ -n &quot;$end_date&quot; ]</span><br><span class="line">then</span><br><span class="line">    end_date_seconds=`date &#x27;+%s&#x27; --date &quot;$end_date&quot;`</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">date</span>指令format字符串时间。</span></span><br><span class="line">    now_seconds=`date &#x27;+%s&#x27;`</span><br><span class="line">    echo &quot;($end_date_seconds-$now_seconds)/24/3600&quot; | bc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p>上面那个有两个小地方可以改进下：<code>echo “HOST: test.com /r/n GET / HTTP/1.1″|openssl s_client -connect test.com:443</code> 这样可以增加速度，因为<code>openssl s_client</code>只负责链接，后面是请求内容如果不输入的话就是等待超时，时间会很长。而且增加一个参数<code>-servername</code>可一直开启<code>TLS SNI support</code>，可以检测一个ip多个证书的情况。</p>
<h2 id="其他监控证书的网站"><a href="#其他监控证书的网站" class="headerlink" title="其他监控证书的网站"></a>其他监控证书的网站</h2><p>如果不想用脚本监控可以用第三方网站监控，下面这三个网站方法都一样：就是填入自己的邮箱注册账户，然后在页面输入自己要监控的域名，然后会给你一个剩余时间，如果快到期了就会给你发邮件通知，这三个网站分别是：</p>
<ol>
<li>letsmonitor.org      	每小时检测一次，但是发送告警邮件只有一次</li>
<li>certificatemonitor.org   非常简单，只能443端口，一共会发9次邮件通知</li>
<li><a href="https://keychest.net/">https://keychest.net/</a>    它支持api，邮件每周一次发送，比较好</li>
</ol>
<p>详情可见<a href="https://www.sooele.com/2784.html">https://www.sooele.com/2784.html</a> 。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://flyhigher.top/develop/755.html">https://flyhigher.top/develop/755.html</a><br><a href="https://blog.skk.moe/post/checkssl-status/">https://blog.skk.moe/post/checkssl-status/</a><br><a href="https://blog.csdn.net/tzdjzs/article/details/28124609">https://blog.csdn.net/tzdjzs/article/details/28124609</a><br><a href="https://www.conum.cn/program/python/241.html">https://www.conum.cn/program/python/241.html</a> （pyopenssl的介绍）<br><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c13/p03_parsing_command_line_options.html">https://python3-cookbook.readthedocs.io/zh_CN/latest/c13/p03_parsing_command_line_options.html</a> (python命令行参数)</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>python3</tag>
        <tag>https证书</tag>
      </tags>
  </entry>
  <entry>
    <title>python不要轻易的去remove元素</title>
    <url>/2021/05/28/python%E4%B8%8D%E8%A6%81%E8%BD%BB%E6%98%93%E7%9A%84%E5%8E%BBremove%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>有一个笔试题，题目很简单就是“生成所有三位数的组合，其中每个数字范围是1到4，且三位数不能有重复”。</p>
<p>然后写出来这个代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">        <span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">            <span class="built_in">list</span>.append(<span class="string">f&#x27;<span class="subst">&#123;i&#125;</span>,<span class="subst">&#123;j&#125;</span>,<span class="subst">&#123;z&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">    <span class="keyword">if</span> x[<span class="number">0</span>] == x[<span class="number">2</span>] <span class="keyword">or</span> x[<span class="number">0</span>] == x[<span class="number">4</span>] <span class="keyword">or</span> x[<span class="number">2</span>] == x[<span class="number">4</span>]:</span><br><span class="line">        <span class="built_in">list</span>.remove(x)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">continue</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>

<p>说实话，这个代码写麻烦了，这是另外一回事，但是这个代码看上去是对的，但是其实跑出来是不对的。跑之后就会发现， ‘1,2,2’，’2,1,1’这样的记录还是会保留下来。</p>
<p>原因就出来<code>list.remove(x)</code>上，它会导致迭代器跳过元素：修改列表时，迭代器的索引会失效，导致部分元素未被检查。</p>
<p>举个例子，假设有一个列表[A, B, C, D]，当使用for循环遍历时，第一次迭代处理A，指针指向索引0。处理完后，指针移动到索引1处理B。如果此时删除了B，列表变为[A, C, D]，那么下一个元素应该是索引1的C，但指针已经移动到索引1，所以会跳过C，直接处理索引2的D，导致C未被处理。比如这个代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> my_list:</span><br><span class="line">    <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        my_list.remove(x)</span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: [1, 3, 4]（2 被删除，但 4 未被处理）</span></span><br></pre></td></tr></table></figure>

<ol>
<li>这个例子里，列表为 [1, 2, 3, 4]，迭代顺序为索引 0 → 1 → 2 → 3。</li>
<li>第一次迭代：处理 1（索引 0）。</li>
<li>第二次迭代：处理 2（索引 1）。</li>
<li>如果删除 2，列表变为 [1, 3, 4]。</li>
<li>此时迭代器的“下一个索引”仍为 2，但列表的索引已缩短。原本的 3 现在位于索引 1，但迭代器会跳到索引 2，导致 3 被跳过。</li>
<li>第三次迭代：处理 4（索引 2），而 3 未被处理</li>
</ol>
<p>所以比较好的解决方案是改成用一个新的list去append：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = []</span><br><span class="line">new_list = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">        <span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">            <span class="comment">#if i !=j and j != z and i !=z:</span></span><br><span class="line">            <span class="built_in">list</span>.append(<span class="string">f&#x27;<span class="subst">&#123;i&#125;</span>,<span class="subst">&#123;j&#125;</span>,<span class="subst">&#123;z&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">    <span class="keyword">if</span> x[<span class="number">0</span>] == x[<span class="number">2</span>] :</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;第1位和第二位有相同&quot;</span>,x[<span class="number">0</span>],x[<span class="number">2</span>],<span class="string">&quot;干掉！&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> x[<span class="number">0</span>] == x[<span class="number">4</span>]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;第1位和第三位有相同&quot;</span>,x[<span class="number">0</span>],x[<span class="number">4</span>],<span class="string">&quot;干掉！&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> x[<span class="number">2</span>] == x[<span class="number">4</span>]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;第二位和第三位有相同&quot;</span>,x[<span class="number">2</span>],x[<span class="number">4</span>],<span class="string">&quot;干掉！&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        new_list.append(x) </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (new_list)</span><br></pre></td></tr></table></figure>

<p>或者从后往前删除元素，避免索引前移。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(my_list)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> my_list[i] % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        my_list.pop(i)</span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: [1, 3]</span></span><br></pre></td></tr></table></figure>

<p>写此文章，记录一下，避免以后踩坑。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>列表</tag>
      </tags>
  </entry>
  <entry>
    <title>screen的用法</title>
    <url>/2017/12/21/screen%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>很多时候在Linux要后台执行程序，都是使用“&amp;”，或者是nohup，不过这两个更多应用于临时的脚本。一个比较高科技的方法就是使用<code>screen</code>。</p>
<p>安装screen的方法很简单：<code>yum install -y screen</code>。</p>
<p>如果新建一个screen，就输入<code>screen -S name</code>，这样会新开一个窗口，然后执行命令。比如我要启动django，那么就输入<code>python manage.py runserver 0.0.0.0:9000</code>即可。</p>
<p>这个重开一个窗口，列出所有screen进程，就这样：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@docker ~]# screen -ls</span><br><span class="line"><span class="title class_">There</span> are screens <span class="attr">on</span>:</span><br><span class="line">	<span class="number">3029.</span><span class="title function_">xiedi</span>	(<span class="title class_">Attached</span>)</span><br></pre></td></tr></table></figure></p>
<p>如果想链接上之前那个django，执行命令<code>screen -r 3029</code>即可。</p>
<p><img data-src="/images/kobe.png" alt="goodbye,Kobe" title="kobe vs durant"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>其他软件</tag>
      </tags>
  </entry>
  <entry>
    <title>pictest</title>
    <url>/2017/12/13/pictest/</url>
    <content><![CDATA[<p>这是一个我用来测试图片上传的文章</p>
<span id="more"></span>

<p>啊！五环，你比四环多一环！<br>啊！五环，你比六环少一环！<br><img data-src="/images/1.gif" alt="akb48" title="天气妹儿"><br>终于有一天，你会修到七环</p>
<p><img data-src="/images/paradin.jpg" alt="paradin" title="SQ"></p>
]]></content>
      <categories>
        <category>用来保护视力的图片</category>
      </categories>
      <tags>
        <tag>美女</tag>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title>python包和模块</title>
    <url>/2018/05/26/python%E5%8C%85%E5%92%8C%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="包和模块的概念"><a href="#包和模块的概念" class="headerlink" title="包和模块的概念"></a>包和模块的概念</h2><p>当前目录结构为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ tree .</span><br><span class="line">--------</span><br><span class="line">.</span><br><span class="line">└── mypackage</span><br><span class="line">    └── mymodule.py</span><br></pre></td></tr></table></figure>
<p>mypackage是一个文件夹，就是一个包。mymodule.py是一个python文件，就是一个模块。所以简单来说，一个包就是一个文件夹，一个模块就是一个.py文件。其中mymodule.py内容为：<code>print(&#39;I am mymodule.py&#39;)</code>。</p>
<h2 id="运行python"><a href="#运行python" class="headerlink" title="运行python"></a>运行python</h2><p>那么运行方式1：（指定文件路径）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python3 mypackage/mymodule.py</span><br><span class="line">I am mymodule.py</span><br></pre></td></tr></table></figure>
<p>运行方式2：（使用-m参数）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python3 -m mypackage.mymodule</span><br><span class="line">I am mymodule.py</span><br></pre></td></tr></table></figure>
<p>方式1简单粗暴，指定python文件路径，将其作为可执行文件执行，是执行入口文件。方式2则使用包的概念，执行mypackage这个包里面的mymodule这个模块，依然是将<code>mymodule.py</code>作为执行入口文件。</p>
<p>补充说明1：使用方式2，需要搜索包和模块， 搜索包和模块的顺序是（查找是否有mypackage的包和mymodule这个模块）<br>1.	builtin<br>	a.系统内置包和模块中<br>2.	sys.path<br>	a.当前目录下<br>	b.PYTHONPATH这个环境变量目录下<br>	c.Python的安装目录下的site_packages中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ tree .</span><br><span class="line">.</span><br><span class="line">└── mypackage</span><br><span class="line">    └── __main__.py</span><br><span class="line">    </span><br><span class="line">$ cat mypackage/__main__.py</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;I am __main__.py&#x27;</span>)</span><br><span class="line"></span><br><span class="line">$ python3 -m mypackage</span><br><span class="line">I am __main__.py</span><br></pre></td></tr></table></figure>


<p>补充说明2：<br>若-m后面只有一个参数， 比如 <code>python3 -m xxx</code><br>1.	优先将xxx理解为包，若该包下有<code>__main__.py</code>文件，则理解为 <code>python3 -m xxx.__main__</code><br>2.	否则将xxx理解为模块，若当前目录下有<code>xxx.py</code>, 则理解为 <code>python3 xxx.py</code><br>3.	以上两种都不是，则报错。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ tree .</span><br><span class="line">.</span><br><span class="line">└── mymodule.py</span><br><span class="line"></span><br><span class="line">$ cat mymodule.py</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;I am mymodule.py&#x27;</span>)</span><br><span class="line"></span><br><span class="line">$ python3 -m mymodule</span><br><span class="line">I am mymodule.py</span><br></pre></td></tr></table></figure>


<p>总结：【-m的用法】仅仅是比【直接指定路径用法】多个一个【去系统搜索】的步骤而已，其他无区别。</p>
<h2 id="入口文件和模块文件"><a href="#入口文件和模块文件" class="headerlink" title="入口文件和模块文件"></a>入口文件和模块文件</h2><p>上面描述的两种运行方式，<code>mymodule.py</code>都是入口文件，而其他python文件就是模块文件了。每次运行，只能有一个文件是入口文件。</p>
<p>若一个文件是入口文件，那么这个<code>.py</code>文件中的<code>__name__</code> 就是 <code>__main__</code>。<br>若一个文件不是入口文件，比如被别的<code>.py</code>文件引用，那么<code>__name__</code>就是<code>包名.模块名</code>。</p>
<h2 id="模块文件如何被导入？"><a href="#模块文件如何被导入？" class="headerlink" title="模块文件如何被导入？"></a>模块文件如何被导入？</h2><p>既然其他文件就是模块文件了，那么其他模块怎么运行呢? 需要被入口文件导入。导入有三类:</p>
<h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ tree .</span><br><span class="line">--------</span><br><span class="line">.</span><br><span class="line">├── mainmodule.py</span><br><span class="line">└── mypackage</span><br><span class="line">    └── mymodule.py</span><br><span class="line">-----------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">$ cat mainmodule.py</span><br><span class="line">-------------------</span><br><span class="line"><span class="keyword">import</span> mypackage</span><br><span class="line">-----------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ cat mypackage/mymodule.py</span><br><span class="line">---------------------------</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;I am mymodule&#x27;</span>)</span><br><span class="line">-----------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ python3 mainmodule.py</span><br><span class="line">-----------------------</span><br></pre></td></tr></table></figure>

<p>这样<code>python3 mainmodule.py</code>就执行成功了， 没有报错，但也没有发生任何事情。<br>注意：<br>● mainmodule.py所在的目录非常关键，它代表了顶层包的上一层目录。<br>● 其实导入包并没有任何意义，因为不会发生任何变化，后续你导入模块依然要填写包名。<br>● 那么为什么导入包语法没错呢，其实它默认导入的还是模块，叫做__init__.py模块，这样的话就相当于实现了导入模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ tree .</span><br><span class="line">--------</span><br><span class="line">.</span><br><span class="line">├── mainmodule.py</span><br><span class="line">└── mypackage</span><br><span class="line">    ├── __init__.py</span><br><span class="line">    └── mymodule.py</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ cat mainmodule.py</span><br><span class="line">-------------------</span><br><span class="line"><span class="keyword">import</span> mypackage <span class="comment"># 相当于默认执行 import mypackage.__init__</span></span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ cat mypackage/__init__.py</span><br><span class="line">---------------------------</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;I am __init__.py&#x27;</span>)</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ cat mypackage/mymodule.py</span><br><span class="line">---------------------------</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;I am mymodule&#x27;</span>)</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ python3 mainmodule.py</span><br><span class="line">-----------------------</span><br><span class="line">I am __init__.py</span><br></pre></td></tr></table></figure>

<p>此时你会发现mypackage&#x2F;<strong>init</strong>.py中的代码被自动执行了，其实也就是导入__init__这个模块了。<br>另外解释一下什么是导入，导入一个模块，就是把该模块中的代码从头到尾执行一遍。</p>
<p>导入一个模块成员，就是声明一下这个模块中的 函数，类，变量等成员，后面可以直接用。比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ tree .</span><br><span class="line">--------</span><br><span class="line">.</span><br><span class="line">├── mainmodule.py</span><br><span class="line">└── mypackage</span><br><span class="line">    ├── __init__.py</span><br><span class="line">    └── mymodule.py</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">$ cat mainmodule.py</span><br><span class="line">-------------------</span><br><span class="line"><span class="keyword">import</span> mypackage <span class="comment"># 相当于默认执行 import mypackage.__init__</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a = &#x27;</span> + <span class="built_in">str</span>(mypackage.a))</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ cat mypackage/__init__.py</span><br><span class="line">---------------------------</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;I am __init__.py&#x27;</span>)</span><br><span class="line">a = <span class="number">100</span></span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ cat mypackage/mymodule.py</span><br><span class="line">---------------------------</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;I am mymodule&#x27;</span>)</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ python3 mainmodule.py</span><br><span class="line">-----------------------</span><br><span class="line">I am __init__.py</span><br><span class="line">a = <span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>但是import mypackage 和 import mypackage.<strong>init__还是有点区别的。区别在于import mypackage是隐式导入__init</strong>，所以调用的时候，你不能直接使用__init__这个模块名，也就是直接用mypackage.a而不是mypackage.<strong>init</strong>.a</p>
<p>当然__init__.py也可以像其他普通模块一样被显式导入，行为和同普通模块是一样的。</p>
<p>另外 import mypackage的语法，由于没有导入模块，所以你用的所有模块都必须带上mymodule这个前缀。</p>
<h3 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h3><p>导入模块的语法是<code>import 包名.模块名</code>。很简单，举个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ tree .</span><br><span class="line">.</span><br><span class="line">├── mainmodule.py</span><br><span class="line">└── mypackage</span><br><span class="line">    ├── __pycache__</span><br><span class="line">    │   └── mymodule.cpython-<span class="number">312.</span>pyc</span><br><span class="line">    └── mymodule.py</span><br><span class="line">    </span><br><span class="line">$ cat mainmodule.py</span><br><span class="line"><span class="keyword">import</span> mypackage.mymodule</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a=&#x27;</span> + <span class="built_in">str</span>(mypackage.mymodule.a))</span><br><span class="line"></span><br><span class="line">$ cat mypackage/mymodule.py</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;I am mymodule&#x27;</span>)</span><br><span class="line">a = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">$ python3 mainmodule.py</span><br><span class="line">I am mymodule</span><br><span class="line">a=<span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>很简单，<code>mainmodule.py</code>中导入了<code>mypackage.mymodule</code>,所以可以引用其中的a变量。</p>
<p>不过如果包层级太多，比如<code>mypackage.mymodule</code>太长了，所以可以一步到位，直接导入模块，比如<code>from mypackage import mymodule</code>，这样的话，直接用<code>mymodule.a</code>就可以了,这种语法就是 <code>from 包名 import 模块名</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mypackage <span class="keyword">import</span> mymodule</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a=&#x27;</span> + <span class="built_in">str</span>(mymodule.a))</span><br></pre></td></tr></table></figure>

<p>这样的话，效果和刚才是一样的。</p>
<p>另外，如果<code>mypackage</code>目录下有很多模块，可以一下子都导入吗？可以的，用<code>*</code>代替就可以了。<br>不过有个前提，就是<code>mypackage</code>目录下要有个<code>__init__.py</code>, 且内容定义了<code>__all__ = [&#39;mymodule&#39;, &#39;mymodule2&#39;, &#39;mymodule3&#39;]</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ tree .</span><br><span class="line">.</span><br><span class="line">├── mainmodule.py</span><br><span class="line">└── mypackage</span><br><span class="line">    ├── __init__.py</span><br><span class="line">    └── mymodule.py</span><br><span class="line"></span><br><span class="line">$ cat mainmodule.py</span><br><span class="line"><span class="keyword">from</span> mypackage <span class="keyword">import</span> *</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a=&#x27;</span> + <span class="built_in">str</span>(mymodule.a))</span><br><span class="line"></span><br><span class="line">$ cat mypackage/__init__.py</span><br><span class="line">__all__ = [<span class="string">&#x27;mymodule&#x27;</span>]</span><br><span class="line"></span><br><span class="line">$ cat mypackage/mymodule.py</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;I am mymodule&#x27;</span>)</span><br><span class="line">a = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">$ python3 mainmodule.py</span><br><span class="line">I am mymodule</span><br><span class="line">a=<span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>不过 <strong>all</strong> 不能指定为*，从而导入所有包，也是为了保护不被滥用吧。另外也不能 <code>from mypackage import *</code>。</p>
<h3 id="导入成员"><a href="#导入成员" class="headerlink" title="导入成员"></a>导入成员</h3><p>上面说的是导入包，导入模块，接下来还可以导入成员，这个成员是指模块成员，也就是函数，类，变量等。</p>
<p>注意，成员的导入:<code>from 包名.模块名 import 成员名</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ tree .</span><br><span class="line">.</span><br><span class="line">├── mainmodule.py</span><br><span class="line">└── mypackage</span><br><span class="line">    └── mymodule.py</span><br><span class="line"></span><br><span class="line">$ cat mainmodule.py</span><br><span class="line"><span class="keyword">from</span> mypackage.mymodule <span class="keyword">import</span> a</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a=&#x27;</span> + <span class="built_in">str</span>(a))</span><br><span class="line"></span><br><span class="line">$ cat mypackage/mymodule.py</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;I am mymodule&#x27;</span>)</span><br><span class="line">a = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">$ python3 mainmodule.py</span><br><span class="line">I am mymodule</span><br><span class="line">a=<span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>导入成员之后，引用的时候就不要加命名空间了（也就是包名.模块名），直接用成员名就可以了。注意可以 <code>from mymoudle import *</code>,  此时<code>*</code>默认是所有，若<code>mymodule.py</code>中有<code>__all__</code>变量，那么就以<code>__all__</code>为准。</p>
<p>所以总结一下。</p>
<p>导入包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.import mypackage  # 等价于 import mypackage.__init__，备注：只要涉及包都会自动隐式导入这个</span><br></pre></td></tr></table></figure>
<p>导入模块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.import mypackage.mymodule</span><br><span class="line">b.from mypackage import mymodule</span><br><span class="line">c.from mypackage import *  # 若存在__init__.py且存在__all__变量，则导入__all__所指定；否则 无</span><br></pre></td></tr></table></figure>
<p>导入成员</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.from mypackage.mymodule import member1， member2，member3 # 可以用括号或者反斜杠跨行</span><br><span class="line">b.from mypackage.mymodule import *  # 若mymodule存在__all__变量，则导入__all__所指定；否则 所有</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh连接port22:Socket error Event:32 Error:10053</title>
    <url>/2018/03/07/ssh%E8%BF%9E%E6%8E%A5port22-Socket-error-Event-32-Error-10053/</url>
    <content><![CDATA[<p>今天遇到了一个奇怪的现象，据开发人员反馈，有一台阿里云服务器在控制台重启了之后，发现无法登陆了。我先使用阿里云的控制台打算远程登陆到这台机器发现，远程登陆总是显示密码错误。然后我使用xshell登陆对应的外网IP和22端口的时候发现爆出如下的错误：<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Connecting</span> to X.<span class="property">X</span>.<span class="property">X</span>.<span class="property">X</span>:<span class="number">22.</span>..</span><br><span class="line"><span class="title class_">Connection</span> established.</span><br><span class="line"><span class="title class_">To</span> <span class="built_in">escape</span> to local shell, press <span class="string">&#x27;Ctrl+Alt+]&#x27;</span>.</span><br><span class="line"></span><br><span class="line"><span class="title class_">Socket</span> error <span class="title class_">Event</span>: <span class="number">32</span> <span class="title class_">Error</span>: <span class="number">10053.</span></span><br><span class="line"><span class="title class_">Connection</span> closing...<span class="title class_">Socket</span> close.</span><br><span class="line"></span><br><span class="line"><span class="title class_">Connection</span> closed by foreign host.</span><br></pre></td></tr></table></figure></p>
<p>这种情况很罕见，google了一下也没有对于我有用的处理办法，于是我就只好给阿里云后台发了一下工单。授权给阿里云让他们登陆一下这台机器看一下里面发生了什么，阿里云的售后人员过了一会打过电话过来说，发现这台机器里面有人操作了<code>chmod -R 777 /</code>，破坏了比如<code>/etc/passwd</code>和<code>/etc/shadow</code>的权限，所以会爆出这样的错误。如图：<br><img data-src="/images/7771.png" alt="paradin"></p>
<p>阿里的售后说他们也把几个跟登陆有关的文件暂时恢复权限，这样这个机器就可以成功登陆了，如图：<br><img data-src="/images/7772.png" alt="paradin"> </p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>python报错：importError: No module named bz2</title>
    <url>/2018/05/12/python%E6%8A%A5%E9%94%99%EF%BC%9A&#39;importError-No-module-named-bz2&#39;/</url>
    <content><![CDATA[<p>每日统计阿里云同步延迟的邮件早就编写完毕了，现在要放到专门跑脚本的服务器里，进去到这个服务器里发现这个机器已经被人装了两个python，分别是python 2.7.5（默认路径）和python 2.7.13（路径是<code>/usr/local/python/bin/python</code>），说实话我个人不太明白这么做的原因何在。</p>
<p>但是既然已经被人搞成这样了，那就适应环境吧，把脚本拷贝过来，把依赖库都安装好，但是在执行<code>matplotlib</code>的库的时候，爆了一个错误：<code>ImportError: No module named bz2</code>。</p>
<p>这就是因为两个python，但是启动的那个python文件夹里面是没有<code>bz2.so</code>这个文件的，于是就需要把系统里默认的2.7.5的<code>bz2.so</code>拷贝到2.7.13的lib路径里。</p>
<p>首先<code>find / -name bz2.so</code>找一下文件，如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@dvl-stun-<span class="number">002</span> <span class="variable constant_">GETDTS</span>]# find / -name bz2.<span class="property">so</span></span><br><span class="line">/usr/local/aegis/<span class="title class_">PythonLoader</span>/lib/python2<span class="number">.7</span>/lib-dynload/bz2.<span class="property">so</span></span><br><span class="line">/usr/local/aegis/<span class="title class_">SecureCheck</span>/lib/python2<span class="number">.7</span>/lib-dynload/bz2.<span class="property">so</span></span><br><span class="line">/usr/lib64/python2<span class="number">.7</span>/lib-dynload/bz2.<span class="property">so</span></span><br></pre></td></tr></table></figure></p>
<p>然后<code>cd /usr/local/python/lib/python2.7/</code>，把<code>/usr/lib64/python2.7/lib-dynload/bz2.so</code>复制到这个文件夹里即可。<br><img data-src="/images/rubio3kill.gif" alt="paradin"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>现役亚洲足球明星排名</title>
    <url>/2025/05/25/%E2%80%9C%E7%8E%B0%E5%BD%B9%E4%BA%9A%E6%B4%B2%E8%B6%B3%E7%90%83%E6%98%8E%E6%98%9F%E5%89%8D%E5%8D%81%E6%8E%92%E5%90%8D%E2%80%9D/</url>
    <content><![CDATA[<p>本文提到的球员都是现役的，他们的生涯其实很多都还没有盖棺定论，说不定日后被大球队看中捞去拿下欧冠，那么这个排名就会有大的变化。我这个排名是依据“当前的荣誉再加上一点点对未来的贷款”，仅仅是个人意见。</p>
<p><img data-src="/images/%E4%BA%9A%E6%B4%B2%E7%90%83%E5%91%98%E8%BA%AB%E4%BB%B7.webp" alt="paradin" title="2024年年末的亚洲球员身价top10"></p>
<p>其实伊藤杨辉、铃木彩艳、佐野海舟等人的实力也非常的强，但是他们不是本赛季受伤就是职业生涯还刚刚开始，积累的荣誉和经典时刻还不多。至于克瓦拉茨赫利亚，他的祖国古鲁吉亚跟俄罗斯一样，国土虽然大部分在亚洲，但是他本人是参加欧洲杯的，所以不算亚洲球员。</p>
<h2 id="第十一名-胡桑诺夫"><a href="#第十一名-胡桑诺夫" class="headerlink" title="第十一名 胡桑诺夫"></a>第十一名 胡桑诺夫</h2><p>他3500万转会曼城后，2月份成了曼城队内的最佳球员。但是后来不知道啥原因又上不了场，不过后防球员在瓜手下往往第一年其实都过的比较挣扎，比如罗德里等人都是第二年才踢出来感觉的。所以我可以接受再给他一年的时间，毕竟他才21岁。但是他成为曼城后防大腿的可能性我觉得不会太高，格瓦迪奥尔目前看才是曼城的防线大腿。他若能稳定跟着曼城走，不掉链子的话，个人天赋也算是兑现了。希望胡桑诺夫不要被曼城早早优化，对得起我个人对他的期望。</p>
<h2 id="第十名-铃木彩艳"><a href="#第十名-铃木彩艳" class="headerlink" title="第十名 铃木彩艳"></a>第十名 铃木彩艳</h2><p>虽然他是混血儿，但是他是日本国籍，所以也就是第一个能在意甲踢首发门将的东亚人。虽然中国网友笑话他是“日本奥纳纳”，但是这位日本奥纳纳的状态最近越来越好，身价也到达了1400万欧元。他也在逼平尤文图斯的比赛里拿下了全场最佳球员，整个赛季下来零封7场，扑救100次，扑救成功率65.4%，都是不错的表现。虽然帕尔马不是强队，在本赛季最后一轮3-2击败了亚特兰大才完成了保级，这只是铃木彩艳第一个意甲赛季，下个赛季他肯定会越来越好。<br><img data-src="/images/%E9%93%83%E6%9C%A8%E5%BD%A9%E8%89%B3.gif" alt="paradin" title="对阵罗马时候神奇两连扑"></p>
<h2 id="第九名-黄喜灿"><a href="#第九名-黄喜灿" class="headerlink" title="第九名  黄喜灿"></a>第九名  黄喜灿</h2><p>黄喜灿的新合同是狼队顶薪的水平，可见他在队内是大腿级别的待遇了。他今年英超拿下13个进球3个助攻，累计为狼队出场超过100次，进球数在狼队历史上已经进top10了。他速度非常快，当年在红牛队的时候跟哈兰德和南野拓实大杀四方。后来到了狼队，以前跟内托搭档后来换成了和库尼亚配合，都是狼队撕开对手防线的利器。他是一个勤奋的球员，第一次射门不中后马上上抢再发起二次进攻是他进球的一个主要手段。他是韩国球员一步一个脚印旅欧的典范，19岁就出国踢球，球风也非常的欧洲范儿。当年亚运会夺冠几乎是他一路得分，让全队免除兵役。当然，他的缺点也很明显，踢球的时候手上动作比较大，而且我觉得他好像对中国人不算太友好。</p>
<h2 id="第八名-富安健洋"><a href="#第八名-富安健洋" class="headerlink" title="第八名 富安健洋"></a>第八名 富安健洋</h2><p>tomi如果是健康的话，那么他的能力肯定不止这个位置，他能踢三后卫也能踢四后卫，场均抢断和高空拦截都是队内前列。可惜他不争气的身体偏偏在合同年膝盖大伤，伤后功力还存有多少真的让人难以预测，辜负了阿尔特塔对他的期待。健康的他绝对可以镇守住阿森纳的一条边，毕竟他在有限的出场时间里表现过高光时刻，联赛里单防住C罗，在世界杯也跟萨内比过赛跑，实力绝对没个说。但是富安健洋论个人能力肯定是不如金玟哉的，富安健洋也在意甲踢过，他没拿到意甲最佳后卫，他也没进入最后的金球奖30人大名单。富安健洋还有一点很可惜，就是他一直没有亚洲杯，团队荣誉除了一个社区盾杯就没啥东西了，这一点对他来说太伤了。最后希望tomi能够早日满血复活。<br><img data-src="/images/%E5%AF%8C%E5%AE%89%E5%81%A5%E6%B4%8B.gif" alt="paradin" title="他是第9位在英超进球的日本球员"></p>
<h2 id="第七名-塔雷米"><a href="#第七名-塔雷米" class="headerlink" title="第七名 塔雷米"></a>第七名 塔雷米</h2><p>塔雷米是一个大器晚成的球员，他在波尔图是大腿的表现，进球如麻，2022年世界杯面对英格兰虽然输了2-6，但是那两个球都是他进的，在2019年亚洲杯，他成了中国队后防的噩梦。31岁高龄的他第一次登陆五大联赛，也是国际米兰第一位伊朗球员，他是这个赛季国米唯一一个所有赛事都参与进球的球员，这个记录看上去很好，但是其实一共只参与9个进球，可以说除了欧冠半决赛之外都并不让人满意。塔雷米工资还不低，被国米球迷吐槽是“除了造点球之外，这人没啥用”。但是毕竟国米现在在备战欧冠决赛，要是真的拿下了对面巴黎，塔雷米就是伊朗第一个拿到欧冠的球员，只是以后国米可能就不再会轻易买葡超来的人了。</p>
<h2 id="第六名-李刚仁"><a href="#第六名-李刚仁" class="headerlink" title="第六名 李刚仁"></a>第六名 李刚仁</h2><p>李刚仁之前在法国超级杯决赛里拿过全场最佳球员，他在本赛季虽然新闻不多，但是其实他的出场时间比上个赛季还多了300多分钟，sofascore的评分到达了7.34的高分。他是恩里克战术体系很重要的一环，能打边路和中路的他是典型的西班牙风格，喜欢前场自由人踢无球，相比较射门，他更喜欢传威胁球，是一个弱版的维蒂尼亚。他的能力足够在五大联赛中游队伍做前场核心，据说阿森纳和曼联都对他很有兴趣，我个人觉得他真要走的话，去曼联的出场机会会更稳定，更有利于他的职业生涯发展，但是我还是觉得恩里克不会轻易放走他。现在孙哥逐渐走到了职业生涯的末期，韩国队需要他来扛大旗，目前看他扛起来还挺费劲的，但是结合他的能力和年轻的客观优势，这里排名第六。</p>
<h2 id="第五名-镰田大地"><a href="#第五名-镰田大地" class="headerlink" title="第五名 镰田大地"></a>第五名 镰田大地</h2><p>记得水晶宫拿下足总杯之后，范志毅在社媒说了一句“我们是冠军”，但是毕竟他那时候的水晶宫只是一个英甲和英冠的球队，说这话被苛责的球迷批评是在蹭流量。这句话应该放在退役以后的镰田大地来说，他是第一个拿到足总杯的日本球员。kamada是进攻中非常重要的一环，虽然他本赛季在英超没有进球助攻（在杯赛2进球3助攻），但是在这个榜单里他在五大联赛里进球仅次于孙兴慜，累计44个进球33个助攻，十足的数据怪。他速度不快但是配合意识和前插意识很强，而且骚的是他的任意球和角球主罚质量很高。镰田大地之前在法兰克福拿下了欧联杯（其中两回合5:4击败了哈维的巴萨，镰田大地他们很好的限制了特劳雷和登贝莱）和德国杯（德国杯他没进大名单），也有单场帽子戏法和任意球直接破门的高光表现，技术弱点就是单干能力不行，简单说他就是一个弱版的京多安。他跟久保建英不太兼容，森保一没办法只能牺牲他。镰田本人也一直有一个跟大球队打欧冠的心，但是自身实力只能在中游球队打出来，所以也算是一个小小的无奈。<br><img data-src="/images/%E9%95%B0%E7%94%B0%E5%A4%A7%E5%9C%B0.webp" alt="paradin" title="散步仙人，冠军赢家"></p>
<h2 id="第四名-远藤航"><a href="#第四名-远藤航" class="headerlink" title="第四名 远藤航"></a>第四名 远藤航</h2><p>endo的实力和武士精神有目共睹，他在克洛普的重用下拼下了联赛杯冠军，赛后发布会上克洛普对他各种赞美之词，利物浦球迷也唱歌“切尔西有enzo,我们有endo”。而在斯洛特手下他不再是主力，出场时间锐减，但是要注意，他的时间其实是随着赛程而慢慢增多的，他自己接受采访也说“斯洛特就是需要我锁分的”，所以说今年的英超冠军绝对有他的一份功劳（这个联赛冠军是他人生的第一个联赛冠军）。这个夏天随着维尔茨的加盟，endo可能会离开利物浦，给利物浦回收大约500万左右的资金。不过以他的口碑和能力，留在英超问题不大，但是去阿森纳的话，阿森纳虽然走了若日尼奥但是基本搞定了苏维门迪。去曼联接班卡塞米罗呢，曼联基本不怎么跟利物浦做生意。所以这俩队伍就基本去不了了。切尔西也不需要他。endo已经32岁了，估计再踢2～3年就会离开五大联赛了，只要这几年endo还能在英超稳住一定的出场时间，那么他的历史地位肯定不会低。而且他本人也是我的偶像，低调勤奋但是又很聪明，用赛场上的表现让那些说他“只会犯规延缓对面进攻和卡位造犯规”的黑子和瞎子们闭嘴。</p>
<iframe src="//player.bilibili.com/player.html?isOutside=true&aid=113899563123697&bvid=BV12QfUYBEdE&cid=28108001014&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>

<h2 id="第三名-金玟哉"><a href="#第三名-金玟哉" class="headerlink" title="第三名 金玟哉"></a>第三名 金玟哉</h2><p>为啥我把金玟哉放在endo前面，因为他在那不勒斯那一年的表现真的很高光，入选了赛季最佳阵容不说，还在同年金球奖评选排名22，是30人大名单里和迪亚斯唯二的后卫，他也是第一个拿到意甲冠军的韩国人，狠狠打了杜威等中国足球工作者的脸。金玟哉在拜仁这两年并不完美，不少拜仁球迷把去年被皇马淘汰的锅扣在他身上。金玟哉他自己说远程兵役对他影响很大，也有自身水平下滑的问题，不过其实最大的原因就是拜仁对他的过度使用上。再加上中国媒体很喜欢挖苦韩国人，凡是说韩国不好的新闻优先安排上热搜，所以大家对他的贡献都是低估的，有跟风黑的嫌疑。但是说来说去他兜里毕竟有两个主力的联赛冠军，而且高光的时候很高光，所以排名还是要压endo一点点的。</p>
<h2 id="第二名-三笘薰"><a href="#第二名-三笘薰" class="headerlink" title="第二名 三笘薰"></a>第二名 三笘薰</h2><p>三球王这个赛季一共11个球，其中英超10个球，打破了自己的最好记录也创造了日本球员在英超联赛的新纪录。他登陆英超3年了，24+16的数据已经比黄喜灿要好了（黄喜灿是24+7，黄喜灿比他多半年。风格相似的曼城多库是11+17，但是时间比他少一半）。他的第一脚触球、盘带和突破依旧非常犀利，也是本赛季全英超加速跑次数最多的球员。但是这个赛季三球王已经被对手有针对性的防守了，暴露了射门天赋比较差的缺点。而且三球王年纪也不小了，身体不算耐操，能维持这个水平到31～32岁已经算很厉害。我当年是希望他能来巴萨的，现在看已经是不可能，传闻他要去拜仁（拜仁打算凑齐一套东亚全明星），也有说曼联要买他来替代要走人的加纳乔。无论去哪，三球王都值得去欧冠看看。考虑到他是进攻球员，天然比防守球员有点优势，而且将来也有几率去了大球会，所以微微领先金玟哉一丢丢。<br><img data-src="/images/%E4%B8%89%E7%90%83%E7%8E%8B%E6%9C%80%E4%BD%B3%E8%BF%9B%E7%90%83.gif" alt="paradin" title="这个进球成了2425赛季最佳进球的候选"></p>
<h2 id="第一名-久保建英"><a href="#第一名-久保建英" class="headerlink" title="第一名 久保建英"></a>第一名 久保建英</h2><p>相比较三球王是边路爆点，久保建英则是进攻核心，而且他也能过人，昨天在莫德里奇的告别战里他全场7次过人成功，本场比赛最多。而且久保建英目前还不满23，所以算上年轻的贷款，他的排名比三球王高。但是属于他的时间我个人觉得不多了，他需要尽快有一个质的飞跃，把数据稳定在15+5。去年就传闻他要去利物浦，但是只是谣传而已。他跟李刚仁一样，身体不搞大但是也不怕对抗。把自己尽快提升成一个S级别的球星，对日本队是一个巨大的帮助。</p>
<h2 id="第零名-孙兴慜"><a href="#第零名-孙兴慜" class="headerlink" title="第零名 孙兴慜"></a>第零名 孙兴慜</h2><p>毫无疑问，sonny是毫无争议的亚洲一哥，就算拉上那些退役的人一起来比，他的成绩都完全不虚任何人，所以他是第零名！细想一下，将来如果有人要超越孙哥，那么他至少要是以球队主力的身份赢下“欧冠冠军or联赛冠军”，且自己有一个mvp或者金靴，且金球奖排名要进前10，这个成绩妥妥的就是国际巨星的成绩单了。孙哥今年饱受伤病，本赛季只进了11球是他个人在热刺生涯的最低值，但是热刺久旱逢甘露拿下了欧联杯，而且下赛季还有可能去争夺一个欧洲超级杯，希望孙哥好好恢复，届时再冲一下这个冠军。<br><img data-src="/images/%E5%AD%99%E5%85%B4%E6%85%9C.webp" alt="paradin" title="以孙哥对热刺的贡献，立个碑不过分吧"></p>
<p>文章写完后发现，本文出现的球员可以正好打一个3-4-3阵容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">三笘薰   塔雷米   孙兴慜</span><br><span class="line">李刚仁  镰田大地  久保建英</span><br><span class="line">           远藤航</span><br><span class="line">胡桑诺夫   金玟哉    富安健洋</span><br><span class="line">     铃木彩艳</span><br><span class="line"></span><br><span class="line">替补坐着 黄喜灿</span><br></pre></td></tr></table></figure>

<p>这个阵容，我觉得在英超保级，问题应该不大。</p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>足球</tag>
        <tag>亚洲</tag>
      </tags>
  </entry>
  <entry>
    <title>yum提示Error: rpmdb open failed</title>
    <url>/2018/01/24/yum%E6%8F%90%E7%A4%BAError-rpmdb-open-failed/</url>
    <content><![CDATA[<p>今天在一台机器里，使用<code>yum</code>安装的时候，出现了如下的故障：<br><img data-src="/images/yum1.png" alt="akb48"></p>
<p>这种情况就是RPM数据库被破坏了，这个时候就需要我们重建数据库，于是就输入如下的命令：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cd / <span class="keyword">var</span> / lib / rpm /</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">` ls | grep &#x27;db.&#x27; `</span> ; <span class="keyword">do</span> mv $i $i .<span class="property">bak</span> ; done</span><br><span class="line">rpm -- rebuilddb</span><br><span class="line">yum clean all</span><br></pre></td></tr></table></figure></p>
<p>重新<code>cleanup</code>就正常了。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>yum</tag>
      </tags>
  </entry>
  <entry>
    <title>rdb的持久化导致线上故障</title>
    <url>/2024/02/01/rdb%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%BC%E8%87%B4%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C/</url>
    <content><![CDATA[<p>这几天在做优化，把应用与rdb超时时间从200ms下降到了50ms。结果rdb在那个时候恰巧出发了aof持久化，整个持久化的过程持续了1.7s，导致线上故障。<br><img data-src="/images/rdb%E6%95%85%E9%9A%9C2.png" alt="akb48" title="cpu达到了99%"><br><img data-src="/images/rdb%E6%95%85%E9%9A%9C3.png" alt="akb48" title="出现了大量的jedis错误"></p>
<p>rdb持久化的过程是什么？这里可以看redis的官方文档：<a href="https://redis.com.cn/redis-persistence.html">https://redis.com.cn/redis-persistence.html</a> 和 <a href="https://redisbook.readthedocs.io/en/latest/internal/aof.html">https://redisbook.readthedocs.io/en/latest/internal/aof.html</a> 。这里可以看出aof是持久化效果最好的方法，但是它依赖文件的大小，aof文件越大，耗时越久。如果关闭了aof，那么rdb就成了一个memcache，断电了而且备库也断电了，那数据就没了。</p>
<p>一般来说1.7s的aof耗时不算是很久，而且每个实例的aof操作其实也挺频繁的，平均20分钟不到就一次，但是aof期间主进程是不工作的，导致这个redis集群执行aof的实例在这个阶段不能正常接受服务请求，但是我们的代码里有两个配置放大了这个情况，进而出现了故障。</p>
<p>第一：我们的服务有重试机制，即如果rdb超时，就会重试3次。后来我们决定这里的重试取消掉，交易链路么，重试非常容易埋雷。<br>第二：我们发现这1.7s时间内写请求飙升，经分析是由于写请求是sku维度的(exhset)，读请求是item维度(exhmget)，按照平均sku数量，重试的写请求相比读请求有10+的放大系数。再叠加之前的重试3次。导致雪崩。</p>
<p>通过这个故障，我们通过复盘也发现了我们一些当前链路不合理的地方，比如“这个redis品仓关系专用的，不应该直接影响下单成功率，考虑后续解耦策略”。</p>
<p>其次是阿里云在选择redis的时候看到的qps是最基础的qps，比如我这个集群，说是能扛住384万qps，但是这个384万是压测512字节的key和value得到的。而在实际的业务开发场景里，key和value的大小是远远大于512字节的，所以实际qps是不够的。这里需要SRE同学帮忙来拿线上比较真实的key-value去压测一下真实的qps水平。<br><img data-src="/images/rdb%E6%95%85%E9%9A%9C1.png" alt="akb48" title="购买rdb的时候，他的qps只是一个极度乐观的参考值"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>一个批量部署脚本（未完成）</title>
    <url>/2019/04/12/%E4%B8%80%E4%B8%AA%E6%89%B9%E9%87%8F%E9%83%A8%E7%BD%B2%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="脚本设计"><a href="#脚本设计" class="headerlink" title="脚本设计"></a>脚本设计</h2><p>首先安装ansible，并且用group1,group2…对相同模块的服务器进行分组，注意！group1只能是一台服务器，剩下的服务器均摊。</p>
<p>按模块依赖顺序输入，模块名称用逗号分隔。进行for循环，先使用ansible对group1进行部署工作，部署模块并且启动之后，暂停600秒，让开发利用这10分钟检查日志和配置项是否有问题，如果有问题就ctrl+c，在暂停600秒的同时，脚本新开一个进程A，paramiko到第一台服务器里，检查日志是否出现ERROR等关键字样，如果有就输出，600秒结束之后，关闭线程A，继续部署group2，直至名单里所有的模块都部署完毕。</p>
<p>作画的意思如下：<br><img data-src="/images/multiprocessing1.png" alt="akb48"></p>
<h2 id="用python去实现tailf功能"><a href="#用python去实现tailf功能" class="headerlink" title="用python去实现tailf功能"></a>用python去实现tailf功能</h2><p>在shell下执行<code>tail -f</code>就是一句话的事，但是用python实现则需要一个脚本了，内容如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">watch</span>(<span class="params">fn, words</span>):</span><br><span class="line">    fp = <span class="built_in">open</span>(fn, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        new = fp.readline()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> new:</span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">                <span class="keyword">if</span> word <span class="keyword">in</span> new:</span><br><span class="line">                    <span class="keyword">yield</span> (word, new)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">fn = <span class="string">&#x27;文件路径&#x27;</span></span><br><span class="line">words = [<span class="string">&#x27;关键词&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> hit_word, hit_sentence <span class="keyword">in</span> watch(fn, words):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;发现关键词 %r 在日志里: %r&quot;</span> % (hit_word, hit_sentence)</span><br></pre></td></tr></table></figure></p>
<h2 id="python实现线程通信"><a href="#python实现线程通信" class="headerlink" title="python实现线程通信"></a>python实现线程通信</h2><p>假设我们有一个函数叫AAA，希望脚本能开两个线程，线程A是等待5秒，线程B是不断的执行AAA（），直到5秒结束，线程B也停止线程AAA（）。那么脚本如下：</p>
<h2 id="按行读取文件取各种集合"><a href="#按行读取文件取各种集合" class="headerlink" title="按行读取文件取各种集合"></a>按行读取文件取各种集合</h2><p>python对于两个字典求交集（&amp;），差集（-），全集（|）比较简单，而对于两个文件按行取集合的方法如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">s1 = <span class="built_in">set</span>(<span class="built_in">open</span>(<span class="string">r&#x27;C:\Users\33664\Desktop\aaa.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>).readlines())</span><br><span class="line">s2 = <span class="built_in">set</span>(<span class="built_in">open</span>(<span class="string">r&#x27;C:\Users\33664\Desktop\bbb.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>).readlines())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;交集是: %s&#x27;</span> % (s1.intersection(s2)))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;并集是: %s&#x27;</span> % (s1.union(s2)))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;差集是: %s&#x27;</span>%(s1.difference(s2)))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;dif: %s&#x27;</span>%(s1.difference(s2).union(s2.difference(s1))))</span><br></pre></td></tr></table></figure></p>
<h2 id="的问题"><a href="#的问题" class="headerlink" title="_的问题"></a>_的问题</h2><p>有些python脚本在for循环里会有这样的代码：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line">	<span class="built_in">print</span> (<span class="string">&quot;我想放假，我想放假&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>这里面的独立_其实没有特殊的意义，仅仅是是用作一个名字，来表示某个变量是临时的或无关紧要的。</p>
<p>不过_还有其他的用途，它可以展示最近的一次表达式的结果，比如：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">20</span> + <span class="number">3</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(_)</span><br><span class="line"><span class="number">23</span></span><br></pre></td></tr></table></figure></p>
<h2 id="额外补充"><a href="#额外补充" class="headerlink" title="额外补充"></a>额外补充</h2><p>1.tailf命令主动停止命令：<code>tail -f 目标日志|sed &#39;/启动成功/Q&#39; </code>，此语句会在”启动成功”打印时退出，但log只能打印到”启动成功”的上一行；<br>2.<code>subprocess.call(&quot;命令1&quot;)</code>，命令1是按顺序执行的，效果等同于<code>subprocess.Popen(&quot;命令1&quot;).wait()</code>；<code>subprocess.Popen(&quot;命令2&quot;)</code>，命令2是与前一个命令并发进行的；  </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://stackoverflow.com/questions/1703640/how-to-implement-a-pythonic-equivalent-of-tail-f">https://stackoverflow.com/questions/1703640/how-to-implement-a-pythonic-equivalent-of-tail-f</a><br><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c12/p03_communicating_between_threads.html">https://python3-cookbook.readthedocs.io/zh_CN/latest/c12/p03_communicating_between_threads.html</a><br><a href="https://stackoverflow.com/questions/22698754/subprocess-calls-are-they-done-in-parallel/22698825#22698825">https://stackoverflow.com/questions/22698754/subprocess-calls-are-they-done-in-parallel/22698825#22698825</a><br><img data-src="/images/%E6%89%8B%E5%88%80%E7%A7%92%E9%A5%BF%E7%8B%BC.gif" alt="akb48" title="琦玉与饿狼的第一次会面"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次排查cpu飙高的问题</title>
    <url>/2025/05/23/%E2%80%9C%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%8E%92%E6%9F%A5cpu%E9%A3%99%E9%AB%98%E7%9A%84%E9%97%AE%E9%A2%98%E2%80%9D/</url>
    <content><![CDATA[<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>今天发现一个集群里的某一台机器CPU涨了很多。如图：<br><img data-src="/images/cpu%E4%B8%8A%E6%B6%A8.png" alt="paradin" title="流量没变化，sys和user都上涨了很多"></p>
<p>爬到容器里，<code>top -Hp 对应的PID</code>看了一下，里面是很多个线程都CPU很高：<br><img data-src="/images/cpu%E4%B8%8A%E6%B6%A82.png" alt="paradin" title="好几个线程"></p>
<p>跑到宿主机里一看，整个宿主机cpu和load都有上涨：<br><img data-src="/images/cpu%E4%B8%8A%E6%B6%A84.png" alt="paradin" title="时间也吻合，所以可见是容器带高了整体宿主机"></p>
<p>从宿主机的监控看，这个容器的cpi也上涨：<br><img data-src="/images/cpu%E4%B8%8A%E6%B6%A85.png" alt="paradin" title="CPI 是衡量CPU性能的指标，表示执行一条指令所需的平均时钟周期数"></p>
<p>同时发现这个容器的younggc频率没变化，但是gc耗时比以前明显多了很多：<br><img data-src="/images/cpu%E4%B8%8A%E6%B6%A83.png" alt="paradin" title="gc耗时上涨的时刻跟cpu上涨时刻吻合"></p>
<p>由于频率没变化，但是耗时上涨，我怀疑可能是内存出了问题，导致现在每一次gc的时候更加消耗cpu了，于是<code>sudo dmesg -T |grep -i &quot;Hardware Error&quot;</code>，果然容器在对应的时刻附近有内存硬件的报警：<br><img data-src="/images/cpu%E4%B8%8A%E6%B6%A86.png" alt="paradin" title="看到大量的mce告警"></p>
<p>于是将这个容器进行了置换，置换后的ip再看CPU和load都恢复了正常。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>其实一个集群里某一个机器出了问题，是比较难查的。因为那么多机器没问题，唯独你有问题，那么就要想哪些地方是这个机器跟其他同集群里机器不同。可以从以下几个方面排查解决：</p>
<ol>
<li>这个机器遇到了一个很特殊的参数，比如我们曾经见过一个很奇葩的商品，里面好几万的sku和子品。唯独流量走到了这个机器上，当这个应用的逻辑处理的时候，暴露了逻辑上问题，所以要结合时间去业务的日志里查。</li>
<li>容器的底层出了问题，看看网络重传率，对比宿主机其他的容器系统情况，使用dmesg定位，然后需要宿主机的同学进一步配合排查。如果容器进行置换之后，问题解决更可以说明是宿主机的问题。</li>
<li>可以跟其他的机器进行对比：对比线程使用cpu的细节，对比内存里都存了啥，对比流量是不是跟其他容器的流量有不同，但是这种有点大海捞针，比较费时间。</li>
</ol>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>CPU</tag>
        <tag>问题定位</tag>
      </tags>
  </entry>
  <entry>
    <title>一个监控挂载盘的python脚本</title>
    <url>/2018/02/27/%E4%B8%80%E4%B8%AA%E7%9B%91%E6%8E%A7%E6%8C%82%E8%BD%BD%E7%9B%98%E7%9A%84python%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>公司产品线有一个公用的挂载盘，主要是用来方便各位开发人员去放置他们自己的一些工作材料，比如异常的日志或者<code>tcpdump</code>的抓包等等杂七杂八的东西，但是这个挂载盘由于使用人众多，容量自然要有监控，于是就有了写这个脚本的动机。</p>
<p>在这里我写了两个脚本，上面这个是用来监控磁盘容量，然后通过<code>df -h</code>的排序生成前十名占容量最大的文件夹，把这个文件夹的名字和对应的大小重定向到一个叫<code>alarm.txt</code>这个文件里，这个文件就是邮件正文。然后在确定他们的主人，统一加上公司邮箱后缀来得到他们主人的邮箱地址，最后对应他们各自的邮箱地址用下面那个脚本来发送文件夹容量过高的邮件。</p>
<h2 id="监控挂载盘的脚本"><a href="#监控挂载盘的脚本" class="headerlink" title="监控挂载盘的脚本"></a>监控挂载盘的脚本</h2><pre><code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/usr/</span>bin/env python</span><br><span class="line"># coding=utf-<span class="number">8</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">AutoMail</span></span><br><span class="line"><span class="keyword">import</span> commands</span><br><span class="line"></span><br><span class="line">#设定变量判断是否挂载和挂载盘的容量</span><br><span class="line">mount = commands.<span class="title function_">getoutput</span>(<span class="string">&quot;mount | grep &#x27;:.*nfs&#x27;|wc -l&quot;</span>)</span><br><span class="line">size = commands.<span class="title function_">getoutput</span>(<span class="string">&quot;df -h | grep share | awk &#x27;&#123;print $5&#125;&#x27; | cut -d &#x27;%&#x27; -f 1&quot;</span>)</span><br><span class="line"> </span><br><span class="line">##建立发邮件的文本文件</span><br><span class="line">def <span class="title class_">Createalarm</span>():</span><br><span class="line">    <span class="keyword">if</span> os.<span class="property">path</span>.<span class="title function_">exists</span>(<span class="string">&#x27;/root/chenscript/alarm.txt&#x27;</span>) == <span class="title class_">True</span>:	</span><br><span class="line">        os.<span class="title function_">system</span>(<span class="string">&quot;python /root/chenscript/weixin_sharealarm.py&quot;</span>)</span><br><span class="line">        <span class="title function_">print</span> (<span class="string">&quot;微信告警已经发送！&quot;</span>)</span><br><span class="line">        os.<span class="title function_">system</span>(<span class="string">&quot;cd /root/chenscript; echo &#x27;share盘容量大于80%，现在将调出容量排名前十位的文件夹名字及对应的容量，请各位处理一下不需要的文件！&#x27; &gt;/root/chenscript/alarm.txt&quot;</span>)</span><br><span class="line">       	os.<span class="title function_">system</span>(<span class="string">&quot;cd /挂载盘名称 ;du -s * --exclude=&#x27;不想要计算在内的文件夹&#x27; --exclude=&#x27;不想要计算在内的文件夹&#x27; --exclude=&#x27;不想要计算在内的文件夹&#x27;|sort -nr |head &gt;&gt;/root/chenscript/alarm.txt&quot;</span>)</span><br><span class="line">        os.<span class="title function_">system</span>(<span class="string">&quot;echo &#x27;\n&#x27; &gt;&gt; /root/chenscript/alarm.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> os.<span class="property">path</span>.<span class="title function_">exists</span>(<span class="string">&#x27;/root/chenscript/alarm.txt&#x27;</span>) == <span class="title class_">False</span>:</span><br><span class="line">        os.<span class="title function_">system</span>(<span class="string">&quot;cd /root/chenscript;touch alarm.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">def <span class="title class_">Sendmail</span>():</span><br><span class="line">        fp = <span class="title function_">open</span>(<span class="string">&#x27;/root/chenscript/alarm.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">        content = fp.<span class="title function_">read</span>()</span><br><span class="line">        <span class="title class_">AutoMail</span>.<span class="title function_">send_mail</span>(<span class="string">&#x27;share挂载盘容量大于80%！收到邮件的各位请整理自己对应的文件夹！&#x27;</span>, content)</span><br><span class="line"> </span><br><span class="line">#将邮件的文件刷新</span><br><span class="line">def <span class="title class_">Dellist</span>():</span><br><span class="line">        os.<span class="title function_">system</span>(<span class="string">&quot;cd /root/chenscript/;rm -f alarm.txt;touch alarm.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> mount == <span class="string">&#x27;1&#x27;</span> and size &gt;= <span class="string">&#x27;80&#x27;</span>:</span><br><span class="line">        <span class="title function_">print</span> (<span class="string">&quot;挂载盘存在！&quot;</span>)</span><br><span class="line">        <span class="title function_">print</span> (<span class="string">&quot;share盘容量大于80%...&quot;</span>)</span><br><span class="line">        <span class="title class_">Createlist</span>()</span><br><span class="line">        <span class="title class_">Sendmail</span>()</span><br><span class="line">        <span class="title class_">Dellist</span>()</span><br><span class="line">elif mount == <span class="string">&#x27;1&#x27;</span> and size &lt; <span class="string">&#x27;80&#x27;</span>:</span><br><span class="line">        <span class="title function_">print</span> (<span class="string">&quot;挂载盘存在！&quot;</span>)</span><br><span class="line">        <span class="title function_">print</span> (<span class="string">&quot;share盘容量正常...&quot;</span>)</span><br><span class="line"><span class="attr">else</span>:</span><br><span class="line">       	<span class="title function_">print</span> (<span class="string">&quot;挂载盘不存在，现在重新挂载...&quot;</span>)</span><br><span class="line">       	os.<span class="title function_">system</span>(<span class="string">&quot;mount -t nfs -o acl,rw,intr,soft,nolock,rsize=8192,wsize=8192 10.160.43.172:/share /share &quot;</span>)</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="发送告警邮件脚本"><a href="#发送告警邮件脚本" class="headerlink" title="发送告警邮件脚本"></a>发送告警邮件脚本</h2><pre><code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/usr/</span>bin/env python</span><br><span class="line">#coding=utf-<span class="number">8</span></span><br><span class="line">#这个脚本的用途是用来发送邮件</span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> email.<span class="property">mime</span>.<span class="property">multipart</span> <span class="keyword">import</span> <span class="title class_">MIMEMultipart</span></span><br><span class="line"><span class="keyword">from</span> email.<span class="property">mime</span>.<span class="property">text</span> <span class="keyword">import</span> <span class="title class_">MIMEText</span></span><br><span class="line"><span class="keyword">from</span> email.<span class="property">mime</span>.<span class="property">application</span> <span class="keyword">import</span> <span class="title class_">MIMEApplication</span></span><br><span class="line"></span><br><span class="line">mailto_list=[]    #这里为空list，会从list.<span class="property">txt</span>里一行一行的当做元素添加进来</span><br><span class="line"></span><br><span class="line">#生成list.<span class="property">txt</span></span><br><span class="line"><span class="keyword">if</span> os.<span class="property">path</span>.<span class="title function_">exists</span>(<span class="string">&#x27;/root/chenscript/list.txt&#x27;</span>) == <span class="title class_">True</span>:</span><br><span class="line">        os.<span class="title function_">system</span>(<span class="string">&quot;cd /挂载盘名称;du -s * --exclude=&#x27;不想要计算在内的文件夹&#x27; --exclude=&#x27;不想要计算在内的文件夹&#x27; --exclude=&#x27;不想要计算在内的文件夹&#x27;|sort -nr |head|awk \&#x27;&#123;print $2\&quot;@dahuatech.com\&quot;&#125;\&#x27;  &gt;&gt;/root/chenscript/list.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> os.<span class="property">path</span>.<span class="title function_">exists</span>(<span class="string">&#x27;/root/chenscript/list.txt&#x27;</span>) == <span class="title class_">False</span>:</span><br><span class="line">        os.<span class="title function_">system</span>(<span class="string">&quot;cd /root/chenscript/;rm -f list.txt;echo &#x27;本人的邮箱地址&#x27;&gt;list.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="title function_">open</span>(<span class="string">&#x27;/root/chenscript/list.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> <span class="attr">f</span>:</span><br><span class="line">    f=f.<span class="title function_">readlines</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="attr">f</span>:</span><br><span class="line">        i=i.<span class="title function_">strip</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        mailto_list.<span class="title function_">append</span>(i)</span><br><span class="line">mail_host=<span class="string">&quot;这里填写邮箱主机&quot;</span></span><br><span class="line">mail_user=<span class="string">&quot;这里填写发送人的邮箱地址&quot;</span></span><br><span class="line">mail_pass=<span class="string">&quot;发送人的邮箱密码&quot;</span></span><br><span class="line">mail_postfix=<span class="string">&quot;dahuatech.com&quot;</span></span><br><span class="line">mail_sender=<span class="string">&quot;与mail_host内容相同&quot;</span></span><br><span class="line">def <span class="title function_">send_mail</span>(sub, content):</span><br><span class="line">    me=mail_sender	</span><br><span class="line">    msg = <span class="title class_">MIMEMultipart</span>()</span><br><span class="line">    msg[<span class="string">&#x27;Subject&#x27;</span>] = sub</span><br><span class="line">    msg[<span class="string">&#x27;From&#x27;</span>] = me</span><br><span class="line">    msg[<span class="string">&#x27;To&#x27;</span>] = <span class="string">&quot;;&quot;</span>.<span class="title function_">join</span>(mailto_list)</span><br><span class="line">    content1 = <span class="title class_">MIMEText</span>(<span class="title function_">str</span>(content), <span class="string">&#x27;plain&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    msg.<span class="title function_">attach</span>(content1)</span><br><span class="line">    <span class="attr">try</span>:</span><br><span class="line">        s = smtplib.<span class="title function_">SMTP</span>()</span><br><span class="line">        s.<span class="title function_">connect</span>(mail_host)</span><br><span class="line">        s.<span class="title function_">login</span>(mail_user,mail_pass)</span><br><span class="line">        s.<span class="title function_">sendmail</span>(me, mailto_list, msg.<span class="title function_">as_string</span>())</span><br><span class="line">        <span class="title function_">print</span>(<span class="string">&#x27;发送成功！\n&#x27;</span>)</span><br><span class="line">        s.<span class="title function_">close</span>()</span><br><span class="line">    except <span class="title class_">Exception</span> <span class="keyword">as</span> <span class="attr">e</span>: <span class="title function_">print</span>(<span class="title function_">str</span>(e))</span><br><span class="line"></span><br><span class="line">os.<span class="title function_">system</span>(<span class="string">&quot;cd /root/chenscript/;rm -f list.txt;echo &#x27;我本人的邮件地址&#x27;&gt;list.txt&quot;</span>)</span><br></pre></td></tr></table></figure>
</code></pre>
<p>执行的效果如下：<br><img data-src="/images/gaojingmail1.png" alt="paradin"></p>
<h2 id="隐藏的知识点"><a href="#隐藏的知识点" class="headerlink" title="隐藏的知识点"></a>隐藏的知识点</h2><p>1）<code>du -s</code>是按照字节来统计，<code>--exclude=&#39;yunwei&#39;</code>是在排序的时候忽略掉<code>yunwei</code>这个文件夹，容后再用<code>sort -nr|head</code>是得到从大到小前10名，如果得到后10名就是<code>sort -nr|tail</code>；<br>2）如果使用的是<code>import commands</code>，那么<code>commands.getoutpu</code>t得到的是字符串！<br>3）用<code>mount | grep &#39;:.*nfs&#39;</code>来判断挂载盘是否存在是一个很简单的方式，如果挂了多个，就用<code>ip in</code>的方式来进一步判断；<br>4）python要一行一行的读取文件，就<code>readline</code>；<br>5）python按行读取文件，去掉换行符<code>\n</code>的方法：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> file.<span class="title function_">readlines</span>():</span><br><span class="line">    line=line.<span class="title function_">strip</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><br>6）<code>import Automail</code>的时候，就已经把<code>Automail.py</code>这个脚本固定住了，这时候<code>mailto_list</code>已经不能变化了，所以要把添加<code>list.txt</code>放到这个脚本里。<br><img data-src="/images/gaojingmail2.png" alt="paradin"></p>
<p>发了邮件，连吼带骂一顿，终于把share盘容量下降到了69这样一个美妙的数字…</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>一个连接两个文件的python脚本</title>
    <url>/2018/01/26/%E4%B8%80%E4%B8%AA%E8%BF%9E%E6%8E%A5%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84python%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="背景交代"><a href="#背景交代" class="headerlink" title="背景交代"></a>背景交代</h1><p>公司在阿里云上有一个模块叫mrs，一共120台，它是跟云录像有关的，这个服务一直都是云服务器里没有公网但是购买了公网SLB，然后20个为一组配置到一个SLB里，这个SLB是按流量收费的。但是最近到了年末，各种账目审核，领导发现这个SLB的费用太惊人了，这么搞不够挣的。但是实在没办法，因为云录像嘛，肯定流量很大，如图：<br><img data-src="/images/mrs1.png"></p>
<p>纵然流量大，但是开源节流也是必须的，于是领导就责令开发赶快想出一个办法，减少SLB的费用。于是开发们拉上运维就吭哧吭哧的开始算经济账，最后确定每一个云服务器买7M带宽，然后流量全部走公网，把SLB的架构舍弃掉。</p>
<p>但是开发在这个模块V2.0里有一个变化，就是Zookeeper需要读取到每一台设备的外网IP，同时这个外网IP必须跟机器是一一对应的，这样模块才能正常工作。</p>
<p>原来的zookeeper在servermap是长这样的：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">&quot;内网IP&quot;</span>] = &#123;app = <span class="string">&quot;mrs&quot;</span>, weight = <span class="number">100</span>&#125;,</span><br><span class="line">[<span class="string">&quot;内网IP&quot;</span>] = &#123;app = <span class="string">&quot;mrs&quot;</span>, weight = <span class="number">100</span>&#125;,</span><br><span class="line">[<span class="string">&quot;内网IP&quot;</span>] = &#123;app = <span class="string">&quot;mrs&quot;</span>, weight = <span class="number">100</span>&#125;,</span><br><span class="line">剩下略</span><br></pre></td></tr></table></figure></p>
<p>而现在开发要求改成这样：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">&quot;内网IP&quot;</span>] = &#123;app = <span class="string">&quot;mrs&quot;</span>,mrsReportIp = <span class="string">&quot;对应的外网IP&quot;</span>,weight = <span class="number">100</span>&#125;,</span><br><span class="line">[<span class="string">&quot;内网IP&quot;</span>] = &#123;app = <span class="string">&quot;mrs&quot;</span>,mrsReportIp = <span class="string">&quot;对应的外网IP&quot;</span>,weight = <span class="number">100</span>&#125;,</span><br><span class="line">[<span class="string">&quot;内网IP&quot;</span>] = &#123;app = <span class="string">&quot;mrs&quot;</span>,mrsReportIp = <span class="string">&quot;对应的外网IP&quot;</span>,weight = <span class="number">100</span>&#125;,</span><br><span class="line">剩下略</span><br></pre></td></tr></table></figure></p>
<p>那么这就要把两个文件合并起来了，而且是在合并后做到一对一，不能把IP搭配串了。</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>首先，阿里云的网页控制台是无法做到“包年包月的服务器批量永久升级基础带宽”的，只能通过API实现。那么开启了外网IP之后，服务器就会有一个对应的外网IP地址，然后在控制台里，点击“导出资源列表”，只选择<code>服务器名称</code>、<code>内网IP</code>和<code>外网IP</code>。<br><img data-src="/images/mrs2.png"></p>
<p>然后在生成的excel表格里，剪除掉不需要的服务器以及服务器名称，然后保证“内网IP”在前，“外网IP”在后的样式，而且不要服务器名只保留IP,然后把这个文件复制到linux里，起个名，比如叫<code>IP.txt</code>,如图：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@paas-online-crs-<span class="number">001</span> tmp]# cat <span class="variable constant_">IP</span>.<span class="property">txt</span></span><br><span class="line"><span class="number">10.161</span><span class="number">.236</span><span class="number">.231</span>	<span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span></span><br><span class="line"><span class="number">10.161</span><span class="number">.235</span><span class="number">.150</span>  <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span></span><br><span class="line"><span class="number">10.51</span><span class="number">.10</span><span class="number">.182</span>	<span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span></span><br><span class="line"><span class="number">10.117</span><span class="number">.219</span><span class="number">.72</span>   <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br></pre></td></tr></table></figure></p>
<p>再把已经使用的zookeeper复制一下，放到一个叫<code>mingdan.txt</code>的文件里，如图：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@paas-online-crs-<span class="number">001</span> tmp]# cat mingdan.<span class="property">txt</span></span><br><span class="line">[<span class="string">&quot;10.117.219.72&quot;</span>] = &#123;app = <span class="string">&quot;mrs&quot;</span>, weight = <span class="number">100</span>&#125;,</span><br><span class="line">[<span class="string">&quot;10.161.235.150&quot;</span>] = &#123;app = <span class="string">&quot;mrs&quot;</span>, weight = <span class="number">100</span>&#125;,</span><br><span class="line">[<span class="string">&quot;10.161.236.231&quot;</span>] = &#123;app = <span class="string">&quot;mrs&quot;</span>, weight = <span class="number">100</span>&#125;,</span><br><span class="line">[<span class="string">&quot;10.51.10.182&quot;</span>] = &#123;app = <span class="string">&quot;mrs&quot;</span>, weight = <span class="number">100</span>&#125;,</span><br></pre></td></tr></table></figure></p>
<h1 id="脚本思路"><a href="#脚本思路" class="headerlink" title="脚本思路"></a>脚本思路</h1><p>我最开始打算用<code>awk</code>的<code>NR</code>、<code>FNR</code>去写，但是发现由于我这个文本的结构太过复杂。<code>awk</code>对付这样的力不从心，稍不好就把人搞得无法自拔，于是就考虑使用python的字典。</p>
<p>各位都知道，字典里key是不能重复的，而我又不想把这个脚本搞得太复杂，就想在<code>mingdan.txt</code>里的每一行加上序号，用这个序号去当key，而后面的内网IP就作为value，这样保证一一对应。加序号的方法很多，你可以在<code>vim</code>状态下<code>:set number</code>，然后手动复制粘贴。不过我是用的是如下两个命令：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/^[ \t]*//g&#x27;</span> mingdan.<span class="property">txt</span>	#这一步是添加每一行序号</span><br><span class="line">sed -i <span class="string">&#x27;s/\t/ /g&#x27;</span>  mingdan.<span class="property">txt</span>		#添加序号之后，会生成一个ta</span><br></pre></td></tr></table></figure></p>
<p>然后<code>mingdan.txt</code>就成了这样：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@paas-online-crs-<span class="number">001</span> tmp]# cat mingdan.<span class="property">txt</span> </span><br><span class="line"><span class="number">1</span> [<span class="string">&quot;10.117.219.72&quot;</span>] = &#123;app = <span class="string">&quot;mrs&quot;</span>, weight = <span class="number">100</span>&#125;,</span><br><span class="line"><span class="number">2</span> [<span class="string">&quot;10.161.235.150&quot;</span>] = &#123;app = <span class="string">&quot;mrs&quot;</span>, weight = <span class="number">100</span>&#125;,</span><br><span class="line"><span class="number">3</span> [<span class="string">&quot;10.161.236.231&quot;</span>] = &#123;app = <span class="string">&quot;mrs&quot;</span>, weight = <span class="number">100</span>&#125;,</span><br><span class="line"><span class="number">4</span> [<span class="string">&quot;10.51.10.182&quot;</span>] = &#123;app = <span class="string">&quot;mrs&quot;</span>, weight = <span class="number">100</span>&#125;,</span><br></pre></td></tr></table></figure></p>
<p>万事俱备，现在就要把<code>IP.txt</code>和<code>mingdan.txt</code>按照相同的内网IP整合成一个文件！</p>
<h1 id="脚本正文"><a href="#脚本正文" class="headerlink" title="脚本正文"></a>脚本正文</h1><p>这个脚本是不怕<code>mingdan.txt</code>和<code>IP.txt</code>的IP顺序的。<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/usr/</span>bin/env python</span><br><span class="line">#coding=utf-<span class="number">8</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">fd = &#123;&#125;		#先设置一个新的空字典叫fd</span><br><span class="line">#以下都是最后拼字符串用的</span><br><span class="line">aaa = <span class="string">&#x27;[&quot;&#x27;</span></span><br><span class="line">bbb = <span class="string">&#x27;&quot;] = &#123;app = &quot;mrs&quot;,mrsReportIp = &quot;&#x27;</span></span><br><span class="line">ccc = <span class="string">&#x27;&quot;,weight = 100&#125;,&#x27;</span>	</span><br><span class="line"> </span><br><span class="line">#首先先判断mingdan.<span class="property">txt</span>里是否存在</span><br><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> <span class="title function_">open</span>(<span class="string">&#x27;mingdan.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>):</span><br><span class="line">        ar = re.<span class="title function_">split</span>(r<span class="string">&#x27;[ &quot;&quot;]&#x27;</span>,l)		#做分割，把内网<span class="variable constant_">IP</span>切出来</span><br><span class="line">        print <span class="string">&quot;ip is :&quot;</span> + ar[<span class="number">2</span>]			#确认是否分割出来的是内网<span class="variable constant_">IP</span>地址</span><br><span class="line">        fd[ar[<span class="number">0</span>]] = ar[<span class="number">2</span>]				#把这个内网<span class="variable constant_">IP</span>地址当作value，前面的序号就是key</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> <span class="title function_">open</span>(<span class="string">&#x27;out.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> <span class="attr">fw</span>:	</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> <span class="title function_">open</span>(<span class="string">&#x27;IP.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>):	</span><br><span class="line">                ar = l.<span class="title function_">split</span>()</span><br><span class="line">	                <span class="keyword">if</span> ar[<span class="number">0</span>] <span class="keyword">in</span> fd.<span class="title function_">values</span>():	#如果<span class="variable constant_">IP</span>.<span class="property">txt</span>里面的内网<span class="variable constant_">IP</span>与字典fd里的value相符合</span><br><span class="line">                       	fw.<span class="title function_">write</span>(aaa + ar[<span class="number">0</span>] + bbb + ar[<span class="number">1</span>] + ccc)	#拼成一个完整的字符串</span><br><span class="line">                       	fw.<span class="title function_">write</span>(<span class="string">&#x27;\n&#x27;</span>)				#保存文件</span><br><span class="line"><span class="title function_">print</span>(<span class="string">&#x27;文件整合完毕，请查看out.txt的结果！&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<h1 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h1><p>执行效果输出如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@paas-online-crs-<span class="number">001</span> tmp]# cat out.<span class="property">txt</span> </span><br><span class="line">[<span class="string">&quot;10.117.219.72&quot;</span>] = &#123;app = <span class="string">&quot;mrs&quot;</span>,mrsReportIp = <span class="string">&quot;1.1.1.1&quot;</span>,weight = <span class="number">100</span>&#125;,</span><br><span class="line">[<span class="string">&quot;10.161.235.150&quot;</span>] = &#123;app = <span class="string">&quot;mrs&quot;</span>,mrsReportIp = <span class="string">&quot;2.2.2.2&quot;</span>,weight = <span class="number">100</span>&#125;,</span><br><span class="line">[<span class="string">&quot;10.161.236.231&quot;</span>] = &#123;app = <span class="string">&quot;mrs&quot;</span>,mrsReportIp = <span class="string">&quot;3.3.3.3&quot;</span>,weight = <span class="number">100</span>&#125;,</span><br><span class="line">[<span class="string">&quot;10.51.10.182&quot;</span>] = &#123;app = <span class="string">&quot;mrs&quot;</span>,mrsReportIp = <span class="string">&quot;4.4.4.4&quot;</span>,weight = <span class="number">100</span>&#125;,</span><br><span class="line">[root@paas-online-crs-<span class="number">001</span> tmp]# </span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>一个暗藏杀机的脚本</title>
    <url>/2018/02/11/%E4%B8%80%E4%B8%AA%E6%9A%97%E8%97%8F%E6%9D%80%E6%9C%BA%E7%9A%84%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="脚本背景"><a href="#脚本背景" class="headerlink" title="脚本背景"></a>脚本背景</h2><p>老总最近总是发现某台relay服务器的CPU值会突然彪很高，于是勒令几位工程师检查问题，但是工程师一时半会也想不到究竟是什么程序这么耗费CPU，于是就委托运维写一个脚本，具体要求是这样的：每隔一秒钟输出一下top命令的前十二行情况（其实就是配置总览和耗费cpu前五名程序情况），将这些情况保存到一个文件里，如果这个文件大于500MB，就把这个文件删除（为啥要删除？我也不知道），重新再生成一个文件用来保存top命令结果。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>由于脚本无法自己跳出运行并检查自己的大小，所以这个任务需要两个脚本，一个是单纯的把top命令重定向到一个文件（recordTOP.sh），另一个脚本就是一个if判断大小（checksize.sh）。再加上crontab每一天一检查（其实完全没必要，500MB足够top这个命令跑5天的），应该可以满足开发人员的需求。</p>
<h2 id="脚本内容"><a href="#脚本内容" class="headerlink" title="脚本内容"></a>脚本内容</h2><p>获取<code>top.txt</code>的脚本<code>recordTOP.sh</code>如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/bin/</span>bash</span><br><span class="line">#written by <span class="title class_">ChenShuo</span> @<span class="number">2016</span>-<span class="number">8</span>-<span class="number">15</span></span><br><span class="line">#<span class="title class_">Desription</span>:每一秒钟记录一次top命令里占用cpu前五程序</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">                $(top -bn <span class="number">1</span> | head -<span class="number">12</span> &gt;&gt; <span class="regexp">/root/</span>top.<span class="property">txt</span>)</span><br><span class="line">                echo <span class="string">&quot;------------------------------------------------&quot;</span> &gt;&gt; <span class="regexp">/root/</span>top.<span class="property">txt</span></span><br><span class="line">                sleep <span class="number">1</span></span><br><span class="line">        done</span><br></pre></td></tr></table></figure></p>
<p>判断<code>top.txt</code>大小的脚本<code>checksize.sh</code>如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/bin/</span>bash</span><br><span class="line">#written by <span class="title class_">ChenShuo</span> @<span class="number">2016</span>-<span class="number">8</span>-<span class="number">15</span></span><br><span class="line">#<span class="title class_">Desription</span>:当recordTOP.<span class="property">sh</span>文件大小超过500MB的时候将会重新覆盖</span><br><span class="line">size=$(ls -l | grep top.<span class="property">txt</span> |cut -d <span class="string">&quot; &quot;</span> -f <span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span> [[ $size -ge <span class="number">536870912</span> ]]</span><br><span class="line">        then</span><br><span class="line">                $(ps -ef|grep recordTOP.<span class="property">sh</span>|grep -v grep|awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>|xargs kill -<span class="number">9</span>)</span><br><span class="line">                $(rm -rf /root/top.<span class="property">txt</span>)</span><br><span class="line">                bash /root/recordTOP.<span class="property">sh</span> &amp;</span><br><span class="line">        fi</span><br></pre></td></tr></table></figure></p>
<p><code>crontab</code>这一步我就略掉不写了。</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p>1）top不可以直接重定向，如果是<code>top &gt; 123.txt</code>，它将会不断的导入，因为top就是一个实时更新的命令，所以这里要用<code>top -bn 1|head 12 &gt;&gt; /top.txt</code>；</p>
<p>2）shell脚本里调用shell，不能采用<code>$()</code>的方法了，因为<code>$()</code>是一个返回值，而.sh是一个不断进行的脚本，所以要用<code>bash +脚本名</code>的方式；</p>
<p>3）recordTOP.sh这个脚本是可以同时存在多个的，但是如果不小心后台启动多个，用checksize脚本ps -ef语句就会报错，因为获得到的不是一个数字，而是多个数字，没法一波kill掉。同理，直接调用checksize也会报错，因为没有ps -ef的值；</p>
<p>4）因为是要先关闭原来的top重定向脚本，所以才用了保守的ps -ef，然后kill的方式，这里不可以使用pkill，因为pkill是干掉整个类型程序，比如<code>pkill -9 java</code>，就是干掉所有java的进程。而在linux里，千万不可以<code>pkill -9 sh</code>，可以想象一下，这个命令的结果就是会从ssh上跳出，同时无法登陆，因为整个sh都被你杀死了。那么真的出现了这个结果怎么办？答曰：重启，重启能救命。</p>
<p>整个执行效果如下，可见top.txt文件是在不断的扩大，由于是测试，我把文件大小调整为20000字节，即大于20000字节就覆盖原文件，当文件大于20000字节的时候，就会把原来的top.txt删除，同时生成一个新的top.txt。<br><img data-src="/images/top5.png" alt="paradin"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>top</tag>
      </tags>
  </entry>
  <entry>
    <title>一次秒杀导致的故障</title>
    <url>/2023/04/14/%E4%B8%80%E6%AC%A1%E7%A7%92%E6%9D%80%E5%AF%BC%E8%87%B4%E7%9A%84%E6%95%85%E9%9A%9C/</url>
    <content><![CDATA[<p>早上9点有一个秒杀活动，没多久就开始有舆情反馈“用户页面显示中奖但是无法购买”。后来10点秒杀活动结束，整个故障就被动关闭了。</p>
<p><img data-src="/images/%E5%B0%8F%E9%BB%91%E7%9B%921.png" title="这是后来找了一个活动"></p>
<p><img data-src="/images/%E5%B0%8F%E9%BB%91%E7%9B%922.png" title="当时的舆情反馈"></p>
<p>整体开奖流程如下：<br><img data-src="/images/%E5%B0%8F%E9%BB%91%E7%9B%923.webp" title="整体开奖流程"></p>
<p>开奖时，大量用户进入开奖页（开奖页会展示实时剩余奖品百分比），当时查询奖品剩余百分比接口的QPM约30W。由于用户中签后会清空奖品剩余的缓存，导致请求打到DB上，出现慢SQL，造成数据库被打满（图），数据库被打满后，中奖凭证保存成功，但是部分中签用户更新奖品状态时失败，前台表达是否中奖是依赖凭证内的是否字段，所以出现了“显示中奖，但是无法下单”的情况。</p>
<p>故障原因很简单，但是带来的后续思考很多：</p>
<ol>
<li>查询抽签商品库存数接口限流设置较高，导致没有限制住“查询奖品库存缓存失效导致直接打满db”。这里要重新对接口进行压测，确定限流量规则。</li>
<li>该场景还有其他乱七八糟的业务玩法，要求对其他线上玩法进行全面review避免同样问题。</li>
<li>缺少直接监控：缺少直接反映预占奖品和确认兑换奖品数据不一致监控导致问题排查和定位长</li>
<li>日常运维工具缺失：排查问题只能靠开发人为db操作进行，缺少产品化的能力，容易让排查周期长和排查失误的问题</li>
<li>业务与技术未充分沟通秒杀需求，未做技术保障，因为此次活动玩法是日常进行过的玩法，未开发新功能，运营多次组织过且评估流量可控，所以并未告知开发有秒杀，开发未进行针对的技术保障，结果本次流量大大超过预期。</li>
</ol>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SRE</tag>
        <tag>秒杀</tag>
      </tags>
  </entry>
  <entry>
    <title>《进击的巨人》观后感</title>
    <url>/2024/03/11/%E3%80%8A%E8%BF%9B%E5%87%BB%E7%9A%84%E5%B7%A8%E4%BA%BA%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F/</url>
    <content><![CDATA[<p>最近工作不算很忙，外加初春我总会拉肚子的习惯，所以这几天下班都比较早。早回家就追了一下荒废许久的番—《进击的巨人》。经过了几乎40个小时的观看，从第二季到最终季我都看完了。这部番果然后劲很大，讨论的主题也非常的深奥，是一部将商业和深度都具备的好漫画。</p>
<p>先说一下整部剧的结构，《进击的巨人》世界观很复杂很大，营造末日的压迫感很强，作者刻画群像剧的能力也很赞，所有的配角基本都有自己的人生，而且作者也很舍得刀人，真的需要这些角色牺牲的时候，狠得下心。让人感受到了悲剧和毁灭的力量。</p>
<p>谏山创这个作品里的主题不是传统的普世价值，而是反其道而行之的“非圣母”旋律，他本身也不是一个讨好读者的作者。这部作品里即讨论了仇恨又讨论了人性又讨论了政治又讨论了战争，可以说已经摸到了严肃文学的边儿了。<br><img data-src="/images/%E8%BF%9B%E5%87%BB%E7%9A%84%E5%B7%A8%E4%BA%BA3.png" title="整件事情其实不是莱纳等人破墙作为源头，而是马莱国跟凯尔迪岛上艾尔迪亚人的仇恨引发的"></p>
<h2 id="一些感触"><a href="#一些感触" class="headerlink" title="一些感触"></a>一些感触</h2><ol>
<li><p>话说前头，考虑到作者谏山创的国籍，估计不少接受民族主义教育的国内读者会跳出来指责作者谏山创在这部作品里的立场和三观。我认为文艺作品的问题就在文艺作品去解决，不要搞扩大化。艺术情节来自现实本身就是无可避免的事情，本文也只是讨论剧中情节和揣摩作者思想。当然，那些“只喝哇哈哈拿农夫山泉冲厕所”的人爱怎么想就怎么想吧。</p>
</li>
<li><p>作者无疑是鄙视血统论和出身论这种标签的，他安排妓女的儿子兵长成了重要的配角，而且兵长是全书里唯一一个能单挑赢智慧巨人的普通人（他跟兽巨属性相克，兽巨善远程怕近战）。而且作者也在“血统论”里加上了一点人性的灰暗：“艾尔迪亚帝国辉煌的时候，贵族都争抢自己能拥有它的血脉，引以为荣，但是后来帝国落寞了，那些血脉反而成了被判处刑罚的证据”。</p>
</li>
<li><p>因为人类的不平等是必要且无法消除的，所以人类就要不停止的追求力量。但是有了强大的力量且没有限制力量的心态或者政策，那么世界肯定会迎来巨大的灾难。</p>
</li>
<li><p>历史是不能改变的，当代人是否要承担祖先或者父辈的罪过？同理，孩子是否也应该被强迫灌输所谓“历史的使命”？</p>
</li>
<li><p>马莱国摆脱了艾尔迪亚巨人的压制，就急匆匆的依赖巨人去征服别的国家，结果别的国家技术里虽然没有巨人，但是奈何技术发展的快，反巨人设备日新月异。大家就这样军备竞赛，到后来巨人不进步就慢慢被淘汰。</p>
</li>
<li><p>作者谏山创毫无疑问研究过不少的罗马神话、北欧神话的。最明显的代表就是尤妮尔就是北欧神话ymir的原型。文中艾伦的嘴里说“尤妮尔虽然遭到百般虐待但是爱着初代弗里茨王”，而且动画里还明确给出初代弗里茨王让三个女人啃食尤妮尔的尸体来获得能量的画面，但是动画里却给出了下面这样的镜头，我认为这里作者表达的意图是传说是假的，真实情况是尤妮尔杀了初代弗里茨王，这个其实与三笠杀掉自己喜欢也是主人的艾伦有前后呼应的效果。还有一个小地方可以证明尤妮尔其实是一个热爱自由的人，因为她偷摸放了猪，给了猪自由。<br><img data-src="/images/%E8%BF%9B%E5%87%BB%E7%9A%84%E5%B7%A8%E4%BA%BA.png" title="最终篇后篇1小时14分左右的地方，三笠说尤妮尔你的爱很痛苦，你可以安息了，然后尤妮尔就消散了。"></p>
</li>
<li><p>尤妮尔她让自己的女儿吃掉自己，但是她作为宿主和她本身也愿意继续繁殖将巨人之力传承下去，因为她知道这个“巨人之力”只会给人带来无尽的掠夺进而引发战争甚至是灭顶之灾，但是又没有结束的那天，所以这其实是尤妮尔对初代弗里茨王的一个诅咒，就是弗里茨的子孙后代都要承担这样的苦。</p>
</li>
<li><p>力量这个东西看上去很美，拿上去很屌，但是很少有人拥有了力量后能控制自己的贪欲不去掠夺和征伐他人，然后冤冤相报何时了。所以有些很美很屌的东西，其实是陷阱，你爽了你自己征讨了别人，但是风水轮流转，没有永恒的王，可能你的子孙后代都要被你坑死。</p>
</li>
<li><p>预见未来其实是一个非常可怕的事情，尤其你遇见的未来只是一些碎片，而且还有一个宿命在裹挟，就会导致你成了一个提线木偶。艾伦的台词里也说过“自己就是一个自由的奴隶”，他为了追逐他心中的自由，不得不去做一些必须做而又不情愿做的事情。</p>
</li>
<li><p>作者也高度认可了“人”的能力，并不一定是超人关键时刻才能拯救世界，普通人就很重要了，普通人只要有一个救人的心、智慧的脑和团队配合，一样可以救人一样可以打败强大的对手。</p>
</li>
<li><p>贾碧这条线安排的特别棒，尤其是饭局上的修罗场，让人痛彻心扉的感受到只教人仇恨的政权肯定不是啥好玩意。对于一个正常人，记住历史很重要，但是记住仇恨并不重要，因为仇恨会懵逼双眼。</p>
</li>
<li><p>结合第11条，人要学会跟不同的人生活在一起。包容是一个美德，应该人人都尽量有。</p>
</li>
<li><p>纷争是不可能不存在的，解决纷争只有两个办法，第一个就是彼此加强交流主动破冰，但是这一步需要勇气双方都坦诚相待、不计前嫌。第二个方法就是这个世界只剩下一个人了，那么自然就没纷争了。<br><img data-src="/images/%E8%BF%9B%E5%87%BB%E7%9A%84%E5%B7%A8%E4%BA%BA5.jpg" title="拯救世界、改善世界这种词特别有蛊惑性，可以赢得大量对当前形势不满的信众"></p>
</li>
<li><p>不会失去就不会进步，巧的是《真探 第一季》里，马修·麦康纳说过没有时间就没有进步。</p>
</li>
<li><p>有些人总是得寸进尺的，人家145代王都已经龟缩苟且立下不战之约了，马莱国还欺负到人家门口，给墙外扔了一堆无脑巨人恶心对方取悦自己，大言不惭说要对方还血债，果然一个漂亮的理由下就是一个肮脏的勾当，用正当性来包装了暴行的行为还是暴行。阿兹马比特的清美至少还是冲着帕拉迪岛上的冰瀑石矿产，马莱其实啥都不懂，就比闭关锁国土到极致的艾尔迪亚人高一点。这也是为啥戴巴家族后悔的说“马莱在巨人的能力上躺吃躺喝，不思进取，军方高层好多酒囊饭袋”。</p>
</li>
<li><p>艾伦被砍，所有的巨人之力已经消灭了，但是几百年后帕拉迪岛依旧遭受重创。</p>
</li>
<li><p>这里说一下剧中几个人的解法，其实整部剧没有正义邪恶之分，只是每个人都有自己心中一个世界的蓝图，然后彼此无法调和而发生的斗争故事：<br>a. 吉克：吉克是极端的悲观主义者，他结合自己的经历认为“孩子不出生也就不用承担罪过”，所以决定实行“艾尔迪亚人结扎”计划，这个计划也吸引了伊蕾娜这样的信徒。持有王血的他跟始祖之力拥有者艾伦接触，然后由他下命令让尤弥尔修改艾尔迪亚人的身体结构，艾尔迪亚人就不再生育，慢慢的“安乐死”。但是这个想法其实本身是被尤妮尔本能的不喜欢的，而且艾伦也否决，艾伦认为，这一代艾尔迪亚人越来越老，将来外族打进来，没几个人能扛得住，就只能惨死。而且一想到他的同伴将来大概率就是这样的下场，一向珍视同伴的艾伦断然拒绝这个提议。<br>b. 145代王：这哥们跟吉克差不多消极，他是一个极端的躲避者，对外留下一句”我有地鸣，你们别逼我“就在墙里死活不出来，这也是一个治标不治本的办法。而且这个办法非常的双标，平民死伤时王的后代雷斯家族说那是为了我们的赎罪而拒绝出手，但是艾伦爸找上门表示你们不管我就动手抢始祖之力，雷斯家族却变身战锤巨人跟他死拚，可见平民的命是草履，他们自己的命才是真金贵。<br>c. 韩吉等人：韩吉是对外交流派，希望帕尔迪岛能主动对外交流，展开外交解除外界对自己族人“恶魔”的刻板印象（这一点其实跟戴巴家族一样，他们也是马莱的对外交流派）。但是这需要帕尔迪岛先拿出“不再地鸣”的诚意，所以就要牺牲女王希丝特莉亚和始祖巨人艾伦，断绝地鸣的源头（帕尔迪岛的军方建议让女王吃掉吉克，这样世界就只有女王这么一个王血持有者了），这也是第三季的政变相关的内容。但是与吉克的想法类似，这个计划里都有伤害艾伦伙伴的行动，所以被艾伦拒绝。<br>d. 艾伦：艾伦最重视的就是“伙伴”，所以他一直不很希望自己的伙伴是巨人，因为巨人寿命短，阿尔敏是无奈的选择。“艾尔迪亚族”这个观念在艾伦心里肯定比不上“伙伴”。所以艾伦选择这个极端的办法，第一是确保马莱国等其他国家不会那么快的报复帕尔迪岛，确保几百年内帕尔迪岛的文化和平安。第二毁掉巨人之力，大家都和平快乐，而且无脑巨人也会恢复正常，能团圆的团圆了。但是他没有解决仇恨的问题，或者他以为“阿尔敏等人通过宣传自己杀死艾伦这个世界大祸害”能成为友善大使，让艾尔迪亚人地位提升一点。但是最终的结局不是他所想象的，而且谏山创也用大量世间惨剧的描写表达了对他这个极端灭世做法的否定。</p>
</li>
</ol>
<h2 id="剧情里一些我没懂的地方"><a href="#剧情里一些我没懂的地方" class="headerlink" title="剧情里一些我没懂的地方"></a>剧情里一些我没懂的地方</h2><ol>
<li><p>艾尔迪亚帝国当初靠着巨人之力掠夺和殖民马莱国，而且他俩当时的土地是接壤的，可见那时候艾尔迪亚人是可以压制马莱国的文化。但是为啥145代艾尔迪亚国王出走帕拉迪岛后，马莱国就翻身做主人了呢？（或者马莱国先崛起，艾尔迪亚国王被动逃跑，但是这都不影响我的问题）难道艾尔迪亚国王身上的始祖巨人这么牛逼？他走了，其他所有的巨人都镇压不住马莱国了？（后来看了一下，原因是九大巨人内斗，无法团结，所以145代王就配合戴巴家族演了一出戏，造出来一个假英雄，然后戴巴家族投靠了马莱人，所以马莱收编了其他智慧巨人而崛起）<br><img data-src="/images/%E8%BF%9B%E5%87%BB%E7%9A%84%E5%B7%A8%E4%BA%BA2.png"></p>
</li>
<li><p>巨人的能力按说是继承者吃掉原来者就会得到，不然就是随机分配。那么按照这个说法，同一时间这个世界应该只有一个智慧型巨人。但是在最终话里，法尔可和吉克都活着，法尔可却已经能通过兽巨的能力变鸟在空中飞了，那么很显然，这个“同一时间只有一个xxx巨人的说法不成立”。（后来我看up主的视频说，其实法尔可没有兽巨的能力，只是他的颚之巨人会飞，所以没有打破既定的原则，我只想说好吧…）</p>
</li>
<li><p>顺着上一条说，所有喝了吉克脊髓液红酒的人，那么在吉克发出怒吼之前弄伤自己是不是就可以直接变化成兽巨了？这样直接就打破了吉克的计划。吉克作为一个巨人研究者不可能没想到这些吧。(理由同上一条，其实喝了脊髓液红酒的人不会得到兽巨的力量，还是无脑巨人)</p>
</li>
<li><p>最终话后篇，艾伦爆料为了保证当时超大型巨人不能提前死，就让无脑巨人走了另一个方向，结果无脑巨人也就是吉克的王妈把艾伦的妈给吃了。但是当时的艾伦还是一个小孩，他压根就没有始祖巨人的能力，始祖巨人的能力是他爸知道了妈被吃了后，十分绝望又觉得自己生命不久而传给他的。所以这里是不是我看漏了啥？（后来仔细看了一些up主对艾伦弑母的讲解，原因就是艾伦有主角光环，未来的他早就在布局，而且道路里的时间跟外面的时间不同。他在道路里一步一步影响现在的局势，但是同样也是始祖巨人的艾伦爹就因为不是主角而且他的继承者艾伦可以选择性的把他的记忆给艾伦爸看，所以他只看到了地鸣的结果，但是细节不清楚）<br><img data-src="/images/%E8%BF%9B%E5%87%BB%E7%9A%84%E5%B7%A8%E4%BA%BA4.jpg" title="颚之巨人死的最多，好惨。他本身攻强守弱，而且还总保护铠之巨人"></p>
</li>
<li><p>为啥艾伦死了，巨人之力就消失了？（因为尤妮尔&amp;怪诞虫是巨人之力的源头，尤妮尔得到安息消散了而且作为肉体寄生的艾伦也死了，自然怪诞虫也死了，所以巨人之力消失了）</p>
</li>
<li><p>145代王当初登岛的时候，带走了一部分族人，为啥不把全部的智慧巨人都带走？以他的控制能力是可以把所有的智慧巨人带走并清除记忆，然后智慧巨人也生活在墙内，可以作为保镖保护他的。（这个后来仔细看了戴巴那部分，看到了原来是戴巴家族也是一个赎罪派，他们当初就不想走，所以145代王没有强迫他们。而戴巴也没有插手马莱成为一个军国主义国家，放纵了马莱对其他几个智慧巨人的使用）</p>
</li>
<li><p>我铠他超那集，贝尔托特变身超大型巨人的时候，艾伦离的很近，却没有因为大爆炸而受伤，而后面皮克跟贾碧则被手铐铐在一起，明显是艾伦防皮克变身。所以这个巨人变身到底爆炸的威力到底几何，觉得是一个BUG。（其实巨人可以自己操纵爆炸的威力）</p>
</li>
</ol>
<h2 id="其他感觉"><a href="#其他感觉" class="headerlink" title="其他感觉"></a>其他感觉</h2><ol>
<li>3月8日，鸟山明工作室公布了鸟山明先生去世的消息，全世界为之哀悼。无疑鸟山明凭借《龙珠》在全球的影响力可以入选漫画家名人堂的。但是我想表达的是《龙珠》主要是配合了当时的香港武打片的风行，配合早期小悟空的冒险故事和天真无邪的轻松搞笑，迅速赢得了第一批读者。后期鸟山明自己发现冒险故事在读者心中热度不长久就开始引入《天下第一武道会》，将这部漫画彻底转成了少年偏格斗漫画。当然这也给他赢来了商业的成功，但是我还是觉得鸟山明先生冒险那部分其实是最吸引人的，小悟空篇和那美克星篇都是经典，其余的就是为了打架而打架。</li>
<li>如果《龙珠》放到现在这个创作大环境下，要火就很难了。现在漫画界太卷了，《龙珠》本身没有什么爱情元素（鸟山明说他不会画温柔的女孩子），亲情元素不太多，早期屎尿屁后期打打打。给读者提供轻松有余厚度不足。我认为《龙珠》是一部伟大的作品，他起了一个奠基石的作用，鸟山明也是无数后辈学习的对象，《龙珠》的成功有天时地利人和多重元素的加持。但是《龙珠》跟当下的几款爆街漫画相比内核部分简直就是太简单了。<br><img data-src="/images/%E9%BE%99%E7%8F%A0.jpg"></li>
</ol>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>动漫</tag>
        <tag>进击的巨人</tag>
      </tags>
  </entry>
  <entry>
    <title>一道传说中是百度面试的shell试题</title>
    <url>/2018/01/23/%E4%B8%80%E9%81%93%E4%BC%A0%E8%AF%B4%E4%B8%AD%E6%98%AF%E7%99%BE%E5%BA%A6%E9%9D%A2%E8%AF%95%E7%9A%84shell%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>【问题】<font color=blue>写脚本实现，可以用shell、perl等。把文件b中有的，但是文件a中没有的所有行，保存为文件c，并统计c的行数。</font><br>翻译成人话就是，假设有一个文件a是:<br>a<br>b<br>c<br>d</p>
<p>文件b是:<br>1<br>2<br>3<br>4<br>a<br>b</p>
<p>现在要求输出“b有a没有”的行，即1 2 3 4，然后<code>wc -l</code>一下。</p>
<p>【思路】两个文件比较，第一想法就是<code>diff</code>，但是<code>diff</code>无论是<code>-c</code>还是<code>-y</code>会牵扯进大量的<code>&gt; &lt; + -</code>不说，而且diff命令是直白对比，即使字母相同但所在行不同，也会被<code>diff</code>记录。如果再用<code>for in</code>语句然后一项一项对比也不会很清晰的解决这个问题，所以要换个方法。</p>
<p>第二个方法就是<code>comm</code>命令，但是这个命令有一个前提，就是要<code>sort</code>排序，<code>comm</code>比<code>diff</code>高明之处在于它只比较内容而不在意是否同一行，但是要注意对比文件的先后。<code>comm -12 a b</code>是找”a和b都有”的项，<code>comm -23 a b</code>就是找”a有而b没有”。</p>
<p>【解答】perl我不会，我就用shell写：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/bin/</span>bash</span><br><span class="line">#written by <span class="title class_">ChrisChan</span> @ <span class="number">2016</span>-<span class="number">4</span>-<span class="number">21</span></span><br><span class="line">sort a.<span class="property">txt</span>&gt;a1.<span class="property">txt</span>        #排序，不然会有提示</span><br><span class="line">sort b.<span class="property">txt</span>&gt;b1.<span class="property">txt</span></span><br><span class="line">comm -<span class="number">23</span> b1.<span class="property">txt</span> a1.<span class="property">txt</span> &gt;c.<span class="property">txt</span>    #由于是要找b有a没有的,就要b写在前，a写在后</span><br><span class="line">echo $(cat c.<span class="property">txt</span>|wc -l)</span><br></pre></td></tr></table></figure></p>
<p>其实还有一个更简单的，只用一句话:<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">grep -v -x b.<span class="property">txt</span> -f a.<span class="property">txt</span>|wc -l</span><br></pre></td></tr></table></figure></p>
<p>很多书上不写<code>grep -x -f</code>的意思，这里补一下：<br><code>-f</code>:指定范本文件，其内容含有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每列一个范本样式。<br><code>-x</code>:只显示全列符合的列。</p>
<p>从一个题就能轻松看出shell的能力级别，用diff死纠缠就是初级，用comm就是中级，而grep就是高级。的确是一个好题。</p>
<p>【补充】如果考python，求这种类似“你有我没有”的东西，用set里面的差集算法。<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;A=&#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>&#125;</span><br><span class="line">&gt;&gt;&gt;B=&#123;<span class="number">3</span>，<span class="number">4</span>，<span class="number">5</span>，<span class="number">6</span>&#125;</span><br><span class="line">&gt;&gt;&gt;<span class="title function_">print</span>(A-B)</span><br><span class="line"><span class="title function_">set</span>([<span class="number">1</span>,<span class="number">2</span>])    #A有B没有</span><br><span class="line">&gt;&gt;&gt;<span class="title function_">print</span>(A ^ B)</span><br><span class="line"><span class="title function_">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>])  #差集的补集</span><br><span class="line">&gt;&gt;&gt; A&amp;B</span><br><span class="line">&#123;<span class="number">3</span>, <span class="number">4</span>&#125;    #交集</span><br><span class="line">&gt;&gt;&gt; A|B</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;    #全集</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>面试经验</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>三寸金莲读后感</title>
    <url>/2022/05/19/%E4%B8%89%E5%AF%B8%E9%87%91%E8%8E%B2%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
    <content><![CDATA[<p>周末读完了冯骥才先生的《三寸金莲》，字数不少，感觉跟前几天读的古龙的《天涯明月刀》差不多字。冯先生善写天津卫的“奇人奇事”，巧的是古龙的作品也有不少的“奇人奇事”，两个善写江湖的大作家作品一口气连读下来，虽然故事年代有差距，倒也没有什么违和感。但是《三寸金莲》看完还是让我觉得又恶心又过瘾又唏嘘。</p>
<p>冯先生是走“清末冥国市井能人”的路线，很多书里都有一些“怪邪荒诞”、“封建迷信”、“特异功能”的东西，比如《阴阳八卦》里的透视眼，硬气功等等。所以他的书要改编成电影电视剧还是个挺难的事儿…</p>
<p>我奶奶的母亲，也就是我的曾祖母，她老人家就是小脚女人。其实在清末慈禧太后就已经颁布法令不准女人缠足了，因为我老家那时候在秦岭山村，消息不通，我奶1936年生人，那时候大清都亡了20多年了，村子里依旧有女孩子在6~10岁在缠足，我奶的两个姐姐都缠了足，而她就躲过了一劫。我奶现在还说“当时是共产党到了村子，勒令不准缠足，谁缠足抓谁，而且那时候也让女娃读书，我才能读书写字”。我算了一下，1936年西安事变，那几年在陕西是有共产党的部队的，但是1943年就到了秦岭的村子宣传“放足”这个事儿细节我还要查一下。</p>
<p>中国自古以来，想要在不积累资本的前提下实现阶级的跨越，对于男人来说最好的方法就是“中科举”，拼一个功名。而女人来说最好的方法就是嫁入豪门。那么脚缠的好，也是能在面容相对普通的前提下可以逆转劣势的条件。而这两条路对于当时的贫困下层都是“正道”，是被有发言权的儒家士大夫阶级所认可的，自然也引得千军万马走独木桥。</p>
<p>不过这本书如果只是认为是一个民间“缠脚，放脚，斗脚”对抗世间礼法习俗的故事，我觉得还是太肤浅了点。当然在中国这个“道德感”特别重的国家，礼法是具有巨大的社会力量的，而且这种社会习俗是可以通过在国家军事能力和国家文化能力进行宣传扩散的，记得书中也有一句话：“要是中国比那洋人强，洋女人也得缠脚”（不过这一点在日本并不好使，日本与中国文化交流密切，但是日本女人无论贵贱都不缠脚）。</p>
<p>其实书里的缠足是一个隐喻，映射了“统治阶级或者话语权阶级的某种运动”。主人公戈香莲其实也就是这个运动里的“模范标杆”，在运动中自然脱颖而出。而她的财富、权力、威望也是建立在“运动大背景下”，自然也不能主动离开和否定这个运动，而成了坚定的“保守派”。但是一旦时代变迁，领导层主动或者被动发生了变化，那么时代的主旋律也会发生变化，曾经运动的“模范标杆”也会被人抛之脑后甚至成了“落后乃至反动”的代表。“缠足是丑八怪是陋习”，这让主人公戈香莲平生的信仰崩塌。但是这一切的一切又是历史前进和人类发展的必然之路，无法逆转。</p>
<p>戈香莲虽然抵制放脚，但是绝不是一个反面角色，她吃到了“缠足”那个时代的红利，恰巧也处于整个中国命运转折的关键点。在意识需要大转弯的时候，难免就有些不适应，但也是为了生存，哪怕被批臭批垮。时代的一粒沙降落到个人头上就是一座山，有的人可以在山峰看景，有的人则被山无情砸死。作为市井小民，选择的确很重要，选择对了，剩下就是努力了。</p>
<p>书里的大老板佟掌柜做的是“以次充好”的古董生意，后来也疏于店铺事务醉心家中。他后来在心腹手下活受出逃后发现自己一屋子的东西到头来都成了假货。还有“帮谁谁赢”的潘妈，等等等等的隐喻就更明显了，不提了。</p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>冯骥才</tag>
        <tag>当代小说</tag>
        <tag>中国小说</tag>
      </tags>
  </entry>
  <entry>
    <title>不要轻易去打开tcp_tw_recycle！</title>
    <url>/2019/03/04/%E4%B8%8D%E8%A6%81%E8%BD%BB%E6%98%93%E5%8E%BB%E6%89%93%E5%BC%80tcp-tw-recycle%EF%BC%81/</url>
    <content><![CDATA[<h2 id="挖坑过程"><a href="#挖坑过程" class="headerlink" title="挖坑过程"></a>挖坑过程</h2><p>有时候，我们可能发现服务器里存在大量的<code>TIME_WAIT</code>，如图：<br><img data-src="/images/time4.png" alt="办公室"></p>
<p>其实这2000+的<code>TIME_WAIT</code>真的不算多，至少低于10000条都不算多。但是<code>TIME_WAIT</code>本身是一个占用内存和CPU的东西，所以很多人就想把它干掉。往往这个时候，就会看到这样的答案：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">打开 sysctl.conf 文件，修改以下几个参数：</span><br><span class="line">net.ipv4.tcp_tw_recycle = <span class="number">1</span></span><br><span class="line">net.ipv4.tcp_tw_reuse = <span class="number">1</span></span><br><span class="line">net.ipv4.tcp_timestamps = <span class="number">1</span>	<span class="comment">#只有打开这个，前俩才能生效</span></span><br></pre></td></tr></table></figure></p>
<p>修改完毕之后，再<code>/sbin/sysctl -p</code>一下，就会看到<code>TIME_WAIT</code>果然大量减少，效果立竿见影！但是不要高兴太早，其实你给自己埋下了一个大坑…</p>
<h2 id="TIME-WAIT是干啥的"><a href="#TIME-WAIT是干啥的" class="headerlink" title="TIME_WAIT是干啥的"></a>TIME_WAIT是干啥的</h2><p><font color=red>只有主动关闭连接的一方，才会转移到<code>TIME_WAIT</code>。只有被动断开连接的一方会出现<code>CLOSE_WAIT</code>，等待<code>close()</code>执行完毕之后，状态变成<code>LAST_ACK</code>。</font></p>
<p><code>TIME_WAIT</code>的主要目的有2个：</p>
<ol>
<li><p>避免误收延迟到达的报文：因为报文又快又慢，而若<code>TIME_WAIT</code>太短就会放弃原来的链接，生成新的链接，而新的链接此时接到迟到了报文，这就出现了数据错误的现象；</p>
</li>
<li><p>保证对端已经关闭了连接：由于<code>TIME_WAIT</code>的时间被缩短了，对端还处于<code>LAST_ACK</code>状态，本段发送的syn报文被直接RST掉了。</p>
</li>
</ol>
<h2 id="再说结论"><a href="#再说结论" class="headerlink" title="再说结论"></a>再说结论</h2><p>当配置了<code>net.ipv4.tcp_tw_recycle = 1</code>之后，<code>TIME_WAIT</code>这个阶段就几乎是不存在了，因为原本它的存活时间是<code>2MSL</code>时间，现在改成了一个<code>RTO</code>，这个RTO可以远远小于2MSL的。当一个socket连接进入<code>TIME_WAIT</code>状态后，内核里会记录包括该socket连接对应的五元组中的对方IP等在内的一些统计数据，当然也包括从该对方IP所接收到的最近的一次数据包时间。当有新的数据包到达，只要时间晚于内核记录的这个时间，数据包都会被统统的丢掉。</p>
<p>那怎么会影响具体业务呢？如果你所在的网络是NAT网络，即“多个客户端，但是同一个IP出口”这样的网络环境，这样很多人其实使用的是同一个IP。但是在服务器端它是始终在跟同一个host打交道，那么在一个RTO的时间内，只能有一个客户端和自己连接成功，而其他人要连接就会出现超时的现象。</p>
<p>抓包体现是<code>客户端发送了syn给服务端，但是服务端不会回复ack，然后客户端就一直处于等待，通畅以为服务器端此时卡死了，可是此时服务器的负载并不高</code>。</p>
<h2 id="为什么TCP4次挥手时等待为2MSL？"><a href="#为什么TCP4次挥手时等待为2MSL？" class="headerlink" title="为什么TCP4次挥手时等待为2MSL？"></a>为什么TCP4次挥手时等待为2MSL？</h2><p>MSL是<code>Maximum Segment Lifetime</code>,译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。等待2MSL时间主要目的是怕最后一个ACK包对方没收到，那么对方在超时后将重发第三次握手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包。TCP只有断开了才会释放占用端口等资源，新来的链接才能复用这个端口。若被动断开的一方一直收不到最后一个ACK,那就会等待retry times到了上限，会reset连接。</p>
<p>如果不等，释放的端口可能会重连刚断开的服务器端口，这样依然存活在网络里的老的TCP报文可能与新TCP连接报文冲突，造成数据冲突，为避免此种情况，需要耐心等待网络老的TCP连接的活跃报文全部死翘翘，2MSL时间可以满足这个需求。</p>
<h2 id="正确做法"><a href="#正确做法" class="headerlink" title="正确做法"></a>正确做法</h2><p>解决办法就是不建议同时开启<code>tcp_timestamp</code>和<code>tcp_tw_recycle</code>。</p>
<p>正确的解决这个总是办法应该是：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net.ipv4.ip_local_port_range = <span class="number">9000</span> <span class="number">6553</span> <span class="comment">#默认值范围较小</span></span><br><span class="line">net.ipv4.tcp_max_tw_buckets = <span class="number">10000</span> <span class="comment">#默认值较小，还可适当调小</span></span><br><span class="line">net.ipv4.tcp_tw_reuse = <span class="number">1</span> <span class="comment">#</span></span><br><span class="line">net.ipv4.tcp_fin_timeout = <span class="number">10</span> <span class="comment">#</span></span><br></pre></td></tr></table></figure></p>
<p>插播一句，<code>tcp_tw_recycle</code>这个参数已经在新的内核<code>kernel 4.12</code>里已经去掉了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnxct.com/coping-with-the-tcp-TIME_WAIT-state-on-busy-linux-servers-in-chinese-and-dont-enable-tcp_tw_recycle/">https://www.cnxct.com/coping-with-the-tcp-TIME_WAIT-state-on-busy-linux-servers-in-chinese-and-dont-enable-tcp_tw_recycle/</a><br><a href="https://ieevee.com/tech/2017/07/19/tcp-tw-recycle.html#TIME_WAIT%E6%98%AF%E5%B9%B2%E5%95%A5%E7%9A%84">https://ieevee.com/tech/2017/07/19/tcp-tw-recycle.html#TIME_WAIT%E6%98%AF%E5%B9%B2%E5%95%A5%E7%9A%84</a><br><a href="https://www.jianshu.com/p/893b5d7e9f30">https://www.jianshu.com/p/893b5d7e9f30</a><br><a href="https://www.zhihu.com/question/67013338">https://www.zhihu.com/question/67013338</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI4MjA4ODU0Ng==&mid=2650910938&idx=2&sn=8b0aa87b0f45b8465e3fe9a70f51c895&chksm=f06a55d7c71ddcc120d49d4808ac471d6ae37c105cf37cbfdf142384a3bb2fb5b94ff76b904a&mpshare=1&scene=1&srcid=0226ijYLsAmX7LdKO206NINd&key=d98c1a7a91040c8d88006a294b27c49cb4fc4e200242db9cfabf2f4d98e420954e2210ce8d72d0ea778a548e2596bef617479a59cc23a4164f93cfd0cfa85a8d460c21de5501f934e13fd0fc2e50cbce&ascene=1&uin=MTE4NTkxNTEwMA==&devicetype=Windows+7&version=62060720&lang=zh_CN&pass_ticket=RxcXlxUz8iYDMMdnmhYX6NfQJkTaZzim2gD9j8q74LaeYI8X1cSH0njnQZXJfH8g">https://mp.weixin.qq.com/s?__biz=MzI4MjA4ODU0Ng==&amp;mid=2650910938&amp;idx=2&amp;sn=8b0aa87b0f45b8465e3fe9a70f51c895&amp;chksm=f06a55d7c71ddcc120d49d4808ac471d6ae37c105cf37cbfdf142384a3bb2fb5b94ff76b904a&amp;mpshare=1&amp;scene=1&amp;srcid=0226ijYLsAmX7LdKO206NINd&amp;key=d98c1a7a91040c8d88006a294b27c49cb4fc4e200242db9cfabf2f4d98e420954e2210ce8d72d0ea778a548e2596bef617479a59cc23a4164f93cfd0cfa85a8d460c21de5501f934e13fd0fc2e50cbce&amp;ascene=1&amp;uin=MTE4NTkxNTEwMA%3D%3D&amp;devicetype=Windows+7&amp;version=62060720&amp;lang=zh_CN&amp;pass_ticket=RxcXlxUz8iYDMMdnmhYX6NfQJkTaZzim2gD9j8q74LaeYI8X1cSH0njnQZXJfH8g</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>tcp链接</tag>
        <tag>内核优化</tag>
      </tags>
  </entry>
  <entry>
    <title>一篇旧文----《当今中国会不会发生革命》</title>
    <url>/2018/09/06/%E4%B8%80%E7%89%87%E6%97%A7%E6%96%87-%E5%BD%93%E4%BB%8A%E4%B8%AD%E5%9B%BD%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%8F%91%E7%94%9F%E9%9D%A9%E5%91%BD/</url>
    <content><![CDATA[<p>苏振华对本文的初稿提出了中肯的批评和建议，在此致以感谢。</p>
<p>二十世纪中国是一个革命的世纪。二十世纪上半叶，中国经历的主要革命运动有辛亥革命、二次革命、五四运动、北伐战争和共产主义革命。1949年中国共产党取得政权后，又搞了许多具有社会革命性质的社会运动，其中最为著名的有土地改革、人民公社运动、大跃进和文化大革命。改革开放后，中国共产党逐渐从一个革命党转变为执政党，但是中国的一些知识分子、学生和民众却从共产党手中接过“革命的旗帜”，于是就有了1989年的学生运动以及最近的“零八宪章运动”和所谓“茉莉花运动”等集体行动的事件。当然也有知识分子提出中国应该“告别革命”，应该反对激进主义。这是一种应然性吁求，但问题在于：中国是否会再发生（或者能避免）一场革命性的社会动荡？</p>
<p>这一问题甚至引发中国政治精英的广泛关注。最近网上有文章说中共高层有不少人在阅读托克维尔（Alexis de Tocqueville）的《旧制度与大革命》（L’Ancien regime et la Revolution），幷说王岐山看完此书后曾担忧地表示：中国的现代化转型不会那么顺利；中国人自己的代价也没有付够。当然，革命一旦发生，人民将付出的代价在一定程度上是由革命性质决定。一般来说，政治革命（一场只改变政权的性质，而不改变社会经济结构的革命）给社会带来的震荡要远远低于社会革命（一场既改变政权的性质，又改变社会经济结构的革命），非暴力革命给社会带来的震荡要远远低于暴力革命。王岐山也许是在担心中国会发生一场暴力革命，甚至是暴力性的社会革命。</p>
<p>不管上述中共高层读书的传说可信度如何，有一点十分明确：虽然近年来中国政府在维护稳定上花了很大的力气，中国的经济在近三十年来取得了举世瞩目的发展，民众的生活水平在近年来也有了很大的提高，但中共高层丝毫没有减轻对在中国再发生一次革命的可能性的焦虑。中共高层为甚么会如此忧虑？当前中国与政权稳定相关的根本问题是甚么？本文试图在理论的指导下对当前中国面临的困境作出分析。</p>
<h1 id="一-革命为甚么会发生：理论简述"><a href="#一-革命为甚么会发生：理论简述" class="headerlink" title="一　革命为甚么会发生：理论简述"></a>一　革命为甚么会发生：理论简述</h1><p>早期的西方理论都把现代化过程中所发生的巨大社会变迁看作是一个国家发生革命的主要诱导因子。这一理论的逻辑很简单：现代化带来了传统的生活方式和价值观的变化，给身处其中的人们带来很大的不适应和不确定性；同时，现代化过程也削弱了传统社会组织对于人们的控制，给革命造就了机会1。的确，世界上的革命无一不发生在正在发生巨大变化的社会之中，而巨大的社会变迁确实会给身处其境的人们带来多方面的不确定性。从这个意义上说，这种理论自有它的道理。但是，世界上每一个国家在现代化过程中都经历过巨大的社会变迁，却不是每个国家都发生了剧烈的革命。社会变迁充其量只能是引发革命的一个必要条件。</p>
<p>在过去的大多数时间，有些学者也常用阶级或者是利益集团的视角来解释一个国家革命的成功与否2。他们的逻辑也很简单：如果一个国家中的一个主要阶级拥护和加入了革命，那么革命就会成功；反之革命就不会发生，就是发生了也会失败。当今中国的不少学者也仍然会自觉或者不自觉地运用这一视角来分析中国社会的危机所在。依笔者所见，这类分析方法表现出了左派知识分子的天真，而反映出来的则是这些知识分子看待问题时的教条性。</p>
<p>这并不是说人们在现代社会中不会产生阶级认同。问题在于：每一个人在社会上都会同时拥有许多身份（比如一个人同时可具有如下的身份：工人、浙江人、男人、某些圈子中的一员、某个俱乐部的成员等），并且具有某一身份的人们之间又存在着巨大的差别（比如工人之间就有蓝领工和白领工、技术工和非技术工、熟练工和非熟练工、临时工和正式职工之间的差别等）。因此，除非存在巨大无比的外力，比如国家对社会上的一个主要人群的利益完全漠视，幷且对这一人群的抗争进行严厉的和系统性的镇压，否则那些被天真的知识分子所认定的“阶级”就很难形成强烈的认同感，去完成知识分子所赋予他们的“历史使命”。</p>
<p>当今世界只有两类大型群体会有着较为“天然的”强大认同感，那就是族群和宗教群体。他们所发起的抗争和革命也因此往往有较大的威力。在很大的程度上，当今所流行的各种“社会分层研究”都是过去知识分子的研究误区的某种产物。不同的社会分层方法除了对了解社会流动和指导政府的公共政策制订有一定的应用性意义外，从社会行动或革命的角度来看，其价值却十分有限。这当然是题外话。</p>
<p>1970年代后，西方学者开始强调国家的性质和结构性行为对革命产生乃至成功的影响3。这类理论背后的一个核心逻辑是：在当代交通和通讯技术的支持下，现代国家获得了古代国家完全没有的渗透社会的能力。与古代国家相比，现代国家的管治领域不但十分宽泛，而且它的政令更能严重影响到社会上绝大多数成员的利益。现代国家的这一性质导致了如下三个后果：第一，国家的错误政策非常容易触发民众大规模的针对国家的怨恨情绪；第二，国家的强势刺激了人们组织起来进行抗争，要求国家颁布和施行对自己群体有利的法律和社会政策；第三，部分人就会想到通过夺取国家的权力（即革命）来彻底改变国家的性质，通过掌握国家权力来推行他们的理想。在这种所谓“国家中心论”的视角下，西方学者做了大量的研究，幷逐渐产生了以下三点共识（即衡量一个国家发生革命可能性的三个维度）：第一，革命不容易发生在一个有着效率较高的官僚集团的国家（官僚集团内的程序政治会增强国家精英的团结、国家决策的合理性和国家镇压机器的有效性）；第二，革命不容易发生在一个对社会精英有着很强吸纳能力的国家；第三，革命不容易发生在一个对社会有着很强渗透力（不仅仅指由国家所控制的交通和通讯工具，而且指警察机构对社会的监控能力）的国家4。</p>
<p>以上的三个维度有很强的解释力。的确，早期的革命，包括法国革命（1789）、俄国革命（1917）、中国革命（1949）和伊朗革命（1979），都发生在用以上三个维度来衡量处境都不太妙的国家。其实，官僚集团的效率、国家对社会精英的吸纳能力，以及国家对社会的渗透能力，是任何国家进行有效统治的关键要素。一个没有这些能力或者是这三方面能力不足的现代国家，无论是民主国家还是威权国家，都会在其运行过程中遇到大量的困难。但问题是，长期以来在分析革命的可能性时，西方学者过于借重了这三个因素，因此直到1980年代他们还在强调苏联和东欧国家具有很大的政治稳定性（因为这些国家都有着比较有效率的官僚集团、对社会精英的吸纳能力和对社会的渗透力）5，而完全没有料想到革命竟然马上就在这些国家发生了，而且其中不少国家的革命都取得了成功。</p>
<p>笔者认为，在分析苏联和东欧国家爆发革命的可能性时，西方学者都忽略了国家权力的合法性基础和国家政权稳定性之间的关系这一维度的重要性。具体来说，一个国家的权力愈是建立在较为稳定的合法性基础之上，这一国家就愈不可能发生革命。苏联和东欧之所以发生革命，不仅仅是因为它们的经济没搞好、它们的军事落后、它们在民族问题上走入误区、它们的领导人采取了错误的政策等（这些因素都很重要），而且更在于这些国家没有把政权建立在一个比较稳定的合法性基础之上。笔者多年来对中外各国革命作出分析时不断强调国家的合法性基础与政权稳定性之间的紧密关系6。笔者认为，西方学者所着重的三个维度都是国家统治手段中偏“硬件”性质的成份，而国家的合法性基础和政权稳定性则构成了国家统治的关键性“软件”，它们缺一不可。</p>
<h1 id="二-合法性和政权的稳定性"><a href="#二-合法性和政权的稳定性" class="headerlink" title="二　合法性和政权的稳定性"></a>二　合法性和政权的稳定性</h1><p>国家虽然掌握着强大的官僚组织以及军队与警察等武装力量，但是其统治的有效性仍必须依赖于国家政权在大众（包括国家官员）心目中的合法性。考察古今中外的统治史，我们会发觉国家在寻求统治合法性时只能采取以下三种方式：通过一种价值性的承诺、通过提供公共服务、通过一个普遍被接受的国家领导选拔程序。相应地，我们可以界定三种理想状态的国家合法性基础：意识形态型、绩效型和程序型7。如果一个国家统治的正当性是基于一个被民众广为信仰的价值体系，我们可以说这个国家的统治是基于意识形态合法性；如果一个国家统治的正当性来源于国家向社会提供公共物品的能力时，这个国家的统治则基于绩效合法性；如果一个国家的领导人是通过一个被大多数人所认可的程序而产生，这一国家的统治则基于程序合法性。</p>
<p>需要强调的是，以上定义的是国家合法性来源的三个理想类型（ideal types）。现实中，任何国家都不会把合法性完全建立在某一理想类型之上；或者说，任何国家的合法性来源都是这些理想类型的一个混合体。但是，在某一历史时期内，某一理想类型往往会成为一个国家统治最为重要的基础，幷在很大程度上定义了一个国家的性质。</p>
<p>现在让我们来讨论不同的国家合法性基础和政权稳定性之间的关系。</p>
<h2 id="（一）意识形态合法性"><a href="#（一）意识形态合法性" class="headerlink" title="（一）意识形态合法性"></a>（一）意识形态合法性</h2><p>意识形态是国家统治的一个最为根本的合法性基础。一个国家如果把执政基础完全建立在某一意识形态之上，那是不行的；但是，一个国家的执政如果没有意识形态作为基础，则是万万不行的。当大多数的民众都认同国家所推崇的某一意识形态时，这种意识形态不仅仅为国家的统治提供了道德性依据，而且为社会提供了一个“核心价值观”。如果一个国家有一个被广为接受的核心价值观，统治成本就会大大降低。</p>
<p>需要强调的是，核心价值观不能是“八荣八耻”，也不能是“雷锋精神”，因为这些都只能是一个国家的从属性价值观，只有核心价值观才有助于建立国家的合法性基础。国家的核心价值观必须是一种宏大的给予历史以某种道德意义的叙事（即西方后现代学者所说的“宏大叙事”[grand narrative]）。美国中学教科书上所描述的美国建国历史以及那些由建国时期政治家所确定的建国原则和理念，就是核心价值观的一个例子；西周初期所形成的“天命论”以及在西周历史中逐渐得以完善的“宗法制度”是有周一代的核心价值观，幷对古代中国的政治哲学和政治文化产生过重大的影响；当代中国学生在学校里学过的围绕着历史唯物主义和“只有共产党才能救中国”而展开的中国近代史叙事，也是核心价值观的一个例子。当然，美国的宏大叙事在其社会中仍然可以获得广泛的认同，而中国教科书中的叙事方式和内容在国内已经没有多少人真正认同了，幷且中国政府至今也没有创造出一套能被广泛认同的宏大叙事。这一意识形态的缺失所导致的后果就是核心价值观的缺乏，幷给当下中国政府的执政带来了很大的困扰。此是后话。</p>
<p>不同的意识形态有着不同的性质，幷对国家政权的稳定性有着不同的影响。意识形态合法性有三个主要类型：领袖魅力型、世俗意识形态型、宗教意识形态型。在这三个类型中，领袖的魅力（近似于韦伯所说的“克里斯玛合法性”）最不能给予政权一个稳定的合法性基础，因为领袖的寿命有限。</p>
<p>一般来说，世俗意识形态对大众所作的承诺比较容易被验证。一旦当国家不能兑现那些承诺，就会产生合法性危机。从这个意义上来说，世俗意识形态也不是一个稳定的合法性基础。但是如果我们把世俗意识形态进一步细分，就会发觉不同的意识形态对人性有不同的要求和对民众有不同的许诺。一般来说，要是一种意识形态对人性的要求愈接近于人的本性幷且其许诺愈不容易被证伪，这一意识形态就愈能为国家的合法性提供一个可靠的基础。比如美国建立在个人主义基础上的“机会之地”（Land of Opportunity）这一意识形态，不但与人的竞争和趋利本性十分接近，而且很难被证伪。这一意识形态有着人们所说的“钱币落在正面我赢，落在反面你输”（heads I win, tails you lose）的性质：你的成功证明了这意识形态的正确性，而你没有成功很容易被解释为是你没有付出足够或恰当的努力。与之相比较，“共产主义”这一意识形态就很难为一个政权提供稳定的合法性基础。共产主义意识形态不但建立在一个过于理想的人性的基础之上，幷且承诺提供一个比其他社会制度更为完美的世俗世界，例如“各尽所能、按需分配”之类。如果一个国家把共产主义意识形态作为合法性基础，一旦国家不能兑现相应的承诺，民众马上就会产生“信仰危机”，从而给国家带来合法性危机。</p>
<p>但是从理论上来说，即使一个国家把合法性建立在像共产主义这样很不牢靠的意识形态之上，这一国家也是有可能取得较为长久的政权稳定的。这里的诀窍是：当大多数民众还相信这一意识形态时，国家就应该采用选举（程序合法性）来补充共产主义意识形态的内禀不稳定性。因为一旦有了选举，幷且在社会上的大多数民众都认可共产主义意识形态的情况下，当政府搞得不好时，候选人就可以攻击政府没有带领人民在共产主义的“康庄大道”上正确地前进，民众就会去怪罪当朝政府的施政，而不是从意识形态本身的误区来检讨国家中所存在的根本问题。读者可以假设，如果中国在毛泽东时代能搞出一个共产党领导下的民主社会的话，今天的中国也许就不会面临如此严重的意识形态合法性危机。</p>
<p>以上的逻辑还支持了以下的推论：宗教意识形态要比任何世俗意识形态更能为一个国家提供稳定的合法性基础。宗教源自于人的可怜的本性──因为害怕失去和死亡而无限放大生命的意义。宗教的承诺也不具有可验证性──“来世”、“净土”或者“天堂”这样的宗教承诺既十分动人又无法验证，而对于宗教来说，最具权威的克里斯玛都是不存在于世俗世界的“神”、“佛”或者是“圣人”。宗教意识形态与人性的贴近和承诺的无法验证性，赋予那些把国家合法性建基于宗教意识形态之上的国家很大的政权稳定性。</p>
<p>不过，在现代社会，宗教意识形态合法性的最大弱点来自宗教力量和国家政权之间的紧张。现代社会极其复杂且变化极快。为了适应新的变化，国家政权就必须以务实的态度来处理日益复杂的世俗性事物，但是国家的务实态度及其所带来的社会后果势必会招来具有强烈保守倾向的宗教力量的反对。由政教斗争所导致的政权不稳定性，对于那些把宗教意识形态作为合法性基础的国家来说，是必定要面临的一个难题。当今伊朗的政治就在较大程度上受到这一因素的困扰。</p>
<h2 id="（二）绩效合法性"><a href="#（二）绩效合法性" class="headerlink" title="（二）绩效合法性"></a>（二）绩效合法性</h2><p>任何一个政府都需要为治下的民众提供必要的公共服务，例如仲裁、维持公共秩序、保证人身安全、保卫国家等。这个层面上的绩效是绝不可少的。如果一个政府没有能力提供这些最为基本的公共物品，相应的国家就不会存在，即便存在也会很快垮台。这里所说的“绩效合法性”，指的是国家领导集团在一个更为进取的层面上积极创造绩效以获取合法性。</p>
<p>获取这一合法性的手段可分为三种亚类型：领导经济发展、官员作为民众的道德表率和炒作民族主义情绪。但是，这三种手段都不能为国家提供一个稳定的合法性基础。首先，没有一个国家能保证经济的永久高增长。其次，把官员的道德表率作为国家合法性基础就会将贪污这样在法律层面上能解决的问题提升为政治问题，从而从根本上削弱了国家的合法性。最后，如果在和平时期政府经常以炒作国际危机来提高其统治合法性的话，这一国家的国际环境就会日趋险恶，幷且大量的极端民族主义者就会在这一国家中产生。这将推动一个国家朝着战争的方向发展，后果不堪设想。　总之，当一个国家的合法性系于绩效承诺时，这一国家的政府就必须设法来兑现这些承诺。如果这些绩效承诺得到了兑现，民众的欲望就会提高，幷对政府提出更高的要求，而政府则不得不把民众不断提高的要求作为新的、更新的，甚至是即时的工作目标。但是，一旦政府不能够兑现其承诺时，这一国家马上就会出现合法性危机。</p>
<h2 id="（三）程序合法性"><a href="#（三）程序合法性" class="headerlink" title="（三）程序合法性"></a>（三）程序合法性</h2><p>现代社会到来之前，除了古希腊之外，程序始终不是世界各国权力合法性的一个重要基础。这幷不是说在古代政府首脑产生的背后没有程序可言，而是说这些程序只在一小部分精英之间才有意义，幷且这些程序在国家政治中不占有像今天的选举政治般重要的地位。笔者认为，以下三个原因使得程序合法性在现代政治中的地位不断上升：</p>
<p>第一，现代国家绝大多数都采取了政教分离原则，宗教意识形态不再是国家的主要合法性来源，或者说现代国家失去了古代国家所拥有的一个十分稳定的合法性基础；第二，现代国家的政府管理的事情愈来愈多，这就使得绩效在现代国家合法性中的地位大大增强，幷给现代国家的政治带来很大的不稳定性；第三，在现代技术的支持下，政府的统治能力不断加强，民众生活受到国家政策愈来愈严重的影响。在这一背景下，怎么控制政府的权力，幷使之不滥用权力，对广大民众来说就变得十分迫切。</p>
<p>我们可以从多种视角来解释为甚么民主政治会在现代国家中兴起。就本文的角度而言，民主兴起的一个重要原因就是现代国家意识形态合法性不足幷且严重倚重于绩效合法性，这就使得国家不得不依靠程序合法性来获得政权的稳定性。</p>
<p>由于以下原因，现代意义上的程序合法性（即民主选举）会给国家政权带来很大的稳定性8：</p>
<p>第一，一旦国家首脑是由民选产生，只要选举被认为是公正的，执政者即使在上台后表现很差，也不会影响政府执政的合法性。用通俗的话说，在绩效合法性的统治基础上，当官如果不为民作主，就有被赶回家卖红薯的危险；而在程序合法性的统治基础上，当官即使不为民作主，也至少得当完一届才回家卖红薯。从这个意义上说，程序合法性大大减低了民众对政府执政的压力。</p>
<p>第二，当一个国家有了程序合法性后，即使有执政者被赶下台也不是甚么大事。这是因为程序合法性在很大程度上把政府和政体分开了。政府即使垮台（比如水门事件[Watergate Scandal]后的尼克松[Richard M. Nixon]政府），政体也不会受到根本性的动摇。</p>
<p>第三，当一个国家有了程序合法性后，民众的不满在相当程度上可以通过选举或其他常规程序的政府更迭而得到缓解。一旦民众有了选择，他们就难以联合起来进行革命，这也给国家政权带来了稳定性。</p>
<p>第四，一旦当官的不为民作主也没有马上就被赶回家卖红薯的危险的时候，公开批评国家领导就不是甚么大事了，这就给言论和结社自由提供了基础。但这自由同时也约束了人民的行为，缓解了社会矛盾，从而构成了政权稳定的一个重要机制。这是因为言论和结社自由让社会上各种思想及利益的交流和竞争，使人们对社会其他群体的利益有了更深的理解，对社会现状有了现实感。同样重要的是，一旦有了言论和结社自由，现代社会的多样性势必会导致社会组织在利益和观点上的分化，这些组织互相牵制使得任何全民性的革命运动变得不大可能。</p>
<p>但就稳定国家政权而言，程序合法性也有着很多弱点，其中最为重要的是它背后必须有一个核心价值观支撑，或者说只有在竞选各方都服从同一意识形态（即“忠诚反对”）时，程序合法性才能为国家提供政权稳定性。如第二次世界大战前的德国，共产党、纳粹党和社会民主党各自有着完全不同的意识形态，幷且共产党和纳粹党都想利用选举来夺取政权，把国家彻底引向对自己有利的方面，形成赢者通吃的格局，选举在这种情形下就不可能成为国家政权稳定的基础。从这个意义上说，一个政治上最为稳定的国家（或者说最不可能发生革命的国家）应该是一个同时拥有意识形态合法性和程序合法性的国家：程序合法性需要强有力的意识形态合法性的支持，幷且程序合法性又是维持国家的意识形态合法性的关键。</p>
<h1 id="三-有关中国政府合法性的经验研究"><a href="#三-有关中国政府合法性的经验研究" class="headerlink" title="三　有关中国政府合法性的经验研究"></a>三　有关中国政府合法性的经验研究</h1><p>在“世界价值观调查”（World Values Survey）和“亚洲民主动态调查”（Asian Barometer Survey）等调查数据基础上，一些学者对中国的国家合法性进行了研究。他们的一个重要发现是：中国民众对政府的认可度要远远高于许多西方民众对他们政府的认可度。他们于是就得出中国政局稳定、国家具有很高的合法性这一结论9。一般来说，我们都会相信这些研究的结论是成立的。这些学者都受过严格的西方学术训练，他们的材料所展示的也是全国民众的普遍看法，而不是少数人的极端观点。同时，中国政府近年来加强了吏治，采取了一系列的“亲民政策”，这些政策应该说是取得一定效果的。笔者近年来在全国范围内与农村和城市的各界民众进行了不少交流，感到中国百姓的生活水平在近年来有了普遍的和显著的提高，或者说大多数百姓确实从国家的政策中获得了实惠。这些学者的研究结果所反映的正是民众对于当今政府的绩效在一定程度上的认可。</p>
<p>但问题是，从“百姓对当下政府的绩效是肯定的”这一现象中，我们是不能推论出“这个国家的政局是稳定的”这样一个结论的。遍览世界各国，民众对政府绩效的评价，可以说是说变就变的。在西方，民众对政府的认可度数月内就可以波动许多个百分点（他们对政府的认可度有时甚至低至百分之十几）。在西方国家，民众对政府绩效的认可度与国家政局的稳定性之间没有很大的关系，因为西方国家合法性的根本基础不是政府的绩效，而是被主流精英和人民所认可的核心价值观和具有程序公正的选举。但是在中国，百姓对政府执政绩效的认可度与政局的稳定却有着密切的关系：如果中国百姓对政府绩效的认可显著下跌的话，的确是有可能引发一场大规模的政治波动甚至革命的。这背后的原因很简单：共产主义意识形态在中国已经式微，但是国家又拿不出其他有效的价值观取而代之；同时，中国领导人也不是通过一种被大多数人所认可的程序而产生的。中国因此非常缺乏意识形态和程序层面上的合法性，于是绩效就成了国家合法性的最为重要、甚至是唯一的基础。</p>
<h1 id="四-当前中国的问题所在──合法性问题"><a href="#四-当前中国的问题所在──合法性问题" class="headerlink" title="四　当前中国的问题所在──合法性问题"></a>四　当前中国的问题所在──合法性问题</h1><p>中国经济发展举世瞩目，百姓的生活水平近年来有了很大的提高。但是，中国维稳的成本却愈来愈高。2011年，中国一些人受到突尼斯“茉莉花革命”的影响，促动“茉莉花运动”，但国内几乎没有人响应。尽管如此，不少市政府还是如临大敌，弄得马路上的警察人数不知超过了寥寥无几的闹事人群多少倍。显然，繁荣的经济和大多数百姓对当下政府在不少方面的表现还算满意这些事实，完全不能减轻中共高层领导的焦虑。到底甚么是当前中国政局的关键性不稳定因素？或者问：中共高层领导到底在忧虑甚么？说到这一点，国内的绝大多数知识分子和百姓都会把诸如贫富差距过大、官员贪污腐败等放在首列，但这些因素的重要性或许幷不是想象般大。当前中国的贫富差距的确很大，而官员贪污腐败（特别是在那些吏治较差的省份）无疑也十分严重。相比之下，印度的贫富差距和官员腐败也十分厉害，甚至在不少方面明显超过了中国，可是印度却不是人们认为很可能发生革命的国家。显然，仅仅是贫富差距和官员贪污腐败是不足以引发革命的。</p>
<p>中国的知识分子和百姓都对贫富差距和官员腐败深恶痛绝，但是中国却完全不存在这方面的高质量研究。于是，在考虑这些问题时，中国的知识分子和民众就不得不凭借想象：你对政府有多大程度上的不信任，你就会把中国的贫富差距和官员腐败问题想象得有多严重。笔者认为，当前中国的问题归根到底是政治问题，或者说国家的合法性问题，而不是诸如贫富差距和官员腐败这类社会问题。而中共政权合法性问题的关键在于：第一，国家在共产主义意识形态式微后再也拿不出一个能被广泛认可的主流价值体系；第二，国家不敢（或者不愿意）把合法性的重心转移到程序合法性的层面上来；第三，国家对于绩效合法性产生了过度的依赖。</p>
<p>当下中国的领导人似乎仍然不了解绩效合法性的内禀不稳定这一特质，因为在他们的各种发言中不断流露出人民自然会拥护一个绩效优良的政府这样一种天真的论点，幷且他们也正在努力地通过加强政府绩效来获取国家的合法性。他们的做法与百姓情绪的耦合就给中国带来了如下的悖论：中国的经济和民众的生活水平在近年来都取得了举世羡慕的发展，但是社会却有朝着革命方向发展的倾向。</p>
<p>当社会上的大多数精英和百姓都认同于国家建构的意识形态时，这一意识形态就会成为一个社会的核心价值观或者说核心意识形态。在有着主流意识形态的国家中，社会就会显得非常平和甚至是保守。比如媒体：如果一个记者经常在某一媒体上发表与主流意识形态不符的言论，百姓就会不喜欢这个媒体，其订阅量或收视率就会下降，媒体老板也因此会不喜欢这一记者。可以说，当国家建构的主流意识形态被广为接受时，百姓就会更相信那些平和甚至是保守的报导，而发表偏激言论的媒体就会没有出路。个体也一样：如果一个人经常在公开场合（和网络上）发表与主流意识形态不符的言论，他的言论就会被忽视，他的朋友也不会喜欢他，他也不会有任何社会影响。但是，如果社会上的精英和大多数百姓不认同国家建构的主流意识形态时，人们就会不相信主流媒体中的报导，特别是与政治有关的报导，与主流意识形态保持一致的媒体就会在民众的心目中被边缘化，幷且不再能建构民众的舆论，而敢于反对主流意识形态的媒体和个人就会被看作是“社会的良知”。</p>
<p>当国家建构的意识形态不再是社会上的主流价值观时，在面对以上的异议时国家也就失去有效的对策。如果国家对闹事者或者发表对国家不满观点的人士进行镇压的话，那么国家政权在民众心目中就会进一步失去道义，稍有良知的国家干部就会感觉愧疚，而闹事者和发表对国家不满观点的人士就会被大家看作是“英雄”。但是如果国家选择容忍的话，那么这些人的行动和言论就得不到约束。更有之，一旦形成了这样的“机会结构”，人们就会发觉“会闹的孩子多吃奶”这一妙诀，社会民风于是趋于民粹和暴戾。同时，一旦大众有着把闹事者和发表对国家强烈不满观点的人士看作是“英雄”的倾向，随着“英雄”形象而产生的种种利益就会刺激有些人带着寻租的心态去装扮“英雄”。社会道德就在围绕着反体制而产生的种种“高尚”话语下不断下降。</p>
<p>当国家建构的意识形态不再是社会上的主流价值观时，政府就会失去公信力。这时，如果国家对舆论不加控制，反政府的言论就会在社会上产生很大的影响力，从而引发政治危机。但是如果国家控制舆论的话，人们就会去追逐谣言；加上长期控制舆论而导致人们普遍的无知，天方夜谭式的谣言很容易不胫而走，比如“江泽民去世了，但是中共却秘不发葬”、“薄熙来手上有一百多条人命”、“被重庆警察击毙的不是周克华而是一个便衣警察”等，也会被大家（包括不少社会精英）津津乐道。这些传言不但会给中国的政局增加不确定因素，幷且使得中国本来就很糟糕的政治文化进一步走向糜烂。</p>
<p>当国家建构的意识形态不再是社会上的主流意识形态时，国家的当权者甚至不敢运用民主选举来增强其合法性。从当权者的私利角度看，在这样的情况下举行选举不但会使他们马上下台，而且整个共产党的统治也会结束；很少有当权者愿意在这样的条件下推动民主选举。而从国家利益来说，如果政治精英不能服从一个主流价值观，由选举而产生的“非忠诚反对派”就会撕裂社会，这给了当局拒绝搞民主选举以一定的道德依据。但接下来的问题是，不搞以选举为核心的程序政治只会使得社会矛盾不断积累，幷为中国从威权国家到民主国家的平稳过渡增加了难度。</p>
<p>一旦国家的合法性不能依托于意识形态和领导人的产生程序，绩效就成了国家唯一可依托的合法性基础。得益于中国的“强国家”传统，中国政府在加强执政绩效方面应该说还是可圈可点的。但是，即便可圈可点的绩效使得中国政府变得十分富有，其后果却是金钱使国家领导变得短视，以为金钱能解决一切问题，结果在解决一个问题的同时制造了几个问题。更令人担忧的是，围绕着金钱所产生的种种利益，使得大量的利益相关者带着工具理性围聚在政府周围。这些人对体制毫无忠诚可言，他们一方面死死地把住体制的大船，另一方面则随时准备另寻高就甚至搞狡兔三窟。当前中国出现了“裸官”现象，即不少国家干部的妻子和子女都在国外拥有永久居住权甚至是公民资格，大多数年轻人都向往公务员和国企的工作，其原因盖出于此。这带来的后果就是当前中国民众的强烈仇官心理以及由此生发出来的对任何成功者的仇恨心理，整个社会的道德维系（moral fabric）被大面积毁坏。</p>
<p>为了进一步加强绩效合法性，政府就必须加强吏治、采取悦民政策，幷且把社会上可能出现各种不安定因素的事情统统管了起来。但是，恶性循环不可避免地开始了：政府管得愈好，民众对政府的要求就会愈高；政府管得愈多，问题也就愈多，很多社会问题于是成了政治问题。社会问题的重新政治化是近十年来中国出现的一个令人担忧的发展方向。</p>
<h1 id="五-中国的前途"><a href="#五-中国的前途" class="headerlink" title="五　中国的前途"></a>五　中国的前途</h1><p>在国内，对国家前途不看好的还真是大有人在，其中既有国内语境下的“自由主义者”和比较极端的“左派”，也有难以计数的掌握着一定话语权的网民。最近，甚至连吴敬琏这样比较持重的学者，都在发表文章惊呼当前中国的“经济社会矛盾几乎到了临界点”10。本文认为，中国的确有再爆发一次革命的可能。与以上的观点不同是，笔者认为当这场动荡到来时，其引发的根本原因不应该是当今中国社会上存在着的各种“经济社会矛盾”，而是民众在主观层面上的不满情绪以及由此带来的大量的社会矛盾。而这些不满情绪和社会矛盾的根源，则是当今政府在国家的法律─选举合法性不足的情况下，过多地把绩效当作了国家合法性的根本基础。笔者同时认为，虽然当前的形势很严峻，但是由于以下原因，中国并没有马上就爆发一场革命的危险：</p>
<p>第一，尽管近年来中国经济发展的势头有所减缓，但是中国仍然是世界上经济发展最为迅速、百姓生活水平有着快速提高的国家。只要中国经济继续能保持目前的增长势头，绩效合法性就还能维持一定的效力，一场革命性的动荡在中国就暂时不会发生。</p>
<p>第二，在中国的不少地区（特别是藏区和新疆地区）有着很严重的民族问题，但中国少数民族人口与汉人相比比例实在太小；这就是说，与前苏联不同，少数民族地区的动乱在中国不会是引发革命的一个主要动因。</p>
<p>第三，由于美国经济的衰退和美国对外政策在世界上普遍不得人心，相当部分的中国知识分子不再简单地把美国政治和政治体制作为理想，或者说当前中国的“自由派”知识分子不再享有1980年代的道德高度，因此也失去了1980年代一呼百应的能力。</p>
<p>第四，中国知识分子在近年来生活水平有了很大的提高，幷且他们发表言论的渠道也大大增加。如果说前一个变化给了知识分子耐心，使他们不会急于鼓动革命，后一个变化则促进了知识群体的分化，从而降低了在中国产生一个人们广为接受的反体制意识形态的可能性。第五，国内外大多数的学者往往会把中国每天都在发生的群体性抗争事件（特别是一些重大事件）看作为革命性事件的可能促发因素。这种观点再一次反映了知识分子的天真。笔者认为，大量的群体性事件对中国政治的稳定实际上有着巨大的正面作用。当前不少地方的地方政府软弱，中国大规模爆发群体性抗争事件的阈值因此较低，社会矛盾也不容易有大规模的堆积。此外，当前中央政府对地方发生的群体性抗争事件采取的基本态度就是让地方政府自己去处理。只要地方政府能控制住局面，中央就保持袖手旁观的姿态；但是如果地方政府让事件失控，或者在处理过程中造成了流血事件，在国内外引起广泛关注，中央政府则会对地方政府官员进行处罚。中央政府的这一做法强化了群体性事件参加者“反贪官不反皇帝”的心态，同时也促使地方政府在处理群体性事件时表现出了极大的多样性和灵活性，从而大大缓解了中国群体性事件走向政治化的倾向。</p>
<p>第六，与一些领袖终身制的国家相比，中国已经形成了一套比较成型的国家领导每届五年，每任不超过两届的做法。虽然新的领导人不是由普选产生，幷且换届过程的不透明也给各种政治流言提供了温床，但是换届送走了人们已经厌烦了的领导（不在于干得好不好，而在于一个人在领导位置坐长了人们都会产生厌倦感），给了人们一种新的想象和希望，从而缓解了社会矛盾朝着革命的方向发展。</p>
<p>但是以上这些有利于缓解社会矛盾激化的因素，完全不可能改变以下的事实：在意识形态和程序合法性严重不足的情况下，执政绩效成了当前中国政府最为主要的合法性基础。因此，即便中国没有马上就发生革命性动荡的危险，只要国家的性质得不到根本性的改变，再发生一次革命的危险在中国始终存在。从这个意义上来说，“中国人自己的代价”的确“没有付够”。</p>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>1　Samuel P. Huntington, Political Order in Changing Societies (New Haven, CT: Yale University Press, 1968); William Kornhauser, The Politics of Mass Society (Glencoe, IL: Free Press, 1959); Eric R. Wolf, “Peasant Rebellion and Revolution”, in National Liberation: Revolution in the Third World, ed. Norman Miller and Roderick Aya (New York: Free Press, 1971), 48-67.</p>
<p>2　Barrington Moore, Social Origins of Dictatorship and Democracy: Lord and Peasant in the Making of the Modern World (Boston: Beacon Press, 1966); Jeffrey M. Paige, Agrarian Revolution: Social Movements and Export Agriculture in the Underdeveloped World (New York: Free Press, 1975).</p>
<p>3　Jeff Goodwin, No Other Way Out: States and Revolutionary Movements, 1945-1991 (New York: Cambridge University Press, 2001); Tim McDaniel, Autocracy, Capitalism, and Revolution in Russia (Berkeley, CA: University of California Press, 1988); Autocracy, Modernization, and Revolution in Russia and Iran (Princeton, NJ: Princeton University Press, 1991); Theda Skocpol, States and Social Revolutions: A Comparative Analysis of France, Russia, and China (New York: Cambridge University Press, 1979); Timothy P. Wickham-Crowley, Guerrillas and Revolution in Latin America: A Comparative Study of Insurgents and Regimes since 1956 (Princeton, NJ: Princeton University Press, 1992).</p>
<p>4、5　Jeff Goodwin and Theda Skocpol, “Explaining Revolutions in the Contemporary Third World”, Politics and Society 17, no. 4 (1989): 489-509.</p>
<p>6　Dingxin Zhao, “State Legitimacy, State Policy, and the Development of the 1989 Beijing Student Movement”, Asian Perspective 23, no. 2 (1999): 245-84; “State-Society Relations and the Discourses and Activities of the 1989 Beijing Student Movement”, American Journal of Sociology 105, no. 6 (2000): 1592-632.</p>
<p>7　Dingxin Zhao, The Power of Tiananmen: State-Society Relations and the 1989 Beijing Student Movement (Chicago: University of Chicago Press, 2001); “The Mandate of Heaven and Performance Legitimation in Historical and Contemporary China”, American Behavioral Scientist 53, no. 3 (2009): 416-33.</p>
<p>8　赵鼎新：〈民主的生命力、局限与中国的出路〉，《领导者》，2007年第18期，页76-86。</p>
<p>9　Jie Chen, Popular Political Support in Urban China (Washington, DC: Woodrow Wilson Center Press; Stanford, CA: Stanford University Press, 2004); Bruce Gilley, “Legitimacy and Institutional Change: The Case of China”, Comparative Political Studies 41, no. 3 (2008): 259-84; Lianjiang Li, “Political Trust in Rural China”, Modern China 30, no. 2 (2004): 228-58; Tianjian Shi, “Cultural Values and Political Trust: A Comparison of the People’s Republic of China and Taiwan”, Comparative Politics 33, no. 4 (2001): 401-19; Wenfang Tang, Public Opinion and Political Change in China (Stanford, CA: Stanford University Press, 2005).</p>
<p>10　参见吴敬琏的博客，<a href="http://wujinglianblog.i.sohu.com/blog/view/236115860.htm%E3%80%82">http://wujinglianblog.i.sohu.com/blog/view/236115860.htm。</a></p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>政治</tag>
      </tags>
  </entry>
  <entry>
    <title>[]不是None</title>
    <url>/2019/11/28/%E4%B8%8D%E6%98%AFNone/</url>
    <content><![CDATA[<p><code>[]不是None</code>是一个易错点，用代码来看：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">aaa = []</span><br><span class="line"><span class="built_in">print</span>(aaa <span class="keyword">is</span> <span class="literal">True</span>)  <span class="comment"># 输出False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (aaa := []):  <span class="comment"># Python 3.8多了一个类似golang的生命方法，等于&quot;aaa=[] if aaa is True&quot;</span></span><br><span class="line">   	<span class="built_in">print</span>(<span class="string">&quot;22222&quot;</span>, aaa,aaa <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   	<span class="built_in">print</span>(<span class="string">&quot;11111&quot;</span>,aaa,aaa <span class="keyword">is</span> <span class="literal">None</span>) <span class="comment"># 会走到这里</span></span><br></pre></td></tr></table></figure></p>
<p>那么判断list是否是一个空集，除了用<code>len</code>之外，是可以直接用<code>True</code>来做的：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l1 = [<span class="string">&quot;Hire&quot;</span>, <span class="string">&quot;the&quot;</span>, <span class="string">&quot;top&quot;</span>, <span class="string">&quot;1%&quot;</span>, <span class="string">&quot;freelancers&quot;</span>]</span><br><span class="line"></span><br><span class="line">l2 = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> l2:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;list is not empty&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;list is empty&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>或者用<code>bool()</code>，原理一样：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l1 = [<span class="string">&quot;Hire&quot;</span>, <span class="string">&quot;the&quot;</span>, <span class="string">&quot;top&quot;</span>, <span class="string">&quot;1%&quot;</span>, <span class="string">&quot;freelancers&quot;</span>]</span><br><span class="line"></span><br><span class="line">l2 = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">bool</span>(l2):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;list is empty&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   	<span class="built_in">print</span>(<span class="string">&quot;list is not empty&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>而且注意的是<code>aaa = [None]</code>这样的aaa也不是<code>None</code>，啥样的情况会出现<code>None</code>?比如<code>bbb=aaa.sort()</code>，那么这个bbb就是<code>None</code>。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>一次官网打不开的经历</title>
    <url>/2018/02/06/%E4%B8%80%E6%AC%A1%E5%AE%98%E7%BD%91%E6%89%93%E4%B8%8D%E5%BC%80%E7%9A%84%E7%BB%8F%E5%8E%86/</url>
    <content><![CDATA[<p>今天有人反映官网在登陆的时候，chrome浏览器不能正常打开页面，反而会出现一个下载框。我使用IE浏览器尝试登录官网，页面也不是正常的页面，而是下面的内容：<br><img data-src="/images/guanwang1.png" alt="paradin"></p>
<p>由于官网的域名跳转是在阿里云的域名解析的地方配置的，于是就登陆到阿里云的域名解析地方，查看了一下发现，这里的配置是<code>www.lechange.com</code>会302跳转到<code>home.lechange.com</code>，而ping一下<code>home.lechange.com</code>得到的ip地址是一个负载均衡的地址，然后在阿里云的控制台查询这个负载均衡的情况，发现这个负载均衡后面挂载的是两台服务器A和B。</p>
<p>于是我在浏览器里面直接输入负载均衡的ip地址，发现还是像上面那样错误的php界面，而浏览器地址栏使用两个服务器的外网ip却是正常可以打开的。这个时候初步怀疑是SLB的问题，而我当时就觉得就凭上面这一点就去跟阿里撕逼不太妥当，但是事实告诉我们事情不是那么简单的。</p>
<p>我检查一下slb的端口配置情况，分别是<code>http 80转8080</code>和<code>https 443转80</code>，可见这个网站有两个协议，一个是http的而一个是https的，我们刚才虽然在浏览器里直接使用A和B的外网ip访问是可以正常打开页面，只能说明http协议是OK的，我们还要测试一下https协议访问的效果。</p>
<p>我就在浏览器地址栏里进一步尝试，发现使用<code>A外网ip：8080</code>访问是OK的，而使用<code>B外网ip：8080</code>访问就是PHP的文字界面。于是基本问题定位到B服务器里有文件的配置错误。</p>
<p>登陆到B服务器里，在nginx的conf文件夹里发现一个多余的文件，打开内容如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server </span><br><span class="line">&#123; </span><br><span class="line">       listen       <span class="number">8080</span>; </span><br><span class="line">       server_name  www.<span class="property">lechange</span>.<span class="property">com</span> (<span class="attr">file</span>:<span class="comment">//www.lechange.com/) www.lechangebuy.com (file://www.lechangebuy.com/); </span></span><br><span class="line">       index index.<span class="property">html</span> index.<span class="property">htm</span> index.<span class="property">php</span>; </span><br><span class="line">       root  /data/www/ecstore; </span><br><span class="line">       add_header  pos <span class="string">&#x27;web2&#x27;</span>; </span><br><span class="line">#       location / &#123; </span><br><span class="line">#               rewrite ^<span class="regexp">/(.*)$ https:/</span><span class="regexp">/www.lechangebuy.com/</span>$1; </span><br><span class="line">#       &#125; </span><br><span class="line">       location /public &#123; </span><br><span class="line">               root  /data/www/ecstore; </span><br><span class="line">       &#125; </span><br><span class="line">       access_log /data/logs/nginx/access.<span class="property">log</span>; </span><br><span class="line">#access_log off; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而原来nginx是有正常的conf文件，现在又多余了一个这个文件，可见是因为没有无法正常解析.php的文件，两个文件都在占用8080端口时出现了冲突，所以就导致这样php download界面的情况。删除这个多余的文件后，重启nginx，清除浏览器缓存，再重新尝试就正常打开页面了。</p>
<p>为什么会多一个这样的文件，后来把各位运维人员严刑拷打一顿才知道，原来有一次某运维小弟在B服务器里面做跳转的测试，测试完毕之后忘记了把这个多余的文件删除，原本这一切是没有问题的，但是可能服务器nginx经历了重启，于是就加载了这两个conf文件，就把这个隐藏的问题暴露了。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>业务监控大盘设计建议</title>
    <url>/2024/02/26/%E4%B8%9A%E5%8A%A1%E7%9B%91%E6%8E%A7%E5%A4%A7%E7%9B%98%E8%AE%BE%E8%AE%A1%E5%BB%BA%E8%AE%AE/</url>
    <content><![CDATA[<p>先说明，这个不是我的原创，只是用来笔记。</p>
<h2 id="业务监控大盘的主要作用"><a href="#业务监控大盘的主要作用" class="headerlink" title="业务监控大盘的主要作用"></a>业务监控大盘的主要作用</h2><p>业务监控大盘（以下简称大盘）的作用主要是2项。</p>
<ol>
<li>直观显示业务核心指标的趋势，在日常运行和发布变更的过程中可以通过这些指标便捷地判断业务是否正常。<br>  ○ 业务指标 &gt; 系统指标：业务指标出现问题，要第一时间确认是否是系统问题。系统指标出现问题，要第一时间评估对业务的影响。</li>
<li>当业务指标出现异动时，大盘可以帮助定位问题的原因，确定影响的范围。<br>  ○ 指标的选取和布局应体现出因果性、相关性。<br>  ○ 指标的维度要能帮助使用者收敛问题发生的点。单元 * 机房是一种常见的维度。<br>  ○ 指标的时效性要满足使用的需要，以及便捷性。流量、成功率等指标往往只需要秒级，错误码这类指标的分钟、秒级统计则各有适用场景。<br>题外话：这份建议介绍的只是自定义的业务监控大盘，通常是采用sunfire来配置。至于sunfire、eagleeye里开箱即用的系统监控，则不在讨论范畴。但是，系统监控的告警设置是一个重要的话题，不久就会做专门介绍，并且是FY24 Q3与Q4将开展的应用健康度治理活动的重要工具。</li>
</ol>
<h2 id="指标的选取"><a href="#指标的选取" class="headerlink" title="指标的选取"></a>指标的选取</h2><h4 id="2-1-最常见的3种核心指标"><a href="#2-1-最常见的3种核心指标" class="headerlink" title="2.1 最常见的3种核心指标"></a>2.1 最常见的3种核心指标</h4><p>● 流量<br>    ○ 多数业务域、业务场景都有若干个关键流量指标，比如正向交易的购物车查看、确认订单、创建订单。它们往往是故障等级定义的观测指标，或是与观测指标有因果关系、强相关性的其他指标。<br>    ○ 另外，除了类PV的原始流量指标以外，也会选取这类流量转换所带来的业务指标，比如创建的交易主订单量，它由创建订单请求产生。<br>    ○ 每个流量指标应细分为总流量（入口原始流量）、成功量、失败量（可选）、限流量（快速失败的一种，应该显式呈现）。<br>    ○ 产品动线，或是业务场景里强相关的一组流量指标可以放置在一个监控项，但不宜过多。这种情况下，一般会为这组流量指标再设置对应的成功量、成功率监控项。<br>    ○ 区分正常流量和压测流量。可以有包含正常和压测总流量的监控项，但应有单独的监控项或者大盘做区分。<br>● 成功率<br>    ○ 基于上述流量指标，设置配套的成功率指标。例如，创建订单请求量，就应有创建订单请求的成功率。系统接收到多少请求，它成功处理了多少，这是一类很实用的观察指标。<br>● RT<br>    ○ 基于上述流量指标，设置配套的RT指标。PV的RT是衡量用户体验的一项关键指标，同时它的激增往往意味着系统出现了问题。</p>
<h4 id="2-2-其他常见指标"><a href="#2-2-其他常见指标" class="headerlink" title="2.2 其他常见指标"></a>2.2 其他常见指标</h4><p>● 错误码<br>  ○ 应用的接口，一般对齐流量类型，设有较完善的错误码体系时，就应设置配套的监控项。这样可以在成功量、成功率下跌时快速地定位失败原因，所以错误码本质上是成功率的一个下钻指标。从大类来看，错误码主要有以下3种类型。<br>    ■ 限流：包括sentinel（接口、key限流）、noah（自适应限流），它们一般作为单独的监控项<br>    ■ 业务规则引起的失败：例如下单时商品售罄造成扣减库存失败，安全风控阻断的访问<br>    ■ 系统问题引起的失败：例如下游服务超时<br>  ○ 业务规则和系统问题的错误码一般直接放在一个监控项内，形式上是表格。</p>
<p>这里对限流多说一句，入口应用没有配置限流是绝对不可以的！入口应用的下游要为自己做限流，不能把自己的安全完全交给上游！</p>
<h4 id="2-3-特色指标"><a href="#2-3-特色指标" class="headerlink" title="2.3 特色指标"></a>2.3 特色指标</h4><p>除了上述常见的指标，能够反应业务流量的压力与负载，以及能够帮助排查问题的指标也可以纳入进大盘。这里举几个例子：<br>● buy2下单大盘的拆单比：用户提交订单时的平均主订单数，值越高意味着合并下单越多，系统处理单个请求的负载越高。<br>● taodetail详情大盘：平均SKU数量，值越高意味着库存、供应链系统的计算压力越大。</p>
<h2 id="维度的设计"><a href="#维度的设计" class="headerlink" title="维度的设计"></a>维度的设计</h2><h4 id="最常见的维度-单元-机房"><a href="#最常见的维度-单元-机房" class="headerlink" title="最常见的维度 - 单元&#x2F;机房"></a>最常见的维度 - 单元&#x2F;机房</h4><p><code>单元*机房</code>是最常见的维度，章节2.1里提到的3种核心指标都应设置按这个维度区分的监控项。<br>● 当个别<code>单元*机房</code>出现异常时，这类监控可以迅速帮助定位到是哪个<code>单元*机房</code>出现了问题。<br>● 每个<code>单元*机房</code>都存在许多差异性，最典型地是会对性能产生影响。通过区分<code>单元*机房</code>查看RT等指标，可以了解和印证同一套系统在不同<code>单元*机房</code>所表现出的差异性。<br>● 不要单独使用单元、机房作为维度，因为同一个单元会有多个机房，同一个机房也可能有多个机房，需要按最小颗粒度做区分。</p>
<h4 id="其他维度"><a href="#其他维度" class="headerlink" title="其他维度"></a>其他维度</h4><p>其他维度通常带有很强的业务特性或时效性，让这个监控项最有效、最便捷地帮助到SRE、研发是第一优先的原则。<br>● 业务特性：例如业务身份、业务类型来细分某个流量指标。<br>● 时效性：例如接口版本，通常用在系统切流阶段。</p>
<h2 id="监控项布局"><a href="#监控项布局" class="headerlink" title="监控项布局"></a>监控项布局</h2><p>● 最核心的指标放首屏<br>● 从前至后<br>  ○ 用户动线、产品链路时序从前到后。比如buy2大盘里确认订单 -&gt; 提交订单，逆向交易大盘里路由 -&gt; 详情 -&gt; 渲染 -&gt; 提交 -&gt; 同意，等等。方便查看是从哪个环节开始出现问题的。<br>● 从上至下<br>  ○ 技术链路，因果关系从上至下。流量 -&gt; 成功率&#x2F;RT -&gt; 限流 -&gt; 错误码。这体现了排查问题的典型思路，比如成功量跌了，是总流量就跌了还是成功率跌了，成功率跌了是因为自身负载高了（RT飙升），还是限流或是某类错误？<br>● 从粗至精<br>  ○ 按维度做细分，先看指标的总量，再看某个维度每个分类的量。最典型的就是按<code>单元*机房</code>来查看，排查问题时一个典型的思路就是看总量跌的时候，是所有<code>单元*机房</code>一起跌，还是个别机房在跌。其他维度也可以起到一样的作用。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>监控</tag>
        <tag>SRE</tag>
      </tags>
  </entry>
  <entry>
    <title>世界杯的一些感悟</title>
    <url>/2018/07/12/%E4%B8%96%E7%95%8C%E6%9D%AF%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B0%E6%84%9F%E6%82%9F/</url>
    <content><![CDATA[<h2 id="传控已死？"><a href="#传控已死？" class="headerlink" title="传控已死？"></a>传控已死？</h2><p>今早英格兰加时赛输给了克罗地亚，至此就剩下一名曼城球员还在本届世界杯继续前进了，那就是法国队的边后卫门迪。再加上之前小组出局的德国和1&#x2F;8赛输球的西班牙，不得让人怀疑是否“传控已死”？</p>
<p>传控被瓜迪奥拉发扬光大已经10年了，2008年的西班牙也是靠着传控和巴萨的班底拿下两次欧洲杯和一次世界杯。传控虽然在理论上是一个完美的战术，但是战术也需要人来执行，球员水平有高低状态有起伏，裁判的尺度也不一样，这都会影响传控的比赛结果。这几年的传控逐渐被各路教练针对性研究，他们用“高压迫，快速反击，大巴防守”的套路击败传控的经典战役已经屡见不鲜。所以这几年的传控可谓是磕磕绊绊，风光不再。</p>
<p>传控对中场球员要求很高，一旦球员失去了往前传球的机会，那么就成了无效控球，倒脚来倒脚去时间就走光了。而传统打法对球员的要求相对简单但是对球员身体素质和纪律要求很高，所以更多球队选择了传统打法，而他们也很有针对性的对强队进行了部署，或打高空球或者摆大巴打反击。</p>
<p>我个人通过今年的世界杯和以往的几次欧冠来得到这样的结论：传控没有死，但是传控在杯赛的统治力已经大幅下滑，仅但在联赛和小型杯赛还有一定的优势。原因很简单，联赛是三十多场比赛，容错率要远大于杯赛，这就是传控的好处—虐菜相对来说比较稳。但是最近的足坛趋势是世界杯&#x2F;欧洲杯&#x2F;欧冠最大，拿不到上面几个锦标，球员就很难得到金球奖。所以在成绩的压力下，足坛也会慢慢将传控降温，改走传统打法。</p>
<p>即使是442也要有能一脚长传功力的中场做炮台，合适的球员搭配合适的战术才会得到胜利。任何战术本身也要自我修复漏洞，现在的传控队伍也开始慢慢放弃无用的控制，讲究定位球破门和远射破门，但是如何破密集防守还是世界教练共同面对的难题。</p>
<h2 id="决赛怎么看？"><a href="#决赛怎么看？" class="headerlink" title="决赛怎么看？"></a>决赛怎么看？</h2><p>世界杯决赛肯定是防守为主的低比分比赛。法国那边进攻肯定还是“吉鲁吸引炮火，格里兹曼见缝插针，有反击找姆巴佩，角球任意球上大个子”的常规进攻路线。而克罗地亚也是慢节奏抓定位球的方法。我觉得克罗地亚中场并不虚法国，但是莫德里奇这几年没有跟坎特交手过，可以通过这场决赛看看双方谁更技高一筹。法国这批球员相对年轻，虽然这场比赛他们输不起，但是他们已经有了2016年欧洲杯亚军的惨痛经验，而克罗地亚虽然有些球员没有决赛经验，但是他们心态更放松，比较明显的隐患就是克罗地亚的体能是否能支持他们再一次顶得住法国的炮火。</p>
<p>从2006年至今，三届世界杯都踢了延长赛，所以我个人推荐买常规时间法国赢或者平。</p>
<p>至于季军赛，我觉得凯恩会进球，但是比利时3：2赢下英超内战。</p>
<p>世界杯让足彩也跟着热闹起来。我也跟着潮流买了几场比赛，但是我发现凡是“我跟别人说自己没买的”比赛，结果真中了；凡是我“下注买”的比赛都输了，且不用说德国输墨西哥，日本赢哥伦比亚的冷门战，英格兰打哥伦比亚那场的常规时间最后一分钟，米纳进了一个头球，我直接损失100块… </p>
<p>由此我坚信了，我就不是一个特别有好运气的人，而且也比较害怕成为赌徒，完全符合毛主席对知识分子和小资产阶级的定义，一辈子就是老婆孩子热炕头的命。</p>
<h2 id="中国足球怎么办？"><a href="#中国足球怎么办？" class="headerlink" title="中国足球怎么办？"></a>中国足球怎么办？</h2><p>每到这种重大足球赛事，国足就要被当作反面典型来说嘴。前几天黄西发了微博调侃遭到国足及相关人士的狂喷，其实喷来喷去，主题就是一个“国足那些球员拿钱多，成绩却这么烂，如何能提高国足成绩？”</p>
<p>其实这个主题是老生常谈，每次都说改革但是也没什么进步，哪怕输给泰国1-5，全国上下一片骂，几天之后涛声依旧…</p>
<p>我个人认为中国足球在20年时间内是不可能强大的，因为这与中国国情有关。</p>
<p>第一，在中国传统教育里，中高阶级就没有那种“把孩子培养成运动员”的想法，毕竟丁俊晖父亲和张玉宁父亲才是少数，更多的父母希望孩子去当医生当公务员做生意，这不仅仅是大陆家庭，香港家庭和台湾家庭也是如此。只有贫苦家庭才会把孩子送去专门搞体育；</p>
<p>第二，为什么中产家庭不希望孩子只是把体育当作兴趣爱好而不是职业？首先现在独生子女太多，家长担心吃苦；其次，搞职业体育是从小开始的，万一踢不出来光阴就白白浪费了，而在发达国家，比如日本，贫富差距没有那么大，而且球员素养相对较高，即使不能大红大紫也不至于饿死，而比如南美部分贫困国家，家里不是独生子女，本来很穷上不起学，踢不出来就继续去搬砖，所以这两种国家的足球成绩不会太烂；再其次，足球青训部分教练素质不高，家长担心孩子跟着学坏；</p>
<p>第三，足球需要青训，而青训需要几代人的时间，但是足协更喜欢速成的方法，这与足球规律相悖，所以搞来搞去钱花了不少却始终原地转圈；</p>
<p>记得“诗人”贺炜在日本与比利时之战之后，发微博羡慕日本足球的同时也说“不多说了，说多了反动”。的确，如果潜规则少一点，贫富差距均衡一点，或许不止是足球，全中国体育的市场化就会有更加显著的改善了。</p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>足球</tag>
        <tag>世界杯</tag>
      </tags>
  </entry>
  <entry>
    <title>中国梦，宪政梦</title>
    <url>/2018/02/13/%E4%B8%AD%E5%9B%BD%E6%A2%A6%EF%BC%8C%E5%AE%AA%E6%94%BF%E6%A2%A6/</url>
    <content><![CDATA[<p><strong>本文原作者：《南方周末》评论部编辑戴志勇</strong></p>
<p>天地之间，时间绽放。</p>
<p>这是我们在2013年的第一次相见，愿你被梦想点亮。</p>
<p>2012年，你守护自己的生活，他们守护自己的工作。守护这份工作，就是在守护他们对生活的梦想。</p>
<p>2012年，庙堂之上发出的宪政强音嗡然回响：”宪法的生命在于实施，宪法的权威也在于实施。”我们期待宪法长出牙齿，宪政早日落地。惟如此，才能成就这个沧桑古国的艰难转型；惟如此，国家与人民，才能重新站立于坚实的大地之上。</p>
<p>今天，已是能够梦想的中国，今天，已是兑现梦想的时代。经历过宪政缺失的”文革”梦魇，我们花费三十多年的时间来逐渐回归常理与常情。从土地联产承包责任制到个体户、乡镇企业到”民企”，稍稍归还国人自主安排生活的权利，我们便创造了繁华城市，收获了满仓粮食。</p>
<p>我们重新体认什么是真，什么是假，是其是，非其非；我们重燃对公义的热爱，对自由的向往。面对暴虐强力，我们双手相握，一起走过艰难时刻，迎接生活转机。</p>
<p>今天，我们终于可以从厚厚的历史尘埃中挺起胸，从琐碎的日常生活中抬起头，重走先辈的宪政长征，重温先辈的伟大梦想。</p>
<p>一百七十多年前，我们开始从天朝上国的迷梦中醒来。先败于英，后败于日。百姓愈加民不聊生，耻感深深刺痛中国士人。保国！保种！由洋务而君宪，由立宪而革命。从器物到制度再至文化，激愤者不惜彻底打倒”孔家店”，决绝地将自己的文明连根拔起。</p>
<p>辛亥革命后，清帝退位，先辈们终于建立了亚洲第一个共和国。但是，一个自由、民主、富强的宪政中国并没有随之而来。</p>
<p>国家内外，战争连连；人群内外，残酷不断。</p>
<p>一度，人们远离仁，远离义，远离天道，远离对自由的坚守。</p>
<p>一度，人们认错为对，指鹿为马，万千生灵生机断绝。</p>
<p>美梦与山河，齐齐破碎。自由与宪政，双双消隐。</p>
<p>度尽人世劫波，深味人性幽暗，我们依然是能做梦的人，有颗能做梦的心。</p>
<p>今天，我们断断不只梦想物质丰盛，更希望性灵充盈；我们断断不只梦想国力能强盛，更希望国民有自尊。新民和新国，救亡与启蒙，谁也离不开谁，谁也不能压倒谁。而宪政便是这一切美梦的根基。</p>
<p>兑现宪政，坚守权利，人人才能心如日月流光溢彩；鳏寡孤独才能感受冬日暖意而非瑟瑟发抖；”城管”与小贩才能谈笑风生；房屋才能成为自己与家人的城堡；</p>
<p>兑现宪政，限权分权，公民们才能大声说出对公权力的批评；每个人才能依内心信仰自由生活；我们才能建成一个自由的强大国家。</p>
<p>兑现宪政大梦，每个人才能做好个人的美梦。而这需要我们就从手边做起，就从守护此时此刻的生活做起，而不要将重任留给子孙。</p>
<p>很多人一直深深懂得这一点，很多人早就努力践行这一点。</p>
<p>不是杰出者才做梦，是善于做梦者才杰出。</p>
<p>你的天赋权利就是可以梦想，并且兑现梦想！</p>
<p>为你的梦想鼓掌，为这个国家的梦想加油，这就是很多新闻人的梦想，是他们不大不小的野心。他们忠于新闻，更忠于内心。愿你也有个玫瑰色的美梦；自由成就自己，完成天之所赋。</p>
<p>总会梦想人人都可以做一个有尊严的人，不论身居高位，还是街头卖艺；</p>
<p>总会梦想人人内心有爱，即使罪犯也未必穷凶极恶，总有恻隐之心自由闪动；</p>
<p>总会梦想阶层只是引人自由流动的动力，而不再是相互猜忌和仇视的天堑；总会梦想这五千年文明生生不息，为改善人类的现代处境，捧出一掬甘冽清泉……</p>
<p>兑现这一千一万个梦想，才能抚平这一百多年的刻骨痛楚。</p>
<p>兜兜转转一百七十年，美梦成真何其难！一百七十年后，依然有人渴望良知萌新芽，重温天命之谓性；依然有人坚持要求权利一一落地，政治复归于正，公义自在流淌。</p>
<p>依然有人相信，不管多难，梦想终会落实为宪政良制，风行为敦敦美俗。</p>
<p>先辈们筚路蓝缕，践义成仁。如今，后人承继其志，燃灯前行。</p>
<p>兑现梦想，自然要借鉴前贤智慧，与古人的信仰、习俗和情感和解。儒释道法墨，百家皆是源泉；周汉唐宋明，代代皆有可取。</p>
<p>但这决不是要复古，古人不能给予今天所需的一切。只是不再轻易贬损先辈，平心静气地吸收转进，以让中华文明开新花，结新果。</p>
<p>兑现梦想，自然要吸取世界经验。所以要认真审视希腊民主，罗马法治，借鉴英美宪政，追赶现代科技文明。</p>
<p>但这也不是仅仅作一个西方文明的优等生，西人有西人演进的轨迹，同样未必能直接给予我们今天所需的一切。</p>
<p>我们要站在自己的大地上，与各国人民一起，生活出一种古今相融的新生活，文明出一种中西合璧的新文明。在古今中西的激荡中，要遵循人类共通的价值，也要不惮于做自己的新梦。</p>
<p>称美古人，赞扬邻居，不是因为他们足够完美，而是因为我们熟悉他们眼中洋溢的快乐，心底流淌的自由。</p>
<p>中国人本应就是自由人。中国梦本应就是宪政梦。</p>
<p>宪政之下，才能国家持续强盛，宪政之下，才有人民真正强大。兑现宪政梦想，才能更好地外争国权，维护国家的自由；才能更好地内争民权，维护人民的自由。而国家的自由最终必得落脚于人民的自由，必得落脚于人人可以我口说我心，人人可以用心做美梦。</p>
<p>生而为人，谁能不热爱自由？这自由，不仅是权利针对权力而言，也是宽恕针对报复而言，是般若针对无明而言，是仁爱针对暴虐而言，是有道针对无道而言。</p>
<p>大道之行，天下为公；万物自在，各正性命。这就是古人的梦想，先辈的梦想，也是今天很多人的梦想。</p>
<p>中国梦，自由梦，宪政梦。</p>
<p>万物速朽，但梦想永在。万物诞生，因梦想不灭。梦想就是生生之几，就是当你失败了一百次，那第一百零一次充实你内心的不死之希望。</p>
<p>依然有人倾听你的梦想，期待你敢于做梦。你从苦难中爬起，他们为你加油；你尝尽人世冷暖，他们为你加油；你收获美好生活，他们为你加油……他们别无所资，惟有对梦想的执着；他们别无所长，惟有对真相的追求。</p>
<p>一句真话能比整个世界还重，一个梦想能让生命迸射光芒！</p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>中国政治</tag>
      </tags>
  </entry>
  <entry>
    <title>中国男篮的垮台</title>
    <url>/2023/09/04/%E4%B8%AD%E5%9B%BD%E7%94%B7%E7%AF%AE%E4%B9%8B%E8%B4%A5/</url>
    <content><![CDATA[<p>2015年，FIBA为了扩大篮球在全世界的影响力，改革男篮世锦赛为男篮世界杯，同时宣布男篮世界杯的成绩决定奥运会男篮的入场资格。这一项举动颠覆了原来男篮亚锦赛（后改名男篮亚洲杯）冠军直接有奥运会资格的玩法，使亚洲杯沦为鸡肋赛事。FIBA的这套改革，影响最大的无疑是篮球水平相差非常严重的非洲和亚洲以及长时间不出篮球新人吃老本的国家。</p>
<p>这次中国男篮耻辱的兵败男篮世界杯，5场比赛一胜四负，累计输分94分，在参赛的32支队伍里排名第29，也就是倒数第四。连续两个奥运周期没有拿到奥运会参赛资格。</p>
<h2 id="归化-小球？国家队何去何从？"><a href="#归化-小球？国家队何去何从？" class="headerlink" title="归化+小球？国家队何去何从？"></a>归化+小球？国家队何去何从？</h2><p>2023年7月24日，在距离FIBA宣布可以归化球员的5年后，中国队归化成功现年29岁的NBA球员李凯尔。李凯尔当年早在2018年就来过深圳寻根寻祖，甚至还上了当时的新闻。整整5年，我们归化他终于成功了。据江湖传言，此前中国队就派人问过林书豪的归化倾向，林书豪没表达出特别的意愿，于是作罢。</p>
<p>要知道FIBA跟FIFA不一样，FIBA对归化球员的要求放的很低，低到年龄大于16岁的球员代表过某支球队出战过国际赛事，只要该国同意，他甚至都可以为第二支球队出战的程度。但是在中国，体育领导首先关注的却是血缘，有血缘的球员才配成为中国男篮统战的目标。男足那种“巴西族雇佣兵”模式是在男篮上不可以的，男篮即要捍卫亚洲霸主的骄傲又要血统纯正还要争取“一年一签”。</p>
<p>要知道在归化上，世界很多篮球并不强大的国家远远走在中国前面。日本的国籍法也很苛刻，他们今年第一次正式将归化中锋霍金斯亮相；约旦归化了神似已故球星科比的杰佛森，甚至黎巴嫩、斯洛文尼亚都有跟本国毫无血缘关系的归化球员。有了归化球员的帮助，他们的实力也有了一定的提升，毕竟篮球是5个人的运动，空降一个外援效果就能很明显，空降两个直接原地起飞。但是在“归化”上，体育总局人为设障“血缘”，导致我们的选择面小了很多，而且李凯尔归化手续进度非常缓慢，这让他与中国男篮的合练时间较短，李凯尔8月20日才国家队首秀，8月25日男篮世界杯开打。</p>
<p>除了李凯尔这个变量，中国男篮去年11月宣布“疫情期间率队拿到世界杯入场券的杜锋教练下课”，塞尔维亚教练乔尔杰维奇走马上任，但是这位名帅真正跟这帮球员密切接触是今年5月份的事儿。乔尔杰维奇合练后发现这支男篮是一个反世界潮流的队伍，在当今“打快、打三分球、打快攻反击”的风格下，中国队依旧慢慢的磨阵地战，再加上投篮命中率甚至罚球命中率惨不忍睹，一场比赛只能拿60~70分左右，跟女篮的一场比赛差不多。</p>
<p>这支看上去很高的、被国内媒体人夸有内线优势的中国队打起来发现其实根本没有什么内线优势，周琦、胡金秋和王哲林3大内线加起来场均10.6个篮板球，其中周琦3.6个、胡金秋3个、王哲林4个（王哲林场均得分比篮板球还少）。在32个世界杯参赛队伍里，中国队篮板球倒数第二，前场篮板倒数第一。三分命中率、内线得分、快攻得分也是32个队伍里的倒数。</p>
<p>也就是说，这支中国队又慢又没有内线优势，三分也不灵光。确切的说，它什么优势都没有。这支队伍即使去了奥运会，也是被人暴打的送分童子，跟原来的国家队相比，“蜀中无大将，廖化做前锋”。</p>
<p>目前的篮球主潮流是“小球”，但是小球不等于小快灵，因为小快灵不特别讲究背身能力，是钱澄海教练口中的“追着屁股打”。亚洲球队是否要回归“小快灵”一直是讨论的话题，但是现实是“小快灵”的队伍在NBA还是FIBA赛事里都没有过稳定的出色成绩，而且小快灵面对防守的压力是很大的，目前裁判吹罚手部动作非常紧，于攻于守小快灵并不是一个有效的解决的方案。而小球是在NBA证明过成功过多次的，所以小球是很多世界强队的主要发展方向。</p>
<p>现在打小球的国际强队的基本配置是球员人人都大运动量好体力（像胡金秋那种打了30分钟就上不来气的，请先去练体能），内线有机动性有防守有篮板，外线能三分能背身单打，队伍不仅有篮板保护还要有三个能防守1~3号位的摇摆人球员，而这些要素在这支中国队里通通都没有。</p>
<p>中国男篮这场大比分输给菲律宾的后果就是未来四年中国男篮没有除亚洲比赛外的国际大赛的任务，本来疫情三年我们就已经耽误了很多跟国际交流比赛的机会，世界杯这么一败，跟欧美强队真刀真枪比划的机会更少的可怜。仅仅靠亚运会和亚洲杯这种别的国家看不上的赛事，男篮根本不能达到锻炼球员的效果。所以说难的日子在后面，我们必须要经历一段闭门自练的时光。</p>
<p>这里多说一下中国男篮的外籍教练，中国男篮最早还是相信美国教练，但是由于自己国家篮球的管理复杂性，比如一到大赛各种官员嘴上说着不管，其实各种谈话施压。所以男篮更多把目光投向了篮球成绩也不错，同时国家体制曾经比较相近的东欧（邓华德是个例外，他虽然是美国人，但是在东欧俱乐部执教多年）。但是这些东欧老教练多半都很固执，能力强但难以沟通，所以这些东欧外教跟中国篮球好聚好散的也没几个。乔尔杰维奇目前看亚运会肯定是要带完的，但大概率带完亚运会后就下课了，中国篮球以后还是土教+洋顾问的模式。</p>
<h2 id="CBA到底是什么水平？"><a href="#CBA到底是什么水平？" class="headerlink" title="CBA到底是什么水平？"></a>CBA到底是什么水平？</h2><p>输给菲律宾之后，王仕鹏在直播里非常痛心的说了一句：“中国男篮其实没有什么黄金时代，就是姚明王治郅易建联等人用自身的能力掩盖了这支队伍、这套系统的很多不足”。这次男篮世界杯之旅可以说把CBA的品牌砸的干净，证明了CBA的水平在国际赛场完全不够看，CBA的MVP、FMVP到了国际赛场就是待宰羔羊。</p>
<p>但是有一说一，相比较日本的B联赛、韩国的KBL还有西亚的种种联赛，除了澳大利亚的NBL，CBA的外援规模、对抗和赛场运营还是在亚洲排的上数的。但全亚洲的联赛就是一个不练人的地方，哪怕CBA掐尖出来的明星也只能窝里横。CBA经历过“是否应该升降级”、“是否全华班”、“外援四节几人次才合理”、“能不能放开外援无限轮”等种种赛场内的讨论，其实所有CBA的死结就是本土球员跟外援的水平差距实在太大，CBA为了观赛性就要让外援上，但是为了国家队练人又要打压外援，这种矛盾的思路让本土球员的对抗和实力在国际赛场上完全不够看，在这次世界杯上中国队连一个称职的投手都没有。</p>
<p>CBA也并不是没有改良，这几年CBA跟快手合作推广、制定了分类合同（后因为周琦事件自扇嘴巴）、解决了八一男篮的历史问题、限制工资帽、限制外援等等，甚至与NBA接轨搞了视频回放中心。这个视频回放中心搞的还是很高效的，如果还是在篮管中心下属的中职篮公司负责下，以中职篮公司国企的属性，光申请加审批费用这事能拖个好几年。但是由于种种“政策”的干预（比如CBA的裁判跟NBA裁判不一样，CBA裁判和视频助理都不是职业的，但是都是篮协指定的）外加CBA20支球队各种各样的股东，有私企有国企有体育局跟国企混合的甚至以前还有军队的，这些老板们都有自己的小算盘，CBA公司一直关系错综复杂，在这种中国特色背景下，CBA公司的改革肯定没法跟英足总、NBA协会相比。CBA公司还涉及了大量的金钱利益，这个利益是几百亿的量级，导致有些表面是公司经理实际是政府官员挂职的人一直迟迟不肯放手早就应该放手的利益。“官办分离”年年喊，直到今年姚明才彻底从CBA公司里辞职董事长。</p>
<p>CBA究竟应不应该为国家队强大负责？这一直是一个引战的问题，毕竟大洋彼岸的NBA并不为美国男篮负责。但是篮管中心副主任兼第一任CBA董事长李金生曾经说过“联赛的发展有三个方面，一是培养人才，二是让球迷获得愉悦的体验，三是实现市场价值，其中培养人才是首要的”。但是CBA没有升降级，打职业篮球的人又不多，导致球员竞争压力很小，摆烂又能奈我何？NBA虽然也没有升降级，但是打破头想进NBA的球员多如牛毛，不好好训练就会被人替代。而且CBA的青训造血能力除了辽宁和广东之外都比较一般，不少青训球员的人事关系在当地体育局，由于全运会的缘故球员要想转会困难重重。这种竞技环境如何能培养高质量人才？</p>
<p>赛场上的低水平导致投资环境较差，靠着姚明个人影响力拉来了几个大赞助商比如人寿投钱，但是今年经济普遍下行，赞助商又有自身危机。</p>
<p>内部对抗环境稀烂，再说说输送到欧美的情况。</p>
<p>我们篮协一直都是嘴上说“鼓励球员出国”，但是行动上扭扭捏捏的像一个娘们。CBA队伍也不愿意放自己的王牌赴美，王哲林当初被孟菲斯灰熊选中，福建为了不让成绩下滑，用1000万的股票来留住他。相比较一年累死累活满打满算能挣6亿日元，交了税再给经济团队分钱后进自己包最多2亿日元（折合人民币1000万）的渡辺雄大，王哲林的生活简直美滋滋。王哲林只是一个缩影，还有像张智涵那样在天津队一直不出场却顶薪的球员。CBA就在这样的“钱多事少离家近”环境下，滋生出一群不愿意提升自己球技却可以躺着赚大钱还不耽误进国家队的人。</p>
<h2 id="如何体教结合？"><a href="#如何体教结合？" class="headerlink" title="如何体教结合？"></a>如何体教结合？</h2><p>2018年教育部下达文件，为了响应素质教育，正式取消了体育特长生、艺术特长生以及优秀道德学生在中考高考的加分。这个决策无疑让教育更加公平，在一定程度上减少了中高考的暗箱操作，举一个简单的例子：刘强东的媳妇是依靠艺术体操进了清华非体育专业，但是直到现在都没有什么人见到过她跳艺术体操的视频。</p>
<p>15岁以上的有运动天赋孩子就要在高中面临一个“极左极右”的选择，要么花费大量时间训练决定终身走职业体育，要么老老实实读书考大学将来搬砖还贷款，因为现在体校取消，教育部要求孩子要当运动员就要上高中，因为高中是有正式学籍的，有学籍才能考大学。由于体育的28效应，肯定很多家长不会让孩子选择收入不稳定的职业体育来养活自己。但是我们的高中又没有质量特别高的比赛，按理说高一的学生，哪怕作为课外锻炼，一年打正式比赛应该是12场，平均一个月一场，外加上热身赛友谊赛，一年应该是20场。但是这些比赛根本没有得到重视，从官从商都没有给于他们很大的支持去运营。所以一个喜欢篮球的孩子可能花了不少课余时间练习，但是他并没有从实战比赛里得到什么具体的经验，也不会被专业球探发现。家长多半也会劝“篮球当一个爱好，锻炼身体是可以的，但是正经班还是要上的”。美国和日本的校园体育为什么火，是因为它很明确的给家长传达“干体育干的好，将来是可以真赚钱养活自己的”。同时他们的校园体育也没有忽视教育，至少学生的文化课考试要及格，不至于当个文盲。就这样欧美很多体育生也不少是短暂尝试了职业体育失败后就转行做上班族，但是经历过系统的训练的学生为国家的体育选材池增加了很多的选择。</p>
<p>而且最重要的是国外的青训系统并不市场化，欧洲他们的青训教练工资并不是训练班或者学校来完全负责，而是一部分来自政府的财政。要训练人肯定先要保障教练不会饿死。“小时候不市场、长大了走市场化”这是正确的道路。但是我们国家的政府财政并不愿意这么分，更喜欢用于维稳和资助第三世界，所以基层青训就是“自己挣钱自己花”，小球员报名少，教练肯定挣得少，挣得少更没人干。恒大足球在2011年重金砸下一个全日制学校，学生缴纳学费可以边踢球边学文化课，而且可以正常会考上大学甚至出国学习，虽然它也培养了不少国青国少队员，但是每年亏损好几亿，后来不得不出租办公楼甚至裁员，原来好几十个外教就剩下4个，现在恒大足球学校的官网从6月份之后就没更新了。</p>
<p>在中国，要真的选择走职业体育这条路，就要尽早的出国，高中大学的时候就申请国外的奖学金，越早出国越能得到专业的锻炼机会。但是这笔费用对于一个普通家庭来说是一笔不小的开支，而且不仅对孩子还要对父母有外语能力的压力，所以哪怕现在有蔡崇信篮球基金等公益组织在做这样的事情，但是收效甚微。</p>
<p>至于很多人说，搞体育吃青春饭，将来一身伤病钱又没挣几个钱多么可怜。这种事情美国也出现过，比如曾经的NBA球员德隆韦斯特，他退役后甚至当了流浪汉，除了他还有不少的NBA球员只知挥霍最后破产。而有些球员就会做生意会投资，副业甚至比打球工资都高。我觉得真正要让体育生明白的是，他们在学校成绩很重要，到了社会也要坚持学习，学习理财知识，学习外语，至少拿一个教师证将来能当去公家学校当老师，或者跟领导搞好关系像韩德君那样退役了能进辽宁体育局当公务员，而不是有了钱就大吃大喝。</p>
<p>当然体教结合是比发展CBA更麻烦的一个事儿，它涉及到教育部门的改革和国家基本生活保障的进步，这两样都需要大量人力物力而且有“前人栽树后人乘凉”的官僚风险。在中国这么卷的社会下，虽然有过职业体育的过去无疑让这个人的求职简历更有意思，但是并不会让他多被用人单位青睐是残忍的事实。</p>
<h2 id="姚明的下场？"><a href="#姚明的下场？" class="headerlink" title="姚明的下场？"></a>姚明的下场？</h2><p>首先中国篮球有几个部门：体育总局、篮管中心、篮协和各地的体育局。这里面除了篮协之外，其他都是公务员，官员是任命制不是选举制，有行政级别，这点篮球跟足球不同，2016年足管中心取消，权力下沉给了中国足协，所以中国足协是有行政级别的，足协官员也是任命的，足协党委书记和主席是正厅级。篮协主席啥级别都没有，但是它的收入要负责国家队的事儿，从主教练任命到吃喝拉撒都要负责。</p>
<p>姚明2017年2月37岁的年纪被选举成篮协主席，据说这个指名是有“超越体育总局的授意”。空降的姚明同时也兼任CBA公司（中篮联体育有限公司）的副董事长，这样他的经历更加丰富，后来姚明转正，以0报酬当了第二任董事长，从之前跟篮协谈判的上海大鲨鱼的老板变成了当年的谈判对象，直到2023年4月5日卸任。上面CBA那一节说了，这段时间CBA还是有不少的改变的，姚明那时候面对的就是一个除了卖票以外，CBA的一切都在篮管中心掌控下，几乎完全不市场化的CBA环境。通过姚明和其他人的努力，篮管中心的一些具体权力大幅缩减，篮协也把自己30%的CBA公司股票放给了20支CBA球队，放弃了自己的一票否决权，让CBA能独立发展有一个比以前更好的环境。</p>
<p>但这段时间国内篮球的丑闻也很多，几乎涵盖了所有方面：原CBA公司CEO王大为据说出轨女下属而辞职、山东女篮决赛大胜结果拿了亚军、CBA裁判吹罚不专业甚至考试作弊、李楠李春江打默契球、四川男篮拖欠外援工资，多名球员劈腿小三、江西篮协主席戴亚利性侵幼女、女篮功勋主教练李亚光涉嫌贪腐、新疆跟周琦撕逼甚至炮轰姚明本人，可以说国足有的东西男篮都有了。这些事情虽然跟姚明直接关系不大但是对中国篮球形象影响很坏，都需要姚明出面处理擦屁股，让他也是无比郁闷。</p>
<p>2019年世界杯失败之后，姚明随后据说就慢慢淡出了CBA公司，这是挂一个名偶尔参加一下颁奖仪式，甚至传言他连CBA公司的办公室都不咋去，后来那里改成了会议室。他的工作重心逐渐从CBA转向到了中国国家队。2019年世界杯之前，姚明甚至还亲自下场跟周琦讨论内线技术细节，而现在这种镜头越来越少。本次世界杯耻辱失败后，无疑姚明是现在压力最大的人，我想他想明白了，其实信兰成当初的策略是对的–中国篮球要想出成绩就是要“在CBA的环境里抓出来尖子，用这些尖子当边角料，然后让留洋的人来当主心骨，然后通过集训猛练这帮人去打国际大赛”。但是在姚明的任期内，这几个边角料中看不中用，留洋的人一样都是废物，如此的兵搭配上沟通不畅的教练外加上合练没几天还不是大包大揽砍分型的归化肯定没有好成绩。男篮国际赛场成绩退步严重是不争的事实，姚明对今年重点关注三大球的体育总局乃至更高层那边实在不好交代。其实姚明身上的确是一个千斤重担，篮球事业的进步一方面是一小股职业人的事情，还有一方面是一大股普通人的社会运动。上面说的“体教结合”改革无疑就是要改变千百年来中国家长的传统思维，毕竟在中国家长里，打篮球有助于长大高个，但是篮球对于家长仅仅限于孩子长个和锻炼身体，打职业篮球是不可以的，会把自己饿死。面对中国独特的档案制，姚明还要跟人事组织部的现有规则做斗争。</p>
<p>姚明有些改革出发点是好的，但是短时间能拿到结果的改革目前看都以失败收场。红蓝国家队的尝试结果红队教练李楠为2019世界杯负责下课，后来甚至因为打默契球被禁赛多年，杜锋随后拿了亚洲第八（一度要跟巴林打加时，其实有球员新冠的因素）和世界杯入场券也“含冤下课”。现在再提起红蓝国家队就被人批评“多浪费了一倍的钱，结果效果很差”。</p>
<p>我觉得尽管今年男篮兵败世界杯要担责，但是姚明大概率不会马上下台，毕竟他把能做的都做了。未来几年男子国家队也没有重大比赛任务，没有CBA职务的他除了乔帅可能下课选男篮新教练之外就是关注女篮和3人制了，或者以政协委员的身份再呼吁体教融合，其他地方也没啥可干的。如果姚明将来要是从篮协主席的位置上顺利退下且清白干净的话，他多半就像郎平一样，回到美国的家里，做做生意享享福，基本不会再回大陆了。</p>
<h2 id="恶心的媒体"><a href="#恶心的媒体" class="headerlink" title="恶心的媒体"></a>恶心的媒体</h2><p>曾经有人说过，“有舆论保护的地方肯定黑幕重重”。也有人说过，“饭圈文化占据主导的行业，肯定离死不远了”。这两条都跟我们当今的篮球媒体环境有关。</p>
<p>世界杯期间，大量的自媒体不负责任的在各种门户网站上、短视频上蹭流量当标题党。动不动就“对手有难了，恭喜姚明，恭喜男篮”，文章看下来整个报道屁股完全是歪的，用的信息也都是旁门左道，成功的概率跟母猪上树概率差不多，我是不知道有啥好恭喜的。说自己就是强无敌，说别人就是“心态不行易急躁，归化多内部不团结，没大牌更衣室混乱”。一副成竹在胸，对方必将屁滚尿流的自我感觉良好的架势，结果自己球队真的有输崩盘了，再来反向吃瓜，两波流量美滋滋，这种自媒体就应该被人唾弃。</p>
<p>自媒体不正规，靠着真假混说的证据能糊弄大多数“到了大赛才关心的球迷”。而正规喉舌的媒体人在一些世界杯节目里，也是盲目乐观，选择性看问题，把CBA的表现直接套用到国际赛场上甚至NBA赛场上，其实完全是井底之蛙的言论。他们一边正义凛然的抨击日本队靠裁判黑哨，但是自己19年对波兰和波多黎各的运作选择性无视。动不动就用别人的短板来掩饰自己的短短板。球队在场上被打爆了，痛心疾首后开始“找目标+抛石头+掺沙子”，做舆论引导的马前卒，保护本方心理脆弱不堪能力又很差的球员。本来中国足球篮球的受众群体大多数是学校学生，我们的媒体却没有做好一个“实事求是”的榜样，借着宣传部搞民族主义的主流把学生们都培养成“面对西方就无比偏激，一谈丑闻就无脑骂资本，面对自己人犯错不争气除了无能狂怒又不知道怎么办”的傻子，这种媒体也是丧了良心。</p>
<p>这样的媒体就会带出来一些傻逼球迷，他们在论坛上一边抨击日本队靠混血球员出成绩是“日本女性下贱不要脸”、靠规划球员是玩赖，一边骂日本靠裁判获利。然后给中国篮球短时间内出成绩的建议就是“换一个比李凯尔更好使的规划”和“让我们的赞助商资本家去做工作，影响比赛”。可能相比较日本的“无耻”，这样比较“有耻”吧。</p>
<p>看着日益不职业的中国职业体育，急的人依旧很急。但毕竟是商业体育，大关注量就注定有大蛋糕，有大蛋糕势必就有大内斗。球迷能做的只是被动接受，这已经够可怜了，如果再有人污染信息，报喜不报忧，骗子来欺骗傻子，就像当年刘翔明明不能跑却故意引人期待，那么球迷们就干脆放过自己，冷眼看之吧。</p>
<p>用曾经一个愤怒的国足球迷的话来做结尾，“这他妈的要不是中国队的比赛，谁愿意花时间和钱来看啊？”</p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>体育</tag>
        <tag>篮球</tag>
        <tag>中国体育</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么我们会被带节奏</title>
    <url>/2021/08/18/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E4%BC%9A%E8%A2%AB%E5%B8%A6%E8%8A%82%E5%A5%8F/</url>
    <content><![CDATA[<h2 id="几个带节奏的例子"><a href="#几个带节奏的例子" class="headerlink" title="几个带节奏的例子"></a>几个带节奏的例子</h2><p>大陆官方宣称有十四亿人口，那么每天这十四亿人出现点故事是再正常不过的事情。这些事情有的上了娱乐新闻，有的上了体育新闻，有的上了社会新闻，有的压根在苗头就被掐死了。但是现在媒体为了抢到第一手流量，就会抢先报道或者是抢先转载，先用刺激的标题来触发一波手机通知，然后内容一点一点补充。当然现在中国大陆网民的讨论地主要就那么几个：微博、豆瓣、天涯、虎扑、B站等，而这些地方就会有很多“帖子带节奏者”、“短视频带节奏者”甚至“弹幕带节奏者”，无论收了钱的或者没收钱的都来凑个热闹。</p>
<p>我印象里这几年最大的几个“带节奏”的例子：重庆公交车坠江、孙杨拒检案、奥运会肖若腾体操银牌、阿里女员工性侵事件。这四个可以说当时都上了热搜，而且后期发展都有一点反转的意思（截止本文发布前，阿里女员工被主管性侵事件目前没有完全反转，但是强制出差、饭桌灌酒被警方确认是子虚乌有，还有很多其他疑点）。想想很简单，因为这些新闻会吸引大量民众关注，所以第一手的信息往往并不细致，甚至会有强烈的主观描述。但是随着信息越来越多，随着跟进的报道，那么可能就有大概率出现“反转”。</p>
<p>一个故事拆成多次新闻发送，媒体活生生的玩成了回合制游戏，也是够厉害的。</p>
<p>带节奏是有目的的，中国不仅有“好事不出门，坏事传千里”的俗语，也有“无利不起早”的老话。一条新闻，尤其是那种被“强者”&#x2F;资本家&#x2F;日本&#x2F;美国压迫的新闻，自然会引起民众当“包青天”的决心，而且尤其是女性民众的强烈愤慨—“定要主持这个公道”。而有些年轻人更是抠细节、挖历史的好手，挖到了细节再来一贴，再来几何级数的转载。中国由于阶级差距悬殊，在一定程度上还是一个“按闹分配”的国家，一旦有了民众的舆论压力，那么就要集中公共资源去给民众一个说法。现在的大陆在外交上无论是周边国家还是跟美日等老冤家持续交恶，所以扯上美日的新闻更是有大流量，网民可以在各种自媒体那夹杂英文字母的字幕视频里，表达愤慨之余，还能在评论区里和转发键上献出一颗爱国丹心。</p>
<p>前几天肖若腾个人全能拿了银牌，被国内媒体甚至党媒宣传成了被日本选手桥本大辉黑走了金牌，一时间桥本大辉的落地照被P，他的落地视频在抖音上跟狗抢食被拼接，他本人的社交媒体被骂。哪怕国际体联给出了打分标准，依旧还是有相关的媒体保留当时的文档，比如<a href="http://www.titan24.com/publish/app/data/2021/07/29/384455/os_news.html">http://www.titan24.com/publish/app/data/2021/07/29/384455/os_news.html</a> 和 <a href="https://new.qq.com/rain/a/20210729A020SU00">https://new.qq.com/rain/a/20210729A020SU00</a> ，以及B站上云南共青团以及咪咕视频也是带头摇旗呐喊，拱得一手好火。现在的民众经过长时间的广播、电视、媒体的宣传以及现实生活中的种种不满夹击下，对待“理中客”和“逍遥派”更是打击连连，这些人往往被扣一个“圣母”“投降派”的大帽子，顶不住压力而成了沉默的大多数。</p>
<p>节奏大师们其实都知道自己在带节奏（毕竟智力降维打击），哪怕是片面的，哪怕是错误的，但是毕竟这种“拿人当枪使”的事儿法不责众嘛！最多就一个辟谣，更有些打着政治正确名义的、皇帝新衣一样的玩法，让人说都没法说。普通民众浪费自己的时间，给他人带来了流量，当韭菜而不自知，而这帮人骗傻子生气的生意做的爽到飞起。</p>
<h2 id="如何带节奏和不被骗？"><a href="#如何带节奏和不被骗？" class="headerlink" title="如何带节奏和不被骗？"></a>如何带节奏和不被骗？</h2><p>带节奏其实属于大众心理学范畴，比如狼人杀或者早年的杀人游戏，总会有人带节奏把正义一方“票出去”，带节奏的人一出，配上少数同伙煽动性的复读，于是把不明真相的吃瓜群众带到坑里。</p>
<p>或者是广场舞，那最前方领舞大爷or大妈也是一个带节奏者，在队首打样，把各位舞友带的整齐划一。</p>
<p>带节奏是利用几点：<br>1）信息的不完全性，正是真相尚未完全水落石出，那么带节奏的人真假混说，可以浑水摸鱼。但是如果是大家都熟悉的东西，那每个人都已经有了基本的判断能力，节奏是带不起来的；<br>2）事情的贴合性，带节奏的事儿肯定是每个人身边有可能发生的事儿，比如家暴、比如抢方向盘、比如贸易战、比如新冠疫情，正是这样的事儿有概率发生在我们周围，所以值得每个人去关心；<br>3）一个招风的树，比如吴亦凡张哲瀚，比如阿里腾讯华为恒大。这个树可以满足普通人“落井下石”、“幸灾乐祸”的心理，你过得不好、我喜闻乐见；<br>4）以上因素再搭配一点男女桃色新闻，方便二次加工，给读者更多想象空间；</p>
<p>从上所述，可见缺乏思考是带节奏泛滥的土壤，盲目跟风是带节奏存活的养分。所以很多“带节奏”是有人钻了“进化不匹配”、“信息不对称”的空子，靠煽动的语言散布对别人不利的消息为自己谋利。哪怕后期有了反转，但是随着很多人的吃瓜热乎劲儿，对当事人负面的印象已经产生，再像恢复名誉何其难。</p>
<p>如何不被带节奏，不让无良媒体消费自己的情感？还是那句老话—让子弹飞一会，不急于站队，不急于表态。不要被哪些故意发表的具有争议性和煽动性的话语，挑起我们个人的跟风甚至争端。</p>
<p>然后还要日常就远离那些一元论的论点，“只要不XX，那就一定是XXX”，这种话除了用于判断“非蠢既坏”（只要将人分三六九等的都是傻逼），在其他地方一点逻辑都不通，这种没有思考的大脑就干脆捐出去吧。虽然“杠精”不是啥好东西，但是面对“带节奏”的行为，还是多一点杠精更好。</p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>心理学</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>中秋苏州游记</title>
    <url>/2019/09/23/%E4%B8%AD%E7%A7%8B%E8%8B%8F%E5%B7%9E%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>我之前对苏州的认识并不多，仅仅是“上有天堂,下有苏杭”这样的一个模糊概念。但是一直以来对金庸先生笔下所描写的那个“姑苏”还是有些向往的，于是在这次中秋三天里，我跟媳妇就选择苏州作为度假点，好好的享受了一下这个吴城。</p>
<h2 id="苏州的玩"><a href="#苏州的玩" class="headerlink" title="苏州的玩"></a>苏州的玩</h2><p>苏州论景点最出名的就是三兄弟—“苏州博物馆+忠王府+拙政园”,这三个地方不仅是苏州地标历史景点，而且地理位置还是在一起的。所以到了苏州的第一站，我们就满血冲了过去，苏州博物馆并不大，除了历史文物还有现代艺展，不到100分钟就能粗略浏览完毕。但是那里是著名的网红博物馆，里面到处都是摆造型拍照的女孩子。因为苏州博物馆的确设计的很漂亮，无论是展厅还是中庭，贝聿铭先生对空间的理解真是大师级别。苏州本身并不是一个尖顶建筑众多的城市，但是苏州博物馆是一个尖顶建筑，它整体但不高，天花棚通过条纹晒进阳光，让室内最大限度的透入自然光，使得墙面非常的好看。而且博物馆里的小窗户都是六边形的，可以通过窗看到院子里种的竹子、凉亭、小桥，古朴又不失现代感，更添一份宁静。在苏州博物馆，感受到里面意境和光影不仅仅是一个博物馆，更像是一个创意山水园。<br><img data-src="/images/%E8%8B%8F%E5%B7%9E%E5%8D%9A%E7%89%A9%E9%A6%86.jpg" alt="akb48"></p>
<p>苏州博物馆旁边就是忠王府，直接相通，他俩加上拙政园合起来就是天平天国忠王李秀成当年的府邸，忠王府也是迄今为止太平天国历史上保存的最好的建筑物了。一下子从苏州博物馆的艺术氛围跳到王府，画风的转变还是有点快。忠王府里面除了教堂、军事办公室、戏台、大厅和一架大炮之外，还收藏了一些太平天国的历史文物。<br><img data-src="/images/%E5%BF%A0%E7%8E%8B%E5%BA%9C%E5%A4%A7%E7%82%AE.png" alt="akb48"></p>
<p>忠王府虽然是李秀成的，但是据说他自己却没有完全的住过，因为在同治二年冬（1863年12月），太平天国在苏州的地盘全面失守，当时忠王府的工程仍未完工，只是初具规模而已，李鸿章把忠王府为江苏巡抚行辕。这个建筑后来在1938年，被日本人当做了“江苏省维新政府”驻所。到了1946年，国立社会教育学院借作校舍，解放后收归国有。这幢建筑虽然几次易主，但是大体还算是平安的。相比较而言，它的第一任主人李秀成的命运要比它惨得多。</p>
<p>从忠王府出来，旁边就是拙政园了。我们同样是在公众号上买票，然后直接安检入门。拙政园就是一个超级大的园林，里面各种树木、池塘、长廊、小亭和假山。鸭子、金鱼在水里随便的游来游去，大片大片的荷叶慵懒的铺在水面上，充足的阳光穿过一层一层的叶子洒落在身上，把人晒得暖洋洋的。拙政园已经是苏州园林的代表，在那里转过之后，那么狮子林和留园等园林也就大同小异了。<br><img data-src="/images/%E6%8B%99%E6%94%BF%E5%9B%AD%E9%95%BF%E5%BB%8A.jpg" alt="akb48"></p>
<p>拙政园离平江路就很近了。平江路作为了一个历史街区，感觉是一个修长的历史画卷。那里面不仅有很多网红店人满为患，还有许多笔直的小里巷，粉墙黛瓦，高低差参，栉比鳞次，有的宽仅一米，狭窄而幽深，空荡荡，看不到一个人。在这里不自觉就会把脚步放慢，一个店一个店慢慢的走过去，在商业化气息严重的今天，还是能感受一下老苏州的质朴。走到夕阳西下，我们花了80块坐了一次小船，摇船的大姐给我们唱了当地的小调—《小城故事多》、《秦淮景》、《四季歌》等等。船在水上，人在画中，小桥流水，倒映着斑驳旧影，垂柳依依，掩映着白墙黑瓦。悠悠水乡，多少沧桑，古朴幽静，船橹摇荡。这就是平江路的夜。</p>
<p>到了苏州，怎能不听评弹？有一句俗话叫做“宁愿听苏州人吵架，也不听宁波人说话”，用以形容苏州方言的动听。而且随着《都挺好》的热播，苏州平江路上大大小小的评弹店都是挂上了各种各样《都挺好》的因素。我选择了“琵琶语评弹茶座”，虽然店面不算太好找，但是里面却是人气爆棚。价钱很便宜，38块钱叫上一杯绿茶就可以在里面听上几段评弹，还可以有昆曲点播。听不懂苏州的吴侬软语不要怕，墙上有电子屏幕同步显示歌词。几曲咿咿呀呀下来，感觉自己被苏大强附体，不禁得摇头晃脑起来。</p>
<p>寒山寺也是一个苏州招牌景点，那句“姑苏城外寒山寺，夜半钟声到客船”俨然成了寒山寺的最好的宣传口号。那首诗也在寺里被至少几十个碑被各种历史名流篆刻。诗虽然流传千年，但是现在寒山寺的钟已经不再是当年的那口钟了，寒山寺还是保留着过年敲钟108下的习惯，为整个苏州辞旧迎新，祈祷平安。<br><img data-src="/images/%E5%AF%92%E5%B1%B1%E5%AF%BA.jpg" alt="akb48"></p>
<p>寒山寺里就跟一般的寺院差不多，到没有什么特别。走了一圈，让我比较有印象的是寒拾殿。此殿位于藏经楼内，楼的屋脊上雕饰着《西游记》人物故事，是唐僧师徒自西天取得真经而归的形象。<br><img data-src="/images/%E5%AF%92%E5%B1%B1%E5%AF%BA%E8%A5%BF%E6%B8%B8%E8%AE%B0.png" alt="akb48"></p>
<p>第一天走完了苏州的古，回到民宿好好泡了脚休息一番。第二天驱车奔向金鸡湖开发区，去感受苏州的新。我们先后逛了苏州中心、东方之门和诚品书店。逛街本身只是例行打卡而已，毕竟苏州有的东西基本杭州都有。不过金鸡湖有直升飞机可以坐，860元一趟（2~4人），可以带你绕金鸡湖飞一圈，一趟下来大约需要20分钟，但是要很早的预约。夜生活的话，如果想去livehouse耍耍，那么观前街和十全街有酒吧可以满足需求，高中低档的一应俱全。<br><img data-src="/images/%E8%AF%9A%E5%93%81%E4%B9%A6%E5%BA%97.jpg" alt="akb48" title="诚品书店不仅仅卖书，看这个大拼图"></p>
<h2 id="苏州的吃"><a href="#苏州的吃" class="headerlink" title="苏州的吃"></a>苏州的吃</h2><p>苏州的吃我并没有特别做攻略下功夫，按照随遇而安的心态，正餐都是在一般的店解决的。第一天到苏州后去琼琳阁吃了有名的焖肉面，晚上是在平江路靠路两边的小吃填饱肚子。第二天中午在苏州中心的南京大排档里尝了鸭血粉丝汤和烤鸭，晚上在石路的小郡肝钢管厂五号的串串店解决。至于最后一天中午，由于要玩VR，我们就在VR店附近的万达广场吃了汉拿山烤肉（囧，这顿饭一点都不苏州）。</p>
<p>苏州菜跟杭州菜对于东北出身的我来说，感觉师出一路，口味都是精致偏甜，里面的甜相比较用糖更多的是用酱。松鼠桂鱼和蟹黄豆腐基本是每一个苏州菜馆的菜单必备，如果觉得油腻再叫上一壶碧螺春刮刮油。相比较杭州羊肉的匮乏，苏州街边的藏书羊肉店是随处可见，里面羊肉汤羊肉饺子羊肉火锅各种吃法一应俱全。中秋时期还算是吃阳澄湖大闸蟹的季节，但是据说苏州的正餐里是不上大闸蟹的，因为一旦上了大闸蟹，大家的注意力都在拆蟹吃蟹上，宴会的气氛就会冷淡下来。至于小吃，我吃到了平江路的鸡脚旮旯的酱鸡爪，味道蛮好的，但是一定要带汤一起吃，没有汤的鸡爪子是没有灵魂的。除此之外，也吃到了哑巴生煎，感觉跟杭州的生煎味道差不多。<br><img data-src="/images/%E9%B8%A1%E8%84%9A%E6%97%AE%E6%97%AF.png" alt="akb48"></p>
<p>最后着重说一下石路上小郡肝钢管厂五区里面的土豆块，真是超级好吃，我后来在杭州的几家小郡肝找了一下都没有这个小菜。所以强烈推荐，到了苏州一定不要错过它！</p>
<h2 id="一点小tips"><a href="#一点小tips" class="headerlink" title="一点小tips"></a>一点小tips</h2><ol>
<li>苏州的老城区是限号的，所以外地车辆在手机地图上应该提前设置好车牌，高德地图就直接把我们导航到了驳接车站那里；</li>
<li>从苏州北旅游换乘中心做免费车去苏州博物馆，但是最晚一趟车是5点半，所以超过这个点就只能打车回换乘中心了；</li>
<li>苏州博物馆、拙政园、狮子林等都可以在微信公众号上购票，由于苏州博物馆是免费的，所以推荐先拍下苏州博物馆的票，然后看一下拙政园的情况再买票，买票检查是需要身份证的；</li>
<li>平江路坐船，撑船大姐唱歌是要付费的，30一次；</li>
</ol>
<p>苏州仅仅游玩了三天是不够的，我这一次的行程非常粗浅，并没有包括狮子林、虎丘、留园、苏州大学以及华谊兄弟乐园（能蹦极）等著名景点。但是这短短的两天时间却让我喜欢上了这个南方小城，它就像杭州的姐妹，既有温婉可人的一面也有工业发展的一面。最后就用刘以达的一首《我的天使》作为结局吧，这段歌词特别符合我这个初行者对苏州的印象：<br>	<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">爱似浓郁咖啡 围裙除去 晚妆一卸</span><br><span class="line">拥抱一夜 以後百夜 亦暖些</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>旅游</tag>
        <tag>苏州</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么我开始主动消费降级</title>
    <url>/2025/06/25/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E5%BC%80%E5%A7%8B%E4%B8%BB%E5%8A%A8%E6%B6%88%E8%B4%B9%E9%99%8D%E7%BA%A7/</url>
    <content><![CDATA[<p>2025年618结束了，我想如果不是诸多APP开屏的广告提示，很多人都不知道各大电商已经开始了618。今年这个618是目前持续时间最长的，持续了47天。当然，未来只会更长。</p>
<p>根据很多电商的公关数据说，本次618的GMV都提升了不少，而且随着“跨店满减”、“凑消费券”活动的叫停，无需大量的退货，所以GMV的质量高了不少，真实度也高了不少。于是在昨天我司内部的618庆功会上，大老板宣布以后要“每月8号和18号都有一次S级大促，含预售的那种”。哦对了，说到预售，去年网络声音是预售就是罪魁祸首，但是今年还是老老实实捡起来预售了。</p>
<p>既然大老板这么做了“每月2次大促”的决策，肯定是他看到了我等小P没有看到的数据，比如搞大促可以让平台是赚得盆满钵满，所以多搞多赚。不过我个人是十分不认可“大促驱动电商”这个战略的，我认为这是恶性循环，只会把羊毛薅光。</p>
<p>现在网购也逐渐在互联网上遭到了排斥，很多人在电商促销的短视频下面评论说“不买直接立省XXX元”，而且是非常骄傲的口吻。这类发言也吸引了很多的点赞。可见“不主动参与网购”或者“网购也追求性价比”是现在人越来越多的选择。</p>
<p>2025年除了新闻联播里的那个平行宇宙，全国市场依旧低迷，只提增速不提通胀是扯淡。寒风吹到了每一个打工牛马，我也不例外要为了以后不确定的生活攒棺材本。最近网上有个图，比如“现在的孩子对钱没概念，30块一杯的咖啡，可以买XXX个鸡蛋，可以买XXX杯水，可以买XXX个蔬菜”。这个图都让我觉得平时消费的确是有点大手大脚，随手掏出来微信支付，嘀一下，我的数个鸡蛋就没了。</p>
<p>所以现在，咖啡我开始关注12.9甚至9.9。要是星巴克、TIMS、manner这些没有券我是不会买的，甚至我还跑去拉人来得到券。食堂超过餐补20的那部分，我也要嘀咕嘀咕，对现金的感觉我应该是到了一种前所未有的关注度。</p>
<p>为什么我现在开始主动选择“消费降级”呢？</p>
<p>第一，我觉得人到中年难免会对一些物质上的东西不再追求。可乐雪碧早就戒了很多年，奶油肥肉看着心里就犯腻，所以我对食欲上的追求淡了不少。至于衣服手机，整体的欲望也下降了不少，甚至有时候会觉得“这双鞋子终于穿破了，终于可以扔掉了”这个想法是一个很好的事儿，也就是说人到中年除了自身欲望的降低，整个消费注意也越来越往实用派的角度去调整。</p>
<p>但是众所周知，一个商品的价格有两个部分组成：使用价格和情绪价格。实用派的消费对象肯定是情绪价格较少的对象。</p>
<p>第二，我也开始越来越多的追求小确幸，比如在工作后来一杯美美的独享咖啡、或者去一家经常去的地方吃一顿简单的好吃的。不想跟别人分享时间，就自己去享受一个独处的美食已经成了我的一个“小舒服”。我想这个可能心态的转变是跟当下的工作节奏太快有直接的关系，不是每次都要消费一个很昂贵的东西才能让自己感受到“奖励”的感觉。除了刚才说的“节奏太快”，“阶级固化”也是一个不小的因素：在这样的社会里奋斗的人本身不一定有大的进步空间，那么自然也不会对自己有大的奖励，所以偶尔的一点点小奖励就够了。</p>
<p>所以我为什么也开始“消费降级”了呢？首先大环境不好，其次整体阶层固化，最后是中年人或者说“越来越多心态中年化、佛系”的人对物质的东西追求降低。这三点因素的交织导致我开始主动的去找各种各样的平替和一种新的取悦自己的方式，毕竟消费降级与生活降级不能画上一个完全的等号，而且钱是要实实在在的省下来，而不是“奶茶不喝，结果钱都扔进了股票，再次打水漂”，“把钱用在刀刃上，同时稳住当前的收入来源”才是最对自己最好的照顾。</p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>消费降级</tag>
        <tag>电商</tag>
        <tag>社会问题</tag>
      </tags>
  </entry>
  <entry>
    <title>乐夏第三季小总结</title>
    <url>/2023/10/26/%E4%B9%90%E9%98%9F%E7%9A%84%E5%A4%8F%E5%A4%A9%E5%B0%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>对于乐夏这种竞技类综艺节目来说，开头是比后面好看的，因为开头的时候几支乐队对于观众来说都很陌生，带有新鲜感，而且乐队们上来都会拿出自己的大金曲来搏一下眼球，所以上来往往是神仙打架，然后随着赛制的进一步发展，没有很多积累的乐队就会面临吃亏。</p>
<p>这几季都会有蒙古乐队，说实话，他们基本就是一招鲜。开头一个王炸，然后观众发现炸来炸去也就这玩意，炸无感了没什么新意，所以这种乐队来往往就是凑数的。</p>
<p>《乐夏》这个节目应该不会再玩了吧，因为愿意来参加的乐队都凑不齐了，第三季都开始有回锅的乐队了。节目排到第三季，乐队们的表现越来越乖，越来越没有锋芒，嘉宾犀利的点评也都剪的七七八八，而且最恶心的是这种歌唱类节目总让乐队改歌词，我估计这种“改歌词”的行为是很多乐队不愿意来的原因，没必要为了几个钱来折损自己的风格。</p>
<p>不总听乐队的人总喜欢讨论的地方就是“很多乐队喜欢用英语唱歌”。其实这个道理很简单，第一是母语羞涩，第二就是有些词中文说出来就不过审，举一个简单的例子，王嘉尔有一个歌词，什么“aim shoot”，这种歌词如果是中文百分百会被和谐掉。所以说为了过审，以及写出来的旋律适合用什么语言就用什么语言，所以这就是很多乐队喜欢用英语唱歌的原因，而且独立音乐原本市场就不大，又以英美为盛，国内乐队写点英文歌，大可不必上纲上线。</p>
<p>说到“以英美为盛”，其实国内很多乐队的热曲都能在国外乐队上找到似曾相识的影子。这里我觉得谈这个问题要先分清“抄袭”和“学习模仿”，这两个毕竟本质上有所不同，我个人很少就直接说“XXX乐队你抄袭了国外XXX乐队的XXX歌”，我一般都说“我觉得这个乐队肯定是听过国外XXX乐队的XXX歌”，这样比较严谨。</p>
<p>文化这种东西就是很容易出现“模仿”的，比如拿了好几百亿票房的《哪吒》，明眼人一眼就能看出来他那三头六臂的法相设定是从印度佛教里“抄”来的。没办法，中国古代神话就是大量的受印度佛教的影响，所以这种事实是没法回避的。跟摇滚一样，英美北欧就是走在我们前面，所以本土摇滚乐里有些外国歌相似的影子我觉得只要不是抄的太明显，都不算过分。</p>
<h2 id="先说说几个乐队的表现"><a href="#先说说几个乐队的表现" class="headerlink" title="先说说几个乐队的表现"></a>先说说几个乐队的表现</h2><h3 id="二手玫瑰"><a href="#二手玫瑰" class="headerlink" title="二手玫瑰"></a>二手玫瑰</h3><p>二手玫瑰我觉得是对待这个节目很认真的乐队了，他整个节目的作品里基本都不是他的大金曲。《伎俩》、《小红小绿》、《月牙五更狂想曲》、《耍猴儿》顺便还翻唱了一下王菲的《偶遇》，这些歌都不是二手非常流行的歌曲，直到最后的大决赛，感觉是为了节目效果配合一下，来了一首《仙儿》。</p>
<p>二手玫瑰凭借“戏谑的歌词+老太太唱腔+二人转风格+视觉系摇滚”这三个特色，在圈内就很有名，出圈是因为主唱梁龙当了美妆博主，但是他们参加这个节目没有忘了初心，在乐夏里是让听众更加关注他们那些不太出名但是也很有心思的歌。二手玫瑰在这个节目之后，梁龙也趁热打铁参加了很多歌唱类的综艺节目，从浙江台到湖南台，后来在音乐节里主唱梁龙说录制乐夏之前，二手玫瑰差点解散，在整个录制过程中乐队每个成员都在自我疗伤。</p>
<p>二手玫瑰现在是不是成了“有钱的艺术家”了呢？我觉得应该还没有，二手玫瑰比较掉价的事儿就是他们曾经为了商业唱了不是自己作词作曲的歌儿，这个事儿让粉丝感觉很不艺术家。经过了乐夏，我觉得他们的粉丝数量应该不会有较大的提升，出场价或许比以前更高了一点，但是要达到财富自由还是有差距。</p>
<p>2024年5月姚澜官宣暂时离队，据说是身体不好需要休养，也有考虑音乐出路的因素。姚澜是一个非常有观众缘、特别讨喜的人儿，瘦不垃圾眼睛贼大，往那一站就让人感觉特别有故事，特别有舞台吸引力。他不是二手玫瑰的元老，原来是紫环乐队的，但是他赶上了二手玫瑰商业化最成功的那几年，甚至一度被人说“梁龙+姚澜”就是二手玫瑰的主心骨。《嫂子颂》的吉他也是姚澜编的，我觉得姚澜应该就是单纯的身体调养，过个一年半载就回来了。</p>
<h3 id="回春丹"><a href="#回春丹" class="headerlink" title="回春丹"></a>回春丹</h3><p>回春丹这个乐队在上这个节目之前正是他们声誉最不好的时候—他们在表演的时候放program，但是凭借《鲜花》这首歌把不利的舆情扭转过来了，不得不承认，人还是要作品说话，只要作品够硬，其他都是小事。</p>
<p>回春丹当时还被批评是网红乐队，用大量的重复来让这个歌很魔性。这个批评估计很难通过乐夏来修改，不过也不重要了。《回春丹》也没有在乐夏这个舞台唱自己的大金曲《艾米莉》，可见整个乐队也是很有骨气的。</p>
<h3 id="声音玩具"><a href="#声音玩具" class="headerlink" title="声音玩具"></a>声音玩具</h3><p>声音玩具跟魏如萱合作的那首《你是无可取代》真的是太顶了！</p>
<p>声音玩具是一个个性、思想性和完整性都比较高的乐队，高亢的歌他们不多，属于那种慢慢唠音乐唠沉淀的例子，所以他这种类型在综艺节目上不太讨巧。之前看过一个评论说“声音玩具也是一个把自己专辑来回打磨的乐队，目的不是把棱角打磨掉，而是打磨出棱角”，我觉得这个说的很对。</p>
<p>欧老师人性格不好之前就有耳闻，这次节目里更是直接就表现出来了，这次跟黄锦重新合作也算是借机会给欧老师洗了一个白。欧老师本身是一个自恋狂性格，是一个自我感知意识很强的人，所以他更像一个艺术家，对自己和周围人的要求都很高，这种情景在各行各业里都很多。</p>
<h3 id="超级市场"><a href="#超级市场" class="headerlink" title="超级市场"></a>超级市场</h3><p>超级市场应该是凭借这个节目收获了大量的粉丝，整个节目组有点营销“龙宽九段”的故事，但是感觉俩个当事人却很无所谓的样子。田鹏老师已经是业内大咖了，他跟上面的欧老师有相同的地方，俩人都是画画出身，但是也有很大的不同，田鹏老师是一个很拧巴的人，他对创作是有要求的，但是言语中总是一副“我没有野心，词曲上也没有什么高要求”这样的一个表现，通过这种无意有意营造一个跟自己相反的性格的角色，我觉得有点逃避现实的感觉，所以有时候看他的访问有点精神错乱。</p>
<p>超级市场是一个后朋克+电子dj的组合，这个组合放到现在的音乐审美下都不过时，而且这种类型的乐队还不是特别的欧美化，有种土法炼钢的美。超级市场的词曲还特别会营造氛围，尤其是深渊的氛围。我个人这里推荐一下《原来》，氛围特别好，听这歌你是能看到正弦曲线的。</p>
<p>从世俗的角度来说，龙宽九段的那张专辑，绝对是可以排的进中国历史最佳专辑的榜单的，跟朴树《生如夏花》、周杰伦《叶惠美》、陶喆《黑色柳丁》一个级别。</p>
<h3 id="麻园诗人"><a href="#麻园诗人" class="headerlink" title="麻园诗人"></a>麻园诗人</h3><p>麻园诗人应该也是凭借这个节目收获了大量的粉丝，尤其是他改编王心凌的那一首《彩虹的微笑》，据说这首歌的点击率很高，有点小丧却唱的很真诚。主唱苦果每次都把自己脖子的青筋爆出来，让人听着上气不接下气。所以说乐队还是要看现场，看了现场才知道它的魅力。</p>
<p>我个人一向对真诚且上进的人很宽容，对河村勇辉是这样，对麻园诗人也是这样。苦果的词很多都是破碎的散文诗的感觉，这种不完美的温柔是这支乐队有很多死忠粉的原因。</p>
<h3 id="瓦伊娜"><a href="#瓦伊娜" class="headerlink" title="瓦伊娜"></a>瓦伊娜</h3><p>瓦伊娜的《大梦》无疑是当时最出圈的作品，也上了热搜。这首已经删减的歌描述了男人在不同时刻遇到的苦难，鲜活的讲述了佛家说的“众生皆苦”，让人后劲儿十足。瓦伊娜可以说是上了节目后就没啥曝光度的乐队了，可见他们农民的人设不是假的，就是单纯的过来唱个歌，唱完就走人。据说他们现在参加音乐节，每次都给买票的人一些礼物，去年是自己种的大米，今年是自己种的李子。</p>
<p>有些人说瓦伊娜的音乐基本功还不够，旋律很简单，但是他们这个乐队的人设就是“简单、淳朴”，所以可以无缝的衔接雷鬼的元素，达到自己很轻松或者自嘲的精神状态。所以这也是它能有一批追求原生态“同志”的原因。</p>
<h2 id="中国摇滚小tips（慢慢补充）"><a href="#中国摇滚小tips（慢慢补充）" class="headerlink" title="中国摇滚小tips（慢慢补充）"></a>中国摇滚小tips（慢慢补充）</h2><p>这里放一点摇滚历史的小故事，方便出去跟滚圈的人吹牛逼用。</p>
<h4 id="二手玫瑰-1"><a href="#二手玫瑰-1" class="headerlink" title="二手玫瑰"></a>二手玫瑰</h4><pre><code>a. 二手玫瑰前吉他手是王钰琪，02年就信佛了，2005年他因为身体原因离队了，然后姚澜入队。
b. 孙权之前的鼓手是张越，病故了。
c. 吴泽坤2000年左右加入乐队的，他是民乐大师吴彤的侄子。吴彤曾经是轮回乐队的主唱，后来被乐队开除了，曾经通过吹那些民族乐器拿过格莱美。
d. 二手玫瑰第一章专辑发布的时候，阵容是梁龙（主唱）、王钰琪（吉他）、陈劲（贝斯）、张越（鼓手）、吴泽琨（民乐）。
d. 姚澜生病期间补进来的吉他手是刘巨然，他曾经给左小祖咒谈过琴，风格是比较重型的。
</code></pre>
<h4 id="果味VC"><a href="#果味VC" class="headerlink" title="果味VC"></a>果味VC</h4><pre><code>a. 甄洋是前贝斯手，后来去了银色灰尘，现在在巨浪乐队。一张嘴一股京片子味，话很密，最近也在做自媒体“甄無聊”，主要就是推广北京摇滚乐队，还挺有意思的。
</code></pre>
<iframe src="//player.bilibili.com/player.html?isOutside=true&aid=114194858901759&bvid=BV1gmXeYWE9b&cid=28971895220&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>
	b. 上乐夏的果味VC的主唱是原来的吉他手刘子滔不是原来的主唱孙凌生，除了乐队名很多人都变了。现在是鼓手老杨，吉他手李小川，贝斯手李小泉。

<h4 id="鲍家街43号"><a href="#鲍家街43号" class="headerlink" title="鲍家街43号"></a>鲍家街43号</h4><pre><code>a. 龙隆就是这支乐队的前吉他手，后来给老狼弹过吉他，现在给华晨宇做制作人了。不过华晨宇的歌我是一首都没听过。
</code></pre>
<h4 id="指南针乐队"><a href="#指南针乐队" class="headerlink" title="指南针乐队"></a>指南针乐队</h4><pre><code>a. 刘伽帝就是刘峥嵘,他还给黑豹当过一段时间的主唱.
b. 最近指南针乐队跟前主唱罗琦有纠纷，说罗琦无版权唱指南针乐队的歌曲。
</code></pre>
<h4 id="谢津"><a href="#谢津" class="headerlink" title="谢津"></a>谢津</h4><pre><code>a. 她比较有名的歌是《说唱脸谱》，个性很强的一个女歌手，曾经因为打了随行人员被华纳封杀，然后1999年情人节那天跳楼身亡了，据说心理压力过大。
</code></pre>
<h4 id="痛仰"><a href="#痛仰" class="headerlink" title="痛仰"></a>痛仰</h4><pre><code>a. 痛仰乐队的前吉他手田然因为从美国演出回来带毒被抓了，后来痛仰的官方微博因为这事儿还鸣不平，被网友喷了。
</code></pre>
<h4 id="眼镜蛇乐队"><a href="#眼镜蛇乐队" class="headerlink" title="眼镜蛇乐队"></a>眼镜蛇乐队</h4><pre><code>a. 原主唱兼吉他手肖楠后来加入了超级市场。
</code></pre>
<h4 id="黑豹乐队"><a href="#黑豹乐队" class="headerlink" title="黑豹乐队"></a>黑豹乐队</h4><pre><code>a. 黑豹乐队历年的主唱：刘金山（都这么说，但是我没看过录像）、丁武、窦唯、栾树、秦勇（他孩子有一个很麻烦的病，所以他退团了）、张克芃（他还演过央视三国的张苞）、秦奇、马克塔勒、刘峥嵘、张淇、项亚蕻
</code></pre>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>摇滚</tag>
        <tag>综艺</tag>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title>从Nginx配置缓存到HTTP缓存</title>
    <url>/2019/03/18/%E4%BB%8ENginx%E9%85%8D%E7%BD%AE%E7%BC%93%E5%AD%98%E5%88%B0HTTP%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h2 id="使用nginx配置缓存"><a href="#使用nginx配置缓存" class="headerlink" title="使用nginx配置缓存"></a>使用nginx配置缓存</h2><p>proxy_cache_path是nginx配置缓存的关键词，它是1.7.9之后的版本推出的功能。配置它很简单，只需要在<code>nginx.conf</code>里的http段里添加一句话：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">proxy_cache_path /data/httpd/nginx_cache/ecstore levels=<span class="number">1</span>:<span class="number">2</span> keys_zone=ecstore:100m max_size=2g inactive=168h;</span><br></pre></td></tr></table></figure></p>
<p>上面的命令先说明<code>/data/httpd/nginx_cache/ecstore</code>就是nginx配置缓存的文件夹，<code>keys_zone</code>指的是缓存空间名称，100m意思是可以存储8000*100个key；<code>max_size</code>指的是缓存文件可以占用的最大空间；<code>nactive</code>指的是如果一个缓存文件多长时间不被访问，就会被删除；</p>
<p>然后手动建立<code>/data/httpd/nginx_cache/ecstore</code>这个文件夹，给予它nginx可访问的权限，然后在具体的配置文件里加上：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">    location = /wap/ &#123;</span><br><span class="line">            <span class="keyword">if</span> ($query_string) &#123;</span><br><span class="line">                    proxy_pass http://<span class="number">172.16</span><span class="number">.0</span><span class="number">.199</span>:<span class="number">3000</span>/wap/?$query_string;</span><br><span class="line">            &#125;</span><br><span class="line">            proxy_pass http://<span class="number">172.16</span><span class="number">.0</span><span class="number">.199</span>:<span class="number">3000</span>/wap/;</span><br><span class="line">            include headerproxy.conf;</span><br><span class="line">            proxy_cache ecstore;	<span class="comment">#这里的ecstore就是上面keys_zone的名称</span></span><br><span class="line">            proxy_cache_key <span class="string">&quot;$host$request_uri$cookie_user&quot;</span>;	<span class="comment">#这里就是缓存的key</span></span><br><span class="line">proxy_cache_min_uses <span class="number">5</span>;		<span class="comment">#至少访问5次就开始缓存，默认情况是访问一次就缓存</span></span><br><span class="line">proxy_cache_methods GET HEAD POST；	<span class="comment">#对GET、HEAD、POST方法都可以缓存</span></span><br><span class="line">            add_header X-Cache web1$upstream_cache_status;	</span><br><span class="line">            proxy_cache_valid <span class="number">200</span> <span class="number">206</span> <span class="number">302</span> <span class="number">301</span> <span class="number">304</span> 2h;	<span class="comment">#对200、206、302、301、304状态码缓存2小时</span></span><br><span class="line">proxy_no_cache $http_pragma $http_authorization;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>上面这个例子就是“如果访问&#x2F;wap，会跳转到<a href="http://172.16.0.199:3000/%EF%BC%8C%E5%90%8C%E6%97%B6%E8%AE%B0%E5%BD%95%E4%B8%8B%E7%BC%93%E5%AD%98%E2%80%9D">http://172.16.0.199:3000/，同时记录下缓存”</a> 的配置。重启nginx就会生效。</p>
<h2 id="验证和排错"><a href="#验证和排错" class="headerlink" title="验证和排错"></a>验证和排错</h2><p>验证nginx是否缓存成功很简单，因为我们在配置文件夹加上了<code>add_header X-Cache web1$upstream_cache_status;</code>这样的配置，那么我们打开目标的网页：<br><img data-src="/images/CDN5.png" alt="akb48" title="我是三台nginx集群，分别是Web1~3，这个显示缓存到了第三台nginx上"></p>
<p>发现看到了<code>add_header</code>的内容，可见缓存是成功的。</p>
<p>如果此刻给这个nginx外面套上一个CDN，那么<code>curl -I</code>在访问页面里具体元素的结果就会是：<br><img data-src="/images/CDN4.png" alt="akb48"></p>
<p>我这里用的是阿里云的CDN，可见他们使用<code>Server: Tengine</code>做的CDN，而且这个js元素被CDN成功缓存。如果是<code>TCP_MEM_HIT</code>的字样，那么就说明是是从内存命中的。不同厂家的CDN展示结果不一样的。</p>
<p>如果nginx缓存没有生效，很大可能是<code>Cache-Control</code>和<code>Set-Cookie</code>的问题，那么就要在上面的配置文件里添加：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">proxy_ignore_headers <span class="type">Set</span>-Cookie Cache-Control;</span><br></pre></td></tr></table></figure></p>
<p>重启nginx看看效果。</p>
<h2 id="Vary跟Etag的差别"><a href="#Vary跟Etag的差别" class="headerlink" title="Vary跟Etag的差别"></a>Vary跟Etag的差别</h2><p>在上面的截图里看到了<code>Etag</code>和<code>Vary</code>这两个字段，先说<code>Etag</code>。</p>
<p><code>Etag</code>是一个比较常见的字段，HTTP利用它来判断所访问的元素是否发生了变化—如果浏览器发送请求的请求头<code>If-None-Match</code>里的<code>Etag</code>没有变化（为False）那么服务器就直接304，把缓存内容返给浏览器；如果<code>Etag</code>发生变化了，那么服务器就拿出新的内容给它同时反馈200。它比<code>Last-Modified</code>强的最重要的地方就是<code>Last-Modified</code>只能精确到秒，遇到1s内修改了N次的情况就只能干瞪眼了，而<code>Etag</code>不会。</p>
<p>而说Vary之前要先说一下<code>Cache-Control</code>，<code>Cache-Control</code>有四个比较出名的缓存策略，分别是：<br>1.no-cache：可以在本地缓存，可以在代理服务器缓存，但是这个缓存要服务器验证才可以使用；<br>2.no-store：彻底得禁用缓存，本地和代理服务器都不缓存，每次都从服务器获取；<br>3.private：为仅浏览器客户端可缓存；<br>4.public：为多个用户都可以缓存，比如可以缓存到CDN上。</p>
<p>而图片里的<code>Vary: Accept-Encoding</code>是什么意思呢？它是告诉缓存服务器根据<code>Accept-Encoding</code>头值的不同去缓存不同的版本，比如同一个文件可能有gzip方式压缩的，有compress方式压缩的，甚至还有没压缩的。因为在实际的场景中，我们需要一些特殊的缓存：它会忽略响应头中的<code>Content-Encoding</code>，从而可能给不支持压缩的客户端返回缓存的压缩版本。有两个方案可以避免这种情况发生：<br>1.将响应头中的<code>Cache-Control</code>字段设为<code>private</code>，告诉中继缓存（比如CDN）不要缓存它；<br>2.增加<code>Vary: Accept-Encoding</code>响应头，明确告知缓存服务器按照<code>Accept-Encoding</code>字段的内容，分别缓存不同的版本；</p>
<p>通常为了更好的利用中间实体的缓存功能，我们都用第二种方案。对于<code>css</code>、<code>js</code>这样的静态资源，只要客户端支持gzip，服务端应该总是启用它；同时为了避免有BUG的缓存服务器给用户返回错误的版本，还应该输出<code>Vary: Accept-Encoding</code>。</p>
<p>nginx配置<code>Vary：Accept-Encoding</code>也很简单，在<code>nginx.conf</code>的http段里加上<code>gzip_vary on;</code>即可。</p>
<p>当然Vary还要很多种，比如<code>Vary: User-Agent, Cookie</code>，这表示“服务端同时使用请求头中User-Agent和Cookie这两个字段来生成内容”。注意！客户端如果直接访问源服务器的话，Vary就没意义了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/dengjiexian123/article/details/53386586">https://blog.csdn.net/dengjiexian123/article/details/53386586</a><br><a href="https://blog.csdn.net/t12x3456/article/details/17301897">https://blog.csdn.net/t12x3456/article/details/17301897</a><br><a href="https://www.jianshu.com/p/625c2b15dad5">https://www.jianshu.com/p/625c2b15dad5</a><br><a href="https://imququ.com/post/vary-header-in-http.html">https://imququ.com/post/vary-header-in-http.html</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ</a><br><a href="https://segmentfault.com/a/1190000016648967">https://segmentfault.com/a/1190000016648967</a><br><img data-src="/images/greenbook.jpg" alt="akb48" title="其实有时候不一定要用仇恨去对抗仇恨"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>CDN</tag>
        <tag>nginx</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>乌俄之战碎碎念</title>
    <url>/2022/03/07/%E4%B9%8C%E4%BF%84%E4%B9%8B%E6%88%98%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
    <content><![CDATA[<p>俄乌战争已经第10天了，乌克兰已经有100万难民逃离了战场。目前两边也愈战愈烈，今天你拿走一个核电站，明天我抢回一个机场。网络上的信息满天飞，辨别假信息着实要费人一番功夫。</p>
<p>不过这篇文章不是什么真信息汇总，也不是说谁是谁非。只是对未来的一个猜想，是一个极不负责任的非专家分析。</p>
<h2 id="未来的发展"><a href="#未来的发展" class="headerlink" title="未来的发展"></a>未来的发展</h2><p>马克龙在3月4日和3月6日两次给普京打了电话，总时长据说3个多小时。但是效果甚微，3月6日晚普京对外宣称“任何一个想要靠谈判拖延的手段，只会让俄罗斯在战略目标上更高要求”，“只有乌克兰投降，满足了俄罗斯的要求，俄罗斯才会停止整个战争”。可见马克龙的刷脸失败了，马克龙自己也说“普京在言语之间表达了要完全吞并乌克兰的意思”。</p>
<p>其实俄罗斯如果真的只是要保护顿巴斯那两个地区，效仿2014年克里米亚就行了，往对方区域安插自己人，然后造既定事实最后公投这一套俄罗斯不知道玩过多少次（南奥塞梯等等），但是俄罗斯却现在大军围着整个乌克兰攻打，甚至在核电站附近开火，可见普京目前的目标不是那么简单。普京在2021年7月有一个长文，里面表达了“乌克兰和俄罗斯是同一个国族，要历史统一”，我想他在实现这一步。至于他在“万字檄文”里说的：“1990年，在讨论德国统一问题时，美国向苏联领导人承诺，北约的管辖权或军事存在不会向东延伸一寸。而且，德国的统一不会导致作为军事组织的北约向东延伸。”这句话目前看根本就没有一个北约有法律效力的文件来支持。</p>
<p>不过这些都是事前的事儿了，俄罗斯跟乌克兰政府之间的恩怨，已经很难说得清了，毕竟双方都沾满了对方民族的鲜血。他俩现在还在这个拳击场里互殴，而北约和美国也在一边一直在拱火，但是就不下场。北约在3月6日也拒绝了乌克兰要求禁飞区的请求，可见它的态度很明显—“给你提供武器物资都可以，但是要我帮你打仗是万万不行的”。</p>
<p>北约的小算盘是“我这一次帮乌克兰打仗，那么以后我还要帮，这是一个无底洞”，第二就是大家都知道的“俄罗斯可能会打大、打核”，要知道俄罗斯是敢扔核弹的，毕竟当年苏联就差一点把核弹扔给中国。</p>
<p>俄罗斯的目标，我们不妨列一下：</p>
<ol>
<li>上签–乌克兰两个州和克里米亚官宣给俄罗斯，黑海控制权也归俄罗斯，泽林斯基死掉或者被审判拘禁，亲俄派亚努科维奇等人重新上岗，宣布乌克兰一辈子不参加北约和欧盟；</li>
<li>中签–俄罗斯拿到两个州，外加现在已经拿到手的黑海一带土地，这样乌克兰成了内陆国家，泽林斯基最好挂掉；</li>
<li>下签–恢复战争前的领土分割，但是这样基本需要北约和美国施加压力才会让俄罗斯把那两个洲吐出来；</li>
</ol>
<p>乌克兰在领土的目标跟俄罗斯正好想反，然后就是希望借此机会可以进欧盟，进北约他就别想了，加入北约的基本条件就是“与邻国没有政治冲突和领土分歧”，它想消停，俄罗斯如果还是普京这样鹰派执政都不会让它消停。</p>
<p>至于北约的目标，我猜测如下：</p>
<ol>
<li>上签–普京下台，但是这个的后果就是俄罗斯必乱，车臣什么的肯定会独立，“俄罗斯-中国”的组合在东南亚的影响力大减，这个场景是欧美喜闻乐见的；</li>
<li>中签–俄罗斯军队被自己耗死，放弃目前作战局面停火谈判，那俩个州爱谁谁，毕竟欧美眼中，乌克兰的领土利益是可以拿去做交易的，至于黑海反正还有土耳其，这样土耳其更不会退出北约了；</li>
<li>下签–俄罗斯完全吃掉乌克兰，波兰芬兰等国反弹，可能会战争扩大化；</li>
</ol>
<p>相比较北约提供标枪反坦克炮的热情，他们参与俄乌谈判的热情明显不高。我个人猜测北约现在乐滋滋的，至少俄罗斯目前是在战争的泥沼里，通过乌克兰消耗俄罗斯的目的达到了一部分，而一个不强大的俄罗斯对中国是没用的，相反只会成为中国的经济累赘，中国已经有了一个朝鲜，再来一个大朝鲜，2021年中国跟伊朗又签了一纸长约，将来可能会被拖垮，那么中国应该会更主动去调和。也就是说战争只要控制在局部，俄罗斯又没有理由停掉德国的气，那么打得越久英美越开心。</p>
<p>如果上面我个人的分析真的是他们各方的目标，那么目标有了就想想怎么做能达到这个目标吧。至于这个战争未来还会打多久？当年俄罗斯跟格鲁吉亚在2008年的时候打了几乎半个月，我估计这一次要15~20天吧，毕竟俄罗斯现在还没有切断乌克兰基辅的补给线和网络。</p>
<h2 id="为什么中国网民这么激动"><a href="#为什么中国网民这么激动" class="headerlink" title="为什么中国网民这么激动"></a>为什么中国网民这么激动</h2><p>从俄罗斯攻打乌克兰开始，大陆大多数网民就进入了一种亢奋的状态，在微博、抖音、B站等公共论坛开始热情发帖转载。其中言论无非就是“乌克兰人死的越多越好，这样我就有乌克兰小媳妇儿了”、“乌克兰总统就是一个戏子，是来丢人搞笑的”、“俄罗斯没打闪电战是因为俄罗斯爱民如子”，“车臣能把乌克兰人脑袋拧下来”、“这场战争全他妈的怪美英”。而且现在民间也有不少人起高调，比如超市摆俄罗斯商品，很多女人在微博抖音B站上狂刷普京好man好帅，然后对美英和乌克兰一番唾弃，甚至波兰球星莱万、祖母是乌克兰的迪卡普里奥也难逃被骂的命运。</p>
<p>我身边也有这样的朋友，据我观察他们分两种，一种就是把自己代入成了俄罗斯，把乌克兰代入成了台湾，认为俄罗斯会闪电拿下乌克兰，大展威风，实现当初的段子“早上吃早餐，中午活捉蔡英文，晚上核酸检查发身份证”，这种基本就是狂热的“革命小将”。还有一种要理智一点，他们对俄罗斯好感没那么多，但是“现在中俄利益一体化”，俄罗斯不行了，美国就会来搞中国，到时候中国就完了。</p>
<p>其实说到历史，乌克兰对中国还是不错的，绝不是亚努科维奇这个亲俄派上台后才好的。辽宁号以前就是乌克兰的瓦良格号，而且我国海军之前的巨型补给舰青海湖号也是乌克兰在1993年卖给我们的，至少在军工技术上，乌克兰由于穷，所以基本上中国只要钱到位，啥都好说，比如AL-31F发动机、UGT系列的内燃油轮机等等技术都给中国的军事现代化很大的帮助。而且乌克兰也是中国一带一路的重要一环。</p>
<p>但是俄罗斯不一样，俄罗斯其实对中国在军工业和重工业都是防一手的，中俄时间在军事交流除了军事演习之外基本就没啥了，因为俄罗斯一直忌惮中国的山寨能力，只要技术和图纸到了中国，以中国强大的仿造能力，很快就能出一个产品，成本是真品的一半，威力也不会差太多。俄罗斯不想核心技术被学走，然后断了自己的财路，所以一直在军事科技上对中国没有完全交流。</p>
<p>不过相比较美国，其实俄美之间的高科技交流很不少，比如NASA跟俄罗斯航天局是从1998年就合作的，这是中国人一直没有进去的门槛。也就是说，相比较信任俄罗斯，美国更不信任中国人。</p>
<p>现在是战争局势，中俄双方官方媒体在信息上达成了高度一致。大陆各路官媒也一直在援引塔斯社的消息或者欧美不利于乌克兰的消息，来用春秋笔法通报前线战局，比如两次转载塔斯社一直说泽林斯基已经离开了基辅，央视媒体一直给国内的网民塑造他是一个懦夫的形象，来让大陆网民取笑讥讽。</p>
<p>不过泽林斯基至少目前还不是卡扎菲，卡扎菲8月20号国内反对派造反，21号就跑回到故乡苏尔特。卡扎菲表现的还不如美国另一个老对手萨达姆，2003年3月20日美军对巴格达行动，将近5月末萨达姆才跑路的。（泽林斯基目前还在基辅，还开新闻发布会，其实他要是真的战死或者被暗杀，他会被乌克兰反俄的人民封为神灵一样的存在—-这个世界很多人都是这样，没人关心你怎么来的，但是会关心你怎么没的。）</p>
<p>当然话说回来，萨达姆被身边保镖出卖被捕之后，美国也做了不少的工作来抹黑他的形象，可见天下的乌鸦在抹黑对方首领的方面都一般黑，手段一样的恶心。</p>
<h2 id="中国的下一步？"><a href="#中国的下一步？" class="headerlink" title="中国的下一步？"></a>中国的下一步？</h2><p>从开战到现在已经大约10天了，在之前联合国大会谴责俄罗斯侵略乌克兰的投票上，大多数国家投的是赞成票，而中国再次投弃权票，这也让外交部在西方媒体面前屡次要回答“中国到底是什么态度？”这个问题，我看华春莹这几天也怒怼了一波法新社的记者。</p>
<p>其实现在中方态度很明显，中国目前肯定是不会跳出来的，因为虽然俄罗斯在攻打乌克兰的进度“远不如预期”。但是以俄罗斯的体量，收拾一个乌克兰问题不大，虽然现在卢布贬值成渣，但是中国还是押宝俄罗斯可以在乌克兰面前“体面的搞定这一切”，所以中国外交部目前依旧可以“打太极”，给俄罗斯破败的经济情况输血，要知道2022冬奥中俄签订的那两个能源大单，中国可是采购了俄罗斯1175亿的原油和天然气，然后普京连国宴都没参加，冬奥开幕式结束后直接走了。</p>
<p>中国什么时候会跳出来呢？我想只有一种可能，那就是俄罗斯的本土遭到了攻击，俄罗斯真正的需要求助了，那么中国才会跳出来的，此时这个军事联盟就正式宣告成立。不然的话它就会继续默默的担任俄罗斯的后勤。</p>
<p>其实中国跟俄罗斯的价值观并不相同，他俩只是在“反美”这一点达成了共识，实现了短期的合作。中俄在一些问题上还有分歧：俄罗斯排斥中国介入哈萨克斯坦，俄罗斯也跟印度走的很近，而中印前段时间还有士兵冲突。这一点跟中国苏联一直以来的关系差不多，那时候两边既有交流，同时毛主席也让林彪在内蒙古搞出来一堆人造山。</p>
<p>毕竟SWIFT将俄罗斯的那几个大银行踢出去是一个让西方也很痛的决定。如果真的美国英国等跟俄国有商业往来的公司，因为SWIFT而导致俄国公司无法结算，会导致这些大财团有自身严重经济危机，再加上俄乌擦枪走火导致战争扩大化。那么上面那个情况还是有大概率出现的，如果出现了怎么办？我等屁民赶紧去取钱吧，然后第一时间买点保质期长久的物资备着，房贷车贷神马的就先缓缓吧。</p>
<p>话说回来，我个人猜测这场战争最大的结局就是：乌克兰放弃加入北约，但是抵抗俄罗斯入侵基辅成功，政府班子不变，同时也失去了那俩个公投的州。而俄罗斯则要长期备受欧洲和美国的经济制裁，欧洲慢慢摆脱俄罗斯的能源，同时由于俄乌都是粮食出口大国，导致发达国家可以拿粮食换其他国家的能源。被制裁的俄罗斯很大概率会成为一个大号的朝鲜—空有核弹，但是穷的叮当响。话说一个朝鲜已经够中国受得了，再来一个大号朝鲜，真不知道这日子怎么过了。</p>
<p>当然从这场战斗里，我们也要学到一些教训，目前为止最大的教训就是不要学德国—为了环保把自己的能源能力全部停工拆除，一点容灾能力都不留。这种法案真的不知道当时怎么通过的，朔尔茨应该庆幸自己不是韩国人，不然将来大概率被清算。<br><img data-src="/images/%E4%B9%8C%E5%85%8B%E5%85%B0%E5%B0%8F%E5%A7%91%E5%A8%98.JPG" title="战争不应该把这样的小孩卷进去，这个世界不需要黑寡妇"></p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>俄罗斯</tag>
        <tag>乌克兰</tag>
        <tag>普京</tag>
      </tags>
  </entry>
  <entry>
    <title>从《荒野大镖客2》看黑社会片和江湖片</title>
    <url>/2023/07/21/%E4%B8%BA%E5%95%A5%E6%88%91%E4%BB%AC%E5%96%9C%E6%AC%A2%E6%B1%9F%E6%B9%96%E7%89%87/</url>
    <content><![CDATA[<p>注意，本文涉及剧透！</p>
<h2 id="荒野大镖客"><a href="#荒野大镖客" class="headerlink" title="荒野大镖客"></a>荒野大镖客</h2><p>《荒野大镖客2》开放性的玩法让他的死忠粉至今还在为它输给《战神4》无缘2018年最佳游戏而叫屈。这款游戏对开放游戏这个领域的确做出了很酷的榜样，当然更主要的是它整个剧情可以说是西部牛仔片的经典。它奇妙的设定在于主人公亚瑟如果荣誉值很高，一路见义勇为仗义疏财，那么在他死后，玩家可以操作第二个主人公约翰走访之前亚瑟帮助过的人，那些被亚瑟救助过的人就会缅怀他，这样达到全文的中心–“救赎”。亚瑟这个角色虽然是一个粗汉子但是也有记日记画画的能力，他知道自己虽然只是一个混混打手和杀手，但是他内心里还是渴望着一片平静，也正是这份良知让他借着身患不治之症的理由可以用行动救赎自己以前的错误。<br><img data-src="/images/%E8%8D%92%E9%87%8E%E5%A4%A7%E9%95%96%E5%AE%A21.jpg" title="策马在夕阳下"></p>
<p>亚瑟可能并不一定是一个“好人”，但是他是一个真男人。</p>
<p>在整个游戏体验里，玩家是能感受到亚瑟的成长，这是养成型RPG游戏里很重要的一点。  而第一代主角约翰在成长上主要是“对小家庭的照顾”。当然这也很重要，因为在黑帮片里，顾家是“男人”的一个重要标准。《教父》里就有这样的台词：<br><img data-src="/images/%E6%95%99%E7%88%B6%E5%8F%B0%E8%AF%8D.JPG" title="意思就是我们为啥要干这个，不是为了自己是为了家人"></p>
<p>但是这里我更想说说反派之一达奇。</p>
<p>达奇这个团伙是一个被通缉的团伙，而且在黑水镇抢的钱还没带出来，导致他们白白冒了风险还没有任何收益。达奇这个逃犯的身份让他在面对其他人的时候不自觉的就矮了一截和“不自信”，毕竟对方一旦识破他们的罪行，就可以报官拿到悬赏金。所以达奇这一路基本没有真正的去同等级的交朋友，除了上面这个“逃犯身份”以外，侦探们的追击也让他们注定无法在一个地方久留，所以达奇有那么多plan，最核心的plan就是“利用”。</p>
<p>在第三章，达奇利用了格雷家族和布雷斯维特家族的矛盾，来回的拿到了好处，但是仔细一看做的这些事情：抢劫私酒、烧田、偷马等等其实并没有赚到什么钱，尤其是格雷家族让亚瑟他们偷马说马能去黑市卖5000美元，结果实际到马贩子那里只有700美元。可见剧情设定里亚瑟等人冒着枪林弹雨就是拿到了一点蝇头微利，最后被双方无情的抛弃，进而火拼。<br><img data-src="/images/%E8%8D%92%E9%87%8E%E5%A4%A7%E9%95%96%E5%AE%A25.jpg" title="当年达奇指挥全军出动救杰克，后来他却怀疑约翰是内鬼而屡次放弃约翰"></p>
<p>其实无论是从格雷家族还是布雷斯维特家族的出发点来看，达奇帮派是突然横插的第三股势力，而且这股势力有“敢打敢拼、草莽出身、不会久留”这几个特质，就自然而然的把他们当成“工具人”，后来摸清了底细发现原来达奇帮派是通缉犯，那达奇等人被抛弃就是情理之中的事情。</p>
<p>快意恩仇虽然爽，但是达奇从第三章结束，尤其是第四章被意大利人骗了之后，再加上抢圣丹尼斯银行的时候脑子被撞了一下，他的心态开始失衡，他开始执着于“抢一票大的，我们远走高飞，去澳大利亚还是什么鸟岛都可以”。也正是这种执着，再加上叛徒迈卡的挑唆，他把“利用”从对外还是扩大到对内，他当初的“侠客、反抗资本压迫、反抗社会不公”的理想主义开始转变的冷血和残酷，让达奇开始逐渐被下属质疑进而决裂。</p>
<p>对于达奇而言，帮派里谁是他的心腹，谁是一般人（中途离队过的约翰肯定不如比尔等人那么心腹），他了如指掌。比如迈卡，达奇对他的情感肯定没有主人公亚瑟高，从达奇开始一直拒绝迈卡屡次提出的“回黑水镇拿钱”看，他俩彼此更多也是互相利用的关系。但是一旦达奇心中的那份“执着”让他不仅对自己心腹开始“利用”对印第安人也“利用”，让自己彻底从当初的“罗宾汉”的形象堕落成了孤家寡人，为最后跳崖自尽的结局埋下伏笔。</p>
<p>所以说，交朋友就老老实实的交朋友，带团队就堂堂正正的带团队，如果对周围的人是“利用”的“心机”，“利用不到”就抛弃掉，那注定交不到真朋友，这种例子在中国皇帝里有很多。</p>
<p>对于迈卡这种叛徒，编剧的安排还是经典的“让背叛者死于背叛”…<br><img data-src="/images/%E8%8D%92%E9%87%8E%E5%A4%A7%E9%95%96%E5%AE%A24.jpg" title="看我的浣熊小帽！"></p>
<h2 id="为什么我们爱江湖片"><a href="#为什么我们爱江湖片" class="headerlink" title="为什么我们爱江湖片"></a>为什么我们爱江湖片</h2><p>《荒野大镖客2》 只是一个引子，但是江湖和黑帮一直是电影世界里的主流力量，它在美国可以是西部片，在中国可以是武侠片，在日本可以是忍者片。江湖片无论是剧情、演员、配乐、动作效果都在世界各种的评奖里拿到过很重量级的奖，那么为什么我们如此热爱江湖片？这种男人戏有什么地方这么迷人？</p>
<p>首先江湖片的主人公注定是一个底层人，只有底层人才会去做杀手打手这样的职业。同时主人公用他的所见所闻来给观众表达他所生活的这个环境，让观众对底层环境有所了解，知道社会里还有这样的一群生活在灰色地带的边缘人。而主人公虽出身卑微，行动在黑暗之中，但是内心里还是想要渴求一片光明和一份宁静，正是这种“救赎”的戏份，传达出一份草莽习气的“真善美”的同时也表达出主人公内心的纠结和挣扎。</p>
<p>其次江湖片主打一个“感情”，而这种感情是主动要经过“生死”来考验的，不是口头上简单说说的，毕竟没有枪战动作戏的江湖片还有啥看头？这种感情里既有对老大的“忠诚”，也有对同级“兄弟义气”，也有对伴侣的“浪漫誓言”，当然也会有“为钱背叛”的戏码，这一波剧情推动更是对人性的拷问。</p>
<p>最后江湖片的主人公也多半会伏法或者死掉，这加深了“宿命感”，让观众叹息个人的奋斗在命理面前的渺小。</p>
<p>以上三点浓缩到一部电影里，就已经有很多的看头。而游戏跟电影不同，电影是两个小时，而游戏是玩家操作着键盘手柄100多小时，对主人公的经历有了更加深的感触，玩家一旦沉浸其中，与主人公合而为一，很难不被剧情所打动，让人久久回味这一路的感觉。</p>
<p>果然潇洒的浪子是很容易让人不自觉的吸引。</p>
<p>江湖片是男人的浪漫，有情有义是男人最好的医美，这一点永不过时。</p>
<p><img data-src="/images/%E8%8D%92%E9%87%8E%E5%A4%A7%E9%95%96%E5%AE%A23.jpg" title="月夜下的约翰，话说约翰比亚瑟要罗锅一点..."></p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>电影</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>人生就是对抗&quot;极&quot;</title>
    <url>/2023/12/01/%E4%BA%BA%E7%94%9F%E5%B0%B1%E6%98%AF%E5%AF%B9%E6%8A%97%E6%9E%81/</url>
    <content><![CDATA[<h2 id="一个撕逼的案例"><a href="#一个撕逼的案例" class="headerlink" title="一个撕逼的案例"></a>一个撕逼的案例</h2><p>这是双十一期间微博热搜上非常有名的图，说实话我第一次见到这张图的时候，真是小刀拉屁股—开了眼了。<br><img data-src="/images/%E8%AF%A6%E6%83%85%E9%A1%B5%E6%95%85%E9%9A%9C.png" title="第一次见到直接把错误码干出来的"></p>
<p>后来这个P1故障当时就引起了两个部门的撕逼，因为这个故障影响面太大，又发生在双十一尾声，当时每秒钟可能几万的GMV，涉及到了理论资损。所以为了各自部门不吃全年325，这两活人就开始甩锅。后来又折腾了前后一周，各方看日志截数据找证据，才最后裁决出主责次责。</p>
<p>复盘是一个很折磨人的事情，既要写很多的材料，又要跟高P们一遍一遍的解释，还要填写时间线，灵魂深处交代当时的心路历程等等等。最重要的是整个过程都要背上巨大的心理包袱。也正是因为避免这样的折磨再次降临到头上，所以在双十一之后的双十二，两个部门都开始在压测模型开始保守，要知道双十二的体量跟双十一相比差了两个级别，但是在这个故障场景—商品详情页的QPS量级上都很保守。所以硬件资源的使用量级相比较双十一不降反升。</p>
<p>这里我有几点思考：</p>
<ol>
<li>压测的时候，上下游已经对流量达成了共识，那么一方在面对意料之外的流量到来的时候，就有义务通知下游，下游先扩容上游再扩容，而不是自己只管自己，事后来一句“我就多加了X%，你就抗不住了？”“你为什么不留余量”。这是违反契约精神的，因为说好了就按照这个数字来，有特殊情况也要在已知压测场景的基础上评估，而不是凭感觉在压测的标准上又预留所谓的“余量”，因为这个“余量”是部门间事前不对焦的，不通知下游就贸然使用“余量”，这是不负责任的行为。</li>
<li>大促实际流量大于压测流量的时候，正确的操作应该是报备大促项目组，然后大家一起统一的操作，比如一起扩容，一起调整限流。因为现在系统的交互错综复杂，不能“只管自己，不管别人”，因为有可能你管了你自己，反而把下游打挂了，然后如果你还依赖下游的返回，下游崩溃再把你带崩溃了。所以这种应急不是一个好的SRE操作，而是在坑人。好比开车的时候，前面有路障，你没有踩刹车，反而猛打方向盘，把别人撞沟里去了，然后大家又是一体的，掉沟里的车把你的车也带进了沟里。</li>
<li>往往撕逼的原因就是当时一方的自救操作引起了另一方的故障，有些是因为后者本身能力不行没有保护性限流等面向失败的设计，有些就是前者的突破约定SLA操作。</li>
<li>好的SRE就是好的副驾驶员，他可以不了解车的“内燃机”，“发动机”等等部件具体的工作原理，但是他是应用系统owner的主辅助，可以横向观察，而且知道什么时候也有权力进行“踩刹车”等应急操作。好的SRE，面对“飞行换发动机”这样的紧急情况的处理就是丝般润滑，而不好的SRE，可能就直接造成停机了。</li>
<li>全链路压测模型制作起来非常麻烦，因为很多部门的口径并不一致，有些是前台交易部门，有些是后端物流部门，他们一个用词是“类目”，一个用词是“行业”。两边的内容又不完全严丝合缝，导致沟通起来很费劲，调整压测模型也费劲，带来大量的沟通成本。这也是全链路压测模型越来越偏，跟实际大促情况越来越大差距的原因。</li>
<li>无意义的卷现在太多了。压测的目标是看在整个链路下自己的系统在极限压力下的表现，但是压测数据报的水分太大或者过于保守，就是导致压测场景与实际场景失真太多，压测即使通过了，也失去了本来的意义，同时也带来了资源成本的大量消耗。</li>
<li>“一朝被蛇咬，十年怕井绳”是人之常情，但是不要因噎废食，不要极左极右跳来跳去，也不能为了保障稳定性无底线的透支硬件能力，到后来挣得钱都不够赔的，做事情的意义何在呢？</li>
<li>大促日常化我现在觉得是一个伪命题。无论在《新闻联播》和国家统计局怎么说，中国大陆广大老百姓现在就是消费降级，靠频繁的大促是不能挽救业绩和股票的，卖血不能救贫穷！把页面做的干净一点，减少狗皮膏药的数字，少点套路，价格实惠一点，其实根本不需要那么多大促，大促也就是大家一起抢抢券，一切恢复简单更加事半功倍。把大促日常化的时间和精力做其他的事儿更有价值。</li>
</ol>
<p><img data-src="/images/%E7%8B%97%E7%9A%AE%E8%86%8F%E8%8D%AF1.png" title="这种狗屁膏药的页面实在让人看了窒息"><br><img data-src="/images/%E7%8B%97%E7%9A%AE%E8%86%8F%E8%8D%AF.png" title="我想问这些活动的运营，你们给老板写汇报，页面上也是这么多数字么？"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>大促</tag>
        <tag>卷</tag>
      </tags>
  </entry>
  <entry>
    <title>Django前端输入变量通过内部脚本加工返回前端展示之八</title>
    <url>/2018/12/10/%E4%BB%8Echeckbox%E9%87%8C%E5%BE%97%E5%88%B0%E4%BC%A0%E5%85%A5%E5%80%BC/</url>
    <content><![CDATA[<h2 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h2><p>python：<code>3.6.5</code><br>Django：<code>2.1.1</code><br>Project：<code>Kubernetes</code>，文件夹路径就是<code>/django/Kubernetes/</code><br>App：<code>createyaml</code>，文件夹路径就是<code>/django/Kubernetes/createyaml</code><br>前文地址：<a href="https://rorschachchan.github.io/2018/12/04/Django%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E5%AF%86%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/">https://rorschachchan.github.io/2018/12/04/Django%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E5%AF%86%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/</a></p>
<h2 id="需求说明以及实现思路"><a href="#需求说明以及实现思路" class="headerlink" title="需求说明以及实现思路"></a>需求说明以及实现思路</h2><p>之前在Django实现了输入文本然后通过ajax传递参数到后端执行脚本并且返回结果的效果。这一次要实现的是“多选框选中对应的选项然后提示确认，最后给后台执行命令”。</p>
<p>多选框在实际的页面里很常见，这一次要实现的效果如图：<br><img data-src="/images/django31.gif" alt="akb48"></p>
<p>要想在django的<code>views.py</code>里获取到<code>checkbox</code>的选择项，如果用表单方法很简单，只要<code>request.POST.getlist</code>就好，我尝试去用ajax去获取，但是得到的data是空值。可能是我道行不够，不过从代码简洁的角度来说还是更推荐用django的方法。</p>
<p>为了用户体验友好，我们一般都会在页面提交的时候加上提示的对话框，让用户再三确认。这样就要把form表单和<code>confirm()</code>对话框一起用，<font color=red>但是有一个现象要注意</font>：如果把<code>&lt;form&gt;</code>标签写到<code>&lt;button type=&quot;submit&quot;&gt;</code>下面的话，<code>comfirm()</code>时点击了“取消”，<code>return false</code>是会生效的，即停留在本页，但是form表单是无法正常传递到目的地；如果把<code>&lt;form&gt;</code>标签写到<code>&lt;button type=&quot;submit&quot;&gt;</code>上面，现在表单可以正常传递了，但是“取消”功能又不生效了—即使点击取消依旧会跳转到表单的目标地。</p>
<p>这种现象产生的原因是：如果函数是包含在form的submit中的话，当点击按钮的时候，在弹出<code>confirm()</code>对话框之前，有很多的js需要执行的，而大家都知道在点击按钮的时候，表单会自动提交的；所以就没有等到用户点击“取消”按钮，form表单已经提交了，自然就不会管你有没有点击”取消”了。</p>
<p>解决方法：只要在按钮的<code>onclick()</code>事件的方法前面加一个<code>return</code>就ok了，这样肯定会先等返回结果在提交表单了，例如：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;请点击我！&quot;</span> onclick=<span class="string">&quot;return method()&quot;</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h2><p><code>ecs_list.html</code>的body部分:<br>	<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&quot;text-align:center;&quot;</span>&gt;</span>数据库里的ECS数据展示<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">function</span> <span class="title function_">ecs_deploy</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="language-javascript">                        &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">var</span> name=<span class="title function_">prompt</span>(<span class="string">&quot;请输入要执行的命令：1&gt;测试连通；2&gt;部署模块并启动；&quot;</span>,<span class="string">&quot;1&quot;</span>);	<span class="comment">//添加一个输入框</span></span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">var</span> userids = [];	<span class="comment">//配置一个空集</span></span></span><br><span class="line"><span class="language-javascript">                        $(<span class="string">&quot;input:checkbox[name = ecs]:checked&quot;</span>).<span class="title function_">each</span>(<span class="keyword">function</span>(<span class="params">i</span>)&#123;    <span class="comment">//使用循环遍历迭代的方式得到所有被选中的checkbox复选框</span></span></span><br><span class="line"><span class="language-javascript">                                <span class="variable language_">console</span>.<span class="title function_">log</span>($(<span class="variable language_">this</span>).<span class="title function_">val</span>());</span></span><br><span class="line"><span class="language-javascript">                                userids.<span class="title function_">push</span>( $(<span class="variable language_">this</span>).<span class="title function_">val</span>() ); <span class="comment">//当前被选中checkbox背后对应的值</span></span></span><br><span class="line"><span class="language-javascript">                                        &#125;)</span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">if</span>(<span class="title function_">confirm</span>(<span class="string">&quot;你确定要对&quot;</span>+userids+<span class="string">&quot;进行&quot;</span>+name+<span class="string">&quot;操作？&quot;</span>))		<span class="comment">//让用户再次确认</span></span></span><br><span class="line"><span class="language-javascript">                                &#123;</span></span><br><span class="line"><span class="language-javascript">                                location.<span class="property">href</span>=<span class="string">&quot;&#123;% url &quot;</span>run_command<span class="string">&quot; %&#125;&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">                                &#125;</span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">else</span></span></span><br><span class="line"><span class="language-javascript">                                &#123;</span></span><br><span class="line"><span class="language-javascript">                                <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//停留在本页，没有操作</span></span></span><br><span class="line"><span class="language-javascript">                                &#125;</span></span><br><span class="line"><span class="language-javascript">                        &#125;</span></span><br><span class="line"><span class="language-javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;left&quot;</span> <span class="attr">style</span>=<span class="string">&quot;float:left&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% url &quot;</span><span class="attr">create_ecs</span>&quot; %&#125;&quot;&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-default&quot;</span>&gt;</span>返回录入界面<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/k8s/run_command/&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;right&quot;</span> <span class="attr">style</span>=<span class="string">&quot;float:left&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-default&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;return ecs_deploy()&quot;</span> /&gt;</span>选择服务器<span class="tag">&lt;/<span class="name">button</span>&gt;</span>		//这里添加了return</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>序号<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>云服务器名称<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>云服务器ID<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>内网地址<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>外网地址<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>操作系统<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>网络类型<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>CPU<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>内存<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>外网带宽<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>备注<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">                        &#123;% for ecs in ecss %&#125;</span><br><span class="line">                        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&#123;&#123;ecs.name&#125;&#125;</span> <span class="attr">name</span>=<span class="string">&quot;ecs&quot;</span>/&gt;</span>&#123;&#123; ecs.id &#125;&#125; <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>&#123;&#123; ecs.name &#125;&#125; <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>&#123;&#123; ecs.ecsid &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>&#123;&#123; ecs.inIP &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>&#123;&#123; ecs.outIP &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>&#123;&#123; ecs.osname &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>&#123;&#123; ecs.networktype &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>&#123;&#123; ecs.CPU &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>&#123;&#123; ecs.memory &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>&#123;&#123; ecs.netwidth &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>&#123;&#123; ecs.remark &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                        &#123;% endfor %&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><code>views.py</code>相关部分如下:<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@csrf_exempt</span><br><span class="line">def <span class="title function_">run_command</span>(request):</span><br><span class="line">   <span class="keyword">if</span> request.<span class="property">method</span> == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">       id = request.<span class="property">POST</span>.<span class="title function_">getlist</span>(<span class="string">&quot;ecs&quot;</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="title class_">HttpResponse</span>(id)</span><br><span class="line">   <span class="attr">else</span>:</span><br><span class="line">       pass</span><br></pre></td></tr></table></figure></p>
<p><code>urls.py</code>相关部分如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path(<span class="string">r&#x27;run_command/&#x27;</span>,views.run_command),</span><br></pre></td></tr></table></figure></p>
<p>启动django后，在<code>ecs_list.html</code>页面如动图点击要操作的选项提交即可看到效果，再配上后台数据库查询+ansible的辅助，我们就可以完成一个运维平台的部署功能啦！</p>
<h2 id="点击页面直接选取"><a href="#点击页面直接选取" class="headerlink" title="点击页面直接选取"></a>点击页面直接选取</h2><p>上面说的是复选框选取，如果需要直接点击就能得到值的话，那么就要用<code>click</code>函数搭配<code>this</code>来实现该效果，举个例子：<br>	<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                $(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                          $(<span class="string">&quot;p&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;	<span class="comment">//触发一个点击的函数，点击标签范围是p</span></span></span><br><span class="line"><span class="language-javascript">                                     <span class="title function_">alert</span>($(<span class="variable language_">this</span>).<span class="title function_">html</span>());		<span class="comment">//this的用途就是获取当前的元素</span></span></span><br><span class="line"><span class="language-javascript">                                    &#125;);</span></span><br><span class="line"><span class="language-javascript">                        &#125;);</span></span><br><span class="line"><span class="language-javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是第一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是第二个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是第三个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>页面效果如图：<br><img data-src="/images/django32.gif" alt="akb48"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://stackoverflow.com/questions/4359238/how-do-i-get-multiple-values-from-checkboxes-in-django">https://stackoverflow.com/questions/4359238/how-do-i-get-multiple-values-from-checkboxes-in-django</a><br><a href="https://stackoverflow.com/questions/14460421/get-the-contents-of-a-table-row-with-a-button-click">https://stackoverflow.com/questions/14460421/get-the-contents-of-a-table-row-with-a-button-click</a><br><a href="https://blog.csdn.net/stpeace/article/details/50816128">https://blog.csdn.net/stpeace/article/details/50816128</a><br><a href="http://www.runoob.com/js/js-popup.html">http://www.runoob.com/js/js-popup.html</a><br><a href="https://blog.csdn.net/qq_36769100/article/details/79173476">https://blog.csdn.net/qq_36769100/article/details/79173476</a><br><a href="https://blog.csdn.net/qq_24018243/article/details/52316949">https://blog.csdn.net/qq_24018243/article/details/52316949</a><br><a href="https://bbs.csdn.net/topics/320062312">https://bbs.csdn.net/topics/320062312</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>checkbox</tag>
      </tags>
  </entry>
  <entry>
    <title>从limit和request来理解k8s的资源调配</title>
    <url>/2019/03/13/%E4%BB%8Elimit%E5%92%8Crequest%E6%9D%A5%E7%90%86%E8%A7%A3k8s%E7%9A%84%E8%B5%84%E6%BA%90%E8%B0%83%E9%85%8D/</url>
    <content><![CDATA[<h2 id="背景交代"><a href="#背景交代" class="headerlink" title="背景交代"></a>背景交代</h2><p>今天用阿里云的k8s做实验，在worker(2核4G)上执行这么一句话：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kubectl run chengx --image=registry.cn-hangzhou.aliyuncs.com/lechangetest/chentest:chengx --port=<span class="number">80</span> --replicas=<span class="number">5</span> --limits=<span class="string">&quot;cpu=200m,memory=512Mi&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>发现命令执行之后，只剩成了4个pod，一个卡在Pending的状态，如图：<br><img data-src="/images/k8s26.png" alt="akb48"></p>
<p>使用<code>kubectl describe pod/chengx-5bb8bcb9c9-tlgz4</code>查看为什么会失败，看到理由是<code>0/4 nodes are available: 1 Insufficient memory, 3 node(s) had taints that the pod didn&#39;t tolerate.</code>，如图：<br><img data-src="/images/k8s27.png" alt="akb48"></p>
<p>错误直译过来就是“4个node里已经没有可用的，现在内存爆缸了，其中三个node都因为有污点同时这个pid无法容忍这个污点”。</p>
<h2 id="limit和request的不同"><a href="#limit和request的不同" class="headerlink" title="limit和request的不同"></a>limit和request的不同</h2><p>我上面的命令里面用到了limit，所以先研究一下limit和request这俩参数，先说request:<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">容器使用的最小资源需求, 作为容器调度时资源分配的判断依赖。</span><br><span class="line">只有当前节点上可分配的资源量 &gt;= request 时才允许将容器调度到该节点。</span><br><span class="line">request参数不限制容器的最大可使用资源</span><br></pre></td></tr></table></figure></p>
<p>再说limit:<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">容器能使用资源的最大值</span><br><span class="line">设置为<span class="number">0</span>表示对使用的资源不做限制, 可无限的使用</span><br></pre></td></tr></table></figure></p>
<p>request和limit的关系:<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">request能保证pod有足够的资源来运行, 而limit则是防止某个pod无限制的使用资源, 导致其他pod崩溃. 两者的关系必须满足:</span><br><span class="line"><span class="number">0</span> &lt;= request &lt;= limit &lt;= Infinity </span><br><span class="line">复制代码如果limit=<span class="number">0</span>表示不对资源进行限制, 这时可以小于request。</span><br><span class="line">目前CPU支持设置request和limit，memory只支持设置request， limit必须强制等于request， 这样确保容器不会因为内存的使用量超过request但是没有超过limit的情况下被意外kill掉。</span><br></pre></td></tr></table></figure></p>
<p>举个例子，在一个2核4G的node里，运行一个<code>(CPU Requst,CPU Limit,Memory Requst, Memory Limit)= (1U, 1U, 2G,2G)</code>的POD是完全OK的，这个POD不一定一定要用满2G，它可以用到0.1G或者1.99G,只要是内存在2G以内，这个POD都是不受影响的。</p>
<p>如果这个时候，又来了一个POD，他的资源参数为<code>(CPU Requst,CPU Limit,Memory Requst, Memory Limit)= (1U, 1U, 1G,2G)</code>，那么这个POD2的内存在2G以内的情况下，POD1和POD2都是OK的。如果POD2的超过了2G，那么POD2会挂掉，而POD1安全无事。</p>
<p><font color=red>若namespace里事前设定了CPU和内存的request和limit，那么在生成pod的时候，若无特殊说明，pod的request和limit值与所处的namespace相同。如果pod说明了request没说明limit，那么pod的limit等于声明的request。如果pod说明了request没有说明limit，那么limit值等于namespace默认的limit。</font></p>
<p>注意！namespace的limit值是可以比实际pod的limit值小的，如图：<br><img data-src="/images/k8s28.png" alt="akb48"></p>
<p>可见这个叫<code>default-mem-example</code>的namespace默认的request是256Mi，limit是512Mi，而我是可以在这个namespace里创建一个request是1G的pod，如图：<br><img data-src="/images/k8s29.png" alt="akb48"></p>
<p>额外补充一下，k8s里的计量单位：1Mi&#x3D;1024x1024，1M&#x3D;1000x1000，其它单位类推，如Ki&#x2F;K、Gi&#x2F;G。</p>
<h2 id="重新说回来"><a href="#重新说回来" class="headerlink" title="重新说回来"></a>重新说回来</h2><p>再次说回<code>0/4 nodes are available: 1 Insufficient memory, 3 node(s) had taints that the pod didn&#39;t tolerate.</code>，从这句话里我们看到虽然这个k8s集群有4个node（3个master+1worker)，使用<code>kubectl describe node master节点名称</code>来查看master上是否存在默认的taint:<br><img data-src="/images/k8s30.png" alt="akb48"></p>
<p>再看一下worker节点的taint:<br><img data-src="/images/k8s31.png" alt="akb48"></p>
<p>在master上默认是<code>不会将Pod调度到具有该污点的Node上</code>，也就是说所有pod都是在worker这个节点上的。worker上只有4G，而我生成了5个limit&#x3D;512Mi的pod，需要2.5G的内存空间。然而worker这个pod现在有多少可用的内存呢？<code>kubectl describe node worker名称</code>可见剩余的memory已经不足，如图:<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Allocated resources:</span><br><span class="line">  (Total limits may be over <span class="number">100</span> percent, i.e., overcommitted.)</span><br><span class="line">  Resource  Requests      Limits</span><br><span class="line">  --------  --------      ------</span><br><span class="line">  cpu       200m (<span class="number">10</span>%)    <span class="number">0</span> (<span class="number">0</span>%)</span><br><span class="line">  memory    1736Mi (<span class="number">62</span>%)  2248Mi (<span class="number">80</span>%)</span><br><span class="line">Events:     &lt;none&gt;</span><br></pre></td></tr></table></figure></p>
<p>现在剩余的内存值仅有20%，所以由于内存不够而生成失败，需要在<code>kubectl run</code>里适当调小内存的limit值，或者干脆扩容一个worker，让它在另一个worker里出现。</p>
<p>如果想要查看某个pod是具体落在哪个node里，使用命令：<code>kubectl get pods -o wide</code>即可。</p>
<h2 id="关于Docker的资源调配"><a href="#关于Docker的资源调配" class="headerlink" title="关于Docker的资源调配"></a>关于Docker的资源调配</h2><p>docker默认情况对cpu和内存都是无限制的，如果cpu跑爆了，那么容器也不会死掉，而是慢慢的跑。但是如果内存跑爆了，容器会被oom，不过可以通过设置oom的值让容器被干掉的几率低一点。</p>
<p>如果在一个四核的服务器里通过<code>docker run -it --rm --cpus=2 镜像:latest /bin/bash</code>启动了一个容器，那么这个进程跑到200%就到顶了，而且这200%是平均分配到4个核上，每个核50%，而不是把1和2核跑100%，剩下3和4是空着的。</p>
<p>如果想要把某一个CPU跑满，命令是<code>docker run -it --rm --cpuset-cpus=&quot;1，3&quot; 镜像名:latest /bin/bash</code>，这样的话就会只在第一个和第三个CPU上跑，而不会动用其他的CPU。</p>
<p>前面说的是CPU，现在说内存。如果是想要限制某个docker的内存最大是300M:<code>docker run -it -m 300M --memory-swap -1 --name con1 镜像名 /bin/bash</code>，设置 memory-swap 值为 -1，它表示容器程序使用内存的受限，而可以使用的 swap 空间使用不受限制(宿主机有多少 swap 容器就可以使用多少)。</p>
<p>如果这个容器大于300M了，那它就直接被OOM kill了。如果有足够的 swap，程序至少还可以正常的运行。当然，我们也可以通过<code>--oom-kill-disable</code>选项强行阻止<code>OOM kill</code>的发生。限制内存上限虽然能保护主机，但是也可能会伤害到容器里的服务：如果为服务设置的内存上限太小，会导致服务还在正常工作的时候就被 OOM 杀死；如果设置的过大，会因为调度器算法浪费内存。所以内存压力测试是不可避免的，而且也尽量不要使用swap，因为swap的使用会导致内存计算复杂，对调度器非常不友好。<br><img data-src="/images/%E5%A5%B3%E5%AD%90%E5%AF%B9%E6%89%93.gif" alt="akb48"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.qikqiak.com/post/understand-kubernetes-affinity/">https://www.qikqiak.com/post/understand-kubernetes-affinity/</a><br><a href="https://blog.frognew.com/2018/05/taint-and-toleration.html">https://blog.frognew.com/2018/05/taint-and-toleration.html</a><br><a href="https://jimmysong.io/kubernetes-handbook/concepts/taint-and-toleration.html">https://jimmysong.io/kubernetes-handbook/concepts/taint-and-toleration.html</a><br><a href="https://stackoverflow.com/questions/53192999/pod-dont-run-insufficient-resources">https://stackoverflow.com/questions/53192999/pod-dont-run-insufficient-resources</a><br><a href="http://dockone.io/article/2509">http://dockone.io/article/2509</a><br><a href="https://www.yangcs.net/posts/understanding-resource-limits-in-kubernetes-cpu-time/">https://www.yangcs.net/posts/understanding-resource-limits-in-kubernetes-cpu-time/</a><br><a href="http://blog.whysdomain.com/blog/171/">http://blog.whysdomain.com/blog/171/</a><br><a href="https://www.cnblogs.com/sparkdev/p/8052522.html">https://www.cnblogs.com/sparkdev/p/8052522.html</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>云原生</tag>
      </tags>
  </entry>
  <entry>
    <title>从excel的大单元格里快速提取内容</title>
    <url>/2018/02/01/%E4%BB%8Eexcel%E7%9A%84%E5%A4%A7%E5%8D%95%E5%85%83%E6%A0%BC%E9%87%8C%E5%BF%AB%E9%80%9F%E6%8F%90%E5%8F%96%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<p>我公司的服务器信息会保存在一份高加密的excel里，由于历史遗留问题，里面的格式节选一部分出来是这样的：<br><img data-src="/images/excel1.png" alt="抱光妹"></p>
<p>注意看，ip地址不分内网外网是放在一个大的单元格里，中间是用空格隔开的，造成了这样的视觉效果。</p>
<p>现在公司需要把所有的服务器重新更换到新的zookeeper，那么使用ansible在批量处理的时候，就需要提取这些服务器的内网ip地址录入到<code>/etc/hosts</code>文件里，但是由于服务器实在太多不可能一个一个手动从excel的单元格挑选出“内网IP地址”复制粘贴，那么就需要进行一下批量挑选内网IP地址的操作。</p>
<p>首先我们先把整个IP的单元列里的”（公）””（内）”的字样去掉，然后把整列全部拷贝，粘贴到<code>notepad</code>里，看到它们变成了这样的样子：<br><img data-src="/images/excel2.png" alt="抱光妹"></p>
<p>在<code>notepad</code>里，双引号之间的内容会被认为同一行，所以这里我们需要使用“替换”功能把所有的双引号去掉，让它变成下面这样：<br><img data-src="/images/excel3.png" alt="抱光妹"></p>
<p>这样就可以把上面的内容复制到一个新的excel去，发现每一个内容对应了一行，即一个小单元格：<br><img data-src="/images/excel4.png" alt="抱光妹"></p>
<p>然后我们把第一行染成黄色，第二行染成绿色，当然颜色你可以选择自己的口味，然后使用excel的“格式刷”功能，一拉到底，让他们变成条纹状：<br><img data-src="/images/excel5.png" alt="抱光妹"></p>
<p>然后在excel里找到“筛选”功能，先选择住这一条纹块，然后选择“按颜色筛选“，由于我们需要内网IP，那么我们就留下绿色内容即可，如图：<br><img data-src="/images/excel6.png" alt="抱光妹"></p>
<p>得到效果如下：<br><img data-src="/images/excel7.png" alt="抱光妹"></p>
<p>这样就可以把整个内容拷贝进ansible的hosts文件里，然后搭配ansible批处理这些内网IP，双管齐下，大大的提升了提取数据的效率。</p>
<p>如果遇到偶尔三行（即中间有空格行）的情况，那么就在notepad那一步的时候，把空格行干掉，不如下图的情况里，第五行和第八行是空格行，可能是当初记录人员复制的时候自带了空格：<br><img data-src="/images/excel8.png" alt="抱光妹"></p>
<p>如果是空格很多的情况，那么就需要批处理一次性的把所有空格都干掉。干掉的方法，还是使用notepad的“替换功能”，选择“正则表达式”，然后把<code>\n[\s|]*\r</code>替换成空值就可以了。<br><img data-src="/images/excel9.png" alt="抱光妹"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>ansible</tag>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title>从“No space left on device”到删除海量文件</title>
    <url>/2018/01/16/%E4%BB%8E%E2%80%9CNo-space-left-on-device%E2%80%9D%E5%88%B0%E5%88%A0%E9%99%A4%E6%B5%B7%E9%87%8F%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>开发发现某个云服务器无法启动进程，提示“No space left on device”，但是使用<code>df -h</code>查看容量的时候，明明还有很多的空间。于是使用<code>df -i</code>，发现inode节点已经全部用光了，所以现在不能建立任何新的文件。如图：<br><img data-src="/images/df1.png" alt="办公室"></p>
<p>既然如此就要查出来是哪个文件夹里会有如此多的文件来占用这些inode,使用一个小脚本：<code>for i in /*; do echo $i; find $i | wc -l; done</code>，获取到&#x2F;mnt下有一个文件占用了绝大多数的inode，如图：<br><img data-src="/images/df2.png" alt="办公室"></p>
<p>于是就进入到mnt这个文件夹里，慢慢找寻到底是哪个文件夹，用上面那个语句一点一点缩小范围，最后确定文件夹原来就是data文件夹，如图：<br><img data-src="/images/df3.png" alt="办公室"></p>
<p>现在如果要<code>rm -rf data/*</code>的话，是没有效果的，有效果的话也很慢。而且很有可能报<code>-bash: /bin/rm: Argument list too long</code>的错，因为这个文件夹里面的小文件实在太多了，有足足两百五十多万个，那么怎么样处理这样的情况？</p>
<p>用find搭配<code>-type f -exec rm {} \;</code>可能会引起内存溢出，用文件夹重置命令搭配<code>--reference</code>也没什么效果。</p>
<p>这时最好的方法就是使用<code>rsync</code>!</p>
<p>先<code>yum install rsync</code>，当然了现在inode是饱和的状态，<code>yum install</code>是会报错的：<br><img data-src="/images/df4.png" alt="办公室"></p>
<p>那么就需要手动删除一些文件，腾出来一部分inode供yum使用，安装完毕rsync之后，找到一个空文件夹，如果没有空文件夹，就手动建立一个。 </p>
<p>使用命令：<code>rsync --delete-before -a -H -v --progress --stats /空文件夹的路径/ /海量小文件的路径/</code></p>
<p>说一下上面几个参数的意思：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">–<span class="keyword">delete</span>-before 接收者在传输之前进行删除操作</span><br><span class="line">–progress 在传输时显示传输过程</span><br><span class="line">-a 归档模式，表示以递归方式传输文件，并保持所有文件属性</span><br><span class="line">-H 保持硬连接的文件</span><br><span class="line">-v 详细输出模式</span><br><span class="line">-stats 给出某些文件的传输状态</span><br></pre></td></tr></table></figure></p>
<p>如果你开了这个服务器的两个窗口，一个是执行上面的命令，另一个是在海量文件夹里执行<code>ls</code>，这个时候ls命令是卡死的，过了大约2分钟，就会看到<code>ls</code>展示的文件喷涌而出，整个电脑屏幕好比黑客帝国一样，异常壮观。</p>
<p>静等大约20分钟，整个文件夹删除干净，inode也释放了97%，世界恢复了清静。<br><img data-src="/images/df5.png" alt="办公室"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>从vmstat命令里看服务器瓶颈</title>
    <url>/2018/01/03/%E4%BB%8Evmstat%E5%91%BD%E4%BB%A4%E9%87%8C%E7%9C%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%93%B6%E9%A2%88/</url>
    <content><![CDATA[<p>这几天重新翻看基础知识，看到了<code>vmstat</code>，我认为它是一个非常优秀的命令,因为它包括了<code>top</code>和<code>free</code>，甚至还包含了一些io的信息，可以说是运维人员常备命令之一。常用方法：<code>vmstat (-a) 多少秒刷一次 刷多少次</code>。</p>
<p><img data-src="/images/vmstat.png" alt="vmstat" title="vmstat的效果"></p>
<p>对上面这个图来一个简单的解释：</p>
<p>r: 运行队列中进程数量，这个值长期大于1就要判断是否需要增加CPU。<br>b: 等待IO的进程数量</p>
<p>swpd: 使用虚拟内存大小(如果swpd的值不为0，但是SI，SO的值长期为0，这种情况不会影响系统性能）<br>free: 空闲物理内存大小<br>buff: 用作缓冲的内存大小<br>cache: 用作缓存的内存大小(如果cache的值大的时候，说明cache处的文件数多，如果频繁访问到的文件都能被cache处，那么磁盘的读IO bi会非常小)<br>inact: 非活跃内存大小（当使用-a选项时显示）<br>active: 活跃的内存大小（当使用-a选项时显示）</p>
<p>si: 每秒从交换区写到内存的大小，由磁盘调入内存<br>so: 每秒写入交换区的内存大小，由内存调入磁盘<br>注意：内存够用的时候，这2个值都是0，如果这2个值长期大于0时，系统性能会受到影响，磁盘IO和CPU资源都会被消耗。有些朋友看到空闲内存（free）很少的或接近于0时，就认为内存不够用了，不能光看这一点，还要结合si和so，如果free很少，但是si和so也很少（大多时候是0），那么不用担心，系统性能这时不会受到影响的。</p>
<p>bi: 每秒读取的块数<br>bo: 每秒写入的块数<br>注意：随机磁盘读写的时候，这2个值越大（如超出1024k)，能看到CPU在IO等待的值也会越大。</p>
<p>in: 每秒中断数，包括时钟中断。<br>cs: 每秒上下文切换数。<br>注意：上面2个值越大，会看到由内核消耗的CPU时间会越大。</p>
<p>us: 用户进程执行时间百分比(user time)<br>注意： us的值比较高时，说明用户进程消耗的CPU时间多，但是如果长期超50%的使用，那么我们就该考虑优化程序算法或者进行加速。</p>
<p>sy: 内核系统进程执行时间百分比(system time)<br>注意：sy的值高时，说明系统内核消耗的CPU资源多，这并不是良性表现，我们应该检查原因。</p>
<p>wa: IO等待时间百分比<br>注意：wa的值高时，说明IO等待比较严重，这可能由于磁盘大量作随机访问造成，也有可能磁盘出现瓶颈（块操作）。</p>
<p>id: 空闲时间百分比</p>
<p>最后总结：如果r经常大于4 ，且id经常少于40，表示cpu的负荷很重。如果bi，bo长期不等于0，表示内存不足。</p>
<p>r（运行队列）展示了正在执行和等待CPU资源的任务个数。当这个值超过了CPU数目，就会出现CPU瓶颈了。 CPU 100%并不能说明什么，Linux总是试图要CPU尽可能的繁忙，使得任务的吞吐量最大化。唯一能够确定CPU瓶颈的还是r（运行队列）的值。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>从最近的裁员联想到的</title>
    <url>/2022/07/01/%E4%BB%8E%E6%9C%80%E8%BF%91%E7%9A%84%E8%A3%81%E5%91%98%E8%81%94%E6%83%B3%E5%88%B0%E7%9A%84/</url>
    <content><![CDATA[<p>赵本山有一个很有名的表情包，就是“你是影响大环境的人啊？”，当然这句话的背景是在乡村爱情里，田娃来找赵本山哭诉，然后赵本山说的一句台词，但是被不少人拿来还挺当回事的解读。<br><img data-src="/images/%E7%A0%B4%E5%9D%8F%E5%A4%A7%E7%8E%AF%E5%A2%83.jpeg"></p>
<p>台词是有固定的背景的，所以不能把台词里的话奉若神明，不分环境不分场合的使用。原因很简单，因为大环境现在真的不好了。</p>
<p>不论是教育、物流、外企、电商、房地产都在这个被赵立坚说“已经取得了抗击新冠肺炎疫情的战略性胜利”之后不到一年的2022年达到了低谷，而且低的目前看不到头。政府机关单位开始降薪，民企开始裁员，据说甚至有裁出人命的，搞得公关部天天忙得不可开交。</p>
<p>但是那些“被毕业”的人真的是“破坏大环境”的人么？肯定不是，在中国，能破坏大环境的人，一只手都能数得过来。</p>
<p>很讽刺的是，赵本山他自己现在也是被大环境打击的那类人，而且说实话，我到现在都无法理解本山传媒—一个靠着“剧场演出、旗下艺人春晚曝光后跟影视公司签约抽成、卖电视台连续剧”的公司是怎么能买得起私人飞机的。但是事实早在2009年赵本山就买了一个，而且据说他通过本山号接送人也交了不少商界朋友，不过据说他也真的快养不起这个本山号了。所以说赵本山的成功的确个人影响力过硬而且沾了那个时代的光，他的成功路是可以被复制的，开心麻花就可以复制，吴京使使劲也能复制。</p>
<p>话说回来，最近这波裁员潮挺狠，打开脉脉、BOSS、天眼查等等APP都是这样的负面新闻，再配上那些唯恐天下不乱的自媒体号的夸张笔法，让人觉得很是压抑，目前的国际形势国内形势也让人看不到什么希望。靠互联网起家的杭州，随着互联网泡沫的消沉，一连串的产业都受到了影响。一直有“青天大老爷”情节的国人还散布信息说“政府会出面的，会让裁员停止的”，但是目前看“出面”是完全没有的事儿。</p>
<p>这次裁员之后，估计杭州人口的增长速度会有一个缓坡，反正现在二手房的交易已经是缓坡了。</p>
<p>前几天我看了一个网络直播交流，说“这次大厂优化出来的高P高T们怎么活？”（ <a href="https://twitter.com/gxgexiao/status/1535480692485681152">https://twitter.com/gxgexiao/status/1535480692485681152</a> ） ，那个交流其实也没什么好交流的，最后几个嘉宾也得出来了一个废话结论：“很多人误把平台的牛逼当成了自己的牛逼”。其实这个交流里很多前提都没有说清楚，比如“P几算高P？”，“做管理的高P怎么办？做技术的高P怎么办？”，“技术里面不带团队做单人贡献者的高P怎么办？”等等情况都没有过深的分析。当然在大厂里带不到10个人的小领导跟那种三四年晋升不了的人一样，都是一个尴尬的存在。一旦没有了利用价值，高层就会判断本身高薪的你“现在打不出粮”+“未来几年也打不出粮”，就会被无情的通知离开。</p>
<p>离开的人，已成定局。哪怕走的人是我不喜欢的人，我也千万不可以兔死狐悲。那么问题来了，目前尚在岸上的我在未来如何保证不被离开？</p>
<p>我的P10领导曾经说过“我理解的碌碌无为，就是每天忙忙碌碌，但是自己冷静下来一看，没有任何的提高和收获，这样的日子是很危险的”。这就指明了方向—不但完成自己的OKR，还要完成的漂亮。这一年哪怕卷也要卷把自己的OKR卷出来，让领导认可你的工作成绩，知道你是他需要的人，同时也要表现出来你在这个事情上很专业，这样可以暂时保一年的安全。</p>
<p>同时也要拓宽视野，不要只执着于技术，也要注重于业务和反思。不能赚钱、不能推广的技术就像“接化发”一样，除了自己开心之外，就是扯淡。</p>
<p>不过说实话，做技术的人应该反思一下，我们投入了那么多的人力去做AI、做VR、做机器学习，真正能用于商业的有几个产品呢？从阿尔法狗到现在，在中国的互联网大厂里，有一个算一个，那些算法、引擎、机器学习的部门哪些是盈利的？感觉除了马路上摄像头的人脸识别，其他的产品基本还都是PPT，包括那个无人驾驶。</p>
<p>尹烨在圆桌派里说过，有些技术一旦落后了后期想弯道超车很难。但是现在各公司都现实了，大锅饭的时代过去了，不挣钱的部门在领导面前就是人心惶惶。虽然这些技术在将来都会有用武之地，但是目前更多的场合都是无法落地的，所以这些算法部门，AI部门都会在退潮的情况下成为“裸泳”的存在，被放大审视。</p>
<p>潮水褪去了，政治家、资本家难免都要“急功近利”，这是几千年滚烂了的规律，不能影响大环境的底层工人只能接受，没办法的。</p>
<p>第二个问题，假如真的被动离开了，应该何去何从？</p>
<p>年纪也不小的人，比如我（而且我今年也“年纪倒挂”了，主管年纪比我小，按理说这已经是一个警钟了），那么一些该考的证应该提上日程了，该学的技能也要抽时间搞定了。离开了现在的公司还想在劳动密集型的职位里讨生活肯定是自讨没趣，管理的书该看也要看起来了，带团队始终是未来中年人在民企的道路，毕竟届时还有你的小兵为你当一层肉垫。</p>
<p>同时也可以涉猎一下产品技术、项目技术PMP等等，转型做指挥者也是一个不错的选择。</p>
<p>《大明王朝1566》也有一个很有名的台词，就是大太监吕芳说“人要三思–思危思退思变”，当然这三思中的“思退”更多的对领导而言的，普通人已经没什么可退的了，韭菜们能做的就是思危和思变。在好的时代里，还是要尽可能多的捞钱。在坏的时代里，苟且一下，保住自己和家庭的正常运转。<br><img data-src="/images/%E6%80%9D%E5%8D%B1%E6%80%9D%E9%80%80%E6%80%9D%E5%8F%98.jpeg"></p>
<p>当然，还是希望在这一年里，先做好第一点，第二个问题希望永远不要发生。</p>
<p>还是长者说得对啊，“命运自己就不可以预料。一个人的命运啊，当然要靠自我奋斗，但是也要考虑到历史的进程”。在这样的一个市场信心明显不足的年代，作为底层韭菜，发现了危险就要尽快找到了自己的未来，同时关心自己的利益，理财减少冲动且无效消费，保证自己工作稳定性，同时尽量丰富自己，渡过惨淡的2022或许能迎来一个转机。</p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>思考</tag>
        <tag>裁员</tag>
        <tag>经济</tag>
      </tags>
  </entry>
  <entry>
    <title>从杜琪峰的访谈说说香港电影</title>
    <url>/2024/11/05/%E4%BB%8E%E6%9D%9C%E7%90%AA%E5%B3%B0%E7%9A%84%E8%AE%BF%E8%B0%88%E8%AF%B4%E8%AF%B4%E9%A6%99%E6%B8%AF%E7%94%B5%E5%BD%B1/</url>
    <content><![CDATA[<h2 id="大势，与不粘锅"><a href="#大势，与不粘锅" class="headerlink" title="大势，与不粘锅"></a>大势，与不粘锅</h2><p>上周六，BBC中文放出来一段长达51分钟的杜琪峰专访。杜大导演虽然近70的年纪，在镜头面前依旧言语犀利，直言“如今的香港没有灵魂”、“政府对人民没有信心”等等惊人之语。果不其然，学啥都不行但是偏偏喜欢学朝鲜的《大公报》迫不及待的跳出来批判了他一顿，说“杜琪峰既然你能接受bbc的采访就已经是言论自由了”。《大公报》的文章转载到微博上，4个图挂了3个。</p>
<p>杜琪峰先生未来的境遇如何，我不清楚，反正他现在电影是带拍不拍好几年了。而且他这个论点从2019年之后也不是第一次说了，其实去年釜山电影节周润发在接受采访的时候也说过一下类似的感受。<br><img data-src="/images/%E6%9D%9C%E7%90%AA%E5%B3%B01.webp" title="枪火和黑社会养活不少的讲电影自媒体，杜sir应该找他们要钱"></p>
<p>不过香港电影是否还有希望复兴呢？我倒是想从我个人的角度分析一下。</p>
<p>首先我先说“复兴”的定义是什么？个人觉得“复兴”指的是香港电影的制作市场能重返90～93年的从业人口数，同时不仅香港本地市场票房飘红而且能在国际也有高的票房收入。这样既有质量高的电影，大家又都有钱赚才是真复兴，只有金字塔尖的人吃的饱，那叫个屁复兴。</p>
<p>说明了定义，再说我个人的结论：香港电影不会死，但是也肯定好不到哪里去，未来大概率是“整体行业不死不活，偶有佳作”，跟内地电影一样。<br><img data-src="/images/%E6%9D%9C%E7%90%AA%E5%B3%B04.webp" title="暗花其实就是杜琪峰拍的，梁朝伟跟他合作的最后一部电影"></p>
<p>以前欧洲、东南亚尤其台湾是香港电影真金白银的付费市场，最重要的是这些人作为客户不挑题材，香港拍什么他们要什么。下到三级上到文艺，从武打到搞笑，照单全收。王晶自己回忆起来都说“那段时间，赶工很夸张，很多电影都没有剧本，立项的时候除了主演和电影名，其他的啥都不知道”。正是因为有这样不挑的金主，香港电影上了风口，让香港和宝莱坞都成为了能与好莱坞齐名的电影工厂，成龙也说过“当时的电影赚钱甚至黑道都要参合一脚”。就连当时还没确立自己风格的杜琪峰自己在90～94这5年，导演了12部作品监制3部，可见当时影片市场需求之大。</p>
<p>当然香港也清楚自己金主爸爸的喜好，所以他们以前的很多电影里也夹杂有批评大陆的成分以满足台湾和欧洲市场。比如周润发的《赌神2》，一直到现在在大陆都是禁片。</p>
<p>但是随着后来台湾金主的萎靡、金融危机以及97香港回归，香港不得不面临金主从台湾转移到大陆的情况。但是大陆在2004年之前把香港电影是当外国电影看待的，无论引入量还是拍片都跟大陆电影有区别。2004年香港大陆打开了CEPA，表面上对电影放开了很多制作的限制，同时也可以30%的票房收入归香港方（原来是15%左右，但是制作上相比较严格）。但是这个CEPA明眼人都知道对香港电影最大的功劳就是“底下小公司纷纷死光，但是总体又死不透，金字塔尖的依旧还能吃”。<br><img data-src="/images/%E9%A6%99%E6%B8%AF%E7%94%B5%E5%BD%B1.jpg" title="香港贺岁档票房创下新低"></p>
<p>之前香港的电影有自己的审查制度，那个制度相对来说比较宽，主要是根据色情、社会议题和血腥来分级的，后来不晓得什么时候，大约是06年，国内的日本动画从各地区电视台断崖消失，香港的僵尸片、泡妞片、赌博片、监狱片也一下子被打的见不得光。香港片又要专门为大陆拍一个单独的结局，或者删掉某个片段。像03年的《大只佬》等知名的例子不说，《十月围城》里，反派胡军的手下建议“暗杀不了孙中山我们可以杀孙母”，被胡军骂了一顿，说“我们是兵不是匪”。原本这个台词是体现胡军这个角色的原则性，但是在大陆版这个片段被删除掉了。</p>
<p>除了题材一下子被打扁，香港电影还是延续90年代的“请大陆成名影星参演，来扩大大陆市场”的方法。记得CEPA签了不久，备受期待的《无间道3》开拍，拍完后当时骂声一片。陈道明更是用“我觉得我就是狗皮膏药”、“我的出现可能是大陆市场的标签”来表示对自己被强塞进来的不满。</p>
<p>那个时候其实不止陈道明，很多大陆明星都表示了对香港电影的水土不服。不过香港那时候还能靠twins、陈冠希等英皇明星来撑场，再加上后来的周杰伦（《头文字D》）延续自己的寿命，那段时间CEPA初期试水，对香港电影其实没啥实质帮助。到了08年，年度港产电影52部，09年更惨仅有49部，2010年54部，可以说一年比一年烂。</p>
<p>香港电影开始正式进入“小公司饿死，家大业大的能掏得出明星出场费的还算温饱”的时代。</p>
<p>小公司为啥会死光？最重要的是不适应大陆的文化审核制度，那些喜欢拍边缘人的、同性恋的、LGBT的、记录疫情的、记录2019的就可以靠边站了。而且没有审查不能拿到国外参展和售卖，所以香港必须只能靠拍出来大陆肯定会买的片子才能活下去，不然一切就是在烧投资人的钱。</p>
<p>08年是一个坎儿，不少的香港导演看清了大势，开始求变，主动北上去纳投名状。投名状纳的好的香港导演就能拿到了不少主旋律的影片执镜资格，比如林超贤先生拿到了《红海行动》。活生生的把这个片拍成了另一个《变形金刚》，2个多小时下来文戏不超过20分钟，看完后一句台词没记住，就记得林超贤先生把所有撞一起能发声响的东西都撞了一遍，在春节档这么特殊的档期拿了30多亿，美滋滋。</p>
<p>这里面也有拍马屁拍的不成功的，比如邱礼涛导演的《竞雄女侠 秋瑾》，原本以为可以给辛亥革命100周年献礼，结果被秋瑾的后人直接告到总理和外交部长去了，我是第一次知道原来外交部还可以管这个事儿，整个拍摄的过程其实更应该被拍成电影。</p>
<p>现在回头看《红海行动》、《湄公河行动》、《蛟龙行动》等等就是更大成本的流水线现代武侠片，整个流程就跟香港曾经的动作片流程一样：恶人出场作恶打破太平生活–》身手不凡正面人物出场–》经过小挫折、某某牺牲–》一场大决战、收工回家。说它是现在武侠片也是抬举它了，没啥侠气。</p>
<p>当然林超贤先生自己也是被逼无奈，他当初拍《湄公河行动》的时候，据说剧本被N多部门改了M回，这个涉及侦查细节不可以拍、那个涉及犯罪细节不能拍。改的他自己都受不了了，后来就只能在血腥上加点猛料，来刺激观众眼球。没办法一切都是为了过审而且赚回票房，毕竟手下人也要吃饭供房供车。<br><img data-src="/images/%E9%A6%99%E6%B8%AF%E7%94%B5%E5%BD%B1.png" title="没有好看的题材是网民认为最大的问题"></p>
<p>不少香港导演摸清了在大陆拍商业片的剧本套路，那就是“家国情怀+功夫特技”，或者“廉政公署整治腐败”再或者就是“在英国人统治下当二等公民的悲惨过往”，或者随机两两组合，不靠剧本细节而是纯靠特技或者情怀来卖票，反正这么玩电影质量不知道，但是绝对能签出去，再搭配上主流报纸媒体就盯着金字塔尖的成绩开始宣传这一切是“多么多么的好，多么多么的炸裂”，一年又一年的过，观众们各个看成傻子还不自知。</p>
<p>香港电影衰败至今，有诸多的原因，有人才原因有经济原因，而文化审查肯定是一个因素之一。因为很多优秀的电影开拍的时候就是没有剧本的，只有一个大纲，然后不断的丰富和打磨人物，让剧情真实且有深度进而成为了影坛经典。现在没有剧本大纲就想天马行空的拍，已经是不可能的了。曾经几万人就业的香港电影市场据说只剩下了几千人，当年人满为患的摄影棚如今空空如也，院线把快30年的老片拿出来重映再收割一波情怀韭菜。</p>
<p>2010年后香港的流行音乐和流行文化也进入了低谷期，香港品牌开始衰败、香港明星开始青黄不接,tvb已连续6年亏损。早于2019年，香港就已经不再是“机会满地的艺术中心”，以前香港是大家挤破头而来，大量非香港人能在这里创出一片天，比如马来西亚的杨紫琼、美国出生的吴彦祖、天津人林雪、哈尔滨人赵文卓、北京人刘洵先生、重庆人张晋。至于台湾人那就更多了：林青霞、舒淇、应采儿、林熙蕾、王祖贤、吴倩莲等等。现在的香港，我看委员们简直不要太多。</p>
<p>正如杜导演说的，现在的香港的确已经不再是当年的香港，原汁原味的香港故事已经是当地中老年人口中的传说。本身艺术家作品就是戴着脚镣跳舞的，现在又有短视频和电子游戏等同样杀时间的业余活动来挤压电影时间，面对没有新鲜血液进入这个曾繁荣的香港电影市场，面对好的港片大家且看且珍惜吧。</p>
<h2 id="2025年6月的补充"><a href="#2025年6月的补充" class="headerlink" title="2025年6月的补充"></a>2025年6月的补充</h2><p>3月份古天乐自曝香港电影行业到达最低谷，呼吁各影星自降片酬，可见香港的电影市场真的已经到了生死存亡的时刻。既然政策帮不了他们太多，或许他们真的需要去短视频上发力了。</p>
<iframe src="//player.bilibili.com/player.html?isOutside=true&aid=114228597886684&bvid=BV1dYoiYLEL7&cid=29077212658&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>

<p>随着《哪吒2》的票房大火，甚至屡屡延期下线，实现了“从穿棉裤看到穿短裤”。有香港网友评论：香港的《九龙城寨》、《破地狱》也有口碑，但是中国大陆从来没有支持一部香港电影像支持《哪吒》这样。这句话背后“后妈生的”的区别待遇真是让人隔着屏幕都能感受到。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>2009年香港电影总结：本土电影明星缺失 <a href="https://ent.sina.cn/film/2009-12-28/detail-iavxeafr7776042.d.html?from=wap">https://ent.sina.cn/film/2009-12-28/detail-iavxeafr7776042.d.html?from=wap</a><br>香港电影，我们再也回不去了 <a href="https://m.thepaper.cn/newsDetail_forward_14086808">https://m.thepaper.cn/newsDetail_forward_14086808</a><br>梁鹏飞漫谈回归20年香港电影变迁：融入内地共创华语电影辉煌 <a href="https://www.guancha.cn/LiangPengFei/2017_07_03_416175.shtml">https://www.guancha.cn/LiangPengFei/2017_07_03_416175.shtml</a><br>1995-2017：历年香港电影公司本土票房累计大PK <a href="https://www.douban.com/note/732087158/?_i=0877206mSYoyTt">https://www.douban.com/note/732087158/?_i=0877206mSYoyTt</a><br>香港电影是如何衰弱的？从殖民时代到合拍片的电影审查 <a href="https://www.youtube.com/watch?app=desktop&v=SYlA8JNgR2s">https://www.youtube.com/watch?app=desktop&amp;v=SYlA8JNgR2s</a><br>合拍片的困境 <a href="https://ent.sina.com.cn/m/2007-06-11/ba1591953.shtml">https://ent.sina.com.cn/m/2007-06-11/ba1591953.shtml</a><br>港片北上16年：香港影人奋进往事 <a href="https://mp.weixin.qq.com/s?__biz=MzIyODEzNjM4OQ==&mid=2652105739&idx=2&sn=65b0c83f0b8c61d9ef91785c93e034c1&chksm=f3b1c8a1c4c641b7d693bd1c9ef3b83d103a9f2b2b24f2787a8528b76b137511b47c4b347ef4&scene=27">https://mp.weixin.qq.com/s?__biz=MzIyODEzNjM4OQ==&amp;mid=2652105739&amp;idx=2&amp;sn=65b0c83f0b8c61d9ef91785c93e034c1&amp;chksm=f3b1c8a1c4c641b7d693bd1c9ef3b83d103a9f2b2b24f2787a8528b76b137511b47c4b347ef4&amp;scene=27</a><br>杜琪峰导演电影票房数据总汇 <a href="https://m.163.com/dy/article/H5IGE20T05527MBG.html?spss=adap_pc">https://m.163.com/dy/article/H5IGE20T05527MBG.html?spss=adap_pc</a><br>港片已死？票房惨淡倒退12年！ <a href="https://news.qq.com/rain/a/20240827A086RM00?web_channel=wap&openApp=false&suid=&media_id=">https://news.qq.com/rain/a/20240827A086RM00?web_channel=wap&amp;openApp=false&amp;suid=&amp;media_id=</a><br>無涯：杜琪峯的電影世界 <a href="https://www.bilibili.com/video/BV1tE411R7J9/?vd_source=5fc229d37e0f67862fcd1c8359f81da6">https://www.bilibili.com/video/BV1tE411R7J9/?vd_source=5fc229d37e0f67862fcd1c8359f81da6</a><br>古天乐表达了对香港电影前景的无限担忧 <a href="https://finance.sina.com.cn/stock/hyyj/2025-03-25/doc-ineqvvkw0025122.shtml">https://finance.sina.com.cn/stock/hyyj/2025-03-25/doc-ineqvvkw0025122.shtml</a></p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>电影</tag>
        <tag>文化</tag>
        <tag>香港</tag>
      </tags>
  </entry>
  <entry>
    <title>从中国女篮看中国体育</title>
    <url>/2025/07/22/%E4%BB%8E%E4%B8%AD%E5%9B%BD%E5%A5%B3%E7%AF%AE%E7%9C%8B%E4%B8%AD%E5%9B%BD%E4%BD%93%E8%82%B2/</url>
    <content><![CDATA[<h2 id="篮球选材的困境"><a href="#篮球选材的困境" class="headerlink" title="篮球选材的困境"></a>篮球选材的困境</h2><p>中国女篮在亚运会上被日本队淘汰，在8个队伍里最后拿到了第三。拿到铜牌后，赛前嘲讽日本主教练的宫鲁鸣赛后给自己打了一个及格分。</p>
<p>再加上U19女篮52-115被加拿大女篮暴揍一顿，女篮领导们的血压估计飙到了峰值。不过幸好大运会的女篮连克日本美国等意识形态对手，让领导们舒服了一点。</p>
<p>现在女篮跟男篮一样，走的还是建国初的路子：仗着14亿人口地大物博，然后从体校找几个大个子，然后搭配几个后卫来伺候这几个大个子。这几个大个的能力在篮球水平比较贫瘠的亚洲还算能吃得开，不过随着现代篮球越来越快、中锋要更多去弧顶发牌的趋势，而且最重要的是澳大利亚男女篮归入了亚洲杯范围，我想再不更换选材思路，以后无论是男女篮想染指亚洲杯是一个挺难的事儿。</p>
<p>从最早的“为什么刘伟就是中国第一后卫”这个问题现在具象化了，演变成“为什么中国出不来河村勇辉，为什么中国出不来田中心”。因为我们的选材眼光就是这样，有姚明的“先进经验”，那就保守主义继续看天由命等下一个姚明呗。</p>
<p>不过，这里我个人想表达一个观点：女篮这项运动是一个观赏性很差的运动。三大球里女排是非常展现女子曲线美的运动，女足的运动员也绝大多数都是苗条的模特身材。唯独女篮，身材普遍偏壮，而且女篮比赛里也有不少倒地争抢的镜头，就难免有点“连滚带爬”，有种菜市场女子互殴的场面。所以真的不要怪女篮球员工资低，因为实在很难看，要不是为了性别平等，这个项目其实真的可以取消，因为实在吸引不来什么金主。</p>
<h2 id="中国人不善快速决策？"><a href="#中国人不善快速决策？" class="headerlink" title="中国人不善快速决策？"></a>中国人不善快速决策？</h2><p>杨毅曾经在他的播客里说过“中国奥运金牌项目集中于小巧难女少”（小是小球，巧是技巧项目，难是难度大，女是女子项目，少是参与人数少）。随着女篮这次在亚洲杯折戟沉沙，让人不禁思考，是不是“需要快速做决策的团队运动也是中国人不擅长的？”</p>
<p>比如足球、篮球这些团队配合的PVP项目，是需要快速决策的，当你面对一个对手是传球还是单打？传球的话是击地传球更好还是吊高球传给他？这些都是要运动员在电光火石之间快速做出判断，然后再搭配平时的基本功做到高成功率的动作。</p>
<p>而相比较举重、体操、游泳、跳水、射击这种，本身就不是PVP的项目，也压根跟不上什么决策，只要够重、够快或者按照评分标准上的要求去做就肯定能拿高分。斯诺克、围棋这种，虽然它是PVP项目，但是他不需要“快速决策”。至于“乒乓球、羽毛球”这些PVP项目，但是最多2个人配合，涉及不到团队配合。</p>
<p>这么一看“需要快速做决策的团队运动是中国人不擅长的”这个结论好像是有道理的，毕竟从事实来看，根据巴黎奥运会的奖牌分布<a href="https://www.olympics.com/zh/news/paris-2024-team-china-medalists-overview">https://www.olympics.com/zh/news/paris-2024-team-china-medalists-overview</a> ，不难发现除了女子曲棍球拿了银牌，其他所有奖牌基本都是少于等于2人的项目。</p>
<p>那么为啥会这样？我想首先“小巧难女少”这五个字很完美的概括了“举国体制”优势。当然这个优势有也不是啥坏事，但是现在的情况是“举国体制”的优势再缩小，而且“市场化高”的运动我们也没有发展起来，而且是不仅发展了好几年没发展起来，倒是发展出来不少贪污犯。我觉得可能主要问题是“市场化高”的运动，需要大量的随机应变即兴发挥，因为这个就是吸引目光的地方，吸引来了目光也吸引来了钱，很多球员都是靠“灵气”吃饭的，但是中国的教育太死板，很难培养出这样的人。</p>
<p>B站有几个经常分析日本体育的UP主，通过他们感觉到日本的体育目前发展的势头不错，无论是女子100米栏、男子100米、男排、女排最近都有冠军入账，而且他们的乒乓球也没有广大群众想的那么差，大阪直美现在明显比郑钦文能打，所以有些项目中国要维持亚洲霸主还是要小心一点。</p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>体育</tag>
        <tag>篮球</tag>
        <tag>奥运会</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Alpine当基础镜像的坑</title>
    <url>/2019/06/24/%E4%BD%BF%E7%94%A8Alpine%E5%BD%93%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<h2 id="踩坑正文"><a href="#踩坑正文" class="headerlink" title="踩坑正文"></a>踩坑正文</h2><p>今天部署开发要上一个新模块，此模块已经通过golang编译好的，而且在本地机器可以正常启动，现在需要将其容器化—-制作一个镜像，然后在根据这个镜像启动程序。</p>
<p>本着基础镜像最小的原则，就选择了<code>alpine:latest</code>。先创建一个干净的alpine镜像挂载模块所在的文件夹，然后<code>docker exec</code>进去执行启动脚本。发现启动脚本里涉及到了<code>cpulimit</code>、<code>rpm</code>、<code>ps -p</code>、 <code>sudo</code>等alpine非自带命令所以无法启动。alpine安装模块的命令即非<code>yum</code>又非<code>apt-get</code>，而是<code>apk add</code>，于是在Dockerfile里添加一句：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">RUN apk add cpulimit &amp;&amp; apk add rpm &amp;&amp; apk add sudo &amp;&amp; apk --update add procps</span><br></pre></td></tr></table></figure></p>
<p>新镜像制作完毕，进去启动还是失败。具体表现是<code>./启动脚本</code>的时候报<code>&quot;no such file or directory&quot;</code>，开始我以为是因为alpine没有<code>/bin/bash</code>的缘故，把所有的shebang都改成了<code>/bin/sh</code>。但是发现启动的时候报格式错误，我想到这是一个go编译好的脚本，那么<code>./</code>就应该可以直接启动的。后来在<a href="https://github.com/gin-gonic/gin/issues/1178">https://github.com/gin-gonic/gin/issues/1178</a> 里查到原来alpine里是没有稳定的libc，所以还要添加<code>libc6-compat</code>和<code>libstdc++</code>。</p>
<p>在镜像里<code>apk add libc6-compat &amp;&amp; apk add libstdc++</code>之后，发现启动脚本还有这样一句话：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">echo <span class="string">&#x27;./core_%e.%p&#x27;</span> | sudo tee /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure></p>
<p>这个命令是无法执行的，因为docker里<code>/proc/sys/kernel/core_pattern</code>是只读文件，自然无法进行修改。但是宿主机上的这个文件是root用户可以修改的。这可怎么办？</p>
<p>我开始想既然宿主机的<code>/proc/sys/kernel/core_pattern</code>可以修改，那么就把宿主机的<code>/proc/sys/kernel/core_pattern</code>挂载给镜像不就得了？但是在执行的时候会报错：<code>cannot be mounted because it is located inside “/proc”</code>，因为Docker不允许在<code>proc</code>目录下随意挂文件，如果你有信心可以通过修改docker的源码来实现挂载的效果。</p>
<p>但是我觉得还是沉稳为上，于是就想出一个办法：在docker run的时候添加<code>--privileged</code>，这样容器获得了额外的特权可以对系统变量的值进行修改。但是要注意如果容器发生了重启，那么值会恢复成原样，即无法持久化。不过在启动脚本里已经有了echo语句，这样每一次执行启动脚本都会更改<code>/proc/sys/kernel/core_pattern</code>，于是就不用太担心这个问题了。</p>
<p>最后完整的Dockerfile如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FROM alpine:latest</span><br><span class="line">MAINTAINER ChrisChan &lt;<span class="number">33664</span>@dahuatech.com&gt;</span><br><span class="line"></span><br><span class="line">RUN apk update &amp;&amp; apk add libc6-compat &amp;&amp; apk add libstdc++ &amp;&amp; apk add cpulimit &amp;&amp; apk add rpm &amp;&amp; apk add sudo &amp;&amp; apk --update add procps</span><br><span class="line">RUN mkdir -p /mnt/agentmizar	<span class="comment">#agentmizar这个就是工作的模块名</span></span><br><span class="line">WORKDIR /mnt/agentmizar		<span class="comment">#设定工作目录</span></span><br><span class="line">CMD [<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;control&quot;</span>, <span class="string">&quot;start&quot;</span>]		<span class="comment">#启动之</span></span><br></pre></td></tr></table></figure></p>
<p>创建完镜像之后，启动语句如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">docker run --name 容器名 -dit  -v /opt/:/opt/:ro -v /etc/localtime:/etc/localtime:ro --privileged 镜像名		<span class="comment">#别忘了对准时间</span></span><br></pre></td></tr></table></figure></p>
<p>补充一句，最后镜像大小不到50MB。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/qq_41980563/article/details/88876874">https://blog.csdn.net/qq_41980563/article/details/88876874</a><br><a href="https://serverfault.com/questions/883625/alpine-shell-cant-find-file-in-docker">https://serverfault.com/questions/883625/alpine-shell-cant-find-file-in-docker</a><br><a href="https://sq.163yun.com/blog/article/155817999160799232">https://sq.163yun.com/blog/article/155817999160799232</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>使用centos7部署Harbor私有仓库</title>
    <url>/2019/07/15/%E4%BD%BF%E7%94%A8Debian9%E9%83%A8%E7%BD%B2Harbor%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><p>首先，我当你在centos7上已经装好了docker，如图：<br><img data-src="/images/harbor1.png" alt="抱光妹"></p>
<p>harbor官方更推荐使用docker-compose(1.18.0+)来配合安装，于是乎我们要安装一下docker-compose，如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">curl -L https://github.com/docker/compose/releases/download/<span class="number">1.24</span><span class="number">.1</span>/docker-compose-`uname -s`-`uname -m` -o /usr/local/<span class="built_in">bin</span>/docker-compose</span><br><span class="line"><span class="comment">#这一步国内的服务器可能会比较费时间</span></span><br><span class="line">chmod +x /usr/local/<span class="built_in">bin</span>/docker-compose</span><br><span class="line">[root@func-lcshop-Harbor ~]<span class="comment"># docker-compose -v</span></span><br><span class="line">docker-compose version <span class="number">1.24</span><span class="number">.1</span>, build 4667896b</span><br></pre></td></tr></table></figure></p>
<p>然后下载离线的harbor1.8安装包：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">wget https://storage.googleapis.com/harbor-releases/release-<span class="number">1.8</span><span class="number">.0</span>/harbor-offline-installer-v1<span class="number">.8</span><span class="number">.2</span>-rc1.tgz</span><br><span class="line">tar -zxvf harbor-offline-installer-v1<span class="number">.8</span><span class="number">.2</span>-rc1.tgz</span><br></pre></td></tr></table></figure></p>
<p>进入harbor的文件夹去修改一下<code>harbor.yml</code>，将hostname改成服务器的外网地址，不过不想要默认的80端口，同时可以加上端口号，如下：<br><img data-src="/images/harbor2.png" alt="抱光妹"></p>
<p>文件下面还有一个<code>harbor_admin_password</code>，这个是登录页面的初始密码。<font color=red>注意！密码不可以有!和@，不然命令行会报错！而且这个密码只能是第一次登陆可用，如果要改</font>然后执行<code>./install.sh</code>，如下：<br><img data-src="/images/harbor3.png" alt="抱光妹"></p>
<p>安装完毕了之后，看一下机器里生成了很多docker容器：<br><img data-src="/images/harbor5.png" alt="抱光妹"></p>
<p>再去浏览器打开<code>ip:端口</code>就能看到harbor的页面，是不是超简单？<br><img data-src="/images/harbor4.png" alt="抱光妹"></p>
<p>如果想要更换端口，在修改完<code>harbor.yml</code>之后，执行如下才会生效：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">docker-compose down -v</span><br><span class="line">./prepare</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></p>
<h2 id="修改密码？"><a href="#修改密码？" class="headerlink" title="修改密码？"></a>修改密码？</h2><p>假设我们已经修改了密码，并且重启了docker-compose，此时用命令行的方式访问harbor镜像库（推荐使用<code>--password-stdin</code>方法而不是在命令行里直接输入密码，先创建一个<code>/root/.harborpwd</code>文件，里面写入<code>harbor.yml</code>的<code>harbor_admin_password</code>），使用<code>docker login -u admin --password-stdin harbor外网IP &lt; /root/.harborpwd</code>试试，竟然返回<code>unauthorized: authentication required</code>这个错误！为什么呢？因为上面说了<code>harbor_admin_password</code>里的密码只能第一次使用，之后改密码了是不能通过<code>harbor.yml</code>修改的。</p>
<p>那么应该如何修改密码？需要进到harbor的数据库里。现在新的harbor数据库默认是<code>postgresql</code>，所以那些重置mysql密码的文章可以直接略过了。</p>
<p>具体修改的方法如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[root@func-lcshop-Harbor ~]<span class="comment"># docker exec -it harbor-db /bin/bash	#先登录到db容器里</span></span><br><span class="line">root [ / ]<span class="comment"># psql -h postgresql -d postgres -U postgres	#这里需要输入配置文件里db密码，默认的是root123</span></span><br><span class="line">Password <span class="keyword">for</span> user postgres: </span><br><span class="line">psql (<span class="number">9.6</span><span class="number">.10</span>)</span><br><span class="line"><span class="type">Type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> <span class="built_in">help</span>.</span><br><span class="line"></span><br><span class="line">postgres=<span class="comment"># \c registry</span></span><br><span class="line">You are now connected to database <span class="string">&quot;registry&quot;</span> <span class="keyword">as</span> user <span class="string">&quot;postgres&quot;</span>.</span><br><span class="line">registry=<span class="comment"># select * from harbor_user;</span></span><br><span class="line"> user_id |  username  |          email          |             password             |    realname    |    comment     | deleted | reset_uuid |               salt               | sysadmin_flag |       creation_time        |        update_time  </span><br><span class="line">---------+------------+-------------------------+----------------------------------+----------------+----------------+---------+------------+----------------------------------+---------------+----------------------------+----------------------------</span><br><span class="line">       <span class="number">2</span> | anonymous  | anonymous@example.com   |                                  | anonymous user | anonymous user | t       |            |                                  | f             | <span class="number">2019</span>-07-<span class="number">23</span> <span class="number">14</span>:<span class="number">17</span>:<span class="number">32.288001</span> | <span class="number">2019</span>-07-<span class="number">23</span> <span class="number">14</span>:<span class="number">17</span>:<span class="number">32.288001</span></span><br><span class="line">       <span class="number">1</span> | admin      | admin@example.com       | a71a7d0df981a61cbb53a97ed8d78f3e | system admin   | admin user     | f       |            | ah3fdh5b7yxepalg9z45bu8zb36sszmr | t             | <span class="number">2019</span>-07-<span class="number">23</span> <span class="number">14</span>:<span class="number">17</span>:<span class="number">32.288001</span> | <span class="number">2019</span>-07-<span class="number">24</span> 04:05:<span class="number">31.260468</span></span><br><span class="line">(<span class="number">3</span> rows)</span><br></pre></td></tr></table></figure></p>
<p>harbor采用的加密方式叫<code>PBKDF2</code>，在国外挺流行的，在国内用的人还不多。如果对这个比较感兴趣的可以去看 <a href="http://phantom0301.cc/2017/02/08/harborpass/">http://phantom0301.cc/2017/02/08/harborpass/</a> 这个文章，里面还有一个python2的脚本来帮助生成密码。</p>
<p>如果想改回默认的harbor12345，就在postgresql里执行<code>update harbor_user set password=&#39;a71a7d0df981a61cbb53a97ed8d78f3e&#39;, salt=&#39;ah3fdh5b7yxepalg9z45bu8zb36sszmr&#39; where username=&#39;admin&#39;;</code>即可，不过我更推荐换一个新的密码，同时 <code>update harbor_user set username=&#39;其他用户名&#39; where user_id=1;</code>，这样把admin也给改掉。</p>
<p>退出harbor-db容器，再新建<code>/etc/docker/daemon.json</code>，里面内容如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;insecure-registries&quot;</span> : [<span class="string">&quot;Harbor外网IP地址&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>保存退出并且重启docker之后，此时就可以在命令行尝试登陆harbor了，如图：<br><img data-src="/images/harbor6.png" alt="抱光妹"></p>
<p>图中的WARNING意思是密码会以一个比较简单的加密方式保存在&#x2F;root&#x2F;.docker&#x2F;config.json里，如果你有好的习惯，每次都会logout的话，那么这个文件还是会自动删除掉这个密码的。</p>
<p>如果想要给harbor开启ldap，请看<a href="https://github.com/goharbor/harbor/blob/master/docs/configure_user_settings.md">https://github.com/goharbor/harbor/blob/master/docs/configure_user_settings.md</a> 。</p>
<h2 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h2><p>整个镜像上传的过程如下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker login -u admin --password-stdin harbor外网IP &lt; /root/.harborpwd			#登录</span><br><span class="line">docker tag [ImageId] harbor外网IP/repository名/具体镜像名:版本号		#打一个tag</span><br><span class="line">docker pull harbor外网IP/repository名/具体镜像名:版本		#推送</span><br><span class="line">docker rmi harbor外网IP/repository名/具体镜像名:版本		#这一步是删除tag</span><br></pre></td></tr></table></figure></p>
<p>repository名这个要在harbor上事前生成，不然无法push，会报错：<code>denied: requested access to the resource is denied</code>。上传上去的镜像会保存在<code>/data/registry/docker/registry/v2/repositories/</code>这个路径下，所以如果是有很多个镜像，建议<code>/data</code>盘买大一点。</p>
<p>注意！如果出现了<code>网页可以登录但是docker login无法登录</code>的情况，请去检查<code>harbor.yml</code>里的<code>hostname</code>与实际docker login的域名是否保持一致，https访问是否也一致。<br><img data-src="/images/harbor8.png" alt="抱光妹"></p>
<h2 id="配置https和高可用方案"><a href="#配置https和高可用方案" class="headerlink" title="配置https和高可用方案"></a>配置https和高可用方案</h2><p>其实在<code>harbor.yml</code>下面就已经有配置https的地方，但是官方的建议是不要在Harbor上启用https，而是在将Harbor放置到一个SLB的后边，配置SLB的端口转发进行访问。或者是再装一个nginx，进行nginx的端口转发。具体配置这里就不写了。</p>
<p>如果想做一个HA方案的话，可以按照如下的方式构建一个（主从模式真的很不靠谱）：<br><img data-src="/images/harbor7.png" alt="抱光妹"></p>
<p>负载均衡同时还要承担健康检查的任务，而Redis用于数据的缓存和消息队列的实现，MySQL存储用户信息和仓库信息，云存储用来存储Docker镜像。</p>
<h2 id="配置阿里云OSS做后端存储"><a href="#配置阿里云OSS做后端存储" class="headerlink" title="配置阿里云OSS做后端存储"></a>配置阿里云OSS做后端存储</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://youendless.com/post/docker_login_pass/">https://youendless.com/post/docker_login_pass/</a><br><a href="https://blog.51cto.com/lzlutao/2388635">https://blog.51cto.com/lzlutao/2388635</a><br><a href="https://blog.frognew.com/2017/06/install-harbor.html">https://blog.frognew.com/2017/06/install-harbor.html</a> （这个版本已经比较老了，只能参考）</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>私有仓库</tag>
      </tags>
  </entry>
  <entry>
    <title>使用DataX传递ODPS数据到Mysql</title>
    <url>/2021/01/28/%E4%BD%BF%E7%94%A8DataX%E4%BC%A0%E9%80%92ODPS%E6%95%B0%E6%8D%AE%E5%88%B0Mysql/</url>
    <content><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>Odps是阿里巴巴集团的一个大数据解决方案,现在改名叫<code>MaxCompute</code>了，但是为了方便还是叫odps居多。我现在的需求就是需要把数据从ODPS同步到MySQL里来，那么首先需要分别在odps和mysql上创建两个两个结构一样的表。</p>
<p>mysql对应的建表语句如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `naxxramas_mactasks` (</span><br><span class="line">  `<span class="built_in">id</span>` varchar(<span class="number">200</span>) NOT NULL COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `rule_case_id` <span class="built_in">int</span>(<span class="number">11</span>) DEFAULT NULL COMMENT <span class="string">&#x27;关联的case表ID&#x27;</span>,</span><br><span class="line">  `rule_name` varchar(<span class="number">100</span>) DEFAULT NULL COMMENT <span class="string">&#x27;规则名称&#x27;</span>,</span><br><span class="line">  `app_name` varchar(<span class="number">50</span>) DEFAULT NULL COMMENT <span class="string">&#x27;关联应用名称&#x27;</span>,</span><br><span class="line">  `product_name` varchar(<span class="number">50</span>) DEFAULT NULL COMMENT <span class="string">&#x27;域名&#x27;</span>,</span><br><span class="line">  `exec_type` varchar(<span class="number">20</span>) DEFAULT NULL COMMENT <span class="string">&#x27;ODPS表示离线核对，RTT表示准实时核对&#x27;</span>,</span><br><span class="line">  `result` mediumtext COMMENT <span class="string">&#x27;执行结果&#x27;</span>,</span><br><span class="line">  `rules` varchar(<span class="number">2000</span>) DEFAULT NULL COMMENT <span class="string">&#x27;内部规则&#x27;</span>,</span><br><span class="line">  `status` <span class="built_in">int</span>(<span class="number">11</span>) DEFAULT NULL COMMENT <span class="string">&#x27;执行状态&#x27;</span>,</span><br><span class="line">  PRIMARY KEY (`<span class="built_in">id</span>`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=<span class="string">&#x27;mac稽核平台的规则对应的任务执行失败的信息&#x27;</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure></p>
<p>odps也创建表，各字段名以及类型情况如下：<br><img data-src="/images/datax%E5%90%8C%E6%AD%A55.png"></p>
<p>这里温馨提示，为了以后的方便，我强烈建议一定要把两个表的列名和列属性设置的完全一致，这样避免很多写不进去或者写进很多脏数据的问题。这是踩坑者的经验之谈！</p>
<p>我之前同步他俩是用自己写的一个python3的脚本，但是遇到大数据量的脚本同步跟MySQL的交互就太频繁了，导致屡屡出现<code>ConnectionResetError: [Errno 104] Connection reset by peer</code>的错误，就想起来干脆都迁移到dataX里同步吧，省事还正规。</p>
<h2 id="安装DataX"><a href="#安装DataX" class="headerlink" title="安装DataX"></a>安装DataX</h2><p>DataX是阿里巴巴集团的一个数据同步工具，可以实现实现包括 MySQL、SQL Server、Oracle、PostgreSQL、HDFS、Hive、HBase、OTS、ODPS 等各种异构数据源之间高效的数据同步功能。它需要以下环境：<code>JAVA1.8+</code>，<code>python2</code>和<code>maven3.x</code>。安装方法如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sudo yum -y install java-<span class="number">1.8</span><span class="number">.0</span>-openjdk-devel.x86_64</span><br><span class="line">sudo yum -y install maven</span><br><span class="line">sudo mkdir -p /opt/dataX</span><br><span class="line">sudo chown admin:admin -R /opt/dataX</span><br><span class="line">cd /opt/dataX</span><br><span class="line">sudo wget http://datax-opensource.oss-cn-hangzhou.aliyuncs.com/datax.tar.gz</span><br><span class="line">tar -zxvf datax.tar.gz</span><br></pre></td></tr></table></figure></p>
<p>从上可见我这个账号是admin并不是root,那么安装了java就不用去<code>source /etc/profile</code>那一步了，因为普通用户source不进去，你<code>sudo source</code>会爆错<code>sudo: source: command not found</code>的。不是不用担心，不耽误正常使用。maven也一样，yum安装后，就可以了，不用去更改系统变量。效果如图：<br><img data-src="/images/datax%E5%90%8C%E6%AD%A5.png" title="可见我的java是1.8.0_262,而且dataX解压缩之后文件也展现了"></p>
<p>首先先到bin目录里，由于我是要从odps数据同步到mysql里，那么执行<code>python datax.py -r odpsreader -w mysqlwriter</code>，-r就是源头，-w就是目标，这里要注意，源头和目标写法要跟plugin文件夹的写法一样，区别大小写，如图：<br><img data-src="/images/datax%E5%90%8C%E6%AD%A52.png" title="plugin是datax里的文件夹"></p>
<p>然后就会出现一个json的例子，你就需要新建一个文件，比如叫odps2mysql.json，按照这个demo一一填写具体的内容就好：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[admin@naxxramas011158137063.na61 /opt/dataX/datax/<span class="built_in">bin</span>]</span><br><span class="line">$python datax.py -r odpsreader -w mysqlwriter</span><br><span class="line"></span><br><span class="line">DataX (DATAX-OPENSOURCE-<span class="number">3.0</span>), From Alibaba !</span><br><span class="line">Copyright (C) <span class="number">2010</span>-<span class="number">2017</span>, Alibaba Group. All Rights Reserved.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Please refer to the odpsreader document:</span><br><span class="line">     https://github.com/alibaba/DataX/blob/master/odpsreader/doc/odpsreader.md</span><br><span class="line"></span><br><span class="line">Please refer to the mysqlwriter document:</span><br><span class="line">     https://github.com/alibaba/DataX/blob/master/mysqlwriter/doc/mysqlwriter.md</span><br><span class="line"></span><br><span class="line">Please save the following configuration <span class="keyword">as</span> a json file <span class="keyword">and</span>  use</span><br><span class="line">     python &#123;DATAX_HOME&#125;/<span class="built_in">bin</span>/datax.py &#123;JSON_FILE_NAME&#125;.json</span><br><span class="line">to run the job.</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;job&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;content&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;reader&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;odpsreader&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">                        <span class="string">&quot;accessId&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;accessKey&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;column&quot;</span>: [],</span><br><span class="line">                        <span class="string">&quot;odpsServer&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;packageAuthorizedProject&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;partition&quot;</span>: [],</span><br><span class="line">                        <span class="string">&quot;project&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;splitMode&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;table&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&quot;writer&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;mysqlwriter&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">                        <span class="string">&quot;column&quot;</span>: [],</span><br><span class="line">                        <span class="string">&quot;connection&quot;</span>: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="string">&quot;jdbcUrl&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;table&quot;</span>: []</span><br><span class="line">                            &#125;</span><br><span class="line">                        ],</span><br><span class="line">                        <span class="string">&quot;password&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;preSql&quot;</span>: [],</span><br><span class="line">                        <span class="string">&quot;session&quot;</span>: [],</span><br><span class="line">                        <span class="string">&quot;username&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;writeMode&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;setting&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;speed&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;channel&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体每一个key的含义可以去看文档，odps的源头字段文档是<a href="https://github.com/alibaba/DataX/blob/master/odpsreader/doc/odpsreader.md">https://github.com/alibaba/DataX/blob/master/odpsreader/doc/odpsreader.md</a> ，mysql的目标字段文档是<a href="https://github.com/alibaba/DataX/blob/master/mysqlwriter/doc/mysqlwriter.md%E3%80%82">https://github.com/alibaba/DataX/blob/master/mysqlwriter/doc/mysqlwriter.md。</a> 其他的数据库也可以在dataX的github地址在这里：<a href="https://github.com/alibaba/DataX/blob/master/userGuid.md">https://github.com/alibaba/DataX/blob/master/userGuid.md</a> 里找到。</p>
<p>保存好json文件，然后<code>python datax.py odps2mysql.json</code>就可以启动了，如图：<br><img data-src="/images/datax%E5%90%8C%E6%AD%A53.png" title="4分钟搞定"></p>
<p>注意一下，如果你的数据库条非常多，比如我这个例子是42万条记录，那么MySQL默认的写入batchSize是1024，很有可能会把1G的内存打挂，所以建议这个值要根据实际情况而来。</p>
<p>如果你启动出现了<code>com.alibaba.fastjson.JSONObject cannot be cast to java.lang.String</code>的错误，如图：<br><img data-src="/images/datax%E5%90%8C%E6%AD%A54.png"></p>
<p>那么只有一个可能：你的json文件格式不正确，请去重新检查再来过。</p>
<p>如果你的datax作业没有任务错误却直接退出了,如图:<br><img data-src="/images/datax%E5%90%8C%E6%AD%A56.png"></p>
<p>那么请调小json文件里的<code>channel</code>值,比如改成2或者1,这样就能跑起来了。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>阿里云</tag>
        <tag>数据集成</tag>
      </tags>
  </entry>
  <entry>
    <title>停止内耗，直接一点</title>
    <url>/2023/12/18/%E4%BC%98%E5%BE%85%E7%9A%84%E4%BB%A3%E4%BB%B7/</url>
    <content><![CDATA[<p>这几天最火的新闻肯定就是东方甄选的头号大主播董宇辉和东方甄选的“小作文”风波，很多自媒体以及相关利益方都频频下场发言。这里面当然少不了罗永浩老师，我个人觉得罗永浩老师现在的“交个朋友”直播间跟东方甄选是一个赛道上的直接竞争对手，他是乐意看到东方甄选在这次时间后一蹶不振大受损伤的，而且罗老师这几天为董宇辉“仗义执言”也赢得了不少董宇辉的粉丝关注，所以我觉得他现在是“煽风点火不嫌事情大”。</p>
<p>其实说白了，董宇辉这个事情就是团队领导跟明星员工的爱恨情仇，这种事情古往今来在任何一个行业都屡见不鲜。公司这么大，不同职业肯定有不同的分工，CEO负责搞定投资人、各个一号位、制定战略调度资源，头牌主播们要做的是配合运营在曝光渠道内吸引新粉丝，搞定老粉丝。但是随着目前“饭圈文化”横行，“如何处理牛逼的下属”的矛盾哪怕有那么多的历史经验但是都似乎不会得到完美的“将相和”。</p>
<p>比如当年湖人与科比、巴黎与姆巴佩、上海电视台与周立波、巴萨与梅西等等事情，都是明星员工在前台太过耀眼，或许耀眼之余还有一丢丢的膨胀，所以引起了内部人的嫉妒和排挤甚至是不安全感。其实耀眼不是员工的错，公司给明星员工特殊优待是正常不过的事情，毕竟人家是台柱子，观众是来看明星休闲放松的不是来看门道搞研究的，也就是常说的“人迷”，但是如何巧妙的处理当事人和其他员工就是一个难点。一旦两者闹了矛盾，粉丝以“退粉”、“取关”相威胁甚至发帖抹黑，那么这种场景对于To C性质的、尤其还是上市的直播零售业是不小的形象打击。</p>
<p>新东方是搞教育出身的企业，里面有大量老师，很多老师虽然长得不帅没什么才艺，但是凭借自身的教育能力和能说会道打造了自己的人格魅力。所以当“双减”政策一下，新东方这些人格魅力的老师们转型做主播相对来说比较简单，无非就是以前面对学生们现在面对的是买货的顾客们，沟通的话术还是有一定的相似性的。但是这里面俞敏洪老师就有一个矛盾点：“既要主播们有魅力吸引粘度高的粉丝，又不希望搞饭圈文化反噬自己”。在当今的流量时代，已经是不可能的了。所以这次俞敏洪老师选择放弃CEO保住董宇辉，也变相承认了“之前董宇辉话语权较低，收入较低”的事实，几天之内就宣布给了董宇辉很大的权和较丰厚的利。</p>
<p>如何避免下一个这样的事情呢？或者说曝光了这样的矛盾怎么样能较好的公关处理呢？</p>
<p>第一，企业文化+个人待遇。打工可不是踢足球打NBA，踢足球来说，既有商业价值又能保证成绩的好球队就那么几支，NBA也是同理。所以C罗梅西奥尼尔他们其实没有什么选择，他们从皇马巴萨洛杉矶离开往往都是被逼的而不是主动的。而对于普通打工人，北京上海广州杭州有的是有实力的老板，想去哪就去哪，所以真的是“此处不留爷，自有留爷处”。管理简单、同时给明星员工一些特权和好的个人待遇，这是基本的基本。特殊待遇也要量力而行，尽量不会因为庙小佛大，而失去好员工。</p>
<p>第二，具体给到什么样的待遇。因为是明星员工，那么他也肯定会有一个领导管理他。这里大老板如果可以干脆直接自己领导明星员工省去不必要的中间麻烦。如果条件不准许，要让员工直属领导处理好跟明星员工的关系，保持沟通顺畅、停止内耗。直属领导可以给明星员工在他擅长范围内的话语权，这叫“让专业的人做专业的事儿”，但是也要尽量再来1~2个同样“专业的人”来制衡明星员工。</p>
<p>第三，KPI不要内耗，让明星员工在他的明星地始终保持新鲜感。明星员工跟直属领导的矛盾点其实主要就是两者为了同一个目标但是有各自的做事方式。如果CEO为了GMV负责，明星员工也为GMV负责，那么两个人为了业绩达成肯定会有正面碰撞。这里建议让明星员工去为GMV负责70%，毕竟优待拿到手了，责任也要扛起来。而CEO为GMV负责30%，剩余是给明星员工打好辅助。但是CEO的可调度资源肯定要包括明星员工，不能让明星员工长时间持有一波只属于自己的兵（业务爆发期间可以临时给）。</p>
<p>第四，如果明星员工跟直属领导关系处理的实在裂痕太大，那么舍弃直属领导另做他用、双方不再纠葛是大老板无奈的选择，毕竟明星员工就这么一个，培养了那么久不可能说换就换。一个团队既然选择了靠流量，那么离开了流量注定啥也不是。</p>
<p>其实说来说去，最朴实的结论就是“当领导的要能容下人，也要有对抗灰犀牛的风险意识和能力”。而当明星员工的，要懂得分寸，双方都把握好度，合作才能愉快和长久，哪怕分开了也不会恶语相向。</p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>新东方</tag>
        <tag>董宇辉</tag>
        <tag>直播</tag>
      </tags>
  </entry>
  <entry>
    <title>使用crontab -l为空，但是有定时任务在跑</title>
    <url>/2021/03/17/%E4%BD%BF%E7%94%A8Crontab-l%E4%B8%BA%E7%A9%BA%EF%BC%8C%E4%BD%86%E6%98%AF%E6%9C%89%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%9C%A8%E8%B7%91/</url>
    <content><![CDATA[<p>接到开发电话反馈，某个应用总是在规定时间出现CPU飙升的情况，看到是由于<code>netstat</code>命令引发的，但是kill掉后，还会问题复发。</p>
<p>登录上去，果不其然，CPU满负荷，杀掉进程之后还恢复，判断后台是有定时任务在跑，或者有看门狗在循环执行定时检查任务，如图：<br><img data-src="/images/crond%E9%97%AE%E9%A2%981.png"></p>
<p>但是通过<code>crontab -l</code>查看定时任务列表却空空如也，查了所有的用户都是空，于是怀疑这个任务是埋在机器里的crontab设定来执行的。通过<code>ps -axjf |grep cron</code>来看果然有一个叫<code>relation</code>的命令在执行，如图：<br><img data-src="/images/crond%E9%97%AE%E9%A2%982.png"></p>
<p>到<code>/etc/cron.d</code>里查看所有的定时任务，还真有一个叫<code>relation</code>的文件，打开内容一看，果然是它，如图：<br><img data-src="/images/crond%E9%97%AE%E9%A2%983.png" title="藏在这里的东西是不会被crontab -l展示"></p>
<p>这里写的是每分钟执行一下<code>/bin/relation</code>命令，然后再去<code>cat /bin/relation</code>发现果然是一个每天5点会执行一个netstat命令同时还去connect某个网址的命令，所以引发的CPU飙升，如图：<br><img data-src="/images/crond%E9%97%AE%E9%A2%984.png"></p>
<p>关闭之后，世界清净了。</p>
<p>这里注意一下，线上环境的功能采用脚本+crontab的方式实现，未放到代码层实现，我想在大公司里都是违反安全生产协议的。涉及到线上产品的功能或者逻辑，一定要在代码层面实现掉，不要单独搞非标的方式，会给新接手的同学埋坑，同时容易给线上扩容或者其他操作造成故障。<br><img data-src="/images/%E5%A4%A7%E8%B6%85PK%E8%8D%92%E5%8E%9F%E7%8B%BC.gif" title="重生大超爆锤荒原狼"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>阿里云</tag>
        <tag>定时任务</tag>
        <tag>Centos</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Django搭建项目室预定功能</title>
    <url>/2021/07/21/%E4%BD%BF%E7%94%A8Django%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%AE%A4%E9%A2%84%E5%AE%9A%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h2 id="达成效果"><a href="#达成效果" class="headerlink" title="达成效果"></a>达成效果</h2><p>每到大促的时候，集团都会特批一个员工会议室做项目室，主要用于开会讨论和复盘使用。但是这个项目室一直没有一个系统来展示预定的细节，所以很多时候都是“谁抢上谁就用”，比较不方便。于是我使用Django2.1写了一个项目室预定的功能。</p>
<p>整个系统的前台效果如下：<br><img data-src="/images/%E9%A1%B9%E7%9B%AE%E5%AE%A4%E9%A2%84%E5%AE%9A1.png"></p>
<p>整个页面就是一个table表格，然后横坐标是时间段，纵坐标是未来七天的日期，每个单元格里是一个modal模态框，“可预订”的模态框点击后的效果如下：<br><img data-src="/images/%E9%A1%B9%E7%9B%AE%E5%AE%A4%E9%A2%84%E5%AE%9A2.png"></p>
<p>如果预定的人是当前登录人，那么就是一个黄色的模态框，点击之后效果如下：<br><img data-src="/images/%E9%A1%B9%E7%9B%AE%E5%AE%A4%E9%A2%84%E5%AE%9A3.png" title="点击释放就取消预订"></p>
<h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h2><p>整个过程最难的地方其实是前端JavaScript，主要就是获取未来七天的日期和星期，这部分内容可以看 <a href="https://brucewayne2099.github.io/2021/07/11/%E7%82%B9%E5%87%BB%E8%A1%A8%E6%A0%BC%E9%87%8C%E7%9A%84%E5%8D%95%E5%85%83%E6%A0%BC%E8%8E%B7%E5%8F%96%E5%AF%B9%E5%BA%94%E8%A1%8C%E9%A6%96%E5%88%97%E9%A6%96%E7%9A%84%E4%BF%A1%E6%81%AF">https://brucewayne2099.github.io/2021/07/11/点击表格里的单元格获取对应行首列首的信息</a> 这一篇，这样获取到了前端的纵坐标。其他部分比如模态框传入值到<code>views.py</code>这部分就用ajax就好了。</p>
<p>先看<code>models.py</code>：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  项目室预定记录表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Booking</span>(models.Model):</span><br><span class="line">    booking_date = models.DateField()</span><br><span class="line">    user = models.CharField(max_length=<span class="number">50</span>, null=<span class="literal">True</span>, blank=<span class="literal">True</span>)    <span class="comment"># 会议室占用者</span></span><br><span class="line">    theme = models.CharField(max_length=<span class="number">50</span>, null=<span class="literal">True</span>, blank=<span class="literal">True</span>)    <span class="comment"># 会议主题</span></span><br><span class="line">    is_deleted = models.CharField(max_length=<span class="number">50</span>, null=<span class="literal">True</span>, blank=<span class="literal">True</span>)    <span class="comment"># 逻辑删除，0是删除，1是未删除</span></span><br><span class="line">    time_id = models.CharField(max_length=<span class="number">50</span>, null=<span class="literal">True</span>, blank=<span class="literal">True</span>)    <span class="comment"># 会议时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(<span class="variable language_">self</span>.user) + <span class="string">&quot;预定了，主题是&quot;</span> + <span class="built_in">str</span>(<span class="variable language_">self</span>.theme)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        verbose_name = <span class="string">&quot;预定信息&quot;</span></span><br><span class="line">        verbose_name_plural = verbose_name</span><br><span class="line">        unique_together = (</span><br><span class="line">            (<span class="string">&quot;user&quot;</span>, <span class="string">&quot;booking_date&quot;</span>, <span class="string">&quot;time_id&quot;</span>, <span class="string">&quot;is_deleted&quot;</span>),  <span class="comment"># 这4个字段联合唯一，防止重复预订</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure></p>
<p>创建对应的表，然后就是<code>views.py</code>如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 大促项目室预定页面</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">meeting</span>(<span class="params">request</span>):</span><br><span class="line">    today = datetime.now().date()</span><br><span class="line">    today2 = today + timedelta(days=<span class="number">1</span>)</span><br><span class="line">    today3 = today + timedelta(days=<span class="number">2</span>)</span><br><span class="line">    today4 = today + timedelta(days=<span class="number">3</span>)</span><br><span class="line">    today5 = today + timedelta(days=<span class="number">4</span>)</span><br><span class="line">    today6 = today + timedelta(days=<span class="number">5</span>)</span><br><span class="line">    today7 = today + timedelta(days=<span class="number">6</span>)  <span class="comment"># 获取未来7天的日期</span></span><br><span class="line"></span><br><span class="line">    date_dict = &#123;<span class="built_in">str</span>(today): <span class="string">&quot;today&quot;</span>, <span class="built_in">str</span>(today2): <span class="string">&quot;today2&quot;</span>, <span class="built_in">str</span>(today3): <span class="string">&quot;today3&quot;</span>, <span class="built_in">str</span>(today4): <span class="string">&quot;today4&quot;</span>, <span class="built_in">str</span>(today5): <span class="string">&quot;today5&quot;</span>, <span class="built_in">str</span>(today6): <span class="string">&quot;today6&quot;</span>, <span class="built_in">str</span>(today7): <span class="string">&quot;today7&quot;</span>&#125;</span><br><span class="line">    book_list = Booking.objects.<span class="built_in">filter</span>(booking_date__gte=today).<span class="built_in">filter</span>(is_deleted=<span class="string">&#x27;0&#x27;</span>)  <span class="comment"># 展示所有未删除，而且预定时间大于今天的case</span></span><br><span class="line">    htmls = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> day <span class="keyword">in</span> date_dict:</span><br><span class="line">        htmls += <span class="string">&#x27;&lt;tr&gt;&lt;td&gt;&lt;a id=&quot;&#123;&#125;&quot;&gt;&lt;/a&gt;&lt;/td&gt;&#x27;</span>.<span class="built_in">format</span>(date_dict[day])  <span class="comment"># 这里字典对应的values主要是给前端输入id用的，将字典的value传入进去</span></span><br><span class="line">        <span class="keyword">for</span> time_choice <span class="keyword">in</span> [<span class="string">&quot;10:00~12:00&quot;</span>, <span class="string">&quot;12:00~14:00&quot;</span>, <span class="string">&quot;14:00~16:00&quot;</span>, <span class="string">&quot;16:00~18:00&quot;</span>, <span class="string">&quot;18:00~20:00&quot;</span>, <span class="string">&quot;20:00~22:00&quot;</span>]:</span><br><span class="line">            book = <span class="literal">None</span></span><br><span class="line">            flag = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> i,book <span class="keyword">in</span> <span class="built_in">enumerate</span>(book_list):      <span class="comment"># 这里的i就是时间轴列表的索引下标，后面是事件</span></span><br><span class="line">                <span class="keyword">if</span> book.time_id == time_choice <span class="keyword">and</span> book.booking_date == day:  <span class="comment"># 意味这个单元格已被预定</span></span><br><span class="line">                    flag = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                <span class="keyword">if</span> book.user == request.user.username:	<span class="comment"># 如果登录人就是预约人</span></span><br><span class="line">                    htmls += <span class="string">&#x27;&lt;td&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-warning&quot; data-toggle=&quot;modal&quot; data-target=&quot;#modal-warning&#123;&#125;&quot; onclick=&quot;RunAlg(this)&quot;&gt;你已预订&lt;/button&gt;&lt;/td&gt;&lt;div class=&quot;modal fade&quot; id=&quot;modal-warning&#123;&#125;&quot;&gt;&lt;div class=&quot;modal-dialog&quot;&gt;&lt;div class=&quot;modal-content bg-warning&quot;&gt;&lt;div class=&quot;modal-header&quot;&gt;&lt;h4 class=&quot;modal-title&quot;&gt;会议室已经被你占用&lt;/h4&gt;&lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-label=&quot;Close&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;&lt;/button&gt;&lt;/div&gt;&lt;div class=&quot;modal-body&quot;&gt;&lt;p&gt;占用人：&#123;&#125;&lt;/p&gt;&lt;p&gt;会议主题：&#123;&#125;&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;modal-footer justify-content-between&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-outline-dark&quot; data-dismiss=&quot;modal&quot;&gt;Close&lt;/button&gt;&lt;input type=&quot;button&quot; class=&quot;btn btn-default&quot; id=&quot;cancel&quot; value=&quot;释放?&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&#x27;</span>.<span class="built_in">format</span>(i, i, book.user, book.theme)		<span class="comment"># 如果这里不加上i，那么所有的button target都是触发同一个模态框</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    htmls += <span class="string">&quot;&lt;td bgcolor=&#x27;#00bbff&#x27; class=&#x27;info item&#x27;&gt;预订人：&#123;&#125;&lt;br&gt;会议主题：&#123;&#125;&lt;/td&gt;&quot;</span>.<span class="built_in">format</span>(book.user, book.theme)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                htmls += <span class="string">&#x27;&lt;td&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-success&quot; data-toggle=&quot;modal&quot; data-target=&quot;#booking-success&quot; onclick=&quot;RunAlg(this)&quot;&gt;可预订&lt;/button&gt;&lt;/td&gt;&#x27;</span></span><br><span class="line">        htmls += <span class="string">&quot;&lt;/tr&gt;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render_to_response(<span class="string">&#x27;meeting.html&#x27;</span>, &#123;<span class="string">&#x27;htmls&#x27;</span>: htmls&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加预定项目室事件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">booking</span>(<span class="params">request</span>):</span><br><span class="line">    today = <span class="built_in">str</span>(datetime.now().date())</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">        book_user = request.POST.get(<span class="string">&quot;booking_user&quot;</span>, <span class="literal">None</span>)   <span class="comment"># 获取订阅者名称</span></span><br><span class="line">        book_theme = request.POST.get(<span class="string">&quot;theme&quot;</span>, <span class="literal">None</span>)  <span class="comment"># 获取会议主题</span></span><br><span class="line">        book_date = request.POST.get(<span class="string">&quot;date&quot;</span>, <span class="literal">None</span>)  <span class="comment"># 获取会议日期</span></span><br><span class="line">        book_time = request.POST.get(<span class="string">&quot;time&quot;</span>, <span class="literal">None</span>)  <span class="comment"># 获取会议时间段</span></span><br><span class="line">        now_time = time.strftime(<span class="string">&quot;%H:%M&quot;</span>, time.localtime())  <span class="comment"># 获取当前的时间，如果预定时间早于当前时间，那么无法预定！</span></span><br><span class="line">        <span class="keyword">if</span> book_date[<span class="number">0</span>:<span class="number">10</span>] + <span class="string">&quot; &quot;</span> + book_time[<span class="number">6</span>:] &gt; today + <span class="string">&quot; &quot;</span> + now_time:   <span class="comment"># 预定期望时间晚于当前时间才能预定成功，这里的比较不用加上秒</span></span><br><span class="line">            book_data = Booking.objects.create(  <span class="comment"># 这里加上年份,区别不同年份</span></span><br><span class="line">                booking_date=book_date[<span class="number">0</span>:<span class="number">10</span>],   <span class="comment"># 这里book_date去掉后面的星期</span></span><br><span class="line">                user=book_user,</span><br><span class="line">                theme=book_theme,</span><br><span class="line">                time_id=book_time,</span><br><span class="line">                is_deleted=<span class="number">0</span>  <span class="comment"># 新生成的会议都是0，被释放后就可以变成1，这里是逻辑删除</span></span><br><span class="line">            )</span><br><span class="line">            book_data.save()  <span class="comment"># 保存到数据库里</span></span><br><span class="line">            <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;status&#x27;</span>: <span class="string">&#x27;success&#x27;</span>&#125;)  <span class="comment"># 这个信息返回给AJAX</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;status&#x27;</span>: <span class="string">&#x27;failed&#x27;</span>&#125;)  <span class="comment"># 这个信息返回给AJAX</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消预订项目室时间</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cancel_booking</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;POST&quot;</span>:  <span class="comment"># 这里是修改添加操作，所以要有CSRFtoken的控制</span></span><br><span class="line">        book_date = request.POST.get(<span class="string">&quot;date&quot;</span>, <span class="literal">None</span>)[<span class="number">0</span>:<span class="number">10</span>] <span class="comment"># 获取会议日期</span></span><br><span class="line">        book_time = request.POST.get(<span class="string">&quot;time&quot;</span>, <span class="literal">None</span>)  <span class="comment"># 获取会议时间段</span></span><br><span class="line">        Booking.objects.<span class="built_in">filter</span>(booking_date=book_date).<span class="built_in">filter</span>(time_id=book_time).update(is_deleted=<span class="number">1</span>)   <span class="comment"># 逻辑删除改成已删除就不透出了</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;status&#x27;</span>: <span class="string">&#x27;success&#x27;</span>&#125;)  <span class="comment"># 这个信息返回给AJAX</span></span><br></pre></td></tr></table></figure></p>
<p>路由相关的<code>urls.py</code>部分如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">	......</span><br><span class="line">    path(<span class="string">&#x27;meeting&#x27;</span>, views.meeting, name=<span class="string">&#x27;meeting&#x27;</span>),  <span class="comment">#大促项目室预订页面</span></span><br><span class="line">    path(<span class="string">&#x27;booking&#x27;</span>, views.booking, name=<span class="string">&#x27;booking&#x27;</span>),  <span class="comment"># ajax添加大促项目室预定数据</span></span><br><span class="line">    path(<span class="string">&#x27;cancel_booking&#x27;</span>, views.cancel_booking, name=<span class="string">&#x27;cancel_booking&#x27;</span>),  <span class="comment"># ajax取消大促项目室预定数据</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>对应的<code>meeting.html</code>内容比较长，我就写表格和JavaScript部分：<br>	<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Main content --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container-fluid&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span> </span><br><span class="line">         <span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">&quot;table table-bordered&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">th</span>&gt;</span>日期/时间段<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">th</span>&gt;</span>10:00~12:00<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">th</span>&gt;</span>12:00~14:00<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">th</span>&gt;</span>14:00~16:00<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">th</span>&gt;</span>16:00~18:00<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">th</span>&gt;</span>18:00~20:00<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">th</span>&gt;</span>20:00~22:00<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">               &#123;&#123; htmls|safe &#125;&#125;</span><br><span class="line">             <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;modal fade&quot;</span> <span class="attr">id</span>=<span class="string">&quot;booking-success&quot;</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">role</span>=<span class="string">&quot;form&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-dialog&quot;</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-content bg-success&quot;</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-header&quot;</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">h4</span> <span class="attr">class</span>=<span class="string">&quot;modal-title&quot;</span>&gt;</span>该时段可以占用项目室<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;close&quot;</span> <span class="attr">data-dismiss</span>=<span class="string">&quot;modal&quot;</span> <span class="attr">aria-label</span>=<span class="string">&quot;Close&quot;</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">span</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="symbol">&amp;times;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-body&quot;</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">p</span>&gt;</span>预定人：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;booking_user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;预订人花名&quot;</span> <span class="attr">id</span>=<span class="string">&quot;booking_user&quot;</span> <span class="attr">required</span>=<span class="string">&quot;required&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">p</span>&gt;</span>会议主题：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;theme&quot;</span> <span class="attr">id</span>=<span class="string">&quot;theme&quot;</span> <span class="attr">required</span>=<span class="string">&quot;required&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-footer justify-content-between&quot;</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-outline-light&quot;</span> <span class="attr">data-dismiss</span>=<span class="string">&quot;modal&quot;</span>&gt;</span>Close<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-default&quot;</span> <span class="attr">id</span>=<span class="string">&quot;booking&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 用来获取点击单元格后，对应的行首和列首的内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">RunAlg</span>(<span class="params">ths</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  　　$(<span class="string">&quot;#myModal&quot;</span>).<span class="title function_">modal</span>(<span class="string">&#x27;show&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> $td = $(ths).<span class="title function_">parent</span>().<span class="title function_">parent</span>().<span class="title function_">children</span>();</span></span><br><span class="line"><span class="language-javascript">      date = $td.<span class="title function_">eq</span>(<span class="number">0</span>).<span class="title function_">text</span>();  <span class="comment">// 去掉var那么就是全局变量了，在下面的click里也能获取到</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> $th = $(ths).<span class="title function_">parent</span>().<span class="title function_">parent</span>().<span class="title function_">parent</span>().<span class="title function_">parent</span>().<span class="title function_">children</span>().<span class="title function_">children</span>().<span class="title function_">find</span>(<span class="string">&quot;th&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> lie = $(ths.<span class="property">parentNode</span>).<span class="title function_">prevAll</span>().<span class="property">length</span>;</span></span><br><span class="line"><span class="language-javascript">      time = $th.<span class="title function_">eq</span>(lie).<span class="title function_">text</span>(); </span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">padStartConvert</span>(<span class="params">n</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    n = n.<span class="title function_">toString</span>()</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> n[<span class="number">1</span>] ? n : <span class="string">&#x27;0&#x27;</span> + n</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">formatDate</span>(<span class="params">num</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> nowTime = now.<span class="title function_">getTime</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> oneDayTime = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> <span class="title class_">ShowTime</span> = nowTime+num*oneDayTime;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> myDate = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="title class_">ShowTime</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> y = myDate.<span class="title function_">getFullYear</span>();<span class="comment">//年</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> m = myDate.<span class="title function_">getMonth</span>() + <span class="number">1</span>;<span class="comment">//月</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> d = myDate.<span class="title function_">getDate</span>();<span class="comment">//日</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> weekday = myDate.<span class="title function_">getDay</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> [y, m, d].<span class="title function_">map</span>(padStartConvert).<span class="title function_">join</span>(<span class="string">&#x27;-&#x27;</span>) + <span class="string">&quot; 星期&quot;</span>+weekday</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;today&quot;</span>).<span class="property">innerHTML</span> = <span class="title function_">formatDate</span>(<span class="number">0</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;today2&quot;</span>).<span class="property">innerHTML</span> = <span class="title function_">formatDate</span>(<span class="number">1</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;today3&quot;</span>).<span class="property">innerHTML</span> = <span class="title function_">formatDate</span>(<span class="number">2</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;today4&quot;</span>).<span class="property">innerHTML</span> = <span class="title function_">formatDate</span>(<span class="number">3</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;today5&quot;</span>).<span class="property">innerHTML</span> = <span class="title function_">formatDate</span>(<span class="number">4</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;today6&quot;</span>).<span class="property">innerHTML</span> = <span class="title function_">formatDate</span>(<span class="number">5</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;today7&quot;</span>).<span class="property">innerHTML</span> = <span class="title function_">formatDate</span>(<span class="number">6</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  $(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    $(<span class="string">&#x27;#booking&#x27;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> booking_user = $(<span class="string">&quot;#booking_user&quot;</span>).<span class="title function_">val</span>();</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> theme = $(<span class="string">&quot;#theme&quot;</span>).<span class="title function_">val</span>();</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">cache</span>: <span class="literal">false</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">type</span>: <span class="string">&quot;POST&quot;</span>,<span class="comment">//方法类型</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">dataType</span>: <span class="string">&quot;json&quot;</span>,<span class="comment">//预期服务器返回的数据类型</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">url</span>: <span class="string">&#x27;&#123;% url &quot;booking&quot; %&#125;&#x27;</span> ,<span class="comment">//url</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">booking_user</span>: booking_user,</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">theme</span>: theme,</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">date</span>: date,</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">time</span>: time    <span class="comment">//这里就是传给后端views.py的值</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">async</span>: <span class="literal">false</span>,  <span class="comment">//必须要为false,必须必须</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="keyword">if</span>(data.<span class="property">status</span> == <span class="string">&quot;success&quot;</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                  <span class="comment">// 关闭模态框并清除框内数据，否则下次打开还是上次的数据</span></span></span><br><span class="line"><span class="language-javascript">                  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;booking-success&quot;</span>).<span class="property">value</span> = <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">                  <span class="comment">// 判断确实正确入库之后提示</span></span></span><br><span class="line"><span class="language-javascript">                  <span class="title function_">alert</span>(<span class="string">&quot;数据库存储成功！&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">                  location.<span class="title function_">reload</span>(); <span class="comment">// 直接刷新当前页面</span></span></span><br><span class="line"><span class="language-javascript">               &#125;</span></span><br><span class="line"><span class="language-javascript">               <span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="language-javascript">                  <span class="title function_">alert</span>(<span class="string">&quot;预定失败，请先检查预定时间段是否早于当前时间？&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">               &#125;</span></span><br><span class="line"><span class="language-javascript">           &#125;,</span></span><br><span class="line"><span class="language-javascript">        error : <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="title function_">alert</span>(<span class="string">&quot;预定失败！&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">               &#125;</span></span><br><span class="line"><span class="language-javascript">          &#125;); </span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript">  $(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    $(<span class="string">&#x27;#cancel&#x27;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;  <span class="comment">// 取消会议室</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">cache</span>: <span class="literal">false</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">type</span>: <span class="string">&quot;POST&quot;</span>, <span class="comment">// 方法类型</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">dataType</span>: <span class="string">&quot;json&quot;</span>, <span class="comment">// 预期服务器返回的数据类型</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">url</span>: <span class="string">&#x27;&#123;% url &quot;cancel_booking&quot; %&#125;&#x27;</span> ,<span class="comment">//url</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">date</span>: date,</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">time</span>: time    <span class="comment">// 这里就是传给后端views.py的值</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">async</span>: <span class="literal">false</span>,  <span class="comment">// 必须要为false,必须必须</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="keyword">if</span>(data.<span class="property">status</span> == <span class="string">&quot;success&quot;</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                  <span class="comment">// 判断确实正确入库之后提示</span></span></span><br><span class="line"><span class="language-javascript">                  <span class="title function_">alert</span>(<span class="string">&quot;项目室取消成功！&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">                  location.<span class="title function_">reload</span>(); <span class="comment">// 直接刷新当前页面</span></span></span><br><span class="line"><span class="language-javascript">               &#125;</span></span><br><span class="line"><span class="language-javascript">           &#125;,</span></span><br><span class="line"><span class="language-javascript">        error : <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="title function_">alert</span>(<span class="string">&quot;项目室取消失败！&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">               &#125;</span></span><br><span class="line"><span class="language-javascript">          &#125;); </span></span><br><span class="line"><span class="language-javascript">  &#125;);  </span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这里有一个地方比较蛋疼，就是在<code>views.py</code>里的时候使用了for循环搭配了<code>html +=</code>。Django在views.py里把数据加工好，然后通过<code>render_to_response</code>是把整个内容传进去。这样是把整个内容传入到template里，因为前端加工数据能力有限，所以把内容再按条件细分就很痛苦。后来想过在for循环的时候给对应的button标签添加属性，但是JavaScript获取不同的属性又很麻烦，而且拿到属性之后还要展示到对应的前端，逻辑很费劲。所以就干脆在for循环里多加了好几个模态框，这样前端HTML代码就会比较臃肿，但是想了半天也不知道怎么办，想来想去只能这样了，如果看客有更好的方案请留言告诉我哈。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/yunwangjun-python-520/p/11137781.html#_label0_3">https://www.cnblogs.com/yunwangjun-python-520/p/11137781.html#_label0_3</a><br><a href="https://blog.csdn.net/Strive_0902/article/details/99705332">https://blog.csdn.net/Strive_0902/article/details/99705332</a></p>
<p><img data-src="/images/%E9%9B%84%E9%B9%BF%E6%80%BB%E5%86%A0%E5%86%9B.webp" title="恭喜字母哥包揽进步最快球员、MVP、DPOY、FMVP，历史首人"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>使用FullCalendar配合Django做一个日程管理系统</title>
    <url>/2020/08/10/%E4%BD%BF%E7%94%A8FullCalendar%E9%85%8D%E5%90%88Django%E5%81%9A%E4%B8%80%E4%B8%AA%E6%97%A5%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>在工作平台里，做一个日程管理是一个很常见的事儿。比如值班安排、比如大促任务等等具体的业务都会需要一个日程管理系统，在这里我选择了FullCalendar，为什么选择了FullCalendar呢？因为很多人都在用…（囧）出于查资料比较方便，所以我也随大流了。那么首先说明一下我的环境：<br>Django:<code>2.1.8</code><br>Python:<code>3.6.4</code><br>project的名称是:<code>naxx</code><br>APP的名称是:<code>naxxramas</code></p>
<p>先看一下效果：<br><img data-src="/images/fullcalender%E6%97%A5%E7%A8%8B%E7%AE%A1%E7%90%86.gif" alt="akb48" title="可以通过整体的一个日历情况，可以看出不同的颜色代表不同的进度"></p>
<p>通过点击日历上的日期，弹出一个交互框来输入任务名称，然后点击交互框可以查看任务详情，进而可以修改和删除。这里主要是说使用FullCalendar的组件通过点击前端页面来新增任务，而修改和删除可以直接根据数据库的ID去update或者delete，这里就不多说了。</p>
<p>首先先<code>models.py</code>创建一个大促任务的模型：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 大促任务表，给日历用的</span><br><span class="line">class Events(models.Model):</span><br><span class="line">    event_name = models.CharField(max_length=255, null=True, blank=True)  # 大促任务名称</span><br><span class="line">    start_date = models.DateField(null=True, blank=True)     # 任务预计完成日期，默认持续时间是一整天，所以不需要end_date</span><br><span class="line">    event_type = models.CharField(max_length=50, null=True, blank=True)   # 事件状态，是完成还是未完成，还是有风险等等</span><br><span class="line">    promotion_name = models.ForeignKey(Promotion, on_delete=models.CASCADE)     # 大促名称，是从大促表里取外键，这里做了联级删除，即大促表里的大促删除了，这里的事件也会删除</span><br><span class="line">    create_date = models.DateField(null=True, blank=True)     # 创建日期，默认是date(now())</span><br><span class="line">    priority = models.CharField(max_length=10, null=True, blank=True)   # 任务重要性</span><br><span class="line">    principal = models.CharField(max_length=20, null=True, blank=True)  # 责任人</span><br><span class="line">    acceptor = models.CharField(max_length=20, null=True, blank=True)   # 验收人</span><br><span class="line">    completion_time = models.DateField(null=True, blank=True)     # 任务实际完成日期</span><br><span class="line">    description = models.CharField(max_length=20, null=True, blank=True)   # 任务描述</span><br></pre></td></tr></table></figure></p>
<p>然后做一个前端，前端代码<code>calendar.html</code>如下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/fullcalendar/3.4.0/fullcalendar.css&quot;/&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot;</span><br><span class="line">          href=&quot;https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.0.0-alpha.6/css/bootstrap.css&quot;/&gt;</span><br><span class="line">    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.18.1/moment.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/fullcalendar/3.4.0/fullcalendar.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        $(document).ready(function () &#123;</span><br><span class="line">            var calendar = $(&#x27;#calendar&#x27;).fullCalendar(&#123;</span><br><span class="line">                header: &#123;</span><br><span class="line">                    left: &#x27;prev,next today&#x27;,</span><br><span class="line">                    center: &#x27;title&#x27;,</span><br><span class="line">                    right: &#x27;month,agendaWeek,agendaDay&#x27;</span><br><span class="line">                &#125;,</span><br><span class="line">                events: [</span><br><span class="line">			        &#123;% for i in events %&#125;	//这里对数据库内容作了循环展示</span><br><span class="line">			        &#123;</span><br><span class="line">			          title          : &#x27;&#123;&#123; i.event_name &#125;&#125;&#x27;,</span><br><span class="line">			          start          : new Date(2020 ,&#123;&#123; i.start_date|date:&quot; m-1, d&quot; &#125;&#125;),   // 这里格式是new Date(y, m, d)，所以用这样的写法，Django前端大法好！！！</span><br><span class="line">			          end          : new Date(2020 ,&#123;&#123; i.start_date|date:&quot; m-1, d&quot; &#125;&#125;),   // 这里格式是new Date(y, m, d)，所以用这样的写法，Django前端大法好！！！</span><br><span class="line">			          backgroundColor: &#x27;&#123;% if i.event_type == &quot;进行中&quot; %&#125; #00c0ef &#123;% elif i.event_type == &quot;有风险&quot; %&#125; #f56954 &#123;% elif i.event_type == &quot;已结束&quot; %&#125; #c9cc06 &#123;% elif i.event_type == &quot;未开始&quot; %&#125; #000000 &#123;% elif i.event_type == &quot;已验收&quot; %&#125; #00a65a &#123;% endif %&#125;&#x27;, //获取事件状态加以判断，赋予不同的颜色</span><br><span class="line">			          borderColor    : &#x27;&#123;% if i.event_type == &quot;进行中&quot; %&#125; #00c0ef &#123;% elif i.event_type == &quot;有风险&quot; %&#125; #f56954 &#123;% elif i.event_type == &quot;已结束&quot; %&#125; #c9cc06 &#123;% elif i.event_type == &quot;未开始&quot; %&#125; #000000 &#123;% elif i.event_type == &quot;已验收&quot; %&#125; #00a65a &#123;% endif %&#125;&#x27;, </span><br><span class="line">			          url            : &#x27;http://127.0.0.1:8000/naxx/event_detail/?id=&#123;&#123; i.id &#125;&#125;&#x27;,		// 这样可以点击任务，进行进一步的查看、修改或者删除</span><br><span class="line">			          allDay         : true  //由于我这个任务不需要精确到具体分钟，所以直接选择一整天</span><br><span class="line">			        &#125;,</span><br><span class="line">			        &#123;% endfor %&#125;</span><br><span class="line">			        ],</span><br><span class="line">                selectable: true,</span><br><span class="line">                selectHelper: true,</span><br><span class="line">                editable: true,</span><br><span class="line">                eventLimit: true,</span><br><span class="line">                select: function (start, end, allDay) &#123;</span><br><span class="line">                    var title = prompt(&quot;请输入任务名称：&quot;);</span><br><span class="line">                    if (title) &#123;</span><br><span class="line">                        var start = $.fullCalendar.formatDate(start, &quot;Y-MM-DD HH:mm:ss&quot;);</span><br><span class="line">                        	// 任务起始时间，可以精确到秒</span><br><span class="line">                        var end = $.fullCalendar.formatDate(end, &quot;Y-MM-DD HH:mm:ss&quot;);</span><br><span class="line">                        	// 任务结束时间</span><br><span class="line">                        $.ajax(&#123;</span><br><span class="line">                            type: &quot;GET&quot;,</span><br><span class="line">                            url: &#x27;/add_event&#x27;,	 //这里使用ajax将前端值传送到views.py</span><br><span class="line">                            data: &#123;&#x27;title&#x27;: title, &#x27;start&#x27;: start, &#x27;end&#x27;: end&#125;,</span><br><span class="line">                            dataType: &quot;json&quot;,</span><br><span class="line">                            success: function (data) &#123;</span><br><span class="line">                                calendar.fullCalendar(&#x27;refetchEvents&#x27;);</span><br><span class="line">		                        alert(&quot;添加任务成功！！！&quot;);</span><br><span class="line">		                        location.reload();  // 刷新一下页面</span><br><span class="line">                            &#125;,</span><br><span class="line">                            failure: function (data) &#123;</span><br><span class="line">                                alert(&#x27;添加失败，请检查问题！！！&#x27;);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;h2 align=&quot;center&quot;&gt;&lt;a href=&quot;#&quot;&gt;title&lt;/a&gt;&lt;/h2&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div id=&quot;calendar&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><br>此时在前端点击一下日历的具体日子就会弹出对话框来增加任务，如图：<br><img data-src="/images/%E7%82%B9%E5%87%BB%E6%97%A5%E5%8E%86%E5%8F%AF%E4%BB%A5%E5%A2%9E%E5%8A%A0%E4%BB%BB%E5%8A%A1.png" alt="akb48" title="可以通过点击日期来新增任务"></p>
<p>新增加<code>views.py</code>的内容如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Events 		<span class="comment"># 将Events引入</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 展示大促日历表</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calendar</span>(<span class="params">request</span>):</span><br><span class="line">    all_events = Events.objects.<span class="built_in">all</span>()</span><br><span class="line"></span><br><span class="line">    context = &#123;</span><br><span class="line">        <span class="string">&quot;events&quot;</span>: all_events,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render_to_response(<span class="string">&#x27;calendar.html&#x27;</span>, context)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增大促任务，点击日历对应日期框，通过AJAX传入</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_event</span>(<span class="params">request</span>):</span><br><span class="line">    start = request.GET.get(<span class="string">&quot;start&quot;</span>, <span class="literal">None</span>)</span><br><span class="line">    title = request.GET.get(<span class="string">&quot;title&quot;</span>, <span class="literal">None</span>)</span><br><span class="line">    new_event = Events(event_name=<span class="built_in">str</span>(title), start_date=start)</span><br><span class="line">    new_event.save()	<span class="comment"># 保存到数据库</span></span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> JsonResponse(data)</span><br></pre></td></tr></table></figure></p>
<p>在对应的创建一下<code>urls</code>：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">path(&#x27;calendar&#x27;, views.calendar, name=&#x27;calendar&#x27;),  # 日历表</span><br><span class="line">path(&#x27;add_event/&#x27;, views.add_event, name=&#x27;add_event&#x27;)  # 新增大促任务</span><br></pre></td></tr></table></figure></p>
<p>这样就OK了！</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/52991783">https://zhuanlan.zhihu.com/p/52991783</a><br><a href="https://zhuanlan.zhihu.com/p/44074860">https://zhuanlan.zhihu.com/p/44074860</a><br><a href="https://blog.csdn.net/u012836361/article/details/96427373">https://blog.csdn.net/u012836361/article/details/96427373</a><br><a href="https://www.youtube.com/watch?v=OePNkDd3Yb8&t=507s">https://www.youtube.com/watch?v=OePNkDd3Yb8&amp;t=507s</a> （youtube上的学习资源真的是被国内视频网站多多了）<br><a href="https://blog.starmeow.cn/detail/36660e59856b4de58a219bcf4e27eba3/">https://blog.starmeow.cn/detail/36660e59856b4de58a219bcf4e27eba3/</a></p>
<p><img data-src="/images/%E6%A2%85%E8%A5%BF%E6%89%93%E9%82%A3%E4%B8%8D%E5%8B%92%E6%96%AF%E7%9A%84%E8%B6%85%E7%BA%A7%E8%BF%9B%E7%90%83.gif" alt="akb48" title="这球给我看精神了！"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>平台搭建</tag>
        <tag>日程管理</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Logstash的正则匹配日志格式</title>
    <url>/2019/02/15/%E4%BD%BF%E7%94%A8Logstash%E7%9A%84%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="牛刀小试"><a href="#牛刀小试" class="headerlink" title="牛刀小试"></a>牛刀小试</h2><p>在ELK里经常需要写正则来匹配日志里的的具体信息，这样可以在<code>kibana</code>上更加直观的观看，<code>grok</code>就是Logstash最重要的插件。你可以在grok里预定义好命名正则表达式，在稍后(grok参数或者其他正则表达式里)引用它。</p>
<p>grok的格式是：<code>%{SYNTAX:SEMANTIC}</code>，如果需要转义就要加上<code>\</code>。具体的grok匹配规则可以在logstash查看<code>grok-patterns</code>这个文件，如图：<br><img data-src="/images/grok2.png" alt="akb48"></p>
<ol>
<li><code>SYNTAX</code>代表匹配值的类型，例如，<code>0.11</code>可以<code>NUMBER</code>类型所匹配，<code>10.222.22.25</code>可以使用<code>IP</code>匹配。</li>
<li><code>SEMANTIC</code>表示存储该值的一个变量声明，它会存储在<code>elasticsearch</code>当中方便<code>kibana</code>做字段搜索和统计，你可以将一个<code>IP</code>定义为客户端IP地址<code>client_ip_address</code>，eg:<code>%{IP:client_ip_address}</code>，所匹配到的值就会存储到<code>client_ip_address</code>这个字段里边，类似数据库的列名。</li>
</ol>
<p>而检测grok正则的网站：<a href="http://grokdebug.herokuapp.com/">http://grokdebug.herokuapp.com/</a> 。</p>
<p>举个例子，如果日志里是：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">100.97</span><span class="number">.73</span><span class="number">.142</span> - - [<span class="number">15</span>/Feb/<span class="number">2019</span>:<span class="number">16</span>:<span class="number">54</span>:<span class="number">24</span> +0800]</span><br></pre></td></tr></table></figure></p>
<p>可以看到里面有IP、日期、时间、时区，那么对比刚才的<code>grok-patterns</code>文件，就知道要匹配IP这个字段，就是用<code>IP (?:%{IPV6}|%{IPV4})</code>，IP即包含了IPV6也有IPV4，那么具体的匹配就是<code>%{IP:client}</code>，client是自己定义名称。同理，<code>[15/Feb/2019</code>这部分是日期，可以使用如下的配置规则：<br><img data-src="/images/grok3.png" alt="akb48"></p>
<p>如法炮制，匹配结果就是<code>\[%{MONTHDAY:day}/%{MONTH:month}/%{YEAR:year}</code>。</p>
<p>拿到检测网站试一下结果：<br><img data-src="/images/grok4.png" alt="akb48"></p>
<p>上面那个例子比较简单，比如匹配下面这样的一个日志：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">2019</span>-02-01T08:<span class="number">59</span>:<span class="number">59.124</span>] [INFO] default - [<span class="number">115.63</span><span class="number">.121</span><span class="number">.10</span> GET /wap/_nuxt/vendor<span class="number">.61</span>a8f274bce0acb0de6d.js <span class="number">200</span> 97s][https://www.lechange.com/wap/node/goodDetail/<span class="number">264</span> HTTP/<span class="number">1.1</span> Mozilla/<span class="number">5.0</span> (Linux; Android <span class="number">8.1</span>; V1818A Build/OPM1<span class="number">.171019</span><span class="number">.026</span>; wv) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Version/<span class="number">4.0</span> Chrome/<span class="number">57.0</span><span class="number">.2987</span><span class="number">.132</span> MQQBrowser/<span class="number">6.2</span> TBS/044409 Mobile Safari/<span class="number">537.36</span>]</span><br></pre></td></tr></table></figure></p>
<p>那么写法就是：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span>%&#123;YEAR:year&#125;-%&#123;MONTHNUM:month&#125;-%&#123;MONTHDAY:day&#125;T%&#123;HOUR:hour&#125;:?%&#123;MINUTE:minutes&#125;(?::?%&#123;SECOND:second&#125;)] \[%&#123;LOGLEVEL:level&#125;\] default - \[%&#123;IP:client&#125; %&#123;WORD:method&#125; %&#123;URIPATHPARAM:request&#125; %&#123;NUMBER:status&#125; %&#123;NUMBER:duration&#125;s\]\[%&#123;DATA:data&#125;\]</span><br></pre></td></tr></table></figure></p>
<p>效果如图:<br><img data-src="/images/grok1.png" alt="akb48"></p>
<p><font color=red>但是要注意!</font>在网站上的匹配可能是OK的，但是在logstash的grok里是不可以有<code>-、&#39;、&quot;</code>等这样的字符出现，比如下面这个日志：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">100.97</span><span class="number">.73</span><span class="number">.232</span> - - [<span class="number">15</span>/Feb/<span class="number">2019</span>:<span class="number">16</span>:<span class="number">54</span>:<span class="number">24</span> +0800] <span class="string">&quot;GET /public/app/site/statics/favicon.ico HTTP/1.1&quot;</span> <span class="number">200</span> <span class="number">4286</span> <span class="string">&quot;https://www.lechange.com/wap/&quot;</span> <span class="string">&quot;Mozilla/5.0 (Linux; Android 7.1.1; OPPO R11 Build/NMF26X; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/57.0.2987.132 MQQBrowser/6.2 TBS/044409 Mobile Safari/537.36 Imou&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>虽然下面的规则是可以正确匹配的：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%&#123;IP:client&#125; - - \[%&#123;MONTHDAY:day&#125;/%&#123;MONTH:month&#125;/%&#123;YEAR:year&#125;:%&#123;HOUR:hour&#125;:%&#123;MINUTE:minutes&#125;:%&#123;SECOND:second&#125; \+0800] \<span class="string">&quot;%&#123;WORD:method&#125; %&#123;URIPATH:request&#125; HTTP/%&#123;NUMBER:httpversion&#125;&quot;</span> %&#123;NUMBER:status&#125; %&#123;NUMBER:<span class="built_in">bytes</span>&#125; <span class="string">&quot;%&#123;DATA:website&#125;&quot;</span> <span class="string">&quot;%&#123;DATA:data&#125;&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>但是当你把这个配置复制到logstash.conf里的时候，启动logstash就会有参数不合法的报错：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">2019</span>-02-18T17:<span class="number">33</span>:<span class="number">52</span>,060][FATAL][logstash.runner          ] The given configuration <span class="keyword">is</span> invalid. Reason: Expected one of <span class="comment">#, &#123;, -, &quot;, &#x27;, &#125; at line 32, column 218 (byte 1226) 。</span></span><br></pre></td></tr></table></figure></p>
<p>应该改成这样：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%&#123;IPORHOST:client_ip&#125; %&#123;USER:ident&#125; %&#123;USER:auth&#125; \[%&#123;HTTPDATE:timestamp&#125;\] <span class="string">&quot;(?:%&#123;WORD:verb&#125; %&#123;NOTSPACE:request&#125;(?: HTTP/%&#123;NUMBER:http_version&#125;)?|-)&quot;</span> %&#123;NUMBER:response&#125; (?:%&#123;NUMBER:<span class="built_in">bytes</span>&#125;|-) %&#123;QUOTEDSTRING:domain&#125; %&#123;QUOTEDSTRING:data&#125;</span><br></pre></td></tr></table></figure></p>
<p>一般来说对于字符串，有双引号包含的用QS，没有的用DATA类型，如<code>%{DATA:request_body}</code>。</p>
<h2 id="grok配置到logstash"><a href="#grok配置到logstash" class="headerlink" title="grok配置到logstash"></a>grok配置到logstash</h2><p>假设这个服务的日志输入到kafka里的topic叫<code>lcshop-log</code>，那么对应的logstash如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">input</span> &#123;</span><br><span class="line">        kafka&#123;</span><br><span class="line">                bootstrap_servers=&gt;<span class="string">&quot;172.31.0.84:9092&quot;</span>	<span class="comment">#这里写的是kafka的ip和端口</span></span><br><span class="line">                topics=&gt;[<span class="string">&quot;lcshop-log&quot;</span>,<span class="string">&quot;lcshop-errorlog&quot;</span>]	<span class="comment">#这里是对应的topic</span></span><br><span class="line">                decorate_events=&gt;<span class="string">&quot;true&quot;</span></span><br><span class="line">                codec=&gt;plain</span><br><span class="line">        &#125;       </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="built_in">filter</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> [@metadata][kafka][topic] == <span class="string">&quot;lcshop-log&quot;</span> &#123;</span><br><span class="line">      mutate &#123;</span><br><span class="line">         add_field =&gt; &#123;<span class="string">&quot;[@metadata][index]&quot;</span> =&gt; <span class="string">&quot;lcshop-log-%&#123;+YYYY-MM&#125;&quot;</span>&#125;</span><br><span class="line">      &#125;  </span><br><span class="line">      grok &#123;	</span><br><span class="line">         <span class="keyword">match</span> =&gt; &#123; <span class="string">&quot;message&quot;</span> =&gt; <span class="string">&quot;%&#123;IPORHOST:client_ip&#125; %&#123;USER:ident&#125; %&#123;USER:auth&#125; \[%&#123;HTTPDATE:timestamp&#125;\] \&quot;(?:%&#123;WORD:verb&#125; %&#123;NOTSPACE:request&#125;(?: HTTP/%&#123;NUMBER:http_version&#125;)?|-)\&quot; %&#123;NUMBER:response&#125; (?:%&#123;NUMBER:bytes&#125;|-) %&#123;QUOTEDSTRING:domain&#125; %&#123;QUOTEDSTRING:data&#125;&quot;</span>&#125;</span><br><span class="line">         remove_field =&gt; [<span class="string">&quot;message&quot;</span>]</span><br><span class="line">		<span class="comment">#这里对双引号增加了转义符</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> [@metadata][kafka][topic] == <span class="string">&quot;lcshop-errorlog&quot;</span> &#123;</span><br><span class="line">      mutate &#123;</span><br><span class="line">         add_field =&gt; &#123;<span class="string">&quot;[@metadata][index]&quot;</span> =&gt; <span class="string">&quot;lcshop-errorlog-%&#123;+YYYY-MM&#125;&quot;</span>&#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">    stdout &#123;</span><br><span class="line">               codec =&gt; rubydebug		<span class="comment">#日志输出，这个看情况开启，生成日志量非常可观！</span></span><br><span class="line">       &#125;</span><br><span class="line">       elasticsearch &#123;</span><br><span class="line">               hosts=&gt;[<span class="string">&quot;172.31.0.76:9200&quot;</span>]		<span class="comment">#这里是es的ip和端口</span></span><br><span class="line">               index=&gt;<span class="string">&quot;%&#123;[@metadata][index]&#125;&quot;</span>		<span class="comment">#这里对不同的topic分配不同的index</span></span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后去kibana里查看结果,然而会发现这是失败的。</p>
<p>为什么明明在grok的测试网站里通过了，但是在实际的kibana里却失败？这是因为在kibana里会自动给双引号添加一个转义符！正式因为多了这个转义符，所以整段正则都不匹配了，自然grok无法生效了。</p>
<p>这个时候需要改成这样：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%&#123;IPORHOST:clientip&#125; - %&#123;NOTSPACE:remote_user&#125; \[%&#123;HTTPDATE:timestamp&#125;\] \\<span class="string">&quot;%&#123;DATA:request&#125;\\&quot;</span> %&#123;NUMBER:response&#125; %&#123;NUMBER:<span class="built_in">bytes</span>&#125; %&#123;DATA:data&#125; \\<span class="string">&quot;%&#123;DATA:detail&#125;\\&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>重启logstash之后，再去kibana里看结果：<br><img data-src="/images/grok5.png" alt="akb48"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://doc.yonyoucloud.com/doc/logstash-best-practice-cn/filter/date.html">https://doc.yonyoucloud.com/doc/logstash-best-practice-cn/filter/date.html</a><br><a href="https://segmentfault.com/q/1010000003801260">https://segmentfault.com/q/1010000003801260</a><br><a href="https://www.cnblogs.com/Orgliny/p/5592186.html">https://www.cnblogs.com/Orgliny/p/5592186.html</a><br><a href="http://kuring.me/post/elk_nginx/">http://kuring.me/post/elk_nginx/</a><br><a href="http://blog.51cto.com/seekerwolf/2106509">http://blog.51cto.com/seekerwolf/2106509</a><br><a href="http://blog.51cto.com/liqingbiao/1928653">http://blog.51cto.com/liqingbiao/1928653</a><br><a href="https://www.jianshu.com/p/d46b911fb83e">https://www.jianshu.com/p/d46b911fb83e</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>elk</tag>
        <tag>logstash</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Google Authenticator给ssh进行登录验证</title>
    <url>/2018/01/16/%E4%BD%BF%E7%94%A8Google-Authenticator%E7%BB%99ssh%E8%BF%9B%E8%A1%8C%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81/</url>
    <content><![CDATA[<p>普通情况下的服务器登录，是“服务器+密码”这种直白的验证方式，但是这种方式太过简单，一旦密码泄露，服务器就有危险，于是为了安全我们就要在登录上再加一把锁，那就是使用Google Authenticator（谷歌身份验证器）这个工具，在登录的时候进行一次验证，只有“验证通过了”+“密码正确”才能登陆服务器。</p>
<h2 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h2><p>1）关闭Selinux ：<code>setenforce 0</code><br>2）安装依赖：<code>yum -y install gcc make pam-devel libpng-devel libtool wget git</code><br>3）添加阿里云epel 源：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">RHEL</span> <span class="number">6</span>/<span class="title class_">Centos</span> <span class="number">6</span></span><br><span class="line">wget -O /etc/yum.<span class="property">repos</span>.<span class="property">d</span>/epel.<span class="property">repo</span> <span class="attr">http</span>:<span class="comment">//mirrors.aliyun.com/repo/epel-6.repo</span></span><br><span class="line"><span class="variable constant_">RHEL</span> <span class="number">7</span>/<span class="title class_">Centos</span> <span class="number">7</span></span><br><span class="line">wget -O /etc/yum.<span class="property">repos</span>.<span class="property">d</span>/epel.<span class="property">repo</span> <span class="attr">http</span>:<span class="comment">//mirrors.aliyun.com/repo/epel-7.repo</span></span><br></pre></td></tr></table></figure><br>4）安装Qrencode，谷歌身份验证器需要调用该程序生成二维码并显示：<code>yum install -y qrencode</code></p>
<h2 id="安装谷歌身份验证器"><a href="#安装谷歌身份验证器" class="headerlink" title="安装谷歌身份验证器"></a>安装谷歌身份验证器</h2><p>这个时候很多教程会让你去执行<code>git clone https://github.com/google/google-authenticator.git</code>，然而现在这个git里面已经不再含有libpam这个文件夹了，下载下来是一个错误的包，那么这个时候你可以使用<code>yum install google-authenticator</code>，不过yum安装的身份验证器的版本很老，这个时候可以执行<code>wget https://github.com/google/google-authenticator-libpam/archive/1.04.tar.gz</code>。</p>
<p>下载下来1.0.4版本的然后拆包解压缩，里面是这样几个文件：<br><img data-src="/images/google1.png" alt="办公室"></p>
<p>然后就<code>./bootstrap.sh &amp;&amp; ./configure &amp;&amp; make &amp;&amp; make install</code>进行编译和安装。</p>
<p>安装过程完毕之后，还要复制google身份验证器pam模块到系统下，命令是：<code>cp /usr/local/lib/security/pam_google_authenticator.so /lib64/security/</code>。</p>
<h2 id="调整登陆方式"><a href="#调整登陆方式" class="headerlink" title="调整登陆方式"></a>调整登陆方式</h2><p>1）编辑<code>/etc/pam.d/sshd</code>这个文件，我这个centos的版本是7.0的，里面的内容可能跟centos 6.x的优点不同，不过没关系，就需要插入黄色框内的<code>auth required pam_google_authenticator.so</code>，如图：<br><img data-src="/images/google2.png" alt="办公室"></p>
<p>修改完毕之后，保存退出。</p>
<p>注意！修改了这步之后，服务器千万不能断开连接，否则再连是需要google验证码的，而我们现在还没有生成码，所以肯定是无法连接服务器，如果是云服务器，可以通过登陆控制台的方式把这个文件修改回来，如果是实体服务器，那就呵呵呵了。</p>
<p>2）编辑<code>/etc/ssh/sshd_config</code>，就修改一个地方：<code>ChallengeResponseAuthentication yes</code><br>3）保存退出之后，重启一下ssh服务：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">RHEL6</span> /<span class="title class_">Centos6</span>：<span class="title class_">Service</span> sshd restart</span><br><span class="line"><span class="title class_">RHEL7</span> /<span class="title class_">Centos7</span>：<span class="title class_">Systemctl</span> resart sshd</span><br></pre></td></tr></table></figure></p>
<h2 id="生成登陆验证码"><a href="#生成登陆验证码" class="headerlink" title="生成登陆验证码"></a>生成登陆验证码</h2><p>这次以root用户为例，那么切换成root用户执行下面的过程。<br>1）执行<code>google-authenticator</code>，由于我们之前已经安装了<code>qrencode</code>，那么这个时候会生成一个超级超级巨大的二维码，给各位感受一下：<br><img data-src="/images/google3.png" alt="办公室"></p>
<p>红色内容是生成的密钥，很重要。绿色的内容是备用的紧急救助码，紧急救助码就是当你无法获取认证码时（比如手机丢了），可以当做认证码来用，每用一个少一个，但其实可以手动添加的，建议如果 root 账户使用 Google Authenticator 的话一定要把紧急救助码另外保存一份。<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Do you want me to update your <span class="string">&quot;/home/test/.google_authenticator&quot;</span> file? (y/n) y</span><br></pre></td></tr></table></figure></p>
<p>是否更新用户的 Google Authenticator 配置文件，选择 y 才能使上面操作对当前用户生效，其实就是在对应用户的 Home 目录下生成了一个 .google_authenticator 文件，如果你想停用这个用户的 Google Authenticator 验证，只需要删除这个用户 Home 目录下的 .google_authenticator 文件就可以了。<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Do you want to disallow multiple uses of the same authentication token? This restricts you to one login about every 30s, but it increases your chances to notice <span class="keyword">or</span> even prevent man-<span class="keyword">in</span>-the-middle attacks (y/n) y</span><br></pre></td></tr></table></figure></p>
<p>每次生成的认证码是否同时只允许一个人使用？这里选择 y。<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">By default, tokens are good <span class="keyword">for</span> <span class="number">30</span> seconds. In order to compensate <span class="keyword">for</span> possible time-skew between the client <span class="keyword">and</span> the server, we allow an extra token before <span class="keyword">and</span> after the current time. If you experience problems <span class="keyword">with</span> poor time synchronization, you can increase the window <span class="keyword">from</span> its default size of +-1<span class="built_in">min</span> (window size of <span class="number">3</span>) to about +-4<span class="built_in">min</span> (window size of <span class="number">17</span> acceptable tokens). Do you want to do so? (y/n) n</span><br></pre></td></tr></table></figure></p>
<p>是否增加时间误差？这里随便选择， ny都可以。<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">If the computer that you are logging into isn<span class="string">&#x27;t hardened against brute-force login attempts, you can enable rate-limiting for the authentication module. By default, this limits attackers to no more than 3 login attempts every 30s. Do you want to enable rate-limiting (y/n) y</span></span><br></pre></td></tr></table></figure><br>	<br>是否启用次数限制？这里选择 y，默认每 30 秒最多尝试登录 3 次。</p>
<p>如果想要写成脚本的话，那么上面交互式的设置也可用通过参数一次性设置：<code>google-authenticator -t -f -d -l test@chen.super -i MR.chen -r 3 -R 30 -W</code>。</p>
<p>-I和-i是可以随便写的，但是-i后期可以改，-I不能改。</p>
<h2 id="搭配手机端"><a href="#搭配手机端" class="headerlink" title="搭配手机端"></a>搭配手机端</h2><p>如果手机是ios，就去apple store里搜索“Google Authenticator”，如果是安卓，就去应用商店搜索“谷歌动态口令”。</p>
<p>安装完后，打开App，点击“开始设置”，选择“扫描条形码”扫描上面google-authenticator命令生成的二维码，或者是选择“输入密钥”，然后手机上就能看到对应的六位数认证码了。</p>
<p>最后一步，返回xshell，修改登陆方式，设置登陆方法为<code>Keyboard Interactive</code>，如图：<br><img data-src="/images/google4.png" alt="办公室"></p>
<p>这个时候，推荐各位保留原有的ssh不要动，在另外一个xshell窗口登陆一下看看效果，如果正常的话，这个时候会看到系统会让你先输入一个<code>Verification code</code>。这个值就是手机里的那个六位数，然后再输入密码，只有两个都是正确的，才能登陆！</p>
<p>至此整个配置完成，如果登陆时遇到问题，请查看日志文件<code>/var/log/secure</code>。</p>
<h2 id="更改存储位置"><a href="#更改存储位置" class="headerlink" title="更改存储位置"></a>更改存储位置</h2><p>在生成二维码那一步的时候，如果你错过了记住密钥也不要怕，系统会自动把密钥和紧急救助码保存在<code>~/.google_authenticator</code>这个文件里。</p>
<p>如果想要改变密钥存储位置，请使用–secret参数:<code>google-authenticator --secret=&quot;/文件路径/用户名&quot;</code>。</p>
<p>然后更改&#x2F;etc&#x2F;pam.d&#x2F;sshd内的路径配置:<code>auth required pam_google_authenticator.so user=root secret=/PATH_FOLDER/${USER}</code>。</p>
<p>上面那句话里“user&#x3D;root” 用于强制PAM使用root用户权限来搜索文件。</p>
<p>另外请注意，由于我们当时切换成了root用户，所以密钥文件的所有者是root，生成文件的用户只能读取文件(chmod: 400)：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chown root.<span class="property">root</span> /<span class="variable constant_">PATH_FILE</span>/<span class="variable constant_">SECRET_KEY_FILES</span></span><br><span class="line">chmod <span class="number">400</span> /<span class="variable constant_">PATH_FILE</span>/<span class="variable constant_">SECRET_KEY_FILES</span></span><br></pre></td></tr></table></figure></p>
<h2 id="使用chrome浏览器查看mfa"><a href="#使用chrome浏览器查看mfa" class="headerlink" title="使用chrome浏览器查看mfa"></a>使用chrome浏览器查看mfa</h2><p>如果你没有带手机，如何查看mfa呢？请使用chrome的插件<a href="http://gauth.apps.gbraad.nl/">http://gauth.apps.gbraad.nl/</a> 。 然后手动添加即可，但是要注意，这台电脑不能断网太久哦，不然就会自动删除。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Docker部署Prometheus</title>
    <url>/2019/10/08/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2Prometheus/</url>
    <content><![CDATA[<p>关于prometheus的基础内容，可以去看<a href="https://www.hi-linux.com/posts/25047.html">https://www.hi-linux.com/posts/25047.html</a> 、<a href="https://yunlzheng.gitbook.io/prometheus-book/">https://yunlzheng.gitbook.io/prometheus-book/</a> 和<a href="https://www.ibm.com/developerworks/cn/cloud/library/cl-lo-prometheus-getting-started-and-practice/index.html">https://www.ibm.com/developerworks/cn/cloud/library/cl-lo-prometheus-getting-started-and-practice/index.html</a> 。</p>
<p>服务器说明：阿里云centos 7.6（内网IP：172.31.0.85） + docker 19.03.2 + git 1.8 + go 1.13</p>
<p>go的安装方法如下，国内可用：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rpm --<span class="keyword">import</span> https://mirror.go-repo.io/centos/RPM-GPG-KEY-GO-REPO</span><br><span class="line">curl -s https://mirror.go-repo.io/centos/go-repo.repo | tee /etc/yum.repos.d/go-repo.repo</span><br><span class="line">yum install -y golang</span><br></pre></td></tr></table></figure></p>
<h2 id="部署Prometheus-Server"><a href="#部署Prometheus-Server" class="headerlink" title="部署Prometheus Server"></a>部署Prometheus Server</h2><p>首先，创建一个普通用户，比如叫<code>lcshop</code>，然后<code>gpasswd -a lcshop docker</code>，把lcshop用户添加到docker组里。</p>
<p>然后在<code>/mnt</code>下创建<code>promethues</code>文件夹和子文件夹<code>server</code>，树形结构如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[lcshop@lcshop-Prometheus mnt]$ tree</span><br><span class="line">.</span><br><span class="line">└── prometheus</span><br><span class="line">    └── server</span><br><span class="line">        ├── prometheus.yml</span><br><span class="line">        └── rules.yml</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> directories, <span class="number">2</span> files</span><br><span class="line">[lcshop@lcshop-Prometheus mnt]$ </span><br></pre></td></tr></table></figure></p>
<p>其中<code>/mnt/promethues/server/prometheus.yml</code>的内容是这样的：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">global</span>:</span><br><span class="line">  scrape_interval:     60s <span class="comment"># 默认抓取间隔, 60秒向目标抓取一次数据。</span></span><br><span class="line">  external_labels:</span><br><span class="line">    monitor: <span class="string">&#x27;codelab-monitor&#x27;</span></span><br><span class="line"><span class="comment"># 这里表示抓取对象的配置</span></span><br><span class="line">rule_files:</span><br><span class="line">  <span class="comment">#- &#x27;prometheus.rules&#x27;</span></span><br><span class="line">scrape_configs:</span><br><span class="line"> <span class="comment">#这个配置是表示在这个配置内的时间序例，每一条都会自动添加上这个&#123;job_name:&quot;prometheus&quot;&#125;的标签  </span></span><br><span class="line">  - job_name: <span class="string">&#x27;prometheus&#x27;</span></span><br><span class="line">    scrape_interval: 30s <span class="comment">#重写了全局抓取间隔时间，由15秒重写成30秒</span></span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [<span class="string">&#x27;localhost:9090&#x27;</span>]</span><br><span class="line">        labels:</span><br><span class="line">          group: <span class="string">&#x27;prometheus&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>至于<code>rules.yml</code>暂时先为空，再把整个<code>/mnt/promethues</code>文件夹及内部所有文件所属组改成<code>lcshop：docker</code>，启动docker进程：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">docker run --name=prometheus -d -p <span class="number">9090</span>:<span class="number">9090</span> -v /mnt/prometheus/server/prometheus.yml:/etc/prometheus/prometheus.yml -v /mnt/prometheus/server/rules.yml:/etc/prometheus/rules.yml -v /etc/localtime:/etc/localtime:ro prom/prometheus:v2<span class="number">.7</span><span class="number">.2</span> --config.file=/etc/prometheus/prometheus.yml --web.enable-lifecycle</span><br></pre></td></tr></table></figure></p>
<p>阿里云安全组放行9090端口，在浏览器使用<code>外网IP:9090</code>就会看到Prometheus的界面：<br><img data-src="/images/prometheus.png" alt="akb48"></p>
<p>如果输入一些监控值，就会出现对应值的结果：<br><img data-src="/images/prometheus2.png" alt="akb48"></p>
<h2 id="部署Prometheus-metrics接口"><a href="#部署Prometheus-metrics接口" class="headerlink" title="部署Prometheus metrics接口"></a>部署Prometheus metrics接口</h2><p>目前我们的server和grafana已经通了，但是仅仅是有一些无实际作用的指标，我们需要收集服务器的指标，收集指标的东西叫<code>node-exporter</code>。这是一个有点类似于zabbix-agent的东西，会帮你收集系统指标和一些软件运行的指标，把指标暴露出去。Prometheus官方是不推荐用Docker来运行 <code>node_exporter</code>的，因为Docker的文件系统和网络都有自己的namespace，收集的数据并不是宿主机真实的指标。所以我们这里还是用常规的方法，安装方法如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cd /usr/local/ &amp;&amp; mkdir node_exporter</span><br><span class="line">   cd /usr/local/node_exporter</span><br><span class="line">wget https://github.com/prometheus/node_exporter/releases/download/v0<span class="number">.18</span><span class="number">.1</span>/node_exporter-<span class="number">0.18</span><span class="number">.1</span>.linux-amd64.tar.gz</span><br><span class="line">tar -zxvf node_exporter-<span class="number">0.18</span><span class="number">.1</span>.linux-amd64.tar.gz</span><br><span class="line">cd node_exporter-<span class="number">0.18</span><span class="number">.1</span>.linux-amd64</span><br><span class="line">./node_exporter</span><br></pre></td></tr></table></figure></p>
<p>这个启动是前台启动，监听9100端口。我们要改一下，改成systemctl启动，这样后台启动更好。创建<code>/usr/lib/systemd/system/node_exporter.service</code>如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=node_exporter</span><br><span class="line">[Service]</span><br><span class="line">Restart=on-failure</span><br><span class="line">ExecStart=/usr/local/node_exporter/node_exporter-<span class="number">0.18</span><span class="number">.1</span>.linux-amd64/node_exporter	<span class="comment">#这里填写的node_exporter 文件的全路径，不然无法启动</span></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></p>
<p>保存退出，<code>systemctl daemon-reload</code>之后再<code>systemctl start node_exporter.service</code>就启动了，然后可以<code>curl http://localhost:9100/metrics</code>查看一下是否正常获取服务器指标，如图：<br><img data-src="/images/prometheus19.png" alt="akb48"></p>
<p>确认可以正常获取到指标之后，就重新编写一下<code>prometheus.yml</code>:<br>	<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">global:</span><br><span class="line">  scrape_interval:     <span class="number">60</span>s # 默认抓取间隔, <span class="number">60</span>秒向目标抓取一次数据。</span><br><span class="line">  external_labels:</span><br><span class="line">    monitor: <span class="string">&#x27;codelab-monitor&#x27;</span></span><br><span class="line"># 这里表示抓取对象的配置</span><br><span class="line">rule_files:</span><br><span class="line">  #- <span class="string">&#x27;prometheus.rules&#x27;</span></span><br><span class="line">scrape_configs:</span><br><span class="line"> #这个配置是表示在这个配置内的时间序例，每一条都会自动添加上这个&#123;job_name:<span class="string">&quot;prometheus&quot;</span>&#125;的标签  </span><br><span class="line">  - job_name: <span class="string">&#x27;prometheus&#x27;</span></span><br><span class="line">    scrape_interval: <span class="number">30</span>s #重写了全局抓取间隔时间，由<span class="number">15</span>秒重写成<span class="number">30</span>秒</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [<span class="string">&#x27;localhost:9090&#x27;</span>]</span><br><span class="line">        labels:</span><br><span class="line">          group: <span class="string">&#x27;prometheus&#x27;</span></span><br><span class="line"></span><br><span class="line">  - job_name: <span class="string">&#x27;server&#x27;</span></span><br><span class="line">    scrape_interval: <span class="number">30</span>s</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [<span class="string">&#x27;172.31.0.85:9100&#x27;</span>]	#本机IP</span><br><span class="line">        labels:</span><br><span class="line">          group: <span class="string">&#x27;server&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>然后重启prometheus容器，重新载入配置文件。然后在web端的<code>Status -&gt; Targets</code>可以看到添加的<code>node-exporter</code>：<br><img data-src="/images/prometheus6.png" alt="akb48"></p>
<p>保存之后，就可以在graph页面里查看一些指标。</p>
<p>Prometheus针对mysql、nginx、jmx都有官方的指标收集策略，感兴趣可以去看<a href="https://www.aneasystone.com/archives/2018/11/prometheus-in-action.html">https://www.aneasystone.com/archives/2018/11/prometheus-in-action.html</a> 。</p>
<h2 id="接入Grafana"><a href="#接入Grafana" class="headerlink" title="接入Grafana"></a>接入Grafana</h2><p>Docker部署Grafana的语句可见<a href="https://rorschachchan.github.io/2019/08/22/%E6%90%AD%E9%85%8DInfluxDB-CADvisor-Grafana%E7%BB%84%E5%90%88%E7%9B%91%E6%8E%A7Docker/">https://rorschachchan.github.io/2019/08/22/%E6%90%AD%E9%85%8DInfluxDB-CADvisor-Grafana%E7%BB%84%E5%90%88%E7%9B%91%E6%8E%A7Docker/</a> ，启动之后登录到grafana界面，在<code>Data Source</code>里选择<code>Prometheus</code>，然后就填写对应的url即可：<br><img data-src="/images/prometheus4.png" alt="akb48"></p>
<p>点击旁边的Dashboards，就会有三张模板，根据需要import。如果import了<code>prometheus 2.0 stats</code>，那么生成的格式就是这样的：<br><img data-src="/images/prometheus5.png" alt="akb48"></p>
<p>页面看上去还是挺有科技感的，保留这个骨架改一下里面具体的监控项就好了。</p>
<p>Prometheus的监控项跟zabbix的item不一样，它的监控项叫Element，格式是类似这样的：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">node_load15&#123;group=<span class="string">&quot;server&quot;</span>,instance=<span class="string">&quot;172.31.0.85:9100&quot;</span>,job=<span class="string">&quot;server&quot;</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个的意思就是<code>172.31.0.85</code>这个服务器的cpu 15分钟的负载。<code>group、job、instance</code>这些都是这个Element的标签。那么如何找到Element呢？在prometheus的web界面的graph里的console就能看到，如图：<br><img data-src="/images/prometheus7.png" alt="akb48" title="这个就叫PromQL的表达式"></p>
<p>然后在grafana页面在对应的表格里添加该element即可：<br><img data-src="/images/prometheus8.png" alt="akb48"></p>
<h2 id="故障排错"><a href="#故障排错" class="headerlink" title="故障排错"></a>故障排错</h2><p>在<code>go build</code>的时候，可能会出现大陆特色错误：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">go: golang.org/x/sys@v0<span class="number">.0</span><span class="number">.0</span>-<span class="number">20190927073244</span>-c990c680b611: unrecognized <span class="keyword">import</span> path <span class="string">&quot;golang.org/x/sys&quot;</span> (https fetch: Get https://golang.org/x/sys?go-get=<span class="number">1</span>: dial tcp <span class="number">216.239</span><span class="number">.37</span><span class="number">.1</span>:<span class="number">443</span>: i/o timeout)</span><br></pre></td></tr></table></figure></p>
<p>此时需要<code>export GOPROXY=https://goproxy.io</code>就OK，如图：<br><img data-src="/images/prometheus3.png" alt="akb48"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://shockerli.net/post/go-get-golang-org-x-solution/">https://shockerli.net/post/go-get-golang-org-x-solution/</a><br><a href="https://www.aneasystone.com/archives/2018/11/prometheus-in-action.html">https://www.aneasystone.com/archives/2018/11/prometheus-in-action.html</a><br><a href="https://blog.xizhibei.me/2017/08/06/monitoring-with-prometheus/">https://blog.xizhibei.me/2017/08/06/monitoring-with-prometheus/</a><br><a href="https://yunlzheng.gitbook.io/prometheus-book/">https://yunlzheng.gitbook.io/prometheus-book/</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>监控</tag>
        <tag>Prometheus</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Nessus进行漏洞扫描的过程</title>
    <url>/2018/01/23/%E4%BD%BF%E7%94%A8Nessus%E8%BF%9B%E8%A1%8C%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>对于一个服务器运维工作者，掌握和运用一门漏洞扫描的工具也是行走江湖的必备项，Nessus就是漏洞扫描的强力武器。Nessus为一款当下比较流行的系统弱点扫描与分析软件，他的优点是操作简单（配置几乎全web化），而且页面精美、扫描项广泛；缺点就是目前不支持中文…</p>
<h2 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h2><p>要安装Nessus，需要登陆<code>https://www.tenable.com/products/nessus/select-your-operating-system</code>,选择对应的系统，我这个服务器是centos 7，那么就选择下图里红色的那个rpm包：<br><img data-src="/images/nessus1.png" alt="paradin"></p>
<p>点击之后，出来一个同意条款，同意之后就开始自动下载。但是要安装nessus仅仅有程序是不够的，还需要一个对应的验证码，在上面那个界面里，下拉一点有一个<code>get an activation code</code>的check，点击之后跳转到<code>https://www.tenable.com/products/nessus/nessus-plugins/obtain-an-activation-code</code>，里选择家用free版，点击下面的<code>register now</code>：<br><img data-src="/images/nessus2.png" alt="paradin"></p>
<p>注册是很简单的，填写名称和电邮就可以了。不久后就会在电子邮件里面获得一个校验码。</p>
<p>把下载的那个Nessus-6.11.1-es7.x86_64.rpm包上传到centos之后，<code>rpm -ivh Nessus-6.11.1-es7.x86_64.rpm</code>进行安装，安装完成之后，<code>service nessusd start</code>启动进程，启动完毕之后，使用<code>netstat -lnpt|grep 8834</code>，来检查一下8834端口是否被监听，如图：<br><img data-src="/images/nessus3.png" alt="paradin"></p>
<p>端口监听OK，那么在浏览器里输入<code>https://服务器外网IP地址:8834</code>打开控制web界面，如果有提示当前连接不安全，无视掉就可以。nessus的欢迎界面如下：<br><img data-src="/images/nessus4.png" alt="paradin"></p>
<p>注册一个账号之后，在这个界面里面选择home那一条，输入邮箱里面获得的那个注册码：<br><img data-src="/images/nessus5.png" alt="paradin"></p>
<p>整个的配置就完事了，继而就是nessus自动安装的过程，大约需要几分钟：<br><img data-src="/images/nessus6.png" alt="paradin"></p>
<p>整个安装完毕之后，就会看到nessus的主界面，简单明了的风格：<br><img data-src="/images/nessus7.png" alt="paradin"></p>
<p>至此整个nessus的安装过程结束。</p>
<h2 id="配置扫描策略以及启动扫描任务"><a href="#配置扫描策略以及启动扫描任务" class="headerlink" title="配置扫描策略以及启动扫描任务"></a>配置扫描策略以及启动扫描任务</h2><p>nessus扫描漏洞的流程很简单：需要先”制定策略”，然后在这个策略的基础上建立”扫描任务”，然后执行任务。首先，我们先建立一个<code>policy</code>，如图：<br><img data-src="/images/nessus8.png" alt="paradin"></p>
<p>点击<code>New Policy</code>之后，就会出现很多种扫描策略，这里我们选择<code>Advanced Scan</code>(高级扫描)：<br><img data-src="/images/nessus9.png" alt="paradin"> </p>
<p>我给这个测试的扫描策略，起名叫”chenchenchen”，如图：<br><img data-src="/images/nessus10.png" alt="paradin"> </p>
<p>对于上面这个图，<code>Permissions</code>是权限管理，是否可以准许其他的nessus用户来使用你这个策略；<code>Discovery</code>里面有主机发现、端口扫描和服务发现等功能；<code>assessment</code>里面有对于暴力攻击的一些设定；<code>Report</code>里面是报告的一些设定；Advanced里面是一些超时、每秒扫描多少项等基础设定，一般来说这里默认就好。我们主要来看看那个<code>plugins</code>。</p>
<p><code>Plugins</code>里面就是具体的策略，里面有父策略，具体的父策略下面还有子策略，把这些策略制定得体的话，使用者可以更加有针对性的进行扫描。比如我这个策略是针对于centos系统的扫描策略，那么一些冗余的项目大可以完全不要，举个例子：<br><img data-src="/images/nessus11.png" alt="paradin"> </p>
<p>在上面这个图里面，我不需要<code>amazon linux local security checks</code>这个“亚马逊linux本地安全检查”父策略，那就把它disabled掉，而对于<code>centos local security checks</code>这个父策略呢，我又不需要那几个关于bind的子策略，那我就单独把那些子策略disabled掉，这样等等操作，就搭配成为了一个用时不长但是又包含了所有制定的检查项的策略，然后点击<code>save</code>保存。</p>
<p>保存完后，我们就发现policy里多了一条<code>chenchenchen</code>的记录：<br><img data-src="/images/nessus12.png" alt="paradin"> </p>
<p>既然策略有了，现在我们就来制定一个任务。在主界面里选择<code>My Scans</code>,点击<code>New Scans</code>,这个时候还是有很多个图标，但是我们选择后面的<code>User defined</code>，如图：<br><img data-src="/images/nessus13.png" alt="paradin"> </p>
<p>这里我们就看到了我们已经制定好的那个chenchenchen策略，点击这个chenchenchen之后，就要给这个依赖chenchenchen策略的任务起名字以及需要扫描的网络段，由于我这个测试机的内网ip段是10.132.27.0，于是我就写了“10.132.27.0&#x2F;24”，任务名字叫chentest：<br><img data-src="/images/nessus14.png" alt="paradin"> </p>
<h2 id="启动扫描任务"><a href="#启动扫描任务" class="headerlink" title="启动扫描任务"></a>启动扫描任务</h2><p>点击save保存之后，就会看到My Scans里多了这个chentest的任务，点击三角播放箭头，那么这个任务就开始执行了！如图：<br><img data-src="/images/nessus15.png" alt="paradin"> </p>
<p>从该界面可以看到扫描任务的状态为Running（正在运行），表示chentest扫描任务添加成功。如果想要停止扫描，可以单击方块（停止一下）按钮。如果暂停扫描任务，单击暂停按钮。</p>
<p>扫描完毕之后，我们就会看到一个结果反馈，如图：<br><img data-src="/images/nessus16.png" alt="paradin"> </p>
<p>具体的颜色代表，在旁边有描述，例子里这些蓝色的info代表没有重大漏洞，点击一下蓝色，还会出现更加详细的信息，包括IP地址、操作系统类型、扫描的起始时间和结束时间：<br><img data-src="/images/nessus17.png" alt="paradin"> </p>
<p><img data-src="/images/nessus18.png" alt="paradin"> </p>
<p>同时，nessus还支持pdf、web、csv等多种方式汇报扫描结果，至此，整个nessus漏洞扫描的全过程就结束了。</p>
<h2 id="Nessus配置smtp"><a href="#Nessus配置smtp" class="headerlink" title="Nessus配置smtp"></a>Nessus配置smtp</h2><p>Nessus漏洞扫描是提供邮件服务，可以将扫描的结果发送给指定的邮箱。配置它的方法很简单，先登陆Nessus的界面，点击左上角的<code>settings</code>，然后选择左侧菜单栏里的<code>Smtp server</code>，如图：<br><img data-src="/images/nessus19.png" alt="paradin"></p>
<p>再就是填写对应的项目，我这里发送邮件的地址是：<code>chenx3314@sina.com</code>，接受的地址是<code>124208739@qq.com</code>，由于发送邮件使用的是新浪的邮箱，那么host就填写新浪的smtp服务器，即smtp.sina.com，如果是要SSL加密的话，端口写465，同时在Encryption那里选择<code>Force SSL</code>，在Auth Method那里选择<code>login</code>的鉴权方式，然后输入<a href="mailto:&#x63;&#104;&#101;&#110;&#x78;&#x33;&#x33;&#49;&#52;&#64;&#x73;&#x69;&#110;&#97;&#x2e;&#x63;&#x6f;&#109;">chenx3314@sina.com</a>的账号密码，如图：<br><img data-src="/images/nessus20.png" alt="paradin"></p>
<p>点击<code>Send Test Email</code>，然后输入接收的邮箱，如果是多个邮箱那么就用英文逗号隔开。看到成功的提示就是OK了：<br><img data-src="/images/nessus21.png" alt="paradin"></p>
<p>然后就可以到邮箱里面看到那个测试的邮件内容：<br><img data-src="/images/nessus22.png" alt="paradin"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>运维技术</tag>
        <tag>nessus</tag>
      </tags>
  </entry>
  <entry>
    <title>使用GTID主从同步阿里云RDS到自建Mysql</title>
    <url>/2019/09/26/%E4%BD%BF%E7%94%A8GTID%E5%A4%87%E4%BB%BD%E9%98%BF%E9%87%8C%E4%BA%91RDS%E5%88%B0%E8%87%AA%E5%BB%BAMYSQL/</url>
    <content><![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>传统的MYSQL主从就是主库每做一个操作会在binlog上做一个position，每做一个event就在binlog做一个起始编号、一个终止编号。然后主库把binlog传递给从库，然后从库根据这个binlog的pos值就按照顺序做一样的操作，达到两个数据库保持一致的目的。</p>
<p>GTID不用这个position的方式，而是用了<code>全局事物标识</code>，这个标识的格式是<code>source_id:transaction_id</code>，如3E11FA47-71CA-11E1-9E33-C80AA9429562:23：</p>
<ol>
<li><code>source_id</code>即是<code>server_uuid</code>，在第一次启动时生成(函数 generate_server_uuid)，并持久化到<code>DATADIR/auto.cnf</code>文件里；</li>
<li><code>transaction_id</code>是顺序化的序列号(sequence number)，在每台 MySQL 服务器上都是从 1 开始<code>自增长</code>的序列，是事务的唯一标识；</li>
</ol>
<p>它的主从过程是这样的：主库更新数据时，会在事务前产生GTID，连通sql记录到<code>binlog</code>日志中。从库的<code>i/o</code>线程将变更的<code>binlog</code>写入到<code>relay log</code>中,读取值是根据<code>gitd_next变量</code>，告诉从库下一个执行哪个GTID。从库的sql线程从<code>relay log</code>中获取GTID，然后对比从库的的<code>binlog</code>是否有记录。如果有记录，说明该GTID的事务已经执行，从库会忽略。如果没有记录，从库就会从<code>relay log</code>中执行该GTID的事务，并记录到从库<code>binlog</code>。在解析过程中会判断是否有主键，如果没有就用二级索引，如果没有二级索引就用全部扫描。</p>
<p>也就是说，无论是级联情况，还是一主多从情况，都可以通过GTID自动找点儿，而无需像之前那样通过<code>binlog</code>和<code>binlog_position</code>找点儿了。更多GTID 原理的知识可以去查看：<a href="https://keithlan.github.io/2016/06/23/gtid/">https://keithlan.github.io/2016/06/23/gtid/</a> 。</p>
<p><font color=red>注意！</font>由于RDS for MySQL 5.6版本引入了GTID特性，因此要求应用不能够在事务中创建和删除临时表。那么如何对待临时表？</p>
<ol>
<li>将SQL语句里的<code>temporary table</code>语句更改为<code>table</code>，使用普通表替代临时表，规避这个问题；</li>
<li>修改代码，将临时表的创建和删除操作放在事务外，并且保证会话的参数<code>autocommit=1</code>；</li>
</ol>
<p>源RDS地址（内网）：rm-bp12k8yne0909uv68.mysql.rds.aliyuncs.com<br>目标ECS地址（内网）：172.31.0.67</p>
<h2 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h2><p>首先是现在ECS里安装<code>mysql 5.6</code>。由于centos 7默认安装的数据库是mariabd，所以使用tar.gz包安装。<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">wget -c <span class="string">&quot;http://dev.mysql.com/get/Downloads/MySQL-5.6/mysql-5.6.33-linux-glibc2.5-x86_64.tar.gz&quot;</span></span><br><span class="line">tar zxvf mysql-<span class="number">5.6</span><span class="number">.33</span>-linux-glibc2<span class="number">.5</span>-x86_64.tar.gz -C /usr/local/</span><br><span class="line">cd /usr/local &amp;&amp; ln -s mysql-<span class="number">5.6</span><span class="number">.33</span>-linux-glibc2<span class="number">.5</span>-x86_64 mysql</span><br><span class="line">mkdir -p /home/mysql/data</span><br><span class="line">chown -R mysql.mysql /home/mysql &amp;&amp; chmod -R o=--- /home/mysql		<span class="comment"># chmod -o是其他以外的人</span></span><br></pre></td></tr></table></figure></p>
<p>使用<code>service mysqld start</code>启动，再用<code>mysql -u root -p </code>登录进去，修改掉root的空密码：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mysql&gt; update mysql.user <span class="built_in">set</span> password=password(<span class="string">&#x27;123123123&#x27;</span>) where user=<span class="string">&#x27;root&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">4</span> rows affected (<span class="number">0.00</span> sec)</span><br><span class="line">Rows matched: <span class="number">4</span>  Changed: <span class="number">4</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>要进行GTID，首先要确认阿里云RDS作为主库是否支持GTID，如图：<br><img data-src="/images/gtid1.png" alt="akb48"></p>
<p>可见阿里云那一段是没问题的。</p>
<p>然后安装xtrabackup，由于我们是<code>mysql 5.6</code>，所以xtrabackup的版本是2.3：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">wget https://www.percona.com/downloads/XtraBackup/Percona-XtraBackup-<span class="number">2.3</span><span class="number">.5</span>/binary/redhat/<span class="number">7</span>/x86_64/percona-xtrabackup-<span class="number">2.3</span><span class="number">.5</span>-<span class="number">1.</span>el7.x86_64.rpm</span><br><span class="line">yum localinstall percona-xtrabackup-<span class="number">2.3</span><span class="number">.2</span>-<span class="number">1.</span>el7.x86_64.rpm</span><br></pre></td></tr></table></figure></p>
<p>最后，检查RDS白名单，确保ECS与RDS可通。</p>
<h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><p>登录阿里云的RDS控制台，选择对应的RDS之后，点击左侧栏的<code>备份恢复</code>，将最近的一次备份下载下来：<br><img data-src="/images/gtid2.png" alt="akb48"></p>
<p>由于是内网，直接就<code>复制内网地址</code>，在ECS上执行如下操作：<br>	<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">wget -c <span class="string">&#x27;&lt;数据备份文件外网下载地址&gt;&#x27;</span> -O /home/mysql/shopoms.tar.gz	#注意引号一定要带！</span><br><span class="line">tar -izxvf shopoms.tar.gz -C /home/mysql/shopoms	#解压缩</span><br></pre></td></tr></table></figure></p>
<p>解压缩完毕之后，打开&#x2F;opt&#x2F;shopoms看一下文件组成：<br><img data-src="/images/gtid3.png" alt="akb48"></p>
<p>用xtrabackup工具恢复解压好的备份文件，于是<code>innobackupex --defaults-file=/home/mysql/data/backup-my.cnf --apply-log /home/mysql/data</code>。稍等一会，解压缩成功，备份一下<code>backup-my.cnf</code>，改名叫<code>slave-oms.cnf</code>：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># from rds backup-my.cnf</span></span><br><span class="line">innodb_checksum_algorithm=innodb</span><br><span class="line">innodb_data_file_path=ibdata1:200M:autoextend</span><br><span class="line">innodb_log_files_in_group=<span class="number">2</span></span><br><span class="line">innodb_log_file_size=<span class="number">524288000</span></span><br><span class="line">innodb_undo_directory=.</span><br><span class="line">innodb_undo_tablespaces=<span class="number">0</span></span><br><span class="line"><span class="comment"># need for slave </span></span><br><span class="line">server-<span class="built_in">id</span> = <span class="number">666</span> 	<span class="comment"># 从实例的id,不能与master的id相同</span></span><br><span class="line">port=<span class="number">3306</span></span><br><span class="line">master-info-repository = file</span><br><span class="line">relay-log-info_repository = file</span><br><span class="line">binlog-<span class="built_in">format</span> = ROW		<span class="comment"># 这里必须是ROW</span></span><br><span class="line">skip-grant-tables   <span class="comment">##忽略mysql权限问题，免密码直接登录</span></span><br><span class="line"><span class="comment"># GTID</span></span><br><span class="line">gtid-mode = ON		<span class="comment"># 打开了gtid模式</span></span><br><span class="line">enforce-gtid-consistency = true</span><br><span class="line">log-<span class="built_in">bin</span> = hostname-<span class="built_in">bin</span></span><br><span class="line">relay-log = /tmp/relay.log	<span class="comment">#注意这个文件要被mysql用户读取到，如果这里不设定对，就会有Slave failed to initialize relay log info structure from the repository的错误</span></span><br><span class="line">expire_logs_days=<span class="number">10</span> <span class="comment"># 控制binlog日志文件保留时间</span></span><br><span class="line">max_binlog_size=100M             </span><br><span class="line">replicate-ignore-db=mysql   <span class="comment"># 不需要同步的库  </span></span><br><span class="line">log-slave-updates=<span class="number">1</span></span><br><span class="line"><span class="comment"># Recommended in standard MySQL setup</span></span><br><span class="line">sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES </span><br><span class="line">[mysqld_safe]</span><br><span class="line">log-error=/var/log/mysqld.log</span><br><span class="line">pid-file=/var/run/mysqld/mysqld.pid</span><br><span class="line">socket = /tmp/mysql.sock</span><br></pre></td></tr></table></figure></p>
<p>同时<code>chown -R mysql:mysql /home/mysql/data</code>修改文件属主，并确定文件所属为MySQL用户。然后执行<code>/usr/local/mysql/bin/mysqld_safe --defaults-file=/home/mysql/data/slave-oms.cnf --user=mysql --basedir=/usr/local/mysql --datadir=/home/mysql/data &amp;</code>启动mysql。如图：<br><img data-src="/images/gtid7.png" alt="akb48"></p>
<p>然后使用root账号登陆该mysql：<br><img data-src="/images/gtid4.png" alt="akb48"></p>
<p>添加主库信息：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mysql&gt; change master to</span><br><span class="line">    -&gt; master_host=<span class="string">&#x27;rm-bp12k8yne0909uv68.mysql.rds.aliyuncs.com&#x27;</span>,</span><br><span class="line">    -&gt; master_user=<span class="string">&#x27;oms&#x27;</span>,master_port=<span class="number">3306</span>,master_password=<span class="string">&#x27;对应密码&#x27;</span>,</span><br><span class="line">    -&gt; master_auto_position=<span class="number">1</span>;</span><br><span class="line">ERROR <span class="number">1794</span> (HY000): Slave <span class="keyword">is</span> <span class="keyword">not</span> configured <span class="keyword">or</span> failed to initialize properly. You must at least <span class="built_in">set</span> --server-<span class="built_in">id</span> to enable either a master <span class="keyword">or</span> a slave. Additional error messages can be found <span class="keyword">in</span> the MySQL error log.</span><br></pre></td></tr></table></figure></p>
<p>原因是由于RDS的备份文件中包含了RDS的主从复制关系，需要把这些主从复制关系清理掉，清理方法：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mysql&gt; truncate table mysql.slave_relay_log_info;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.14</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; truncate table mysql.slave_master_info;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>重启mysql，注意！恢复完成的<code>mysql.user</code>是不包含rds中创建的用户的，需要重新创建：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mysql&gt; delete <span class="keyword">from</span> mysql.db where user&lt;&gt;<span class="string">&#x27;root&#x27;</span> <span class="keyword">and</span> char_length(user)&gt;<span class="number">0</span>;</span><br><span class="line">Query OK, <span class="number">10</span> rows affected (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; delete <span class="keyword">from</span> mysql.tables_priv where user&lt;&gt;<span class="string">&#x27;root&#x27;</span> <span class="keyword">and</span> char_length(user)&gt;<span class="number">0</span>;</span><br><span class="line">Query OK, <span class="number">42</span> rows affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; change master to</span><br><span class="line">    -&gt; master_host=<span class="string">&#x27;rm-bp12k8yne0909uv68.mysql.rds.aliyuncs.com&#x27;</span>,</span><br><span class="line">    -&gt; master_user=<span class="string">&#x27;oms&#x27;</span>,master_port=<span class="number">3306</span>,master_password=<span class="string">&#x27;对应密码&#x27;</span>,</span><br><span class="line">    -&gt; master_auto_position=<span class="number">1</span>;</span><br><span class="line">ERROR <span class="number">1201</span> (HY000): Could <span class="keyword">not</span> initialize master info structure; more error messages can be found <span class="keyword">in</span> the MySQL error log</span><br></pre></td></tr></table></figure></p>
<p>这里是因为在<code>/home/mysql/data</code>下有一个<code>master.info</code>，需要先删掉他，然后重新执行<code>change master to ...</code>就可以了，这期间不用停止mysql进程。</p>
<p>然后就是启动同步：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mysql&gt; reset master;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.03</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; reset slave;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; start slave;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.04</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>使用<code>show slave status\G</code>查看一下主从状态：<br><img data-src="/images/gtid11.png" alt="akb48"></p>
<h2 id="出现1236错误"><a href="#出现1236错误" class="headerlink" title="出现1236错误"></a>出现1236错误</h2><p>但是此时大概率应该出现了<code>Last_IO_Error: Got fatal error 1236 from master when reading data from binary log: &#39;The slave is connecting using CHANGE MASTER TO MASTER_AUTO_POSITION = 1, but the master has purged binary logs containing GTIDs that the slave requires.&#39;</code>这个错误，如图：<br><img data-src="/images/gtid9.png" alt="akb48"></p>
<p>这里要先说两个概念：</p>
<ol>
<li>gtid_executed(global)：MySQL数据库已经执行过的Gtid事务，处于内存中。<code>show master status/show slave status</code>中的<code>Executed_Gtid_Set</code>也取自这里；</li>
<li>gtid_purged(global)：由于binlog文件的删除(如<code>purge binary logs</code>或者超过<code>expire_logs_days</code>设置)已经丢失的Gtid事务，它是<code>gtid_executed</code>的子集；</li>
</ol>
<p>明白了上面两个概念，我们再来回溯一下这个过程：</p>
<ol>
<li>我们用RDS做的备份集来恢复出一个自建ECS的mysql实例；</li>
<li>启动主从同步；</li>
<li>从库在开始同步前,主库会依靠GTID来确认从库在开始同步以后, 能够把每一个主库上执行过的事务(包括slave的SQL Thread)都复现一次,最终保持和主库完全一致;</li>
<li>但是从库指定的<code>GTID_PURGED</code>并不等于主库的<code>GTID_EXECUTED</code>，为什么呢?因为主库多出来的这些gtid已经purge（丢失）掉了或者是新的从库未指定过<code>GTID_PURGED</code>；</li>
<li>出现1236的故障报错；</li>
</ol>
<p>此时我们分别进入到主从mysql里，执行<code>show global variables like &#39;%gtid%&#39;\G</code>，查询一下<code>gtid_purged</code>，如图：<br><img data-src="/images/gtid10.png" alt="akb48" title="左边主库rds，右边自建ecs"></p>
<p>我们先在主库上<code>show global variables like &#39;GTID_EXECUTED&#39;;</code>看一下效果：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mysql&gt; show <span class="keyword">global</span> variables like <span class="string">&#x27;GTID_EXECUTED&#x27;</span>;</span><br><span class="line">+---------------+------------------------------------------------------------------------------------------------+</span><br><span class="line">| Variable_name | Value                                                                                          |</span><br><span class="line">+---------------+------------------------------------------------------------------------------------------------+</span><br><span class="line">| gtid_executed | 18e99fbf-5f38-<span class="number">11e8</span>-8a6f-6c92bf21d8b5:<span class="number">1</span>-<span class="number">1519695</span>, 4ccd3917-5f58-<span class="number">11e8</span>-8b41-7cd30adfe86a:<span class="number">1</span>-<span class="number">9717278</span> |</span><br><span class="line">+---------------+------------------------------------------------------------------------------------------------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>在从库上执行如下的内容：<br>	<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mysql&gt; stop slave;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; reset master;		# 这一步是为了把GTID_EXECUTED清空</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.03</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show global variables like <span class="string">&#x27;GTID_EXECUTED&#x27;</span>;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| gtid_executed |       |</span><br><span class="line">+---------------+-------+</span><br><span class="line"><span class="number">1</span> row in set (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global GTID_PURGED=<span class="string">&#x27;18e99fbf-5f38-11e8-8a6f-6c92bf21d8b5:1-1519695,4ccd3917-5f58-11e8-8b41-7cd30adfe86a:1-9717278&#x27;</span>;	# 把主库的GTID_EXECUTED值填进来</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.03</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show global variables like <span class="string">&#x27;GTID_EXECUTED&#x27;</span>;                                              </span><br><span class="line">+---------------+------------------------------------------------------------------------------------------------+</span><br><span class="line">| Variable_name | Value                                                                                          |</span><br><span class="line">+---------------+------------------------------------------------------------------------------------------------+</span><br><span class="line">| gtid_executed | <span class="number">18e99</span>fbf<span class="number">-5</span>f38<span class="number">-11e8</span><span class="number">-8</span>a6f<span class="number">-6</span>c92bf21d8b5:<span class="number">1</span><span class="number">-1519695</span>, <span class="number">4</span>ccd3917<span class="number">-5</span>f58<span class="number">-11e8</span><span class="number">-8</span>b41<span class="number">-7</span>cd30adfe86a:<span class="number">1</span><span class="number">-9717278</span> |</span><br><span class="line">+---------------+------------------------------------------------------------------------------------------------+</span><br><span class="line"><span class="number">1</span> row in set (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; start slave;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>再次执行<code>show slave status\G</code>，就好了：<br><img data-src="/images/gtid12.png" alt="akb48"></p>
<p>由于mysql的配置文件没有规定<code>readonly</code>，所以我在从库也可以执行insert和update等写操作，但是是不会同步到主库的，而且还会由于主从数据不一致而报错。如果RDS不想要了，直接<code>stop slave</code>，把这个自建mysql当主库就行了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/weifeng1463/p/9678303.html">https://www.cnblogs.com/weifeng1463/p/9678303.html</a><br><a href="https://misakatang.cn/2019/03/02/%E9%98%BF%E9%87%8C%E4%BA%91RDS%E9%80%BB%E8%BE%91%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D%E4%B8%BB%E4%BB%8E/">https://misakatang.cn/2019/03/02/%E9%98%BF%E9%87%8C%E4%BA%91RDS%E9%80%BB%E8%BE%91%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D%E4%B8%BB%E4%BB%8E/</a><br><a href="https://segmentfault.com/a/1190000015657340">https://segmentfault.com/a/1190000015657340</a><br><a href="https://help.aliyun.com/knowledge_detail/41817.html">https://help.aliyun.com/knowledge_detail/41817.html</a> </p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>阿里云</tag>
        <tag>mysql主从</tag>
        <tag>gtid</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Django编写Restful API</title>
    <url>/2020/05/27/%E4%BD%BF%E7%94%A8Django%E7%BC%96%E5%86%99restful-API/</url>
    <content><![CDATA[<p>在工作中写restful API是一个常见的事儿，用django来写restful API也是非常简单，先说明一下我的环境：<br>Django <code>2.1.8</code><br>Python <code>3.6.4</code><br>project的名称是<code>naxx</code><br>APP的名称是<code>naxxramas</code><br>MySQL <code>5.5.64-MariaDB</code></p>
<h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><p>首先，我们先去<code>naxxramas/models.py</code>里添加一个数据模型，比如：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 记录各部门的监控覆盖率情况</span><br><span class="line">class Monitor(models.Model):</span><br><span class="line">    domain_name = models.CharField(max_length=50)	# 部门名</span><br><span class="line">    monitor_percentage = models.FloatField()		# 监控覆盖率</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.domain_name</span><br></pre></td></tr></table></figure></p>
<p>保存退出后，我们往里面加一点数据，可以从Django自带的后台添加或者直接在MySQL里insert，如图：<br><img data-src="/images/djangoapi2.jpg" alt="akb48"></p>
<p>先<code>pip install djangorestframework</code>安装<code>djangorestframework</code>,然后在<code>naxxramas</code>文件夹里，新创建<code>serializers.py</code>文件，内容如下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from .models import Monitor	#从同文件夹的models.py里引用Monitor类</span><br><span class="line">from rest_framework import serializers</span><br><span class="line"></span><br><span class="line">class MonitorSerializer(serializers.HyperlinkedModelSerializer):</span><br><span class="line">    class Meta:</span><br><span class="line">        model = Monitor</span><br><span class="line">        fields = [&#x27;domain_name&#x27;, &#x27;monitor_percentage&#x27;]	#这个是需要展示的项，我这里把数据的所有列都写出来了，可以根据需要展示</span><br></pre></td></tr></table></figure></p>
<p>然后编辑<code>views.py</code>，新增的内容如下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">默认内容略</span><br><span class="line">from rest_framework import viewsets</span><br><span class="line">from .serializers import MonitorSerializer</span><br><span class="line"></span><br><span class="line">class MonitorViewSet(viewsets.ModelViewSet):</span><br><span class="line">   	queryset = Monitor.objects.all()	#这里会去读取Monitor数据模型里所有的值</span><br><span class="line">   	serializer_class = GroupSerializer</span><br></pre></td></tr></table></figure></p>
<p>最后一步，配置一下<code>naxx/urls.py</code>，这里我为了配置方便，把不同的APP放在对应的路径下统一管理了，如下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from django.urls import path, include</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;admin/&#x27;, admin.site.urls),    #后台</span><br><span class="line">    path(r&#x27;naxx/&#x27;, include(&#x27;naxxramas.urls&#x27;)),  #naxx路径的单独去naxxramas里的urls.py里配置</span><br><span class="line">    path(&#x27;&#x27;, views.portal, name=&#x27;portal&#x27;),  #主页</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>再去编辑一下<code>naxxramas/urls.py</code>：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.urls import path, include</span><br><span class="line">from . import views</span><br><span class="line">from rest_framework import routers</span><br><span class="line"></span><br><span class="line">router = routers.DefaultRouter()</span><br><span class="line">router.register(r&#x27;monitor&#x27;, views.MonitorViewSet)</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;&#x27;, include(router.urls)), #api相关</span><br><span class="line">    path(&#x27;api-auth/&#x27;, include(&#x27;rest_framework.urls&#x27;, namespace=&#x27;rest_framework&#x27;)),  #api相关</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>还差最后一步，那就是去<code>naxx/settngs.py</code>里添加如下两个配置：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">   &#x27;DEFAULT_PAGINATION_CLASS&#x27;: &#x27;rest_framework.pagination.PageNumberPagination&#x27;,</span><br><span class="line">   &#x27;PAGE_SIZE&#x27;: 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>和<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">   	...</span><br><span class="line">   	&#x27;rest_framework&#x27;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>重启Django即可。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>要验证我们的api成功很简单，curl一下就行，这里我写了一个Python的脚本来使用<code>requests</code>验证，如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#python3，需要先pip install requests</span></span><br><span class="line"><span class="comment">#测试api的文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests, json</span><br><span class="line"></span><br><span class="line">monitorurl = <span class="string">&#x27;http://127.0.0.1:8000/naxx/monitor/&#x27;</span></span><br><span class="line"></span><br><span class="line">monitor_response = requests.get(monitorurl)</span><br><span class="line">monitor_data_json = json.loads(monitor_response.text)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;得到的monitor-json是：\n&#x27;</span>, monitor_data_json)</span><br></pre></td></tr></table></figure><br>执行效果如下：<br><img data-src="/images/djangoapi1.jpg" alt="akb48"><br>	<br>成功！
	</p>
<h2 id="添加参数"><a href="#添加参数" class="headerlink" title="添加参数"></a>添加参数</h2><p>上面的例子可见，我们请求的URL没有任何参数，而且数据库里有10多个数据，但是api取到的结果是默认是降序而且取的是前5位。那么如果我们要在url里添加参数怎么做？比如我们想要升序排列，而且这次只取三位。那么这次我们请求的URL路径是：<a href="http://127.0.0.1:8000/naxx/monitor/?order=top&num=3%E3%80%82">http://127.0.0.1:8000/naxx/monitor/?order=top&amp;num=3。</a></p>
<p>改一下<code>views.py</code>，如下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MonitorViewSet(viewsets.ModelViewSet):</span><br><span class="line">    #queryset = Monitor.objects.all()</span><br><span class="line">    serializer_class = MonitorSerializer</span><br><span class="line">    def get_queryset(self):</span><br><span class="line">        queryset = Monitor.objects.all()</span><br><span class="line">        num = self.request.query_params.get(&#x27;num&#x27;, &#x27;5&#x27;)		#这里判断是否得到num，如果没有默认为5</span><br><span class="line">        order = self.request.query_params.get(&#x27;order&#x27;, &#x27;top&#x27;)	#这里判断是否得到order，如果没有认为是top</span><br><span class="line">        if num is not None and order == &#x27;top&#x27;:</span><br><span class="line">            queryset = queryset.order_by(&#x27;-monitor_percentage&#x27;)[0:int(num)]		# 满足上面条件的话得到的是以monitor_percentage降序的前num位</span><br><span class="line">        elif num is not None and order == &#x27;bottom&#x27;:</span><br><span class="line">            queryset = queryset.order_by(&#x27;monitor_percentage&#x27;)[0:int(num)]</span><br><span class="line">        return queryset</span><br></pre></td></tr></table></figure></p>
<p>保存之后，还要去修改<code>naxxramas/urls.py</code>，因为我们添加的参数，所以要在<code>router.register</code>添加对应的<code>basename</code>:<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">略</span><br><span class="line">router.register(r&#x27;monitor&#x27;, views.MonitorViewSet, basename=&#x27;num&#x27; and &#x27;order&#x27;)	#在原有的基础上添加了basename并且指定参数名是num和order</span><br><span class="line">略</span><br></pre></td></tr></table></figure></p>
<p>Django会默认重启，如果成功的话，再用上面的python脚本试试效果：<br><img data-src="/images/djangoapi3.jpg" alt="akb48"></p>
<p>可见这次获取到了从小到大的三项数据了！</p>
<h2 id="自定义JSON返回"><a href="#自定义JSON返回" class="headerlink" title="自定义JSON返回"></a>自定义JSON返回</h2><p>如果此刻是按照做下来的话，会发现你的python脚本返回的值跟我不同。因为在实际工作中，每个公司都有自己的返回json格式，比如我们公司要求返回的格式是：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;success&quot; : true,</span><br><span class="line">  &quot;msg&quot;: &quot;asdf&quot;,</span><br><span class="line">  &quot;data&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而我已经修改了默认的返回格式，重新自定义JSONRenderer。自定义的方法简单说就是创建一个类去继承JSONRenderer，然后重构它的方法，然后在settings.py文件里修改默认使用的renderer类为我们自定义的类即可。</p>
<p>首先在naxx（也就是我的Django project）文件夹下创建一个utils文件夹，在这个文件夹里添加<code>rendererresponse.py</code>文件，内容如下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 导入控制返回的JSON格式的类</span><br><span class="line">from rest_framework.renderers import JSONRenderer</span><br><span class="line"></span><br><span class="line">class customrenderer(JSONRenderer):</span><br><span class="line">    # 重构render方法</span><br><span class="line">    def render(self, data, accepted_media_type=None, renderer_context=None):</span><br><span class="line">        if renderer_context:</span><br><span class="line">            # 获取需要返回的msg和code信息</span><br><span class="line">            if isinstance(data, dict):</span><br><span class="line">                msg = data.pop(&#x27;msg&#x27;, &#x27;success&#x27;)</span><br><span class="line">                code = data.pop(&#x27;code&#x27;, 0)</span><br><span class="line">            else:</span><br><span class="line">                msg = &#x27;success&#x27;</span><br><span class="line">                code = 0</span><br><span class="line">            # 重新构建返回的JSON字典</span><br><span class="line">            ret = &#123;</span><br><span class="line">                &#x27;success&#x27;: True,</span><br><span class="line">                &#x27;msg&#x27;: &#x27;This Data from Alibaba-GOC&#x27;,</span><br><span class="line">                &#x27;data&#x27;: data,</span><br><span class="line">            &#125;</span><br><span class="line">            # 返回JSON数据</span><br><span class="line">            return super().render(ret, accepted_media_type, renderer_context)</span><br><span class="line">        else:</span><br><span class="line">            return super().render(data, accepted_media_type, renderer_context)</span><br></pre></td></tr></table></figure></p>
<p>保存退出后，在<code>naxx/settings.py</code>里我们刚刚添加的<code>REST_FRAMEWORK</code>字段改成这样：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    &#x27;DEFAULT_PAGINATION_CLASS&#x27;: &#x27;rest_framework.pagination.PageNumberPagination&#x27;,</span><br><span class="line">    &#x27;PAGE_SIZE&#x27;: 10,</span><br><span class="line">    &#x27;DEFAULT_RENDERER_CLASSES&#x27;: (		#添加这一部分</span><br><span class="line">        &#x27;utils.rendererresponse.customrenderer&#x27;,</span><br><span class="line">    ),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.django-rest-framework.org/tutorial/quickstart/">https://www.django-rest-framework.org/tutorial/quickstart/</a><br><a href="https://www.django-rest-framework.org/api-guide/viewsets/#viewset-actions">https://www.django-rest-framework.org/api-guide/viewsets/#viewset-actions</a><br><a href="https://my.oschina.net/u/2474096/blog/1933456">https://my.oschina.net/u/2474096/blog/1933456</a><br><a href="https://www.django-rest-framework.org/tutorial/2-requests-and-responses/">https://www.django-rest-framework.org/tutorial/2-requests-and-responses/</a><br><a href="https://www.django-rest-framework.org/api-guide/filtering/">https://www.django-rest-framework.org/api-guide/filtering/</a><br><a href="https://stackoverflow.com/questions/48299466/django-rest-framework-passing-parameters-with-get-request-classed-based-views">https://stackoverflow.com/questions/48299466/django-rest-framework-passing-parameters-with-get-request-classed-based-views</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>python</tag>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Python GUI去将本地文件上传阿里云OSS</title>
    <url>/2019/05/13/%E4%BD%BF%E7%94%A8Python-GUI%E5%8E%BB%E5%B0%86%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E9%98%BF%E9%87%8C%E4%BA%91OSS/</url>
    <content><![CDATA[<p>前端同事会甩过来一个zip包，然后我们需要将其解压，然后上传到阿里云OSS里对应的目录，为了提高效率，就用python 3写了一个GUI，如图：<br><img data-src="/images/tkinter3.png" alt="akb48" title="选择对应的zip包，然后选择目录"></p>
<p>具体代码如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python </span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># 作者：ChrisChan</span></span><br><span class="line"><span class="comment"># 用途：使用GUI上传阿里云OSS</span></span><br><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk</span><br><span class="line"><span class="keyword">import</span> tkinter.ttk <span class="keyword">as</span> ttk</span><br><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> messagebox  <span class="comment"># 弹窗</span></span><br><span class="line"><span class="comment"># from tkinter import filedialog  # 选择单独文件</span></span><br><span class="line"><span class="keyword">from</span> tkinter.filedialog <span class="keyword">import</span> askdirectory <span class="comment"># 选择文件夹</span></span><br><span class="line"><span class="keyword">import</span> oss2,os,sys,zipfile,time  <span class="comment">#引入zipfile解压</span></span><br><span class="line"></span><br><span class="line">window = tk.Tk()</span><br><span class="line">window.title(<span class="string">&quot;将桌面文件上传到阿里云国内线上OSS&quot;</span>)   <span class="comment"># 窗体的标题</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">confirm</span>():</span><br><span class="line">    result = messagebox.askokcancel(<span class="string">&quot;请确认&quot;</span>, <span class="string">&#x27;&#x27;&#x27;本地文件是：%s,对应OSS路径是：%s&#x27;&#x27;&#x27;</span> % (filename,region1.get())) <span class="comment"># 前面是弹窗主题，后面是弹窗内容</span></span><br><span class="line">    Des_path = region1.get()</span><br><span class="line">    fileroot = filename.split(<span class="string">&#x27;.zip&#x27;</span>)[<span class="number">0</span>]    <span class="comment">#获取文件路径，不含.zip后缀</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;上传zip包路径是:%s&quot;</span> % fileroot)  <span class="comment"># 获取要上传的文件路径</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;要解压的zip包名是:%s&quot;</span> % filename)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;目标路径是:%s&quot;</span> % Des_path)   <span class="comment"># 获取目的完整路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> result <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">        ak = <span class="string">&quot;账号ak&quot;</span></span><br><span class="line">        sk = <span class="string">&quot;账号sk&quot;</span>   <span class="comment"># 秘钥</span></span><br><span class="line">        auth = oss2.Auth(ak, sk)   <span class="comment"># 鉴权</span></span><br><span class="line">        ossBucket = oss2.Bucket(auth, <span class="string">&#x27;http://oss-cn-hangzhou.aliyuncs.com&#x27;</span>,Des_path)   <span class="comment"># 定义ossBucket</span></span><br><span class="line">        date = time.strftime(<span class="string">&quot;%Y-%m-%d&quot;</span>, time.localtime())  <span class="comment">#获取今天日期</span></span><br><span class="line">        <span class="comment">#解压缩zip包</span></span><br><span class="line">        zFile = zipfile.ZipFile(filename, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> fileM <span class="keyword">in</span> zFile.namelist():</span><br><span class="line">            zFile.extract(fileM, <span class="string">&quot;D:\OSSback&quot;</span>)</span><br><span class="line">        zFile.close()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 文件夹上传</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">uploadFile</span>(<span class="params">file</span>):</span><br><span class="line">            remoteName = file.replace(fileroot,<span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;\\&#x27;</span>,<span class="string">&#x27;/&#x27;</span>)[<span class="number">1</span>:]     <span class="comment"># 将“/”去掉</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;uploading...&#x27;</span>, file, <span class="string">&#x27;remoteName:&#x27;</span>, remoteName)</span><br><span class="line">            result = ossBucket.put_object_from_file(remoteName, file)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;http status: &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(result.status))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">list</span>(<span class="params"><span class="built_in">dir</span></span>):</span><br><span class="line">            fs = os.listdir(<span class="built_in">dir</span>)</span><br><span class="line">            <span class="keyword">for</span> f <span class="keyword">in</span> fs:</span><br><span class="line">                file = <span class="built_in">dir</span>+<span class="string">&quot;\\&quot;</span>+f</span><br><span class="line">                <span class="keyword">if</span> os.path.isdir(file):</span><br><span class="line">                    <span class="built_in">list</span>(file)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    uploadFile(file)</span><br><span class="line">        <span class="built_in">list</span>(fileroot)   <span class="comment"># 开始上传</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;目标文件夹里所有文件上传完毕！&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#zip包改名</span></span><br><span class="line">        os.rename(filename,filename + date) <span class="comment">#按日期重命名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chooseZip</span>():</span><br><span class="line">    <span class="keyword">global</span> filename</span><br><span class="line">    filename = tk.filedialog.askopenfilename()    <span class="comment"># 选择单独的文件</span></span><br><span class="line">    <span class="keyword">if</span> filename != <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        lb.config(text=<span class="string">&quot;您选择的文件是：&quot;</span> + filename)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        lb.config(text=<span class="string">&quot;您没有选择任何文件&quot;</span>)</span><br><span class="line"></span><br><span class="line">lb = tk.Label(window, text=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">lb.grid(row=<span class="number">0</span>, column=<span class="number">1</span>, sticky=tk.W, padx=<span class="number">10</span>, pady=<span class="number">5</span>)</span><br><span class="line">btn = tk.Button(window, text=<span class="string">&quot;选择要上传的文件&quot;</span>, command=chooseZip)</span><br><span class="line">btn.grid(row=<span class="number">0</span>, column=<span class="number">0</span>, sticky=tk.E, padx=<span class="number">10</span>, pady=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">lb2 = tk.Label(window, text=<span class="string">&#x27;请选择上传地址&#x27;</span>)</span><br><span class="line">lb2.grid(row=<span class="number">2</span>, column=<span class="number">0</span>, sticky=tk.W, padx=<span class="number">10</span>, pady=<span class="number">5</span>)</span><br><span class="line">number = tk.StringVar()</span><br><span class="line">region1 = ttk.Combobox(window,width=<span class="number">35</span>,textvariable=number,state=<span class="string">&#x27;readonly&#x27;</span>)    <span class="comment">#下拉列表设置成为只读模式</span></span><br><span class="line">region1[<span class="string">&#x27;values&#x27;</span>] = (<span class="string">&#x27;resource-public/lccms&#x27;</span>,<span class="string">&#x27;resource-public/phoneAlarm&#x27;</span>,<span class="string">&#x27;resource-public/lcview&#x27;</span>,<span class="string">&#x27;resource-public/webFront/annualReport&#x27;</span>,<span class="string">&#x27;resource-public/webFront/cancellation&#x27;</span>,<span class="string">&#x27;resource-public/webFront/deviceShare&#x27;</span>,<span class="string">&#x27;resource-public/webFront/discoverNews&#x27;</span>,<span class="string">&#x27;resource-public/webFront/timeAlbum&#x27;</span>,<span class="string">&#x27;resource-public/chenchenchen&#x27;</span>)   <span class="comment">#下拉列表里面具体的元素</span></span><br><span class="line">region1.grid(row=<span class="number">2</span>,column=<span class="number">1</span>)</span><br><span class="line">region1.current(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">tk.Button(window, text=<span class="string">&#x27;上传&#x27;</span>, width=<span class="number">10</span>, command=confirm).grid(row=<span class="number">3</span>, column=<span class="number">0</span>, sticky=tk.W, padx=<span class="number">10</span>, pady=<span class="number">5</span>)</span><br><span class="line">tk.Button(window, text=<span class="string">&#x27;退出&#x27;</span>, width=<span class="number">10</span>, command=window.quit).grid(row=<span class="number">3</span>, column=<span class="number">1</span>, sticky=tk.E, padx=<span class="number">10</span>, pady=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">tk.mainloop()</span><br></pre></td></tr></table></figure></p>
<p>整个过程还是出现一个gui界面，然后传入zip包，然后将其在源目录下解压缩，并且上传到选择的OSS路径里，上传成功后将原zip改名已做备份。</p>
<p>最后吐槽一下，阿里云OSS的SDK里是没有文件改名的功能，只能复制一份然后靠上传新的顶替掉原来老的内容，这样很不友善…所以我才选择将zip包保留在本地。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>python3</tag>
        <tag>阿里云OSS</tag>
        <tag>gui</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Rancher2.1部署k8s集群</title>
    <url>/2019/07/25/%E4%BD%BF%E7%94%A8Rancher2-1%E9%83%A8%E7%BD%B2k8s/</url>
    <content><![CDATA[<h2 id="rancher是个啥？"><a href="#rancher是个啥？" class="headerlink" title="rancher是个啥？"></a>rancher是个啥？</h2><p>Rancher是一个开源的企业级全栈化容器部署及管理平台。简单的说，就是一个可以让你通过web界面管理docker容器的平台。定位上和K8s比较接近，都是通过web界面赋予完全的docker服务编排功能。而且它自带账户权限。相比K8s没有账号管理rancher自带账号权限体系。账号可以独立创建，也可以很方便地接入ldap等账号体系，对于公司使用是一大利器。</p>
<p>还有一个最牛逼的就是它有一个应用商店，并且可以做到配置自用的应用商店，部署服务，很快就能搞定！</p>
<p>所以说在k8s势不可挡的今天，学习一下rancher还是很有必要的。哪怕你领导担心它搞不定线上业务，拿来给测试环境部署也好啊！具体rancher的优点和不足可以去看 <a href="https://blog.csdn.net/CSDN_duomaomao/article/details/78029800">https://blog.csdn.net/CSDN_duomaomao/article/details/78029800</a> 。</p>
<h2 id="安装rancher以及创建k8s集群"><a href="#安装rancher以及创建k8s集群" class="headerlink" title="安装rancher以及创建k8s集群"></a>安装rancher以及创建k8s集群</h2><p>安装rancher的方法非常简单：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">docker run -d --restart=unless-stopped \</span><br><span class="line">   --name rancher-managment \</span><br><span class="line">      -p <span class="number">8080</span>:<span class="number">80</span> -p <span class="number">8443</span>:<span class="number">443</span> \</span><br><span class="line">      -v /rancher/data:/var/lib/rancher \</span><br><span class="line">      rancher/rancher:latest</span><br></pre></td></tr></table></figure></p>
<p>参数<code>--restart=unless-stopped</code>的意思是<code>在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器</code>。</p>
<p>然后确认一下防火墙是否对外开放了8443和8080端口，打开浏览器输入<code>IP:8443</code>就会看到rancher的样子，自带中文版，就问你感动不感动？<br><img data-src="/images/rancher5.png" alt="抱光妹"></p>
<p>然后准备三台服务器，资料如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">名称：k8s-001	IP：<span class="string">&quot;172.20.52.12&quot;</span>	角色：etcd+control+worker</span><br><span class="line">名称：k8s-002	IP：<span class="string">&quot;172.20.52.11&quot;</span>	角色：worker</span><br><span class="line">名称：k8s-003	IP：<span class="string">&quot;172.20.52.10&quot;</span>	角色：worker</span><br></pre></td></tr></table></figure></p>
<p>以上服务器系统均为centos7，而且与rancher网络的8443和8080端口互通。为了路径相同，个人建议在rancher买一个大一点的高效云盘，然后让这三个worker都挂载这个云盘，这样的话启动容器的时候，数据都持久化保存在云盘里。</p>
<p>回到rancher页面，点击<code>添加集群</code>，选择<code>CUSTOM</code>，然后给集群起个名儿，如果有其他的rancher成员可以管理或者访问这个集群就编辑一下成员角色，默认情况下是安装<code>k8s-1.11</code>版本。然后点击<code>下一步</code>：<br><img data-src="/images/rancher6.png" alt="抱光妹"></p>
<p>下一步很重要了，先在第一台172.20.52.12上勾选所有的角色以及输入对应IP，然后会web页面下面生成一个命令，将这个命令在172.20.52.12上执行一下，瞬间它就会尝试去注册到rancher：<br><img data-src="/images/rancher1.png" alt="抱光妹"></p>
<p>如果注册不成功，web提示<code>[etcd]Pulling image [rancher/coreos-etcd:v3.12.18] on host XXX</code>的话，那么还要去该服务器上手动<code>docker pull rancher/coreos-etcd:v3.12.18</code>一下，不久之后就会看到主机被成功注册到rancher上：<br><img data-src="/images/rancher7.png" alt="抱光妹"></p>
<p>点击<code>主机</code>，能看到一点CPU和内存的细节：<br><img data-src="/images/rancher8.png" alt="抱光妹"></p>
<h2 id="安装kuberctl"><a href="#安装kuberctl" class="headerlink" title="安装kuberctl"></a>安装kuberctl</h2><p>使用rancher部署的k8s集群是没有自带kuberctl命令的，只能通过rancher页面的执行<code>kubectl命令行</code>来操作，若需要worker里使用kubectl，那就得手动安装，过程如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/<span class="built_in">bin</span>/linux/amd64/kubectl		<span class="comment">#国内可以正常打开，表怕</span></span><br><span class="line">chmod +x kubectl</span><br><span class="line">sudo mv ./kubectl /usr/local/<span class="built_in">bin</span>/kubectl</span><br><span class="line">echo <span class="string">&quot;source &lt;(kubectl completion bash)&quot;</span> &gt;&gt; ~/.bash_profile  <span class="comment"># 增加自动补全功能  </span></span><br><span class="line">kubectl version</span><br></pre></td></tr></table></figure></p>
<p>此时得到的结果应该是：<br><img data-src="/images/rancher9.png" alt="抱光妹"></p>
<p>如果执行的结果是：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">/usr/local/<span class="built_in">bin</span>/kubectl: line <span class="number">1</span>: syntax error near unexpected token `&lt;<span class="string">&#x27;</span></span><br><span class="line"><span class="string">/usr/local/bin/kubectl: line 1: `&lt;?xml version=&#x27;</span><span class="number">1.0</span><span class="string">&#x27; encoding=&#x27;</span>UTF-<span class="number">8</span><span class="string">&#x27;?&gt;&lt;Error&gt;&lt;Code&gt;NoSuchKey&lt;/Code&gt;&lt;Message&gt;The specified key does not exist.&lt;/Message&gt;&lt;Details&gt;No such object: kubernetes-release/release//bin/linux/amd64/kubectl&lt;/Details&gt;&lt;/Error&gt;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>那么很有可能是你的kubectl没有下载完全，这个文件应该是41M左右的，大于小于都不对！</p>
<p>返回到rancher的集群页面，点击<code>kubeconfig文件</code>，将里面的内容复制到<code>~/.kube/config</code>里（没有就创建一个），保存退出之后，重开一个终端就能正常使用了，如图：<br><img data-src="/images/rancher10.png" alt="抱光妹"></p>
<h2 id="清理节点"><a href="#清理节点" class="headerlink" title="清理节点"></a>清理节点</h2><p>当你不想要一个node的时候，一定要清理干净，不然在新加node的时候就会出现：<code>[etcd] Etcd Cluster is not healthy</code>的错误。清理节点的方法语句如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 停止服务</span></span><br><span class="line">systemctl  disable kubelet.service</span><br><span class="line">systemctl  disable kube-scheduler.service</span><br><span class="line">systemctl  disable kube-proxy.service</span><br><span class="line">systemctl  disable kube-controller-manager.service</span><br><span class="line">systemctl  disable kube-apiserver.service</span><br><span class="line">	</span><br><span class="line">systemctl  stop kubelet.service</span><br><span class="line">systemctl  stop kube-scheduler.service</span><br><span class="line">systemctl  stop kube-proxy.service</span><br><span class="line">systemctl  stop kube-controller-manager.service</span><br><span class="line">systemctl  stop kube-apiserver.service</span><br><span class="line">	</span><br><span class="line"><span class="comment"># 删除所有容器</span></span><br><span class="line">docker rm -f $(docker ps -qa)</span><br><span class="line">	</span><br><span class="line"><span class="comment"># 删除所有容器卷</span></span><br><span class="line">docker volume rm $(docker volume ls -q)</span><br><span class="line">	</span><br><span class="line"><span class="comment"># 卸载mount目录</span></span><br><span class="line"><span class="keyword">for</span> mount <span class="keyword">in</span> $(mount | grep tmpfs | grep <span class="string">&#x27;/var/lib/kubelet&#x27;</span> | awk <span class="string">&#x27;&#123; print $3 &#125;&#x27;</span>) /var/lib/kubelet /var/lib/rancher; do umount $mount; done</span><br><span class="line"></span><br><span class="line"><span class="comment"># 备份目录</span></span><br><span class="line">mv /etc/kubernetes /etc/kubernetes-bak-$(date +<span class="string">&quot;%Y%m%d%H%M&quot;</span>)</span><br><span class="line">mv /var/lib/etcd /var/lib/etcd-bak-$(date +<span class="string">&quot;%Y%m%d%H%M&quot;</span>)</span><br><span class="line">mv /var/lib/rancher /var/lib/rancher-bak-$(date +<span class="string">&quot;%Y%m%d%H%M&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>node上的重要数据，已经要备份好！</p>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>如果node是集群，那么把web的语句复制到node的命令行执行后却迟迟不见注册成功，那么可以点击高级选项，然后输入内网IP和名称，如图：<br><img data-src="/images/rancher30.png" alt="抱光妹"></p>
<p>如果在node上执行<code>kubectl version</code>的时候报错：<code>Unable to connect to the server: x509: certificate signed by unknown authority</code>，原因可以看<a href="https://www.cnrancher.com/docs/rancher/v2.x/cn/configuration/admin-settings/custom-ca-root-certificate/">https://www.cnrancher.com/docs/rancher/v2.x/cn/configuration/admin-settings/custom-ca-root-certificate/</a> 。不过不知道是我姿势不对还是怎么的，我按照官方文档操作没有成功，这样可以在rancher的执行语句里添加<code>--no-cacerts</code>，如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">docker run -d --restart=unless-stopped \</span><br><span class="line">  --name rancher-managment \</span><br><span class="line">  -p <span class="number">8080</span>:<span class="number">80</span> -p <span class="number">8443</span>:<span class="number">443</span> \</span><br><span class="line">  -v /rancher/data:/var/lib/rancher/ \</span><br><span class="line">  rancher/rancher:latest   --no-cacerts </span><br></pre></td></tr></table></figure></p>
<p>这样就可以解决了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/horizonli/p/10572834.html">https://www.cnblogs.com/horizonli/p/10572834.html</a><br><a href="https://systemoutprint.github.io/kubernetes/2018/07/19/kubernetes%E9%9B%86%E7%BE%A4%E7%97%9B%E8%8B%A6%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/">https://systemoutprint.github.io/kubernetes/2018/07/19/kubernetes%E9%9B%86%E7%BE%A4%E7%97%9B%E8%8B%A6%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>云原生</tag>
        <tag>rancher</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Nginx+Uwsgi将Django部署上线</title>
    <url>/2019/01/05/%E4%BD%BF%E7%94%A8Nginx-Uwsgi%E5%B0%86Django%E9%83%A8%E7%BD%B2%E4%B8%8A%E7%BA%BF/</url>
    <content><![CDATA[<p>Uwsgi与Nginx搭配Django的原理请移步去看<a href="https://rorschachchan.github.io/2018/02/02/Uwsgi%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/">https://rorschachchan.github.io/2018/02/02/Uwsgi%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</a> 。</p>
<h2 id="配置uwsgi"><a href="#配置uwsgi" class="headerlink" title="配置uwsgi"></a>配置uwsgi</h2><p>安装Uwsgi的方法很简单，<code>pip install uwsgi</code>即可，一般来说会直接下载到python路径下的bin目录夹里。</p>
<p>首先，如果启动了django的进程，请先关闭。</p>
<p>然后我们要在django根目录同级里，新增一个文件夹，比如叫<code>chensite_uwsgi</code>，里面手动编写一个配置文件<code>chensite.ini</code>，内容如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line">chdir = /chendjango/Kubernetes	<span class="comment">#这里指定django根目录地址</span></span><br><span class="line">module = Kubernetes.wsgi:application	<span class="comment">#这里指定django默认自带的wsgi文件路径，前面是文件夹名，后面带上:application</span></span><br><span class="line">master = <span class="literal">True</span>	<span class="comment">#指定启动主进程</span></span><br><span class="line">processes = <span class="number">4</span>	<span class="comment">#指定进程数</span></span><br><span class="line">harakiri = <span class="number">60</span>	<span class="comment">#当客户端请求uWSGI接口超过60s时，uWSGI会强制关闭客户端连接，然后重启响应客户端的worker</span></span><br><span class="line"><span class="built_in">max</span>-requests = <span class="number">5000</span>		<span class="comment">#最多5000请求</span></span><br><span class="line">socket = <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8000</span>		<span class="comment">#使用本地的8000端口启动Django，效果等于python manage.py runserver 0.0.0.0:8000</span></span><br><span class="line">uid = www	<span class="comment">#使用www的用户去启动uwsgi，这里注意，如果非root用户可能会出现权限不足的情况，但是使用root用户会危险</span></span><br><span class="line">gid = www</span><br><span class="line">pidfile = /chendjango/chensite_uwsgi/chendjango.pid		<span class="comment">#指定pid文件</span></span><br><span class="line">daemonize = /chendjango/chensite_uwsgi/chendjango.log	<span class="comment">#指定log文件，同时要求进程在后台运行</span></span><br><span class="line">vacuum = <span class="literal">True</span>	<span class="comment">#当服务器退出时自动删除socket文件和pid文件</span></span><br><span class="line">logfile-chmod=<span class="number">644</span> <span class="comment">#指定日志文件的权限</span></span><br></pre></td></tr></table></figure><br>配置文件搞定之后，就可以使用<code>/usr/local/python3/bin/uwsgi --ini chensite.ini</code>来启动uwsgi了，启动完毕之后，<code>ps -aux|grep uwsgi</code>看一下进程是否正常，正常的话Django的进程就应该被uwsgi拉起来了，如果不正常可以通过我们刚刚指定的log文件来调试问题。</p>
<h2 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h2><p>Nginx在这里的用途就是监听uwsgi，由于uwsgi已经把django进程开启，所以也达到了nginx“控制”django的效果。Nginx的安装方法就不多说了，这里主要说具体配置。</p>
<p>在nginx的<code>conf/vhosts</code>文件夹里，新建一个叫<code>django.conf</code>的文件来搭配uwsgi。文件内容如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">	listen <span class="number">80</span>;	<span class="comment">#指定外人对应访问端口</span></span><br><span class="line">	server_name django.lechange.com;	<span class="comment">#指定域名</span></span><br><span class="line">	charset utf-<span class="number">8</span>;</span><br><span class="line">	</span><br><span class="line">	client_max_body_size 75M;</span><br><span class="line">	</span><br><span class="line">	location /static &#123;		<span class="comment">#这里如实填写静态资源路径</span></span><br><span class="line">		alias /chendjango/Kubernetes/static;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	location /media &#123;		<span class="comment">#同上</span></span><br><span class="line">		alias /chendjango/Kubernetes/media;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	location / &#123;		<span class="comment">#如果非静态资源，那么就跳转访问去8000端口</span></span><br><span class="line">		uwsgi_pass <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8000</span>;</span><br><span class="line">		include	/usr/local/nginx/conf/uwsgi_params;		<span class="comment">#这里填写uwsgi_params文件的地址</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>保存退出之后，直接启动nginx，确认进程和端口号都正常的话，在浏览器里上登录对应的django页面就OK了！<br><img data-src="/images/django40.png" alt="akb48"></p>
<h2 id="给网页title添加ico图标"><a href="#给网页title添加ico图标" class="headerlink" title="给网页title添加ico图标"></a>给网页title添加ico图标</h2><p>首先先找到一个喜欢的图片，然后去google一下“ico图标转换”，这种转换网站一搜一大把。登录到网站将这个喜欢的图片制作成<code>16X16</code>的ico图标文件，然后上传到服务器，放到django的静态文件目录里的任何地方。比如我只做好了一个<code>batman.ico</code>文件，然后把它放到<code>static/pic</code>文件夹下：<br><img data-src="/images/django38.png" alt="akb48"></p>
<p>然后就是在html文件的title字段里添加如下两句话：<br>	<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--网页标题左侧显示--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/static/pic/batman.ico&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/x-icon&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--收藏夹显示图标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;shortcut icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/static/pic/batman.ico&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/x-icon&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>保存之后，刷新一下页面，就看到效果了：<br><img data-src="/images/django39.png" alt="akb48"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://uwsgi-docs-zh.readthedocs.io/zh_CN/latest/tutorials/Django_and_nginx.html">https://uwsgi-docs-zh.readthedocs.io/zh_CN/latest/tutorials/Django_and_nginx.html</a><br><a href="https://segmentfault.com/a/1190000014361352">https://segmentfault.com/a/1190000014361352</a><br><a href="http://www.runoob.com/django/django-nginx-uwsgi.html">http://www.runoob.com/django/django-nginx-uwsgi.html</a><br><a href="https://segmentfault.com/a/1190000007952589">https://segmentfault.com/a/1190000007952589</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Nginx</tag>
        <tag>Uwsgi</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Zabbix去监控Redis</title>
    <url>/2018/01/10/%E4%BD%BF%E7%94%A8Zabbix%E5%8E%BB%E7%9B%91%E6%8E%A7Redis/</url>
    <content><![CDATA[<h2 id="了解Redis的info"><a href="#了解Redis的info" class="headerlink" title="了解Redis的info"></a>了解Redis的info</h2><p>要获得Redis的当前情况，使用<code>info</code>命令即可。具体用法：<code>redis-cli -h 127.0.0.1 -p 6379 -a redis_passwd info [参数]</code> 。针对不同的参数就会看到具体的数字，如果没有带参数，那么就会把默认情况写出来，如果带上<code>all</code>参数，那么就会把所有情况都写出来。比如：<code>redis-cli -h 127.0.0.1 -p 6379 -a redis_passwd info server</code>，就会看到redis关于server的一些数据，如下：<br><img data-src="/images/redisinfo.png" alt="抱光妹" title="redis的info内容"><br>可以看出，从server里可以查询到的是版本号、pid号、配置文件路径等等东西。</p>
<p>如果参数是<code>client</code>，记录了是客户端的相关信息：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@func-redis-<span class="number">001</span> ~]# redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6379</span> info clients</span><br><span class="line"># <span class="title class_">Clients</span></span><br><span class="line"><span class="attr">connected_clients</span>:<span class="number">64</span>    #已连接客户端的数量（不包括通过从属服务器连接的客户端）</span><br><span class="line"><span class="attr">client_longest_output_list</span>:<span class="number">0</span>    #当前连接的客户端当中，最长的输出列表</span><br><span class="line"><span class="attr">client_biggest_input_buf</span>:<span class="number">0</span>    #当前连接的客户端当中，最大输入缓存</span><br><span class="line"><span class="attr">blocked_clients</span>:<span class="number">0</span>    #正在等待阻塞命令（<span class="variable constant_">BLPOP</span>、<span class="variable constant_">BRPOP</span>、<span class="variable constant_">BRPOPLPUSH</span>）的客户端的数量</span><br></pre></td></tr></table></figure></p>
<p>如果参数是<code>memory</code>，记录的是内存的相关信息：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@func-redis-<span class="number">001</span> ~]# redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6379</span> info memory</span><br><span class="line"># <span class="title class_">Memory</span></span><br><span class="line"><span class="attr">used_memory</span>:<span class="number">2252984</span>    #由 <span class="title class_">Redis</span> 分配器分配的内存总量，以字节（byte）为单位</span><br><span class="line"><span class="attr">used_memory_human</span>:<span class="number">2.</span>15M    #上面的数字加上了单位</span><br><span class="line"><span class="attr">used_memory_rss</span>:<span class="number">9293824</span>    #常驻集大小，即<span class="title class_">Redis</span>已分配的内存总量。这个值和top、ps等命令的输出一致</span><br><span class="line"><span class="attr">used_memory_peak</span>:<span class="number">2607520</span>    #<span class="title class_">Redis</span> 的内存消耗峰值（以字节为单位）</span><br><span class="line"><span class="attr">used_memory_peak_human</span>:<span class="number">2.</span>49M    #上面的数字加上了单位</span><br><span class="line"><span class="attr">used_memory_lua</span>:<span class="number">33792</span>    #<span class="title class_">Lua</span> 引擎所使用的内存大小（以字节为单位）</span><br><span class="line"><span class="attr">mem_fragmentation_ratio</span>:<span class="number">4.13</span>    #used_memory_rss 和 used_memory 之间的比率</span><br><span class="line"><span class="attr">mem_allocator</span>:jemalloc-<span class="number">3.2</span><span class="number">.0</span>    #在编译时指定的，<span class="title class_">Redis</span>所使用的内存分配器。可以是libc、jemalloc或者tcmalloc。</span><br></pre></td></tr></table></figure></p>
<p>这里要注意！<font color=red>在理想情况下， used_memory_rss 的值应该只比 used_memory 稍微高一点儿</font>（我这个机器就已经属于严重的级别了）。当 rss &gt; used ，且两者的值相差较大时，表示存在（内部或外部的）内存碎片。内存碎片的比率可以通过 mem_fragmentation_ratio 的值看出。当 used &gt; rss 时，表示 Redis 的部分内存被操作系统换出到交换空间了，在这种情况下，操作可能会产生明显的延迟。</p>
<p>如果参数是<code>stats</code>，那就是统计的相关信息：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@func-redis-<span class="number">001</span> ~]# redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6379</span> info stats</span><br><span class="line"># <span class="title class_">Stats</span></span><br><span class="line"><span class="attr">total_connections_received</span>:<span class="number">150383</span>    #服务器已接受的连接请求数量</span><br><span class="line"><span class="attr">total_commands_processed</span>:<span class="number">500935</span>    #服务器已执行的命令数量</span><br><span class="line"><span class="attr">instantaneous_ops_per_sec</span>:<span class="number">0</span>    #服务器每秒钟执行的命令数量</span><br><span class="line"><span class="attr">rejected_connections</span>:<span class="number">0</span>    #因为最大客户端数量限制而被拒绝的连接请求数量</span><br><span class="line"><span class="attr">sync_full</span>:<span class="number">0</span>    </span><br><span class="line"><span class="attr">sync_partial_ok</span>:<span class="number">0</span>    </span><br><span class="line"><span class="attr">sync_partial_err</span>:<span class="number">0</span>    #查找数据库键成功的次数</span><br><span class="line"><span class="attr">expired_keys</span>:<span class="number">41</span>    #因为过期而被自动删除的数据库键数量</span><br><span class="line"><span class="attr">evicted_keys</span>:<span class="number">0</span>    #因为最大内存容量限制而被驱逐（evict）的键数量</span><br><span class="line"><span class="attr">keyspace_hits</span>:<span class="number">78121</span>    #查找数据库键成功的次数</span><br><span class="line"><span class="attr">keyspace_misses</span>:<span class="number">56</span>    #查找数据库键失败的次数</span><br><span class="line"><span class="attr">pubsub_channels</span>:<span class="number">0</span>    #目前被订阅的频道数量</span><br><span class="line"><span class="attr">pubsub_patterns</span>:<span class="number">0</span>    #目前被订阅的模式数量</span><br><span class="line"><span class="attr">latest_fork_usec</span>:<span class="number">878</span>    #最近一次 <span class="title function_">fork</span>() 操作耗费的微秒数</span><br></pre></td></tr></table></figure></p>
<p>如果参数是<code>CPU</code>，那么就会返回CPU的相关信息：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@func-redis-<span class="number">001</span> ~]# redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6379</span> info cpu</span><br><span class="line"># <span class="variable constant_">CPU</span></span><br><span class="line"><span class="attr">used_cpu_sys</span>:<span class="number">63.95</span>    #<span class="title class_">Redis</span>服务器耗费的系统<span class="variable constant_">CPU</span></span><br><span class="line"><span class="attr">used_cpu_user</span>:<span class="number">129.54</span>    #<span class="title class_">Redis</span>服务器耗费的用户<span class="variable constant_">CPU</span> </span><br><span class="line"><span class="attr">used_cpu_sys_children</span>:<span class="number">1.70</span>    #子进程耗费的系统<span class="variable constant_">CPU</span></span><br><span class="line"><span class="attr">used_cpu_user_children</span>:<span class="number">1.03</span>    #子进程耗费的用户<span class="variable constant_">CPU</span></span><br></pre></td></tr></table></figure></p>
<p>如果参数是<code>keyspace</code>，那么就会返回数据库相关的统计信息：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@func-redis-<span class="number">001</span> ~]# redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6379</span> info keyspace</span><br><span class="line"># <span class="title class_">Keyspace</span></span><br><span class="line"><span class="attr">db0</span>:keys=<span class="number">262</span>,expires=<span class="number">183</span>,avg_ttl=<span class="number">284091259423</span>    #据库的键数量、数据库设置有过期时间的key的数量（这个值减少是正常的）</span><br></pre></td></tr></table></figure></p>
<p>除了以上之外其他还有更多信息，请移步：<a href="http://redisdoc.com/server/info.html">http://redisdoc.com/server/info.html</a> 。感谢前人栽树！！！</p>
<h2 id="使用zabbix监控redis"><a href="#使用zabbix监控redis" class="headerlink" title="使用zabbix监控redis"></a>使用zabbix监控redis</h2><p>用zabbix监控redis是一个很简单的事儿，只需要把需要监控的数据提取出来即可。而提取数据的方法就是利用info去得到对应的数值。</p>
<p>首先先来一个判断redis服务器连接的脚本：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@func-redis-<span class="number">001</span> ~]# cat check_redis.<span class="property">sh</span></span><br><span class="line">#这个脚本是用来zabbix监控自建redis的</span><br><span class="line">#!<span class="regexp">/bin/</span>bash</span><br><span class="line"><span class="variable constant_">PORT</span>=<span class="string">&#x27;6379&#x27;</span></span><br><span class="line"><span class="variable constant_">PASSWD</span>=‘<span class="variable constant_">REDIS</span>密码’ </span><br><span class="line">STATUS_redis=$(redis-cli -h <span class="string">&#x27;127.0.0.1&#x27;</span> -p $PORT -a $PASSWD ping)</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;$STATUS_redis&quot;</span> == <span class="string">&#x27;PONG&#x27;</span> ];then</span><br><span class="line">        echo <span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        echo <span class="string">&#x27;0&#x27;</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p>然后更改<code>zabbix_agentd.conf</code>,如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">UserParameter</span>=redis_status[*],redis-cli -h <span class="string">&#x27;127.0.0.1&#x27;</span> -p $1 info | grep -w $2 | awk -F<span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span></span><br><span class="line"><span class="title class_">UserParameter</span>=redis_ping,sudo sh /root/check_redis.<span class="property">sh</span></span><br></pre></td></tr></table></figure></p>
<p>修改<code>/etc/sudoers</code>文件如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">## <span class="title class_">Allow</span> root to run any commands anywhere</span><br><span class="line">root    <span class="variable constant_">ALL</span>=(<span class="variable constant_">ALL</span>)       <span class="variable constant_">ALL</span></span><br><span class="line">zabbix  <span class="variable constant_">ALL</span>=(<span class="variable constant_">ALL</span>)       <span class="attr">NOPASSWD</span>:<span class="variable constant_">ALL</span>    #这个是新增</span><br><span class="line"><span class="title class_">Defaults</span>:zabbix !requiretty        #这个是新增</span><br></pre></td></tr></table></figure></p>
<p>保存之后，重启<code>zabbix-agent</code>服务，由于我这个redis是通过<code>zabbix-proxy</code>监控的，所以在<code>zabbix-proxy</code>一端用<code>zabbix_get</code>来查看结果：<br><img data-src="/images/motiorredis.png" alt="抱光妹" title="zabbix_get到redis内容"></p>
<p>然后在<code>zabbix-proxy</code>的模板里面添加一些需要监控的<code>item</code>即可，有必要的话可以设置<code>trigger+action</code>用来报警，如图：<br><img data-src="/images/zabbixredis.png" alt="抱光妹" title="配置item"></p>
<p>最后就是<code>grafana</code>搞一个炫酷的图表来，如图：<br><img data-src="/images/grafanaredis.png" alt="抱光妹" title="使用grafana展示成果"></p>
<p>最后一点，关于redis的内存优化，各位可以来看看：<a href="https://cachecloud.github.io/2017/02/16/Redis%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/">https://cachecloud.github.io/2017/02/16/Redis%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</a> ，写的很全面了。还有zabbix各种模板整理，有需要的同学也可以去下载：<a href="https://monitoringartist.github.io/zabbix-searcher/">https://monitoringartist.github.io/zabbix-searcher/</a> 。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title>使用ZABBIX自带模板去监控Mysql</title>
    <url>/2018/12/18/%E4%BD%BF%E7%94%A8ZABBIX%E8%87%AA%E5%B8%A6%E6%A8%A1%E6%9D%BF%E5%8E%BB%E7%9B%91%E6%8E%A7Mysql/</url>
    <content><![CDATA[<h2 id="事前准备"><a href="#事前准备" class="headerlink" title="事前准备"></a>事前准备</h2><p>Zabbix-agent:<code>3.0.8</code>，安装路径是<code>/etc/zabbix/</code><br>Mysql:<code>5.7.10</code>，安装路径是<code>/opt/mysql/</code><br>配置<code>/etc/sudoers</code>让zabbix用户可以使用sudo，如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">## <span class="title class_">Allow</span> root to run any commands anywhere</span><br><span class="line">root    <span class="variable constant_">ALL</span>=(<span class="variable constant_">ALL</span>)       <span class="variable constant_">ALL</span></span><br><span class="line">zabbix  <span class="variable constant_">ALL</span>=(<span class="variable constant_">ALL</span>)       <span class="attr">NOPASSWD</span>:<span class="variable constant_">ALL</span></span><br><span class="line"><span class="title class_">Defaults</span>:zabbix !requiretty</span><br></pre></td></tr></table></figure></p>
<h2 id="配置-my-cnf"><a href="#配置-my-cnf" class="headerlink" title="配置.my.cnf"></a>配置.my.cnf</h2><p>众所周知，Zabbix官方提供了自带监控Mysql的模板，但是这个模板并不能直接使用。所以我们需要有如下的改动：</p>
<p>首先，先在mysql目录下的etc文件夹里先创建一个<code>.my.cnf</code>文件，全路径是<code>/opt/mysql/etc/.my.cnf</code>，这个文件是zabbix要求的用于存放连接mysql数据库的账户信息的隐藏文件，这样可以避免在命令行里输入密码。整个<code>.my.cnf</code>文件内容如下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysql]                     #mysql程序要使用的账户信息</span><br><span class="line">host=localhost</span><br><span class="line">user=用户名</span><br><span class="line">password=&quot;密码&quot;   #此处的密码强烈建议加上引号</span><br><span class="line">socket=/tmp/mysql.sock  #确认mysql的sock文件路径</span><br><span class="line"></span><br><span class="line">[mysqladmin]             #mysqladmin程序要使用的账户信息</span><br><span class="line">host=localhost</span><br><span class="line">user=用户名</span><br><span class="line">password=&quot;密码&quot;</span><br><span class="line">socket=/tmp/mysql.sock</span><br></pre></td></tr></table></figure></p>
<p>这里建议在mysql里插入一个叫zabbix的用户，密码自己设定，然后在<code>.my.cnf</code>里就是用这个用户即可。此时，在命令行直接输入<code>HOME=/opt/mysql/etc/ mysql</code>和<code>HOME=/opt/mysql/etc/ mysqladmin ping</code>都应该是直接出结果，而不是用输入账号和密码，如图：<br><img data-src="/images/mysql-sock4.png" alt="akb48"></p>
<p><font color=red>注意!</font>这个<code>.my.cnf</code>的权限是644，用户和用户组是root，如果权限过大，那么启动mysql时就会报错：<code>Warning: World-writable config file &#39;/opt/mysql/etc/.my.cnf&#39; is ignored</code>。</p>
<h2 id="修改userparameter-mysql-conf"><a href="#修改userparameter-mysql-conf" class="headerlink" title="修改userparameter_mysql.conf"></a>修改userparameter_mysql.conf</h2><p>然后在<code>zabbix-agent</code>配置文件的文件夹<code>/etc/zabbix/zabbix_agentd.d/</code>里，会发现一个叫<code>userparameter_mysql.conf</code>的文件，把里面的内容改成如下样子:<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># <span class="title class_">For</span> all the following commands <span class="variable constant_">HOME</span> should be set to the directory that has .<span class="property">my</span>.<span class="property">cnf</span> file <span class="keyword">with</span> password information.</span><br><span class="line"></span><br><span class="line"># <span class="title class_">Flexible</span> parameter to grab <span class="variable language_">global</span> variables. <span class="title class_">On</span> the frontend side, use keys like mysql.<span class="property">status</span>[<span class="title class_">Com</span>_insert].</span><br><span class="line"># <span class="title class_">Key</span> syntax is mysql.<span class="property">status</span>[variable].</span><br><span class="line"><span class="title class_">UserParameter</span>=mysql.<span class="property">status</span>[*],echo <span class="string">&quot;show global status where Variable_name=&#x27;$1&#x27;;&quot;</span> | sudo <span class="variable constant_">HOME</span>=<span class="regexp">/opt/my</span>sql/etc /opt/mysql/bin/mysql -N | awk <span class="string">&#x27;&#123;print $$2&#125;&#x27;</span></span><br><span class="line"><span class="title class_">UserParameter</span>=mysql.<span class="property">ping</span>,sudo <span class="variable constant_">HOME</span>=<span class="regexp">/opt/my</span>sql/etc/ <span class="regexp">/opt/my</span>sql/bin/mysqladmin ping | grep -c alive</span><br><span class="line"><span class="title class_">UserParameter</span>=mysql.<span class="property">version</span>,<span class="regexp">/opt/my</span>sql/bin/mysql -V</span><br></pre></td></tr></table></figure></p>
<p>这个文件第一行注释的内容就是说明HOME路径就是<code>.my.cnf</code>文件所在的路径，后面的<code>mysql</code>和<code>mysqladmin</code>都要用绝对路径，同时加上<code>sudo</code>，这样zabbix才能正确的调用它。</p>
<p>来到<code>zabbix-server</code>端使用<code>zabbix-get</code>去试试结果：<br><img data-src="/images/mysql-sock5.png" alt="akb48"></p>
<p>然后就是在zabbix网页端将目标机器添加<code>Template DB MySQL</code>，至此，使用zabbix自带的mysql监控模板监控mysql数据库就结束了，效果如下：<br><img data-src="/images/mysql-sock6.png" alt="akb48"></p>
<h2 id="监控连接数"><a href="#监控连接数" class="headerlink" title="监控连接数"></a>监控连接数</h2><p>上面那个模板是不带有监控连接数的，要是单纯的去使用netstat获取当前链接值可能会反应较慢，那么就是用mysql自带的查连接数的命令：<code>show status like &#39;%connect%&#39;;</code>，执行效果如下：<br><img data-src="/images/mysql-sock8.png" alt="akb48"></p>
<p>简单说下这几个值的含义：</p>
<ol>
<li>Connections：试图连接到（不管是否成功）MYSQL服务器的连接总数</li>
<li>Locked_connects：锁住的链接数</li>
<li>Max_used_connections：服务器启动后已经同时使用过的连接最大数量（并发）</li>
<li>Max_used_connections_time：出现Max_used_connections时的时间</li>
<li>Aborted_connects：尝试连接到MySQL服务器失败的次数</li>
<li>Threads_connected：当前的连接数</li>
</ol>
<p>那么知道了含义，我们就可以对症下药了，这里我们监控两个数值<code>Locked_connects</code>和<code>Threads_connected</code>，那么就把下面的语句添加到<code>userparameter_mysql.conf</code>里：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">UserParameter</span>=mysql.<span class="property">connections</span>,echo <span class="string">&quot;show status like &#x27;%Threads_connected%&#x27;;&quot;</span> | sudo <span class="variable constant_">HOME</span>=<span class="regexp">/opt/my</span>sql/etc /opt/mysql/bin/mysql -N | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span></span><br><span class="line"><span class="title class_">UserParameter</span>=mysql.<span class="property">lockconnections</span>,echo <span class="string">&quot;show status like &#x27;%Locked_connects%&#x27;;&quot;</span> | sudo <span class="variable constant_">HOME</span>=<span class="regexp">/opt/my</span>sql/etc /opt/mysql/bin/mysql -N | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span></span><br><span class="line"><span class="title class_">UserParameter</span>=mysql.<span class="property">rowofalarm</span>,echo <span class="string">&quot;select count(*) from alarm.adm_log_alarm;&quot;</span> | sudo <span class="variable constant_">HOME</span>=<span class="regexp">/opt/my</span>sql/etc /opt/mysql/bin/mysql -N | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>	#这个是检测alarm.<span class="property">adm_log_alarm</span>的数据行数</span><br></pre></td></tr></table></figure><br>重启<code>zabbix-agent</code>，配置对应的items和trigger即可。</p>
<p>额外补充一下，查看mysql数据库对应每个IP的详细链接情况的语句是：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">select <span class="title function_">substring_index</span>(host,<span class="string">&#x27;:&#x27;</span>,<span class="number">1</span>) <span class="keyword">as</span> ip , <span class="title function_">count</span>(*) <span class="keyword">from</span> information_schema.<span class="property">processlist</span> group by ip;</span><br></pre></td></tr></table></figure></p>
<p>效果如下：<br><img data-src="/images/mysql-sock7.png" alt="akb48"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/erasin/notes/blob/master/linux/mysql/monitor.md">https://github.com/erasin/notes/blob/master/linux/mysql/monitor.md</a> （其他mysql状态监控语句）<br><a href="http://www.cnblogs.com/kerrycode/p/9206787.html">http://www.cnblogs.com/kerrycode/p/9206787.html</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Rancher搭配Harbor部署Kafka集群</title>
    <url>/2019/07/25/%E4%BD%BF%E7%94%A8Rancher%E6%90%AD%E9%85%8DHarbor%E9%83%A8%E7%BD%B2Kafka/</url>
    <content><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>Kafka是没有一个官方的镜像的，但是有一个star比较高的个人镜像，是<code>wurstmeister/kafka</code>，更新的也比较频繁，所以我们就选择这个镜像：<code>docker pull wurstmeister/kafka</code>。而kafka启动依赖zookeeper，于是我们还需要<code>docker pull digitalwonderland/zookeeper</code>，然后把他俩都上传到自建的harbor仓库里。</p>
<p>在部署的时候，rancher会去harbor里拉取镜像，但是harbor的私有仓是需要账号密码鉴权的，于是我们就要在rancher的界面点击<code>集群</code>—&gt;<code>执行kubectl命令行</code>，然后输入对应的内容：<br><img data-src="/images/rancher14.png" alt="抱光妹" title="如果右上角显示连接中，那么请换一个浏览器"></p>
<p>其中<code>secret-name</code>：secret的名称，<code>namespace</code>：命名空间，<code>docker-server</code>：Harbor仓库地址，<code>docker-username</code>：Harbor仓库登录账号，<code>docker-password</code>：Harbor仓库登录密码，<code>docker-email</code>：邮件地址。</p>
<p>执行之后，三个worker就应该可以登录到harbor仓库里了。</p>
<h2 id="部署zookeeper"><a href="#部署zookeeper" class="headerlink" title="部署zookeeper"></a>部署zookeeper</h2><p>现在我们开始部署zookeeper，首先来到<code>项目/命名空间</code>，在<code>Default</code>这个项目里新建一个命名空间，比如叫shop。<br><img data-src="/images/rancher15.png" alt="抱光妹"></p>
<p>然后点击集群的下拉菜单，选择<code>default</code>:<br><img data-src="/images/rancher16.png" alt="抱光妹"></p>
<p>点击<code>部署服务</code>，填写一些基本资料：<br><img data-src="/images/rancher17.png" alt="抱光妹"></p>
<p>然后点击启动，就完事了！但是不要高兴太久，发现pod有错误，是处于<code>Unavailable</code>的状态：<br><img data-src="/images/rancher18.png" alt="抱光妹"></p>
<p>来到worker里，<code>kubectl get pods --namespace=shop</code>查看一下这几个pod的状态：<br><img data-src="/images/rancher19.png" alt="抱光妹"></p>
<p>竟然是<code>ImagePullBackOff</code>？那么除了网络问题外，就是：镜像tag不正确、镜像不存在（或者是在另一个仓库）、Kubernetes没有权限去拉那个镜像。使用<code>kubectl describe pod 对应pod名 --namespace=shop</code>查看细节，果然被拒绝了：<br><img data-src="/images/rancher20.png" alt="抱光妹"></p>
<p>后来发现犯了两个错误，第一我把secret的namespace写到了<code>default</code>这个namespace里，结果部署是在<code>shop</code>这个namespace里；第二使用<code>kubectl get secret  secret-name -o yaml</code>以及<code>echo &quot;秘钥&quot; | base64 --decode</code>发现，我的harbor IP写错了，在<code>secret</code>里写的是内网IP，结果在部署的时候，镜像填写的是外网IP，更改过来之后，就OK了！<br><img data-src="/images/rancher24.png" alt="抱光妹"></p>
<p>如果习惯使用yaml的方式去部署的话，可以直接在工作负载的地方点击<code>导入yaml</code>：<br><img data-src="/images/rancher23.png" alt="抱光妹"></p>
<p>然后复制进如下的yaml:<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kind: Deployment</span><br><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">metadata:</span><br><span class="line">  name: zookeeper-deployment-1</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: zookeeper-1</span><br><span class="line">      name: zookeeper-1</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: zookeeper-1</span><br><span class="line">        name: zookeeper-1</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - name: zoo1</span><br><span class="line">          image: digitalwonderland/zookeeper</span><br><span class="line">          imagePullPolicy: IfNotPresent</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 2181</span><br><span class="line">          env:</span><br><span class="line">            - name: ZOOKEEPER_ID</span><br><span class="line">              value: &quot;1&quot;</span><br><span class="line">            - name: ZOOKEEPER_SERVER_1</span><br><span class="line">              value: zoo1</span><br><span class="line">            - name: ZOOKEEPER_SERVER_2</span><br><span class="line">              value: zoo2</span><br><span class="line">            - name: ZOOKEEPER_SERVER_3</span><br><span class="line">              value: zoo3</span><br><span class="line">---</span><br><span class="line">kind: Deployment</span><br><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">metadata:</span><br><span class="line">  name: zookeeper-deployment-2</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: zookeeper-2</span><br><span class="line">      name: zookeeper-2</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: zookeeper-2</span><br><span class="line">        name: zookeeper-2</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - name: zoo2</span><br><span class="line">          image: digitalwonderland/zookeeper</span><br><span class="line">          imagePullPolicy: IfNotPresent</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 2181</span><br><span class="line">          env:</span><br><span class="line">            - name: ZOOKEEPER_ID</span><br><span class="line">              value: &quot;2&quot;</span><br><span class="line">            - name: ZOOKEEPER_SERVER_1</span><br><span class="line">              value: zoo1</span><br><span class="line">            - name: ZOOKEEPER_SERVER_2</span><br><span class="line">              value: zoo2</span><br><span class="line">            - name: ZOOKEEPER_SERVER_3</span><br><span class="line">              value: zoo3</span><br><span class="line">---</span><br><span class="line">kind: Deployment</span><br><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">metadata:</span><br><span class="line">  name: zookeeper-deployment-3</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: zookeeper-3</span><br><span class="line">      name: zookeeper-3</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: zookeeper-3</span><br><span class="line">        name: zookeeper-3</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - name: zoo3</span><br><span class="line">          image: digitalwonderland/zookeeper</span><br><span class="line">          imagePullPolicy: IfNotPresent</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 2181</span><br><span class="line">          env:</span><br><span class="line">            - name: ZOOKEEPER_ID</span><br><span class="line">              value: &quot;3&quot;</span><br><span class="line">            - name: ZOOKEEPER_SERVER_1</span><br><span class="line">              value: zoo1</span><br><span class="line">            - name: ZOOKEEPER_SERVER_2</span><br><span class="line">              value: zoo2</span><br><span class="line">            - name: ZOOKEEPER_SERVER_3</span><br><span class="line">              value: zoo3</span><br></pre></td></tr></table></figure></p>
<p>点击提交之后，上面三个deployment就生成了，去任意的一台worker服务器里使用<code>for i in pod的名称后缀; do kubectl exec zookeeper-$i --namespace=shop /bin/bash /opt/zookeeper/bin/zkServer.sh status ; done</code>获得结果如下：<br><img data-src="/images/rancher22.png" alt="抱光妹"></p>
<p>zk的角色都已经分配好了，至此zookeeper集群搭建完毕！</p>
<h2 id="部署kafka"><a href="#部署kafka" class="headerlink" title="部署kafka"></a>部署kafka</h2><p>还是在这个集群里，点击上面菜单栏的<code>服务发现</code>，再点击旁边的<code>导入yaml</code>，复制粘贴如下的yaml内容：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: kafka-service-1</span><br><span class="line">  labels:</span><br><span class="line">    app: kafka-service-1</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort</span><br><span class="line">  ports:</span><br><span class="line">    - port: 9092</span><br><span class="line">      name: kafka-service-1</span><br><span class="line">      targetPort: 9092</span><br><span class="line">      nodePort: 30901</span><br><span class="line">      protocol: TCP</span><br><span class="line">  selector:</span><br><span class="line">    app: kafka-service-1</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: kafka-service-2</span><br><span class="line">  labels:</span><br><span class="line">    app: kafka-service-2</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort</span><br><span class="line">  ports:</span><br><span class="line">    - port: 9092</span><br><span class="line">      name: kafka-service-2</span><br><span class="line">      targetPort: 9092</span><br><span class="line">      nodePort: 30902</span><br><span class="line">      protocol: TCP</span><br><span class="line">  selector:</span><br><span class="line">    app: kafka-service-2</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: kafka-service-3</span><br><span class="line">  labels:</span><br><span class="line">    app: kafka-service-3</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort</span><br><span class="line">  ports:</span><br><span class="line">    - port: 9092</span><br><span class="line">      name: kafka-service-3</span><br><span class="line">      targetPort: 9092</span><br><span class="line">      nodePort: 30903</span><br><span class="line">      protocol: TCP</span><br><span class="line">  selector:</span><br><span class="line">    app: kafka-service-3</span><br></pre></td></tr></table></figure></p>
<p>然后再返回工作负载里，同样进入<code>导入yaml</code>，输入如下yaml:<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kind: Deployment</span><br><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">metadata:</span><br><span class="line">  name: kafka-deployment-<span class="number">1</span></span><br><span class="line">spec:</span><br><span class="line">  replicas: <span class="number">1</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      name: kafka-service-<span class="number">1</span></span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        name: kafka-service-<span class="number">1</span></span><br><span class="line">        app: kafka-service-<span class="number">1</span></span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: kafka-<span class="number">1</span></span><br><span class="line">        image: wurstmeister/kafka</span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: <span class="number">9092</span></span><br><span class="line">        env:</span><br><span class="line">        - name: KAFKA_ADVERTISED_PORT</span><br><span class="line">          value: <span class="string">&quot;9092&quot;</span></span><br><span class="line">        - name: KAFKA_ADVERTISED_HOST_NAME</span><br><span class="line">          value: [kafka-service1的clusterIP]</span><br><span class="line">        - name: KAFKA_ZOOKEEPER_CONNECT</span><br><span class="line">          value: zoo1:<span class="number">2181</span>,zoo2:<span class="number">2181</span>,zoo3:<span class="number">2181</span></span><br><span class="line">        - name: KAFKA_BROKER_ID</span><br><span class="line">          value: <span class="string">&quot;1&quot;</span></span><br><span class="line">        - name: KAFKA_CREATE_TOPICS</span><br><span class="line">          value: mytopic:<span class="number">2</span>:<span class="number">1</span></span><br><span class="line">---</span><br><span class="line">kind: Deployment</span><br><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">metadata:</span><br><span class="line">  name: kafka-deployment-<span class="number">2</span></span><br><span class="line">spec:</span><br><span class="line">  replicas: <span class="number">1</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      name: kafka-service-<span class="number">2</span></span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        name: kafka-service-<span class="number">2</span></span><br><span class="line">        app: kafka-service-<span class="number">2</span></span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: kafka-<span class="number">2</span></span><br><span class="line">        image: wurstmeister/kafka</span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: <span class="number">9092</span></span><br><span class="line">        env:</span><br><span class="line">        - name: KAFKA_ADVERTISED_PORT</span><br><span class="line">          value: <span class="string">&quot;9092&quot;</span></span><br><span class="line">        - name: KAFKA_ADVERTISED_HOST_NAME</span><br><span class="line">          value: [kafka-service2的clusterIP]</span><br><span class="line">        - name: KAFKA_ZOOKEEPER_CONNECT</span><br><span class="line">          value: zoo1:<span class="number">2181</span>,zoo2:<span class="number">2181</span>,zoo3:<span class="number">2181</span></span><br><span class="line">        - name: KAFKA_BROKER_ID</span><br><span class="line">          value: <span class="string">&quot;2&quot;</span></span><br><span class="line">---</span><br><span class="line">kind: Deployment</span><br><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">metadata:</span><br><span class="line">  name: kafka-deployment-<span class="number">3</span></span><br><span class="line">spec:</span><br><span class="line">  replicas: <span class="number">1</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      name: kafka-service-<span class="number">3</span></span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        name: kafka-service-<span class="number">3</span></span><br><span class="line">        app: kafka-service-<span class="number">3</span></span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: kafka-<span class="number">3</span></span><br><span class="line">        image: wurstmeister/kafka</span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: <span class="number">9092</span></span><br><span class="line">        env:</span><br><span class="line">        - name: KAFKA_ADVERTISED_PORT</span><br><span class="line">          value: <span class="string">&quot;9092&quot;</span></span><br><span class="line">        - name: KAFKA_ADVERTISED_HOST_NAME</span><br><span class="line">          value: [kafka-service3的clusterIP]</span><br><span class="line">        - name: KAFKA_ZOOKEEPER_CONNECT</span><br><span class="line">          value: zoo1:<span class="number">2181</span>,zoo2:<span class="number">2181</span>,zoo3:<span class="number">2181</span></span><br><span class="line">        - name: KAFKA_BROKER_ID</span><br><span class="line">          value: <span class="string">&quot;3&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>然后就会生成kafka了！我个人还是很喜欢用yaml去生成服务的。<br><img data-src="/images/rancher25.png" alt="抱光妹"></p>
<p>如果发现导入<code>yaml界面</code>卡死了，极有可能是yaml格式有问题。点击取消修改错误再提交即可。</p>
<h2 id="验证kafka"><a href="#验证kafka" class="headerlink" title="验证kafka"></a>验证kafka</h2><p>部署完了还要验证的，首先来到workers里，先使用<code>kubectl get service --all-namespaces</code>获取kafka的<code>CLUSTER-IP</code>。如下：<br><img data-src="/images/rancher27.png" alt="抱光妹"></p>
<p>然后再<code>kubectl exec -it kafkapod名称 /bin/bash --namespace=shop</code>进入到跟刚才记录IP不一样的kafka里，先<code>cd opt/kafka/bin</code>，然后<code>kafka-console-producer.sh --broker-list 任意kafka的CLUSTER-IP:9092 --topic test</code>。此时打开另一个xshell窗口，同样随机进入一个kafka的pod里，也是到<code>opt/kafka/bin</code>下之后，执行<code>kafka-console-consumer.sh --bootstrap-server 另一个kafka的CLUSTER-IP:9092 --topic test --from-beginning</code>，此时在原先窗口里输入字符，可以在第二个窗口里看到，这样就算OK了！如图：<br><img data-src="/images/rancher26.png" alt="抱光妹" title="两个IP地址不一样的"></p>
<h2 id="部署kafka-manager"><a href="#部署kafka-manager" class="headerlink" title="部署kafka-manager"></a>部署kafka-manager</h2><p>开发又提出了需求，希望安装一个kafka的可视化插件，提高办公效率。于是我就选择了kafka-manager作为插件，yaml内容如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: kafka-manager</span><br><span class="line">  labels:</span><br><span class="line">    app: kafka-manager</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: NodePort</span><br><span class="line">  ports:</span><br><span class="line">  - name: kafka</span><br><span class="line">    port: <span class="number">9000</span></span><br><span class="line">    targetPort: <span class="number">9000</span></span><br><span class="line">    nodePort: <span class="number">30900</span></span><br><span class="line">  selector:</span><br><span class="line">    app: kafka-manager</span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: kafka-manager</span><br><span class="line">  labels:</span><br><span class="line">    app: kafka-manager</span><br><span class="line">spec:</span><br><span class="line">  replicas: <span class="number">1</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: kafka-manager</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: kafka-manager</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: kafka-manager</span><br><span class="line">        image: zenko/kafka-manager:<span class="number">1.3</span><span class="number">.3</span><span class="number">.22</span></span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        ports:</span><br><span class="line">        - name: kafka-manager</span><br><span class="line">          containerPort: <span class="number">9000</span></span><br><span class="line">          protocol: TCP</span><br><span class="line">        env:</span><br><span class="line">        - name: ZK_HOSTS</span><br><span class="line">          value: <span class="string">&quot;[zookeeper的IP]:2181&quot;</span></span><br><span class="line">        livenessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /api/health</span><br><span class="line">            port: kafka-manager</span><br><span class="line">        readinessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /api/health</span><br><span class="line">            port: kafka-manager</span><br><span class="line">        resources:</span><br><span class="line">          limits:</span><br><span class="line">            cpu: 500m</span><br><span class="line">            memory: 512Mi</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 250m</span><br><span class="line">            memory: 256Mi</span><br></pre></td></tr></table></figure></p>
<p>同样在<code>工作负载</code>—<code>导入yaml</code>里粘贴上面的yaml之后，执行一下就会看到kafka-manager的deployment生成了，如图：<br><img data-src="/images/rancher28.png" alt="抱光妹"></p>
<p>在阿里云SLB里配置对应的端口，然后在浏览器里就可以访问了，如图：<br><img data-src="/images/rancher29.png" alt="抱光妹"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://o-my-chenjian.com/2017/04/11/Deploy-Kafka-And-ZP-With-K8s/">https://o-my-chenjian.com/2017/04/11/Deploy-Kafka-And-ZP-With-K8s/</a><br><a href="http://blog.yuandingit.com/2019/03/26/Practice-of-Business-Containerization-Transformation-(3)/">http://blog.yuandingit.com/2019/03/26/Practice-of-Business-Containerization-Transformation-(3)/</a><br><a href="https://www.cnblogs.com/00986014w/p/9561901.html">https://www.cnblogs.com/00986014w/p/9561901.html</a> （文中yaml的作者）<br><a href="https://k8smeetup.github.io/docs/tutorials/stateful-application/zookeeper/">https://k8smeetup.github.io/docs/tutorials/stateful-application/zookeeper/</a><br><a href="http://www.mydlq.club/article/29/">http://www.mydlq.club/article/29/</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>rancher</tag>
        <tag>harbor</tag>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Zabbix的Python api去获取当前监控值</title>
    <url>/2019/01/09/%E4%BD%BF%E7%94%A8Zabbix%E7%9A%84python-api%E5%8E%BB%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%9B%91%E6%8E%A7%E5%80%BC/</url>
    <content><![CDATA[<h2 id="事前准备"><a href="#事前准备" class="headerlink" title="事前准备"></a>事前准备</h2><p>有些时候我们需要在非zabbix的web界面里得到zabbix-server对某台服务器的实时监控值。但是有些值是zabbix-server加工过的，比如<code>eth0入网流量</code>，zabbix-server加工的方法如下：<br><img data-src="/images/zabbix1.png" alt="akb48"></p>
<p>可见是每秒的变量并且还乘了8，那么如果要得到这样加工过的值，想通过shell得到linux的指标无疑是十分麻烦的。那么对于这种需求，我们想到的第一个办法就是使用zabbix的api，通过api去获取值比爬网页要方便许多（而且zabbix-server的web页面不是那么好爬的）。</p>
<p>Zabbix 3.0的API官方文档：<a href="https://www.zabbix.com/documentation/3.0/manual/api">https://www.zabbix.com/documentation/3.0/manual/api</a><br>Zabbix 3.0的python版API官方文档：<a href="https://github.com/gescheit/scripts/tree/master/zabbix">https://github.com/gescheit/scripts/tree/master/zabbix</a><br>这里我更推荐用python版的api，因为使用<code>zabbix-api</code>这个python第三方库让开发变得更为简洁。</p>
<h2 id="安装zabbix-api"><a href="#安装zabbix-api" class="headerlink" title="安装zabbix-api"></a>安装zabbix-api</h2><p>安装<code>zabbix-api</code>最方便的方法就是pip安装。本文的python版本<code>2.7.15</code>，使用源码安装的，安装包并不带pip，那么安装pip的方法如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">yum install -y zlib-devel zlib openssl openssl-devel</span><br><span class="line">mv /usr/<span class="built_in">bin</span>/pip /usr/<span class="built_in">bin</span>/pip-bak	<span class="comment">#备份原有的pip</span></span><br><span class="line">wget --no-check-certificate https://pypi.python.org/packages/source/s/setuptools/setuptools-<span class="number">12.0</span><span class="number">.3</span>.tar.gz<span class="comment">#md5=f07e4b0f4c1c9368fcd980d888b29a65</span></span><br><span class="line">tar -zxvf setuptools-<span class="number">12.0</span><span class="number">.3</span>.tar.gz</span><br><span class="line">cd setuptools-<span class="number">12.0</span><span class="number">.3</span></span><br><span class="line">python setup.py install	<span class="comment">#这一步需要上面刚安装的zlib</span></span><br><span class="line">wget https://files.pythonhosted.org/packages/d0/<span class="number">92</span>/1e8406c15d9372084a5bf79d96da3a0acc4e7fcf0b80020a4820897d2a5c/pip-<span class="number">7.1</span><span class="number">.2</span>.tar.gz</span><br><span class="line"><span class="comment">#或者去https://pypi.org/project/pip/7.1.2/#files页面下载pip-7.1.2.tar.gz </span></span><br><span class="line">tar -zxcf pip-<span class="number">7.1</span><span class="number">.2</span>.tar.gz</span><br><span class="line">cd pip-<span class="number">7.1</span><span class="number">.2</span></span><br><span class="line">sudo python setup.py install</span><br><span class="line">ln -s /usr/local/python27/<span class="built_in">bin</span>/pip2<span class="number">.7</span> /usr/<span class="built_in">bin</span>/pip	<span class="comment">#做一个新的快捷方式</span></span><br></pre></td></tr></table></figure></p>
<p>有了pip之后，就可以安装<code>zabbix-api</code>，命令是：<code>pip install zabbix-api</code> 。在python的命令行里输入<code>from zabbix_api import ZabbixAPI</code>不报错就代表安装成功。</p>
<h2 id="链接zabbix"><a href="#链接zabbix" class="headerlink" title="链接zabbix"></a>链接zabbix</h2><p>通过zabbix-server鉴权的代码如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#<span class="attr">coding</span>:utf-<span class="number">8</span></span><br><span class="line">#这个脚本是用来获取zabbix 定时流量值</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> zabbix_api <span class="keyword">import</span> <span class="title class_">ZabbixAPI</span></span><br><span class="line">zapi = <span class="title class_">ZabbixAPI</span>(server=<span class="string">&quot;http://网页地址/zabbix/api_jsonrpc.php&quot;</span>)	</span><br><span class="line">zapi.<span class="title function_">login</span>(<span class="string">&quot;网页的用户名&quot;</span>, <span class="string">&quot;网页的密码&quot;</span>)	#鉴权</span><br></pre></td></tr></table></figure><br>如果没报错，就证明已经成功连接到zabbix-server了。</p>
<h2 id="获取监控项"><a href="#获取监控项" class="headerlink" title="获取监控项"></a>获取监控项</h2><p>还是以<code>eth0入网流量</code>为例，获取它的代码如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="comment">#这个脚本是用来获取zabbix 定时流量值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> zabbix_api <span class="keyword">import</span> ZabbixAPI</span><br><span class="line">zapi = ZabbixAPI(server=<span class="string">&quot;http://网页地址/zabbix/api_jsonrpc.php&quot;</span>)	</span><br><span class="line">zapi.login(<span class="string">&quot;网页的用户名&quot;</span>, <span class="string">&quot;网页的密码&quot;</span>)	<span class="comment">#鉴权</span></span><br><span class="line"></span><br><span class="line">hostname = [<span class="string">&quot;服务器1名称&quot;</span>,<span class="string">&quot;服务器2名称&quot;</span>,<span class="string">&quot;服务器3名称&quot;</span>,<span class="string">&quot;服务器4名称&quot;</span>]	</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> hostname:</span><br><span class="line">        list_item = zapi.item.get(&#123;<span class="string">&quot;output&quot;</span>: <span class="string">&quot;extend&quot;</span>,<span class="string">&quot;filter&quot;</span>:&#123;<span class="string">&#x27;host&#x27;</span>:name&#125;,<span class="string">&quot;search&quot;</span>:&#123;<span class="string">&#x27;key_&#x27;</span>:<span class="string">&#x27;net.if.in[eth0]&#x27;</span>&#125;&#125;)</span><br><span class="line">        eth0_value = list_item[<span class="number">0</span>][<span class="string">&quot;lastvalue&quot;</span>]</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;Incoming traffic bandwidth is:&quot;</span>+(eth0_value)</span><br></pre></td></tr></table></figure></p>
<p>可见多么简单！</p>
<p>上面代码里的hostname就是zabbix网页里的<code>Host name</code>，如图：<br><img data-src="/images/zabbix2.png" alt="akb48"></p>
<p>然后使用<code>zapi.item.get</code>方法通过<code>filter</code>来过滤，最后得到对应的key值。zapi下面还有很多方法，比如<code>zapi.hostgroup.get</code>、<code>zapi.host.get</code>、<code>zapi.application.get</code>等等等等，可以对于自己的需要，灵活运用。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://blog.csdn.net/LYJ_viviani/article/details/70568434">https://blog.csdn.net/LYJ_viviani/article/details/70568434</a><br><a href="https://segmentfault.com/a/1190000014241994">https://segmentfault.com/a/1190000014241994</a><br><a href="http://blog.51cto.com/xiaofengfeng/1907573">http://blog.51cto.com/xiaofengfeng/1907573</a></p>
<p><img data-src="/images/%E4%B8%9C%E6%96%B9%E4%B8%89%E4%BE%A0.gif" alt="akb48"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
        <tag>python</tag>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Dockbix监控进程</title>
    <url>/2018/10/15/%E4%BD%BF%E7%94%A8dockbix%E7%9B%91%E6%8E%A7%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p>之前在<a href="https://rorschachchan.github.io/2018/05/17/%E4%BD%BF%E7%94%A8zabbix%E5%8E%BB%E7%9B%91%E6%8E%A7docker%E5%AE%B9%E5%99%A8/">https://rorschachchan.github.io/2018/05/17/%E4%BD%BF%E7%94%A8zabbix%E5%8E%BB%E7%9B%91%E6%8E%A7docker%E5%AE%B9%E5%99%A8/</a> 介绍了如何使用dockbix去自动监控容器的cpu、mem和端口等值。而本文的内容就是讲述如何使用dockbix监控进程。</p>
<p>服务器情况如下：<br>172.31.0.77，普通模式安装zabbix-server；<br>172.16.0.194，服务器里有两个容器，一个是dockbix，另一个是具体的服务，里面是一个centos 7跑着nginx和php两个进程，如图：<br><img data-src="/images/dockbix1.png" alt="paradin"></p>
<p>如果你启动dockbix的语句是这样的话:<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  --name=dockbix-agent-xxl \</span><br><span class="line">  --net=host \</span><br><span class="line">  --privileged \</span><br><span class="line">  -v /:/rootfs \</span><br><span class="line">  -v /<span class="keyword">var</span>/<span class="attr">run</span>:<span class="regexp">/var/</span>run \</span><br><span class="line">  --restart unless-stopped \</span><br><span class="line">  -e <span class="string">&quot;ZA_Server=zabbix-server的IP地址&quot;</span> \</span><br><span class="line">  -e <span class="string">&quot;ZA_ServerActive=zabbix-server的IP地址&quot;</span> \</span><br><span class="line">  -d monitoringartist/dockbix-agent-xxl-<span class="attr">limited</span>:latest</span><br></pre></td></tr></table></figure></p>
<p>那么发现监控进程是失败的，如图：<br><img data-src="/images/dockbix2.png" alt="paradin"></p>
<p>原因就是dockbix和具体服务之间是两个独立的进程，所以dockbix无法访问到另一个容器的进程情况，这样就要干掉原有的dockbix，并且更改一下dockbix的启动语句：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  --name=dockbix-agent-xxl \</span><br><span class="line">  --net=host \</span><br><span class="line">  --pid=host \	#增加这句话</span><br><span class="line">  --privileged \</span><br><span class="line">  -v /:/rootfs \</span><br><span class="line">  -v /<span class="keyword">var</span>/<span class="attr">run</span>:<span class="regexp">/var/</span>run \</span><br><span class="line">  --restart unless-stopped \</span><br><span class="line">  -e <span class="string">&quot;ZA_Server=172.31.0.77&quot;</span> \</span><br><span class="line">  -e <span class="string">&quot;ZA_ServerActive=172.31.0.77&quot;</span> \</span><br><span class="line">  -d monitoringartist/dockbix-agent-xxl-<span class="attr">limited</span>:latest</span><br></pre></td></tr></table></figure></p>
<p>然后再去重新使用<code>zabbix-get</code>命令，就可以获取到进程了！<br><img data-src="/images/dockbix3.png" alt="paradin"></p>
<p>默认下，所有的容器都启用了PID命名空间。PID命名空间提供了进程的分离。PID命名空间删除系统进程视图，允许进程ID可重用，包括pid 1。<code>docker run</code>的时候添加了<code>--pid=host</code>就是允许容器内的进程可以查看主机的所有进程。</p>
<p>如果是不要看所有主机的进程，而只是看某一个容器的进程，其他进程pid不看怎么设置呢？<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">docker run --name my-redis -d redis	#假设你启动了一个名叫my-redis的容器</span><br><span class="line">docker run -it --pid=<span class="attr">container</span>:my-redis my_strace_docker_image bash	#在建立一个my_strace_docker_imag容器，只与my-redis共享pid</span><br></pre></td></tr></table></figure></p>
<p>如果zabbix-server发现容器内的某个服务死了，要进入容器里重启服务怎么办？答曰：<code>docker exec 容器ID /bin/bash -c &quot;启动服务命令&quot;</code></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/monitoringartist/dockbix-agent-xxl/issues/42">https://github.com/monitoringartist/dockbix-agent-xxl/issues/42</a><br><a href="https://www.zabbix.com/documentation/3.4/zh/manual/appendix/items/proc_mem_num_notes">https://www.zabbix.com/documentation/3.4/zh/manual/appendix/items/proc_mem_num_notes</a><br><a href="https://docs.docker.com/engine/reference/run/#imagetag">https://docs.docker.com/engine/reference/run/#imagetag</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>使用django-crontab创建定时任务</title>
    <url>/2022/04/15/%E4%BD%BF%E7%94%A8django-crontab%E5%88%9B%E5%BB%BA%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在Django开发中经常会遇到一些定时任务，那么提到定时任务肯定就会第一时间想到crontab。大家现在都是用容器去部署，那么在dockerfile里写crontab是一个很痛苦的事儿，所以自然就会想到用一些更加优雅的方法去让django跟crontab链接起来。</p>
<p>其实Django里用定时任务有很多方法，很多人用的是<code>apscheduler</code>或者是<code>django-apscheduler</code>。但是这个方案在我公司并不可行，原因是<code>django-apscheduler</code>会创建两张MySQL的表，而其中有一个表的id字段必须是<code>varchar</code>，是用来记录定时任务名称的。而我公司的开发规定要求id字段必须是<code>int</code>，所以直接使用它这个表是不行的，需要修改源码，这样就很麻烦了，对后期的维护和代码的传承也不利，而<code>django-celery</code>的方法比较重，于是我改用了<code>django-crontab</code>。</p>
<p>先说明环境：<br>django &#x3D;&#x3D; 3.2.12<br>python &#x3D;&#x3D; 3.7.5<br>django的project叫<code>naxx</code>,app叫 <code>naxxramas</code></p>
<p>安装<code>django-crontab</code>的方法很简单，<code>pip install django-crontab</code>即可，目前的版本是<code>0.7.1</code>，这个版本还支持，不过它已经很久不更新了，它的源码地址是：<a href="https://github.com/kraiz/django-crontab">https://github.com/kraiz/django-crontab</a></p>
<p>使用的方法也很简单。</p>
<p>首先，在django项目的<code>settings.py</code>的<code>INSTALLED_APPS</code>添加<code>django-crontab</code>:<br><img data-src="/images/django-crontab1.png"></p>
<p>然后再去我们创建的app–naxxramas里创建一个文件叫<code>crontabs.py</code>，里面的代码如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/python3</span></span><br><span class="line"><span class="comment"># 用途：定时任务相关,每天23点半执行这个任务,可见settings.py的配置</span></span><br><span class="line"><span class="keyword">from</span> naxxramas.models <span class="keyword">import</span> MoneyLost, Change_appinfo, Dcchain_coreapp      <span class="comment"># 引入数据库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">crontab_change_app_info</span>():</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">    fo = <span class="built_in">open</span>(<span class="string">&quot;/tmp/test1.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    fo.write(<span class="string">&quot;文件名: &quot;</span>, fo.name)</span><br><span class="line">    fo.write(<span class="string">&quot;写入成功\n 写入成功!\n&quot;</span>)</span><br><span class="line">    <span class="comment"># 关闭打开的文件</span></span><br><span class="line">    fo.close()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    fo = <span class="built_in">open</span>(<span class="string">&quot;/tmp/test2.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    fo.write(<span class="string">&quot;文件名: &quot;</span>, fo.name)</span><br><span class="line">    fo.write(<span class="string">&quot;写入失败\n 写入失败!\n&quot;</span>)</span><br><span class="line">    fo.write(e)</span><br><span class="line">    fo.close()</span><br></pre></td></tr></table></figure><br>	<br>这个文件很简单，就是成功的话写入<code>test1.txt</code>对应的内容，失败的话就写入<code>test2.txt</code>对应的内容。</p>
<p>保存这个文件之后，就返回<code>settings.py</code>,在添加一个定时函数,如下：<br><img data-src="/images/django-crontab2.png"></p>
<p>上面这个任务代表每天9点27分执行一个django自带的命令，目标就是export相关的信息到<code>/tmp/export.log</code>。下面那个任务代表每小时50分的时候，执行一下我们上面那个<code>crontabs.py</code>的<code>crontab_change_app_info</code>函数， 并将结果输出到<code>/tmp/chenx.log</code>里。</p>
<p>保存了<code>settings.py</code>之后，不用重启Django。在命令行执行<code>python manage.py crontab add</code>:<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$python manage.py crontab add</span><br><span class="line"></span><br><span class="line">  adding cronjob: (5e1f9075ca8672d43e82009a2e1f3402) -&gt; (<span class="string">&#x27;27 9 * * *&#x27;</span>, <span class="string">&#x27;django.core.management.call_command&#x27;</span>, [<span class="string">&#x27;export&#x27;</span>], &#123;&#125;, <span class="string">&#x27;&gt;&gt; /tmp/export.log&#x27;</span>)</span><br><span class="line">  adding cronjob: (17e25872cfb38fa6ce1b8ab61075e5dc) -&gt; (<span class="string">&#x27;50 * * * *&#x27;</span>, <span class="string">&#x27;naxxramas.crontabs.crontab_change_app_info&#x27;</span>, <span class="string">&#x27;&gt;&gt; /tmp/chenx.log 2&gt;&amp;1&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>然后<code>crontab -l</code>就能看到效果了：<br><img data-src="/images/django-crontab3.png" title="把django的任务同步到机器的crontab里了"></p>
<p>其他相关的命令如下，把这些命令添加到对应的dockerfile或者启动文件里，保证Django启动的时候，也要启动<code>django-crontab</code>，同理退出Django的时候，也要退出<code>django-crontab</code>：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py crontab add　　添加定时任务</span><br><span class="line">python manage.py crontab remove 清除定时任务,这里注意，先不要修改settings.py的任务，不然它发现原来的任务编号不存在了，就会remove报错，建议remove后再修改settings.py里的定时函数</span><br><span class="line">python manage.py crontab show 显示定时任务</span><br></pre></td></tr></table></figure></p>
<p>有时候设置django定时任务定时时间为每分钟执行，有时候可能出现上一次任务还没执行完下一次任务又会开始这样的BUG。解决办法就是在<code>settings.py</code>中加入<code>CRONTAB_LOCK_JOBS = True</code>：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># setting.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定时任务</span></span><br><span class="line">CRONJOBS = [</span><br><span class="line">    (<span class="string">&#x27;* * * * *&#x27;</span>, <span class="string">&#x27;app.xxx.xxx.main&#x27;</span>, <span class="string">&#x27;&gt;&gt;/var/log/xxx.log&#x27;</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">CRONTAB_LOCK_JOBS = <span class="literal">True</span>   <span class="comment"># 定时任务如果同一作业的旧实例仍在运行，则阻止启动作业</span></span><br><span class="line">CRONTAB_COMMAND_PREFIX = <span class="string">&#x27;PYTHONUNBUFFERED=1&#x27;</span>   <span class="comment"># 不加这句话，main方法里使用print打印到xxx.log的日志不是实时的。通过这个使设置定时任务print打印不缓存（类似python -u xxx.py）,不过推荐还是用logging模块记录日志</span></span><br></pre></td></tr></table></figure></p>
<p>这里要注意3点：<br>	第一，因为<code>django-crontab</code>依赖crontab进程，所以要确认crontab是启动的；<br>	第二，如果你的输出文件仅仅是一个print XXX 到某某文件的话，那估计不会看到效果，只能看到这个文件被创建了而已；<br>	第三，如果定时任务没有效果，可以在命令行去执行<code>crontab -l</code>里的命令，看看是什么错误，根据对应的错误排查即可；<br>	第四，无法做到Django退出后，django-crontab一起退出，所以建议在django退出的脚本或者uwsgi退出的脚本里补充上<code>python manage.py crontab remove</code>；</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://2016519.com/article/2020/5/15/35.html">http://2016519.com/article/2020/5/15/35.html</a><br><a href="https://www.xkblogs.com/index.php/archives/26/">https://www.xkblogs.com/index.php/archives/26/</a><br><a href="https://www.jianshu.com/p/dd22e8bd29c1">https://www.jianshu.com/p/dd22e8bd29c1</a><br><a href="https://www.cnblogs.com/weidaijie/p/12747685.html">https://www.cnblogs.com/weidaijie/p/12747685.html</a><br><a href="https://www.youtube.com/watch?v=6eoS9CFOmFw">https://www.youtube.com/watch?v=6eoS9CFOmFw</a>		这里的视频讲解更全面<br><img data-src="/images/%E8%BF%94%E8%80%81%E8%BF%98%E7%AB%A5.webp" title="周末看了返老还童，感触颇深"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>定时任务</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用docker做一个主从同步的redis集群</title>
    <url>/2018/04/18/%E4%BD%BF%E7%94%A8docker%E5%81%9A%E4%B8%80%E4%B8%AA%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E7%9A%84redis%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h2 id="查看容器内部信息"><a href="#查看容器内部信息" class="headerlink" title="查看容器内部信息"></a>查看容器内部信息</h2><p>之前用<code>docker run -it --name redis-master redis /bin/bash</code>创建了一个redis的docker，现在登陆发现状态已经是exit，于是就使用<code>docker container start 容器ID号or容器名称</code>来重新启动。如图：<br><img data-src="/images/docker4.png" alt="paradin"></p>
<p>然后书里说到要用<code>docker inspect</code>来查看所挂载volume的情况，使用命令:<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@chen-docker ~]# docker inspect --format &quot;&#123;&#123; .Volumes &#125;&#125;&quot; f391531120b0</span><br></pre></td></tr></table></figure></p>
<p>但是很不幸，系统反馈给我一个错误：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Template parsing error: template: :1:3: executing &quot;&quot; at &lt;.Volumes&gt;: map has no entry for key &quot;Volumes&quot;</span><br></pre></td></tr></table></figure></p>
<p>没有这个<code>Volumes</code>，那就干脆查看一下这个容器的所有信息：<code>docker inspect f391531120b0</code>，这个命令里面有<code>Config、Mounts</code>、<code>HostConfig</code>、<code>NetworkSettings</code>等等整个容器的所有信息，比如看一下NetworkSettings相关的内容，如图：<br><img data-src="/images/docker6.png" alt="paradin"></p>
<p>此时使用如下命令：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@chen-docker ~]# docker inspect --format &quot;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&quot; f391531120b0    #注意前面的.</span><br><span class="line">192.168.0.2</span><br><span class="line">[root@chen-docker ~]# docker inspect --format &quot;&#123;&#123; .NetworkSettings.MacAddress &#125;&#125;&quot; f391531120b0</span><br><span class="line">02:42:c0:a8:00:02</span><br></pre></td></tr></table></figure></p>
<p>这样就可以获取到内网IP和mac地址，同理换成<code>docker inspect f391531120b0 | grep Mounts -A 10</code>，看一下挂载信息，如图：<br><img data-src="/images/docker5.png" alt="paradin"></p>
<p>原来容器里的&#x2F;data其实就是宿主机的<code>/var/lib/docker/volumes/94b3c20a6d269c7498ab59ee45c560e84fed64a636767a4baa54fa7befbcd4ff/_data</code>这个文件夹。为了验证这一点，我先到宿主机去创建一个叫aaa文件，如下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@f391531120b0:/data# cat aaa </span><br><span class="line">123123</span><br></pre></td></tr></table></figure></p>
<p>再返回到宿主机上看：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@chen-docker ~]# cd /var/lib/docker/volumes/94b3c20a6d269c7498ab59ee45c560e84fed64a636767a4baa54fa7befbcd4ff/_data</span><br><span class="line">[root@chen-docker _data]# ls</span><br><span class="line">aaa</span><br><span class="line">[root@chen-docker _data]# cat aaa </span><br><span class="line">123123</span><br></pre></td></tr></table></figure></p>
<p>这就搞定了！</p>
<h2 id="主从同步排错"><a href="#主从同步排错" class="headerlink" title="主从同步排错"></a>主从同步排错</h2><p>就是按书里写的开始配置和启动<code>redis-slave</code>，但是却发现同步没有成功，在<code>redis-slave</code>日志里发现这样的话：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">32677:S 08 Feb 16:14:40.952 * Connecting to MASTER 172.168.10.70:6379</span><br><span class="line">32677:S 08 Feb 16:14:40.952 * MASTER &lt;-&gt; SLAVE sync started</span><br><span class="line">32677:S 08 Feb 16:14:40.953 # Error condition on socket for SYNC: Connection refused</span><br></pre></td></tr></table></figure></p>
<p>这个的原因就是redis主服务器绑定了127.0.0.1，那么跨服务器IP的访问就会失败，从服务器用IP和端口访问主的时候，主服务器发现本机6379端口绑在了127.0.0.1上，也就是只能本机才能访问，外部请求会被过滤。所以需要修改<code>redis-master</code>的<code>redis.conf</code>，注释掉<code>bind 127.0.0.1</code>，如果是线上生产环境建议绑定IP地址。</p>
<p>重新启动redis之后，发现同步依然失败，日志变成了这样：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">90:S 17 Apr 09:27:35.906 * Non blocking connect for SYNC fired the event.</span><br><span class="line">90:S 17 Apr 09:27:35.907 # Error reply to PING from master: &#x27;-DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connect&#x27;</span><br><span class="line">90:S 17 Apr 09:27:36.908 * Connecting to MASTER 192.168.0.2:6379</span><br><span class="line">90:S 17 Apr 09:27:36.909 * MASTER &lt;-&gt; SLAVE sync started</span><br><span class="line">90:S 17 Apr 09:27:36.909 * Non blocking connect for SYNC fired the event.</span><br><span class="line">90:S 17 Apr 09:27:36.909 # Error condition on socket for SYNC: Connection reset by peer</span><br></pre></td></tr></table></figure></p>
<p>这个日志的意思是说redis在没有开启bind和密码的情况下，保护模式被开启。然后Redis的只接受来自环回IPv4和IPv6地址的连接。于是还是要修改redis-master的<code>redis.conf</code>关闭保护模式：<code>portected-mode no</code>，然后重启redis-master即可。</p>
<h2 id="容器内安装ping"><a href="#容器内安装ping" class="headerlink" title="容器内安装ping"></a>容器内安装ping</h2><p>先检查你的容器是使用什么系统的景象，如果是ubantu那就是<code>apt-get</code>，安装ping的命令如下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install inetutils-ping</span><br></pre></td></tr></table></figure></p>
<h2 id="如何让容器一直启动"><a href="#如何让容器一直启动" class="headerlink" title="如何让容器一直启动"></a>如何让容器一直启动</h2><p>如果用了一段时间的docker就会发现，我们的容器经常用了一段时间就自动退出了，<code>docker ps</code>已经找不到了，在<code>docker ps -a</code>里面了，如图：<br><img data-src="/images/docker7.png" alt="paradin"></p>
<p>然后我们<code>docker start containerId</code>想重新开启这个容器，可能这次来的更快，没几分钟容器又自己关了，由这个问题又可能引发其它很多的问题。</p>
<p><code>docker run</code>指定的命令如果不是那些一直挂起的命令（比如运行top，不断echo），就是会自动退出的。<code>-d</code>命令是设置detach为<code>true</code>，根据官方的文档，意思是让这个命令在后台运行，但并不是一直运行，Docker容器后台运行,就必须有一个前台进程。主线程结束，容器会退出。</p>
<p>我们启动容器的时候不要<code>-d</code>命令启动，用<code>-dit</code>就好了，例如：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">docker run -d hello-<span class="title function_">world</span>(不要这么做)</span><br><span class="line">docker run -dit hello-<span class="title function_">world</span>(推荐)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>docker</tag>
        <tag>主从同步</tag>
      </tags>
  </entry>
  <entry>
    <title>使用gdb去进入Too many connections的Mysql</title>
    <url>/2019/03/11/%E4%BD%BF%E7%94%A8gdb%E5%8E%BB%E8%BF%9B%E5%85%A5Too-many-connections%E7%9A%84Mysql/</url>
    <content><![CDATA[<p>今天在登录mysql的时候，发现Too many connections的错误，如图：<br><img data-src="/images/mysql.png" alt="akb48"></p>
<p>很明显，连接数不够用了，在<code>my.cnf</code>里看到当前的最大链接是500。一般来说很多人就会修改<code>my.cnf</code>将<code>max_connections</code>改大然后重启mysql生效。但是我这个mysql是生产环境的，如果重启势必产生不小的影响，于是就需要不重启mysql还要能达到修改<code>max_connections</code>的目的。</p>
<p>那就用gdb，语句如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[root@db-02 data]<span class="comment"># gdb -p $(cat /opt/mysql/data/Storage.pid) -ex  &quot;set max_connections=1024&quot; -batch</span></span><br></pre></td></tr></table></figure></p>
<p>执行完毕之后，就可以正常登录到mysql的交互页面了：<br><img data-src="/images/mysql2.png" alt="akb48"></p>
<p>此时查询一下最大连接数：<br><img data-src="/images/mysql3.png" alt="akb48"></p>
<p>可见已经生效了，但是如果这个时候mysql有重启的话，还是会读取<code>my.cnf</code>里的<code>max_connections</code>配置，所以再手动改下<code>max_connections</code>即可。<br><img data-src="/images/king%E5%87%BA%E5%9C%BA.jpg" alt="akb48"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>使用gitlab搭配阿里云容器镜像服务构建镜像</title>
    <url>/2018/08/15/%E4%BD%BF%E7%94%A8gitlab%E6%90%AD%E9%85%8D%E9%98%BF%E9%87%8C%E4%BA%91%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E6%9C%8D%E5%8A%A1%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h2 id="工作思路"><a href="#工作思路" class="headerlink" title="工作思路"></a>工作思路</h2><p>本次北京AWS技术峰会里看到了很多公司在运维上使用容器部署和扩容的实例，一天下来感受良多。现在比较流行部署办法就是“云镜像”：<strong>即开发把新的代码提交到gitlab上，然后gitlab与云厂家的镜像服务相关联，然后每一次commit提交都会触发一次镜像的构建，然后再根据这个镜像部署到实际的服务器里，同时将此服务器作一个快照，同时再搭配上容器监控，如果服务吃紧，就用此快照购买实例扩容；如果服务闲余，那么也会自动将最老的服务器实例关机，进而释放退款。</strong></p>
<p>用图像来说就是这个意思：<br><img data-src="/images/aliyungitlab7.png" alt="paradin" title="也可以gitlab触发jenkins，用jenkins构建镜像并且把镜像推送到阿里云容器仓库去"></p>
<h2 id="勾连gitlab与云镜像"><a href="#勾连gitlab与云镜像" class="headerlink" title="勾连gitlab与云镜像"></a>勾连gitlab与云镜像</h2><p>本文使用的镜像厂家是阿里云，gitlab版本是<code>10.7.3</code>。</p>
<p>进入阿里云的“容器镜像”页面，如果你是第一次使用这个产品需要先建立一个仓库密码，然后点击左侧的代码源，如图：<br><img data-src="/images/aliyungitlab1.png" alt="paradin"></p>
<p>在gitlab地方选择“绑定账号”，就需要填写对应的栏目：<br><img data-src="/images/aliyungitlab2.png" alt="paradin"></p>
<p>前两项很好写，最后一个token需要在gitlab里创建：在gitlab的页面，点击个人的头像，然后<code>settings</code>—<code>Access Tokens</code>，填写好名字（生产环境一般都是填运维的账号）然后在<code>api</code>处打勾，生成的那个东东就是token，直接复制填写到阿里云的页面即可。如图：<br><img data-src="/images/aliyungitlab3.png" alt="paradin"></p>
<h2 id="配置镜像仓库"><a href="#配置镜像仓库" class="headerlink" title="配置镜像仓库"></a>配置镜像仓库</h2><p>在阿里云容器镜像界面点击“创建镜像仓库”，填写好名字摘要仓库类型之后，在代码源里选择gitlab，由于刚刚填写了token所以是可以看得到gitlab用户下所有的project名的，如图：<br><img data-src="/images/aliyungitlab4.png" alt="paradin"></p>
<p>然后点击新创建的那个仓库，在构建一栏默认已经选择好了“代码变更时自动构建镜像”，点击“添加规则”，如图：<br><img data-src="/images/aliyungitlab5.png" alt="paradin"></p>
<p>这里我选择了master分支，然后指明了dockerfile文件名和路径，最后版本号就先写一个version，这个可以通过gitlab在commit时特殊指定。</p>
<p>右侧栏里的Webhook是用来发送提示的，可以在钉钉里创建一个机器人，在创建机器人时会生成webhook，然后把机器人的webhook添加到这个webhook即可。如果在添加的时候提示“当前请求失败，请重试”，这个情况是因为Webhook的名称里有中文，要全英文才可以。<br><img data-src="/images/aliyungitlab8.png" alt="paradin"></p>
<h2 id="编写dockerfile"><a href="#编写dockerfile" class="headerlink" title="编写dockerfile"></a>编写dockerfile</h2><p>如果没有dockerfile是无法构建镜像的，于是就在上面“规则”的目录里创建对应的dockerfile文件，<font color=red>注意!“规则”里的根目录就是代码文件夹的顶目录，而不是整个服务器的根目录</font>。写dockerfile的基础知识和语法这里不多说了，网络上有的是，我就随便写一个nginx dockerfile，内容如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">############################################################</span><br><span class="line"># <span class="title class_">Dockerfile</span> to build <span class="title class_">Nginx</span> container images</span><br><span class="line"># <span class="title class_">Based</span> on <span class="title class_">Debian</span></span><br><span class="line">############################################################</span><br><span class="line"><span class="variable constant_">FROM</span>    <span class="attr">debian</span>:latest</span><br><span class="line"><span class="variable constant_">MAINTAINER</span>      <span class="title class_">ChrisChan</span> <span class="string">&quot;Chris@jjfjj.com&quot;</span></span><br><span class="line"><span class="variable constant_">RUN</span>     apt-get update</span><br><span class="line"><span class="variable constant_">RUN</span>     apt-get install -y nginx	</span><br><span class="line"><span class="variable constant_">RUN</span>     apt-get install -y vim	</span><br><span class="line"><span class="variable constant_">RUN</span>     apt-get install -y procps	#安装ps命令</span><br><span class="line"><span class="variable constant_">RUN</span>     echo <span class="string">&#x27;HI!WARRIOR is the champion!!!&#x27;</span> &gt; <span class="regexp">/var/</span>www/html/index.<span class="property">nginx</span>-debian.<span class="property">html</span></span><br><span class="line"><span class="variable constant_">EXPOSE</span>  <span class="number">8080</span>	#开放<span class="number">8080</span>端口</span><br><span class="line"><span class="variable constant_">COPY</span>    /file/kubernetes.<span class="property">tar</span>.<span class="property">gz</span> /mnt/</span><br><span class="line">#<span class="variable constant_">CMD</span>    service nginx start &amp;&amp; nginx -g <span class="string">&quot;daemon off;&quot;</span></span><br><span class="line"><span class="variable constant_">ENTRYPOINT</span> [ <span class="string">&quot;/usr/sbin/nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span> ]</span><br></pre></td></tr></table></figure></p>
<p><font color=red>注意！使用上面注释的CMD语句作为结尾的话，那么这个镜像docker run的时候就会马上退出，这是因为把command做为容器内部命令，那么nginx程序将后台运行，这个时候nginx并不是pid为1的程序，而是执行的bash，这个bash执行了nginx指令后就挂了，所以容器也就退出了。</font>简而言之，Docker容器后台运行,就必须有一个前台进程。因为Docker容器仅在它的1号进程（PID为1）运行时，会保持运行。如果1号进程退出了，Docker容器也就退出了。</p>
<p>在gitlab触发之后，阿里云就自动把这个dockerfile build成了镜像保存在阿里云的容器仓库里，如图：<br><img data-src="/images/aliyungitlab6.png" alt="paradin"></p>
<p>想用这个镜像就可以直接去阿里云的仓库里下载并启动，这样就节省了本地的硬盘容量。最后就是把这个镜像部署到对应的kubernetes集群里，这样就完成了“gitlab代码提交触发阿里云构建镜像”的过程，而如何使用kubernetes的内容将在以后细说。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
        <tag>持续集成</tag>
        <tag>阿里云</tag>
        <tag>docker镜像</tag>
      </tags>
  </entry>
  <entry>
    <title>使用expect来实现远程登录ssh</title>
    <url>/2018/03/14/%E4%BD%BF%E7%94%A8expect%E6%9D%A5%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95ssh/</url>
    <content><![CDATA[<h2 id="先说说shebang"><a href="#先说说shebang" class="headerlink" title="先说说shebang"></a>先说说shebang</h2><p>我们在写一个<code>shell</code>脚本时，总是习惯在最前面加上一行<code>#!/bin/bash</code>,这个就是脚本的<code>shebang</code>,可以把它理解成是一种解释器。至于为什么叫这么个奇怪的名字，C语言和Unix的开发者Dennis Ritchie称它为可能是类似于“hash-bang”的英国风描述性文字；</p>
<p>贴一段wiki上的解释:</p>
<blockquote>
<p>在计算机科学中，shebang是一个由井号和叹号构成的字符串行，其出现在文本文件的第一行的前两个字符。 在文件中存在shebang的情况下，类unix操作系统的程序载入器会分析shebang后的内容，将这些内容作为解释器指令，并调用该指令，并将载有shebang的文件路径作为该解释器的参数。</p>
</blockquote>
<p>简单的说，它指示了此脚本运行时的解释器，所以，使用文件名直接执行shell脚本时，必须带上这个<code>shebang</code>; 此外，我们还可以在<code>shebang</code>后面直接附加选项，执行时默认使用选项执行；</p>
<p>比如<code>test.sh</code>的<code>shebang</code>为<code>#!/bin/sh -x</code>，那我们执行脚本时:<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">./test.<span class="property">sh</span> hello</span><br></pre></td></tr></table></figure></p>
<p>相当于：<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">bin/sh -x ./test.<span class="property">sh</span> hello;</span><br></pre></td></tr></table></figure></p>
<p>而expect编写的脚本，需要用到的shebang为<code>/usr/bin/expect</code>;</p>
<p>需要注意的是：在指定脚本解释器来执行脚本时，<code>shebang</code>会被指定的脚本解释器覆盖，即优先使用指定的脚本解释器来执行脚本（习惯性地用<code>sh ./test.sh</code>却提示<code>command not found</code>）</p>
<h2 id="实例脚本"><a href="#实例脚本" class="headerlink" title="实例脚本"></a>实例脚本</h2><p>expect的具体语法我这里就不说了，看一下下面的参考资料就好了。其实说来说去，就是根据命令栏上的反馈来输入对应的内容，举一个ssh登陆的例子。如图:<br><img data-src="/images/expectssh.png" alt="paradin"></p>
<p>从这个我们非常熟悉的ssh登陆的过程就看到，在登陆的时候，页面会返回几个交互的问题，而我们就可以针对这几个问题的关键字来输入答案。最后也根据“Welcome”这个关键字认为我们已经登陆成功了，这样就直接在连接的服务器里操作命令。</p>
<p>于是根据这个思路，来写一个远程ssh到A机器上的脚本：<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/usr/</span>bin/expect -f</span><br><span class="line"></span><br><span class="line">set timeout <span class="number">30</span>        #设定超时时间是<span class="number">30</span>秒，如果是-<span class="number">1</span>那就是永不超时</span><br><span class="line">spawn ssh root@A服务器<span class="variable constant_">IP</span>地址        #这里开始ssh连接到目标服务器上</span><br><span class="line"></span><br><span class="line">expect &#123;</span><br><span class="line">  <span class="string">&quot;*(yes/no)?&quot;</span> &#123;    #如果是第一次连接，那么命令栏里就会出现(yes/no)的字样</span><br><span class="line">     send <span class="string">&quot;yes\r&quot;</span>    #此时匹配yes</span><br><span class="line">     expect <span class="string">&quot;*password:&quot;</span> &#123;send <span class="string">&quot;服务器密码\r&quot;</span>&#125;    #如果命令栏出现了password的字样，直接填写密码</span><br><span class="line">   &#125;</span><br><span class="line">      <span class="string">&quot;*password:&quot;</span> &#123;send <span class="string">&quot;服务器密码\r&quot;</span>&#125;        #如果不是第一次连接，那么就会直接出现password，所以可以直接填写密码</span><br><span class="line">&#125;</span><br><span class="line">expect <span class="string">&quot;*Welcome*&quot;</span>    #连接成功就会出现welcome的字样</span><br><span class="line">send <span class="string">&quot;echo &#x27;我就是你的爹地&#x27; &gt;&gt; /tmp/123321.txt\r&quot;</span>        #此时执行第一个命令</span><br><span class="line">send <span class="string">&quot;df -h\r&quot;</span>        #执行第二个命令</span><br><span class="line">send <span class="string">&quot;cp /tmp/123321.txt /tmp/123123.txt\r&quot;</span>        #执行第三个命令</span><br><span class="line">interact     #脚本fork的子进程会将操作权交给用户，允许用户与当前A服务器的shell进行交互</span><br></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.sctux.com/?p=343">http://blog.sctux.com/?p=343</a><br><a href="http://www.zyy1217.com/2017/07/02/linux%20expect%E8%AF%A6%E8%A7%A3/">http://www.zyy1217.com/2017/07/02/linux%20expect%E8%AF%A6%E8%A7%A3/</a><br><a href="https://github.com/jiangxianli/SSHAutoLogin">https://github.com/jiangxianli/SSHAutoLogin</a><br><a href="https://peiqiang.net/2014/05/10/ssh-auto-login.html">https://peiqiang.net/2014/05/10/ssh-auto-login.html</a><br><a href="https://www.jianshu.com/p/9bee08dc3dca">https://www.jianshu.com/p/9bee08dc3dca</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>运维技术</tag>
        <tag>expect</tag>
      </tags>
  </entry>
  <entry>
    <title>使用nginx开启http2协议</title>
    <url>/2018/03/16/%E4%BD%BF%E7%94%A8nginx%E5%BC%80%E5%90%AFhttp2%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="部署过程"><a href="#部署过程" class="headerlink" title="部署过程"></a>部署过程</h2><p><code>HTTP/2</code>是建立在TLS的基础上的，那么先要查看nginx的版本和openssl的版本，如果<code>nginx</code>版本在<code>1.10.0</code>以上且需要<code>openssl</code>版本在<code>1.0.2</code>以上那么就可以进行下一步了：<br><img data-src="/images/http2-10.png" alt="paradin"></p>
<p>如果版本并不符合要求，可以按照<a href="https://rorschachchan.github.io/2018/01/03/Nginx%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91%E6%96%B0%E7%9A%84%E6%A8%A1%E5%9D%97/">https://rorschachchan.github.io/2018/01/03/Nginx动态编译新的模块/</a> 里的方法升级对应的模块版本。</p>
<p>先编辑https（443端口）对应的<code>conf</code>文件：<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen <span class="number">443</span> ssl http2;    #这里多加一句http2</span><br><span class="line">        server_name  cuntao.<span class="property">lechange</span>.<span class="property">com</span> *.<span class="property">lechange</span>.<span class="property">com</span>;    #这里填写实际的域名，我这里以cuntao.<span class="property">lechange</span>.<span class="property">com</span>为例</span><br><span class="line"></span><br><span class="line">        ssl_certificate /实际路径/server-com.<span class="property">crt</span>;        </span><br><span class="line">        ssl_certificate_key /实际路径/server-com.<span class="property">key</span>;</span><br><span class="line"></span><br><span class="line">        ssl_session_timeout  30m;        #客户端会话缓存时间</span><br><span class="line">        ssl_protocols  <span class="title class_">TLSv1</span> <span class="title class_">TLSv1</span><span class="number">.1</span> <span class="title class_">TLSv1</span><span class="number">.2</span>;    #允许的协议</span><br><span class="line">        ssl_ciphers  <span class="variable constant_">EECDH</span>+<span class="title class_">CHACHA20</span>:<span class="variable constant_">EECDH</span>+<span class="title class_">AES128</span>:<span class="variable constant_">RSA</span>+<span class="title class_">AES128</span>:<span class="variable constant_">EECDH</span>+<span class="title class_">AES256</span>:<span class="variable constant_">RSA</span>+<span class="title class_">AES256</span>:<span class="variable constant_">EECDH</span>+3<span class="attr">DES</span>:<span class="variable constant_">RSA</span>+3<span class="attr">DES</span>:!<span class="title class_">MD5</span>;    #加密算法(<span class="title class_">CloudFlare</span> 推荐的加密套件组)</span><br><span class="line">        ssl_prefer_server_ciphers   on;        #优化 <span class="variable constant_">SSL</span> 加密套件</span><br><span class="line">        ssl_session_cache <span class="attr">builtin</span>:<span class="number">1000</span> <span class="attr">shared</span>:<span class="attr">SSL</span>:10m;        #<span class="variable constant_">SSL</span>会话缓存类型和大小</span><br><span class="line">        ssl_buffer_size <span class="number">1400</span>;        #每个<span class="variable constant_">MTU</span>大小1400b</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.<span class="property">html</span> index.<span class="property">htm</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page  <span class="number">404</span>              /<span class="number">404.</span>html;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>保存之后再编辑http（80端口）对应的<code>conf</code>文件：<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">80</span> <span class="keyword">default</span>;</span><br><span class="line">    add_header <span class="title class_">Strict</span>-<span class="title class_">Transport</span>-<span class="title class_">Security</span> max-age=<span class="number">15768000</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">301</span> <span class="attr">https</span>:<span class="comment">//$host$request_uri;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后使用<code>nginx -t</code>检查一下是否文件有错误，如果是OK的话，那么就<code>nginx -s reload</code>平滑重启一下nginx即可。</p>
<p>验证<code>HTTP/2</code>协议是否开启很简单，有两个方法：<br>1）登陆<code>https://tools.keycdn.com/http2-test</code>，将你的域名填写进去，查看一下配置成功：<br><img data-src="/images/http2-11.png" alt="paradin"></p>
<p>2)在Chrome浏览器上可以通过安装<code>HTTP/2 and SPDY indicator</code>插件来检验，网址是<a href="https://chrome.google.com/webstore/detail/http2-and-spdy-indicator/mpbpobfflnpcgagjijhmgnchggcjblin">https://chrome.google.com/webstore/detail/http2-and-spdy-indicator/mpbpobfflnpcgagjijhmgnchggcjblin</a>  ，如果地址栏出现蓝色的闪电就是该网站开启了<code>HTTP/2</code>协议，灰色的话就是<code>HTTP/2</code>协议没开启。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.nginx.com/blog/nginx-1-9-5/">https://www.nginx.com/blog/nginx-1-9-5/</a><br><a href="https://blog.fazero.me/2017/01/06/upgrate-nginx-and-use-http2/">https://blog.fazero.me/2017/01/06/upgrate-nginx-and-use-http2/</a><br><a href="https://iyaozhen.com/nginx-http2-conf.html">https://iyaozhen.com/nginx-http2-conf.html</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>http协议</tag>
      </tags>
  </entry>
  <entry>
    <title>使用pandas来做html表格</title>
    <url>/2018/03/27/%E4%BD%BF%E7%94%A8pandas%E6%9D%A5%E5%81%9Ahtml%E8%A1%A8%E6%A0%BC/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近电子商城慢sql问题引了小BOSS的重视，于是就打算给开发们搞一个表格，在表格里可以看到前一天阿里云数据库的慢sql。这一次我不打算用html邮件了，因为慢sql数量不固定，今天可能三个，明天可能五个，后天抽风可能就一百个。而html邮件的格式是要事先写死的，于是我就用pandas来做这个表格，直接生成一个html文件，通过访问浏览器去让开发看慢sql。</p>
<h2 id="慢日志脚本"><a href="#慢日志脚本" class="headerlink" title="慢日志脚本"></a>慢日志脚本</h2><p>我要承认，阿里云自带的api在线调试工具真是一个好东西，有了它，脚本demo可以直接生成，地址是：<a href="https://api.aliyun.com/?spm=a2c4g.750001.952925.6.1QrDYe">https://api.aliyun.com/?spm=a2c4g.750001.952925.6.1QrDYe</a> ，于是乎，阿里云获取慢日志脚本<code>test.py</code>如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/usr/</span>bin/env python</span><br><span class="line">#coding=utf-<span class="number">8</span></span><br><span class="line"><span class="keyword">import</span> json	</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore <span class="keyword">import</span> client</span><br><span class="line"><span class="keyword">from</span> aliyunsdkrds.<span class="property">request</span>.<span class="property">v20140815</span> <span class="keyword">import</span> <span class="title class_">DescribeSlowLogRecordsRequest</span></span><br><span class="line">	</span><br><span class="line">clt = client.<span class="title class_">AcsClient</span>(<span class="string">&#x27;这里是ak&#x27;</span>,<span class="string">&#x27;这里是sk&#x27;</span>,<span class="string">&#x27;这里是地域&#x27;</span>)</span><br><span class="line"></span><br><span class="line"># 设置参数</span><br><span class="line">request = <span class="title class_">DescribeSlowLogRecordsRequest</span>.<span class="title class_">DescribeSlowLogRecordsRequest</span>()</span><br><span class="line">request.<span class="title function_">set_accept_format</span>(<span class="string">&#x27;json&#x27;</span>)</span><br><span class="line"></span><br><span class="line">request.<span class="title function_">add_query_param</span>(<span class="string">&#x27;DBInstanceId&#x27;</span>, <span class="string">&#x27;RDS的ID号&#x27;</span>)</span><br><span class="line">request.<span class="title function_">add_query_param</span>(<span class="string">&#x27;StartTime&#x27;</span>, <span class="string">&#x27;2018-03-26T08:00Z&#x27;</span>)	#<span class="number">3</span>月<span class="number">26</span>日早上<span class="number">8</span>点开始</span><br><span class="line">request.<span class="title function_">add_query_param</span>(<span class="string">&#x27;EndTime&#x27;</span>, <span class="string">&#x27;2018-03-27T08:00Z&#x27;</span>)	#<span class="number">3</span>月<span class="number">27</span>日早上<span class="number">8</span>点结束</span><br><span class="line">request.<span class="title function_">add_query_param</span>(<span class="string">&#x27;DBName&#x27;</span>, <span class="string">&#x27;对应的数据库名&#x27;</span>)</span><br><span class="line">request.<span class="title function_">add_query_param</span>(<span class="string">&#x27;PageSize&#x27;</span>, <span class="number">100</span>)	#这个值只能是<span class="number">30</span>/<span class="number">50</span>/<span class="number">100</span></span><br><span class="line"></span><br><span class="line"># 发起请求</span><br><span class="line">response = clt.<span class="title function_">do_action_with_exception</span>(request)</span><br><span class="line">print response</span><br><span class="line"></span><br><span class="line">#把json格式的返回值改成dict格式</span><br><span class="line">slow_log=json.<span class="title function_">loads</span>(response)</span><br><span class="line">num = slow_log[<span class="string">&#x27;TotalRecordCount&#x27;</span>]</span><br><span class="line"><span class="title class_">Hostaddress</span> = []</span><br><span class="line"><span class="title class_">LockTimes</span> = []</span><br><span class="line"><span class="title class_">ParseRowCounts</span> = []</span><br><span class="line"><span class="title class_">QueryTimes</span> = []</span><br><span class="line"><span class="title class_">SQLText</span> = []</span><br><span class="line"></span><br><span class="line">#将有用的值做成list</span><br><span class="line"><span class="keyword">if</span> num &lt; <span class="number">100</span>:</span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> <span class="title function_">range</span>(<span class="number">0</span>,num):</span><br><span class="line">               <span class="title class_">Hostaddress</span>.<span class="title function_">append</span>(slow_log[<span class="string">&#x27;Items&#x27;</span>][<span class="string">&#x27;SQLSlowRecord&#x27;</span>][i][<span class="string">&#x27;HostAddress&#x27;</span>])</span><br><span class="line">               <span class="title class_">LockTimes</span>.<span class="title function_">append</span>(slow_log[<span class="string">&#x27;Items&#x27;</span>][<span class="string">&#x27;SQLSlowRecord&#x27;</span>][i][<span class="string">&#x27;LockTimes&#x27;</span>])</span><br><span class="line">               <span class="title class_">ParseRowCounts</span>.<span class="title function_">append</span>(slow_log[<span class="string">&#x27;Items&#x27;</span>][<span class="string">&#x27;SQLSlowRecord&#x27;</span>][i][<span class="string">&#x27;ParseRowCounts&#x27;</span>])</span><br><span class="line">               <span class="title class_">QueryTimes</span>.<span class="title function_">append</span>(slow_log[<span class="string">&#x27;Items&#x27;</span>][<span class="string">&#x27;SQLSlowRecord&#x27;</span>][i][<span class="string">&#x27;QueryTimes&#x27;</span>])</span><br><span class="line">               <span class="title class_">SQLText</span>.<span class="title function_">append</span>(slow_log[<span class="string">&#x27;Items&#x27;</span>][<span class="string">&#x27;SQLSlowRecord&#x27;</span>][i][<span class="string">&#x27;SQLText&#x27;</span>])</span><br><span class="line"><span class="attr">else</span>:</span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> <span class="title function_">range</span>(<span class="number">0</span>,<span class="number">100</span>):</span><br><span class="line">               <span class="title class_">Hostaddress</span>.<span class="title function_">append</span>(slow_log[<span class="string">&#x27;Items&#x27;</span>][<span class="string">&#x27;SQLSlowRecord&#x27;</span>][i][<span class="string">&#x27;HostAddress&#x27;</span>])</span><br><span class="line">               <span class="title class_">LockTimes</span>.<span class="title function_">append</span>(slow_log[<span class="string">&#x27;Items&#x27;</span>][<span class="string">&#x27;SQLSlowRecord&#x27;</span>][i][<span class="string">&#x27;LockTimes&#x27;</span>])</span><br><span class="line">               <span class="title class_">ParseRowCounts</span>.<span class="title function_">append</span>(slow_log[<span class="string">&#x27;Items&#x27;</span>][<span class="string">&#x27;SQLSlowRecord&#x27;</span>][i][<span class="string">&#x27;ParseRowCounts&#x27;</span>])</span><br><span class="line">               <span class="title class_">QueryTimes</span>.<span class="title function_">append</span>(slow_log[<span class="string">&#x27;Items&#x27;</span>][<span class="string">&#x27;SQLSlowRecord&#x27;</span>][i][<span class="string">&#x27;QueryTimes&#x27;</span>])</span><br><span class="line">               <span class="title class_">SQLText</span>.<span class="title function_">append</span>(slow_log[<span class="string">&#x27;Items&#x27;</span>][<span class="string">&#x27;SQLSlowRecord&#x27;</span>][i][<span class="string">&#x27;SQLText&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>这个<code>response</code>的格式是一个<code>json</code>，在<code>www.json.cn</code>里查看是这个样子：<br><img data-src="/images/pandas1.png" alt="paradin"></p>
<p>可以看到返回值里面<code>TotalRecordCount</code>就是总返回值，如果这个值大于<code>PageSize</code>，那么就会有第二篇，需要手动翻篇。所以我这里直接最大值就是100，一篇100已经够开发看了…</p>
<h2 id="脚本如下"><a href="#脚本如下" class="headerlink" title="脚本如下"></a>脚本如下</h2><p>在上面的脚本里可以获取到所有慢sql的<code>json</code>格式，那么就可以再写一个脚本把<code>json</code>转化成<code>html</code>格式并且生成一个<code>html</code>文件，然后在nginx里直接把这个文件展示出来。既然用到了<code>pandas</code>库，那么就要先安装<code>pandas</code>,方法如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pip install --upgrade pip</span><br><span class="line">pip install pandas</span><br><span class="line">如果有“<span class="title class_">Please</span> upgrade numpy to &gt;= <span class="number">1.9</span><span class="number">.0</span> to use <span class="variable language_">this</span> pandas version”的反应，那么执行下一句</span><br><span class="line">pip install -U numpy	</span><br></pre></td></tr></table></figure></p>
<p>生成html的整个脚本如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/usr/</span>bin/env python</span><br><span class="line">#coding=utf-<span class="number">8</span></span><br><span class="line"><span class="keyword">from</span> test <span class="keyword">import</span> <span class="title class_">Hostaddress</span>,<span class="title class_">LockTimes</span>,<span class="title class_">ParseRowCounts</span>,<span class="title class_">QueryTimes</span>,<span class="title class_">SQLText</span>	#从刚写的test.<span class="property">py</span>里得到那些list变量</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">def <span class="title function_">convertToHtml</span>(result,title):</span><br><span class="line">    #将数据转换为html的table</span><br><span class="line">    #result是list[list1,list2]这样的结构</span><br><span class="line">    #title是list结构；和result一一对应。titleList[<span class="number">0</span>]对应resultList[<span class="number">0</span>]这样的一条数据对应html表格中的一列</span><br><span class="line">    d = &#123;&#125;</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> <span class="attr">title</span>:</span><br><span class="line">        d[t]=result[index]</span><br><span class="line">        index = index+<span class="number">1</span></span><br><span class="line">    pd.<span class="title function_">set_option</span>(<span class="string">&#x27;max_colwidth&#x27;</span>,<span class="number">200</span>)	#默认的行长度是<span class="number">50</span>，这里我调成了<span class="number">200</span></span><br><span class="line">    df = pd.<span class="title class_">DataFrame</span>(d)</span><br><span class="line">    df = df[title]</span><br><span class="line">    h = df.<span class="title function_">to_html</span>(index=<span class="title class_">False</span>)</span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    result = [<span class="title class_">Hostaddress</span>,<span class="title class_">LockTimes</span>,<span class="title class_">ParseRowCounts</span>,<span class="title class_">QueryTimes</span>,<span class="title class_">SQLText</span>]</span><br><span class="line">    title = [u<span class="string">&#x27;HostAddress&#x27;</span>,u<span class="string">&#x27;LockTimes&#x27;</span>,u<span class="string">&#x27;ParseRowCounts&#x27;</span>,u<span class="string">&#x27;QueryTimes&#x27;</span>,u<span class="string">&#x27;SQLText&#x27;</span>]</span><br><span class="line">    #生成一个叫biaoge.<span class="property">html</span></span><br><span class="line">    <span class="keyword">with</span> <span class="title function_">open</span>(<span class="string">&#x27;/nginxhtml路径/biaoge.html&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> <span class="attr">f</span>:</span><br><span class="line">        f.<span class="title function_">write</span>(<span class="title function_">convertToHtml</span>(result,title))</span><br><span class="line">        print <span class="string">&quot;html文件已经生成！&quot;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="执行效果"><a href="#执行效果" class="headerlink" title="执行效果"></a>执行效果</h2><p>将这个<code>biaoge.html</code>直接生成到nginx的html文件夹里，在浏览器里打开这个html就看到效果了，如图：<br><img data-src="/images/pandas2.png" alt="paradin"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pandas</tag>
        <tag>大数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>使用jquery从bootstrap4的模态框（model）里取值</title>
    <url>/2020/07/08/%E4%BD%BF%E7%94%A8jquery%E4%BB%8Ebootstrap4%E9%87%8C%E5%8F%96%E5%80%BC/</url>
    <content><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>我们在用Django框架做前端页面的时候经常有这样的需求：某一个表格页面，点击“添加”这个button，然后弹出来一个窗口（术语叫模态框），填写对应的资料提交后，这个表格页面直接刷新，最新添加的数据赫然在列。这个设计里面主要有3个part：<br>1）通过前端模态框输入值可以被Django后台顺利获取；<br>2）获取的值记录到数据库里；<br>3）自动刷新对应页面，将数据库最新的值展现出来；</p>
<p>第二part不是难点。这里先解决第一part。</p>
<p>这里假设我们有一个基于adminLTE的HTML页面，内容如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">  &lt;meta http-equiv=<span class="string">&quot;X-UA-Compatible&quot;</span> content=<span class="string">&quot;IE=edge&quot;</span>&gt;</span><br><span class="line">  &lt;title&gt;阿里供应链平台 | 历次大促列表&lt;/title&gt;</span><br><span class="line">  &lt;!-- Tell the browser to be responsive to screen width --&gt;</span><br><span class="line">  &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- Font Awesome --&gt;</span><br><span class="line">  &lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;/static/plugins/fontawesome-free/css/all.min.css&quot;</span>&gt;</span><br><span class="line">  &lt;!-- Ionicons --&gt;</span><br><span class="line">  &lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css&quot;</span>&gt;</span><br><span class="line">  &lt;!-- Theme style --&gt;</span><br><span class="line">  &lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;/static/dist/css/adminlte.min.css&quot;</span>&gt;</span><br><span class="line">  &lt;!-- Google Font: Source Sans Pro --&gt;</span><br><span class="line">  &lt;link href=<span class="string">&quot;https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,400i,700&quot;</span> rel=<span class="string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body <span class="keyword">class</span>=<span class="string">&quot;hold-transition sidebar-mini&quot;</span>&gt;</span><br><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- Content Wrapper. Contains page content --&gt;</span><br><span class="line">  &lt;div <span class="keyword">class</span>=<span class="string">&quot;content-wrapper&quot;</span>&gt;</span><br><span class="line">    &lt;!-- Content Header (Page header) --&gt;</span><br><span class="line">    &lt;section <span class="keyword">class</span>=<span class="string">&quot;content-header&quot;</span>&gt;</span><br><span class="line">      &lt;div <span class="keyword">class</span>=<span class="string">&quot;container-fluid&quot;</span>&gt;</span><br><span class="line">        &lt;div <span class="keyword">class</span>=<span class="string">&quot;row mb-2&quot;</span>&gt;</span><br><span class="line">          &lt;div <span class="keyword">class</span>=<span class="string">&quot;col-sm-6&quot;</span>&gt;</span><br><span class="line">            &lt;h1&gt;历次大促阵型&lt;/h1&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;&lt;!-- /.container-fluid --&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Main content --&gt;</span><br><span class="line">    &lt;section <span class="keyword">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span><br><span class="line">      &lt;div <span class="keyword">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span><br><span class="line">        &lt;div <span class="keyword">class</span>=<span class="string">&quot;col-12&quot;</span>&gt;</span><br><span class="line">          &lt;div <span class="keyword">class</span>=<span class="string">&quot;card&quot;</span>&gt;</span><br><span class="line">            &lt;div <span class="keyword">class</span>=<span class="string">&quot;card-header&quot;</span>&gt;</span><br><span class="line">              &lt;!-- 按钮触发模态框 --&gt;</span><br><span class="line">              &lt;div <span class="keyword">class</span>=<span class="string">&quot;columns columns-right btn-group pull-right&quot;</span>&gt;</span><br><span class="line">                  &lt;button <span class="built_in">type</span>=<span class="string">&quot;button&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;btn btn-primary&quot;</span> data-toggle=<span class="string">&quot;modal&quot;</span> data-target=<span class="string">&quot;#myModal&quot;</span>&gt;新增大促记录&lt;/button&gt;</span><br><span class="line">              &lt;/div&gt;</span><br><span class="line">              &lt;!-- 新增模态框（Modal） --&gt;</span><br><span class="line">                &lt;form <span class="built_in">id</span>=<span class="string">&quot;add-project-form&quot;</span> action=<span class="string">&quot;#&quot;</span> method=<span class="string">&quot;post&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;form-horizontal&quot;</span> role=<span class="string">&quot;form&quot;</span>&gt;</span><br><span class="line">                  &lt;div <span class="keyword">class</span>=<span class="string">&quot;modal fade&quot;</span> <span class="built_in">id</span>=<span class="string">&quot;myModal&quot;</span> tabindex=<span class="string">&quot;-1&quot;</span> role=<span class="string">&quot;dialog&quot;</span> aria-labelledby=<span class="string">&quot;myModalLabel&quot;</span> aria-hidden=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">                    &lt;div <span class="keyword">class</span>=<span class="string">&quot;modal-dialog&quot;</span>&gt;</span><br><span class="line">                      &lt;div <span class="keyword">class</span>=<span class="string">&quot;modal-content&quot;</span>&gt;</span><br><span class="line">                        &lt;div <span class="keyword">class</span>=<span class="string">&quot;modal-header&quot;</span>&gt;</span><br><span class="line">                         &lt;h5 <span class="keyword">class</span>=<span class="string">&quot;modal-title&quot;</span> <span class="built_in">id</span>=<span class="string">&quot;myModalLabel&quot;</span>&gt;请填写&lt;/h5&gt;</span><br><span class="line">                          &lt;button <span class="built_in">type</span>=<span class="string">&quot;button&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;close&quot;</span> data-dismiss=<span class="string">&quot;modal&quot;</span> aria-hidden=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">                            &amp;times;</span><br><span class="line">                          &lt;/button&gt;</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line">                     &lt;div <span class="keyword">class</span>=<span class="string">&quot;modal-body&quot;</span> style=<span class="string">&quot;height: 100%;&quot;</span>&gt;</span><br><span class="line">                      &lt;div <span class="keyword">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span><br><span class="line">                          &lt;label <span class="keyword">for</span>=<span class="string">&quot;firstname&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;col-sm-3 control-label&quot;</span>&gt;项目名称&lt;/label&gt;</span><br><span class="line">                          &lt;div <span class="keyword">class</span>=<span class="string">&quot;col-sm-7&quot;</span>&gt;</span><br><span class="line">                          &lt;select data-placeholder=<span class="string">&quot;选择大促项目...&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;form-control&quot;</span> name=<span class="string">&quot;project_name&quot;</span> required=<span class="string">&quot;required&quot;</span>&gt;</span><br><span class="line">                              &lt;option value=<span class="string">&quot;&quot;</span>&gt;请选择项目&lt;/option&gt;</span><br><span class="line">                              &lt;option&gt;三八女神节&lt;/option&gt;</span><br><span class="line">                              &lt;option&gt;<span class="number">618</span>精品生活节&lt;/option&gt;</span><br><span class="line">                              &lt;option&gt;九九划算节&lt;/option&gt;</span><br><span class="line">                              &lt;option&gt;双十一购物狂欢节&lt;/option&gt;</span><br><span class="line">                              &lt;option&gt;双十二购物狂欢节&lt;/option&gt;</span><br><span class="line">                              &lt;option&gt;新春购物年货节&lt;/option&gt;</span><br><span class="line">                          &lt;/select&gt;</span><br><span class="line">                          &lt;/div&gt;</span><br><span class="line">                      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">                      &lt;/div&gt;</span><br><span class="line">                          &lt;div <span class="keyword">class</span>=<span class="string">&quot;modal-footer&quot;</span>&gt;</span><br><span class="line">                            &lt;button <span class="built_in">type</span>=<span class="string">&quot;button&quot;</span> data-dismiss=<span class="string">&quot;modal&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;btn btn-danger&quot;</span>&gt; CLOSE &lt;/button&gt;</span><br><span class="line">                          &lt;/div&gt;</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line">                      &lt;/div&gt;&lt;!-- /.modal-content --&gt;</span><br><span class="line">                  &lt;/div&gt;&lt;!-- /.modal --&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">             &lt;/form&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;!-- /.card-header --&gt;</span><br><span class="line"></span><br><span class="line">            &lt;div <span class="keyword">class</span>=<span class="string">&quot;card-body&quot;</span>&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;!-- /.card-body --&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">          &lt;!-- /.card --&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;!-- /.col --&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;!-- /.row --&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">    &lt;!-- /.content --&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;!-- /.content-wrapper --&gt;</span><br><span class="line">  &lt;footer <span class="keyword">class</span>=<span class="string">&quot;main-footer&quot;</span>&gt;</span><br><span class="line">    &lt;div <span class="keyword">class</span>=<span class="string">&quot;float-right d-none d-sm-block&quot;</span>&gt;</span><br><span class="line">      &lt;b&gt;Version&lt;/b&gt; <span class="number">3.0</span><span class="number">.2</span></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;strong&gt;Copyright &amp;copy; <span class="number">2014</span>-<span class="number">2019</span> &lt;a href=<span class="string">&quot;http://adminlte.io&quot;</span>&gt;AdminLTE.io&lt;/a&gt;.&lt;/strong&gt; All rights</span><br><span class="line">    reserved.</span><br><span class="line">  &lt;/footer&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- Control Sidebar --&gt;</span><br><span class="line">  &lt;aside <span class="keyword">class</span>=<span class="string">&quot;control-sidebar control-sidebar-dark&quot;</span>&gt;</span><br><span class="line">    &lt;!-- Control sidebar content goes here --&gt;</span><br><span class="line">  &lt;/aside&gt;</span><br><span class="line">  &lt;!-- /.control-sidebar --&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!-- ./wrapper --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- jQuery --&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;/static/plugins/jquery/jquery.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- Bootstrap <span class="number">4</span> --&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;/static/plugins/bootstrap/js/bootstrap.bundle.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><br>效果如图：<br><img data-src="/images/HTML%E9%A1%B5%E9%9D%A2.png" alt="akb48" title="左边的空栏不用管，那是原来放导航栏的"></p>
<p>现在我们要点击“新增大促记录”，然后选择大促对应的名称，同时在页面进行反馈，那么现在就要用到jquery来取model的值。</p>
<p>首先我先在页面空白处创建一个div，<code>&lt;div id=&quot;result&quot;&gt; &lt;/div&gt;</code>，再给“新增大促记录”的button添加一个id叫<code>addproject</code>，再输入框添加一个id叫<code>project_name</code>，然后添加对应的script如下:<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;-- 添加获取值的脚本 --&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">  $(document).ready(function()&#123;</span><br><span class="line">    $(<span class="string">&#x27;#addproject&#x27;</span>).click(function()&#123;</span><br><span class="line">      var data = $(<span class="string">&quot;#myModal #project_name&quot;</span>).val().trim();</span><br><span class="line">        $(<span class="string">&#x27;#result&#x27;</span>).html(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p>
<p>整个脚本很简单，通过点击<code>#addproject</code>给data这个变量赋值，这个data赋值是myModal里的project_name。然后将这个值在result的地方展示出来。</p>
<p>完整的HTML如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">  &lt;meta http-equiv=<span class="string">&quot;X-UA-Compatible&quot;</span> content=<span class="string">&quot;IE=edge&quot;</span>&gt;</span><br><span class="line">  &lt;title&gt;阿里供应链平台 | 历次大促列表&lt;/title&gt;</span><br><span class="line">  &lt;!-- Tell the browser to be responsive to screen width --&gt;</span><br><span class="line">  &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- Font Awesome --&gt;</span><br><span class="line">  &lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;/static/plugins/fontawesome-free/css/all.min.css&quot;</span>&gt;</span><br><span class="line">  &lt;!-- Ionicons --&gt;</span><br><span class="line">  &lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css&quot;</span>&gt;</span><br><span class="line">  &lt;!-- Theme style --&gt;</span><br><span class="line">  &lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;/static/dist/css/adminlte.min.css&quot;</span>&gt;</span><br><span class="line">  &lt;!-- Google Font: Source Sans Pro --&gt;</span><br><span class="line">  &lt;link href=<span class="string">&quot;https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,400i,700&quot;</span> rel=<span class="string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body <span class="keyword">class</span>=<span class="string">&quot;hold-transition sidebar-mini&quot;</span>&gt;</span><br><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- Content Wrapper. Contains page content --&gt;</span><br><span class="line">  &lt;div <span class="keyword">class</span>=<span class="string">&quot;content-wrapper&quot;</span>&gt;</span><br><span class="line">    &lt;!-- Content Header (Page header) --&gt;</span><br><span class="line">    &lt;section <span class="keyword">class</span>=<span class="string">&quot;content-header&quot;</span>&gt;</span><br><span class="line">      &lt;div <span class="keyword">class</span>=<span class="string">&quot;container-fluid&quot;</span>&gt;</span><br><span class="line">        &lt;div <span class="keyword">class</span>=<span class="string">&quot;row mb-2&quot;</span>&gt;</span><br><span class="line">          &lt;div <span class="keyword">class</span>=<span class="string">&quot;col-sm-6&quot;</span>&gt;</span><br><span class="line">            &lt;h1&gt;历次大促阵型&lt;/h1&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;&lt;!-- /.container-fluid --&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Main content --&gt;</span><br><span class="line">    &lt;section <span class="keyword">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span><br><span class="line">      &lt;div <span class="keyword">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span><br><span class="line">        &lt;div <span class="keyword">class</span>=<span class="string">&quot;col-12&quot;</span>&gt;</span><br><span class="line">          &lt;div <span class="keyword">class</span>=<span class="string">&quot;card&quot;</span>&gt;</span><br><span class="line">            &lt;div <span class="keyword">class</span>=<span class="string">&quot;card-header&quot;</span>&gt;</span><br><span class="line">              &lt;!-- 按钮触发模态框 --&gt;</span><br><span class="line">              &lt;div <span class="keyword">class</span>=<span class="string">&quot;columns columns-right btn-group pull-right&quot;</span>&gt;</span><br><span class="line">                  &lt;button <span class="built_in">type</span>=<span class="string">&quot;button&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;btn btn-primary&quot;</span> data-toggle=<span class="string">&quot;modal&quot;</span> data-target=<span class="string">&quot;#myModal&quot;</span>&gt;新增大促记录&lt;/button&gt;</span><br><span class="line">              &lt;/div&gt;</span><br><span class="line">              &lt;!-- 新增模态框（Modal） --&gt;</span><br><span class="line">                &lt;form <span class="built_in">id</span>=<span class="string">&quot;add-project-form&quot;</span> action=<span class="string">&quot;#&quot;</span> method=<span class="string">&quot;post&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;form-horizontal&quot;</span> role=<span class="string">&quot;form&quot;</span>&gt;</span><br><span class="line">                  &lt;div <span class="keyword">class</span>=<span class="string">&quot;modal fade&quot;</span> <span class="built_in">id</span>=<span class="string">&quot;myModal&quot;</span> tabindex=<span class="string">&quot;-1&quot;</span> role=<span class="string">&quot;dialog&quot;</span> aria-labelledby=<span class="string">&quot;myModalLabel&quot;</span> aria-hidden=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">                    &lt;div <span class="keyword">class</span>=<span class="string">&quot;modal-dialog&quot;</span>&gt;</span><br><span class="line">                      &lt;div <span class="keyword">class</span>=<span class="string">&quot;modal-content&quot;</span>&gt;</span><br><span class="line">                        &lt;div <span class="keyword">class</span>=<span class="string">&quot;modal-header&quot;</span>&gt;</span><br><span class="line">                         &lt;h5 <span class="keyword">class</span>=<span class="string">&quot;modal-title&quot;</span> <span class="built_in">id</span>=<span class="string">&quot;myModalLabel&quot;</span>&gt;请填写&lt;/h5&gt;</span><br><span class="line">                          &lt;button <span class="built_in">type</span>=<span class="string">&quot;button&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;close&quot;</span> data-dismiss=<span class="string">&quot;modal&quot;</span> aria-hidden=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">                            &amp;times;</span><br><span class="line">                          &lt;/button&gt;</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line">                     &lt;div <span class="keyword">class</span>=<span class="string">&quot;modal-body&quot;</span> style=<span class="string">&quot;height: 100%;&quot;</span>&gt;</span><br><span class="line">                      &lt;div <span class="keyword">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span><br><span class="line">                          &lt;label <span class="keyword">for</span>=<span class="string">&quot;firstname&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;col-sm-3 control-label&quot;</span>&gt;项目名称&lt;/label&gt;</span><br><span class="line">                          &lt;div <span class="keyword">class</span>=<span class="string">&quot;col-sm-7&quot;</span>&gt;</span><br><span class="line">                          &lt;select data-placeholder=<span class="string">&quot;选择大促项目...&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;form-control&quot;</span> name=<span class="string">&quot;project_name&quot;</span> <span class="built_in">id</span>=<span class="string">&quot;project_name&quot;</span> required=<span class="string">&quot;required&quot;</span>&gt;</span><br><span class="line">                              &lt;option value=<span class="string">&quot;&quot;</span>&gt;请选择项目&lt;/option&gt;</span><br><span class="line">                              &lt;option&gt;三八女神节&lt;/option&gt;</span><br><span class="line">                              &lt;option&gt;<span class="number">618</span>精品生活节&lt;/option&gt;</span><br><span class="line">                              &lt;option&gt;九九划算节&lt;/option&gt;</span><br><span class="line">                              &lt;option&gt;双十一购物狂欢节&lt;/option&gt;</span><br><span class="line">                              &lt;option&gt;双十二购物狂欢节&lt;/option&gt;</span><br><span class="line">                              &lt;option&gt;新春购物年货节&lt;/option&gt;</span><br><span class="line">                          &lt;/select&gt;</span><br><span class="line">                          &lt;/div&gt;</span><br><span class="line">                      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">                      &lt;/div&gt;</span><br><span class="line">                          &lt;div <span class="keyword">class</span>=<span class="string">&quot;modal-footer&quot;</span>&gt;</span><br><span class="line">                            &lt;button <span class="built_in">type</span>=<span class="string">&quot;button&quot;</span> data-dismiss=<span class="string">&quot;modal&quot;</span> <span class="built_in">id</span>=<span class="string">&quot;addproject&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;btn btn-danger&quot;</span>&gt; CLOSE &lt;/button&gt;</span><br><span class="line">                          &lt;/div&gt;</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line">                      &lt;/div&gt;&lt;!-- /.modal-content --&gt;</span><br><span class="line">                  &lt;/div&gt;&lt;!-- /.modal --&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">             &lt;/form&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;!-- /.card-header --&gt;</span><br><span class="line"></span><br><span class="line">            &lt;div <span class="built_in">id</span>=<span class="string">&quot;result&quot;</span>&gt; &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">            &lt;div <span class="keyword">class</span>=<span class="string">&quot;card-body&quot;</span>&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;!-- /.card-body --&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">          &lt;!-- /.card --&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;!-- /.col --&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;!-- /.row --&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">    &lt;!-- /.content --&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;!-- /.content-wrapper --&gt;</span><br><span class="line">  &lt;footer <span class="keyword">class</span>=<span class="string">&quot;main-footer&quot;</span>&gt;</span><br><span class="line">    &lt;div <span class="keyword">class</span>=<span class="string">&quot;float-right d-none d-sm-block&quot;</span>&gt;</span><br><span class="line">      &lt;b&gt;Version&lt;/b&gt; <span class="number">3.0</span><span class="number">.2</span></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;strong&gt;Copyright &amp;copy; <span class="number">2014</span>-<span class="number">2019</span> &lt;a href=<span class="string">&quot;http://adminlte.io&quot;</span>&gt;AdminLTE.io&lt;/a&gt;.&lt;/strong&gt; All rights</span><br><span class="line">    reserved.</span><br><span class="line">  &lt;/footer&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- Control Sidebar --&gt;</span><br><span class="line">  &lt;aside <span class="keyword">class</span>=<span class="string">&quot;control-sidebar control-sidebar-dark&quot;</span>&gt;</span><br><span class="line">    &lt;!-- Control sidebar content goes here --&gt;</span><br><span class="line">  &lt;/aside&gt;</span><br><span class="line">  &lt;!-- /.control-sidebar --&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!-- ./wrapper --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- jQuery --&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;/static/plugins/jquery/jquery.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- Bootstrap <span class="number">4</span> --&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;/static/plugins/bootstrap/js/bootstrap.bundle.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">  $(document).ready(function()&#123;</span><br><span class="line">    $(<span class="string">&#x27;#addproject&#x27;</span>).click(function()&#123;</span><br><span class="line">      var databack = $(<span class="string">&quot;#myModal #project_name&quot;</span>).val().trim();</span><br><span class="line">        $(<span class="string">&#x27;#result&#x27;</span>).html(databack);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>这样你在模态框里输入值的话，result的div就会变成你输入值的样子。</p>
<h2 id="Django从jQuery取值"><a href="#Django从jQuery取值" class="headerlink" title="Django从jQuery取值"></a>Django从jQuery取值</h2><p>上面的内容可以在HTML里获取到JS的值。那如果要从Django的后台<code>views.py</code>里获取到<code>project_name</code>怎么办呢?我们就要改一下jquery：<br>	<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  $(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    $(<span class="string">&#x27;#addproject&#x27;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> project_name =  $(<span class="string">&quot;#project_name&quot;</span>).<span class="title function_">val</span>();		<span class="comment">// 这样就获取到了</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">cache</span>:<span class="literal">false</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">type</span>: <span class="string">&quot;POST&quot;</span>,<span class="comment">//方法类型</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">dataType</span>: <span class="string">&quot;json&quot;</span>,<span class="comment">//预期服务器返回的数据类型</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">url</span>: <span class="string">&#x27;&#123;% url &quot;add_activity&quot; %&#125;&#x27;</span> ,<span class="comment">// 添加的url，这里需要去url.py里指定一下</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">data</span>: $(<span class="string">&#x27;#add-project-form&#x27;</span>).<span class="title function_">serialize</span>(), <span class="comment">//将模态框的form表单数据序列化，以便提交到后台</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">async</span>: <span class="literal">false</span>,  <span class="comment">//如果是true是异步方式，$.ajax执行后，会继续执行ajax后面的脚本，直到服务器端返回数据后，触发$.ajax里的success方法</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">console</span>.<span class="title function_">log</span>(data);    <span class="comment">//打印服务端返回的数据(调试用)</span></span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">if</span>(data.<span class="property">status</span> == <span class="string">&quot;success&quot;</span>)&#123;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">              <span class="comment">// 关闭模态框并清除框内数据，否则下次打开还是上次的数据</span></span></span><br><span class="line"><span class="language-javascript">              <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;add-project-form&quot;</span>).<span class="title function_">reset</span>();</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">              <span class="comment">// 判断确实正确入库之后提示</span></span></span><br><span class="line"><span class="language-javascript">              <span class="title function_">alert</span>(<span class="string">&#x27;提交数据成功&#x27;</span> + data);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">              location.<span class="title function_">reload</span>(); <span class="comment">// 直接刷新当前页面，这样新加的数据就展示出来了</span></span></span><br><span class="line"><span class="language-javascript">           &#125;</span></span><br><span class="line"><span class="language-javascript">       &#125;,</span></span><br><span class="line"><span class="language-javascript">    error : <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;数据存入数据库失败，请检查...&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">           &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;); </span></span><br><span class="line"><span class="language-javascript">     &#125;);</span></span><br><span class="line"><span class="language-javascript">   &#125;)</span></span><br></pre></td></tr></table></figure></p>
<p>后台的views.py如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Promotion   <span class="comment">#这里需要先去model.py创建一个叫promotion的class用来存储数据</span></span><br><span class="line"><span class="comment"># 大促信息展示</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">activity</span>(<span class="params">request</span>):</span><br><span class="line">    context = &#123;&#125;</span><br><span class="line">    context[<span class="string">&quot;activities&quot;</span>] = Promotion.objects.<span class="built_in">all</span>()</span><br><span class="line">    <span class="keyword">return</span> render_to_response(<span class="string">&#x27;activity.html&#x27;</span>,context)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 大促信息录入到数据库</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_activity</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;POST&quot;</span>:  <span class="comment"># 这里是修改添加操作，所以要有CSRFtoken的控制</span></span><br><span class="line">        project = request.POST.get(<span class="string">&quot;project_name&quot;</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(project）</span><br><span class="line">    activity_data = Promotion.objects.create(promotionname=project）</span><br><span class="line">   	activity_data.save()  <span class="comment">#保存到数据库里</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;status&#x27;</span>: <span class="string">&#x27;success&#x27;</span>&#125;)  <span class="comment"># 这个信息返回给AJAX,django 2.1的写法</span></span><br></pre></td></tr></table></figure></p>
<p>这样就实现了“弹出模态框输入内容保存到数据库里，同时界面刷新”的效果了，如下：<br><img data-src="/images/jQuery%E5%8F%96%E5%80%BC%E4%B8%8A%E4%BC%A0.gif" alt="akb48" title="这个图是加了其他效果的展示"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.runoob.com/jquery/jquery-dom-get.html">https://www.runoob.com/jquery/jquery-dom-get.html</a><br><a href="https://www.youtube.com/watch?v=8zTL1LMxBqc">https://www.youtube.com/watch?v=8zTL1LMxBqc</a><br><a href="https://github.com/YoLoveLife/DevOps/issues/22">https://github.com/YoLoveLife/DevOps/issues/22</a><br><a href="https://www.jianshu.com/p/26cd9f442a13">https://www.jianshu.com/p/26cd9f442a13</a><br><a href="https://www.cnblogs.com/gcgc/p/11176389.html">https://www.cnblogs.com/gcgc/p/11176389.html</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>jquery</tag>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title>使用matplotlib画图的一个脚本</title>
    <url>/2018/02/27/%E4%BD%BF%E7%94%A8matplotlib%E7%94%BB%E5%9B%BE%E7%9A%84%E4%B8%80%E4%B8%AA%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>之前在<a href="https://rorschachchan.github.io/2018/02/24/%E9%98%BF%E9%87%8C%E4%BA%91%E8%8E%B7%E5%8F%96DTS%E6%9C%8D%E5%8A%A1%E5%BB%B6%E8%BF%9F%E7%9A%84%E8%84%9A%E6%9C%AC/">https://rorschachchan.github.io/2018/02/24/阿里云获取DTS服务延迟的脚本/</a> 里已经可以获取到阿里云DTS服务的延迟时长和同步速率。下一步就是把这些值以24小时为周期作一个图像，然后每天在固定时间发送到领导们的邮件里。</p>
<p>python作图的第三方工具叫<code>matplotlib</code>，安装步骤如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pip install matplotlib	#画图模块</span><br><span class="line">pip install numpy	#依赖的库</span><br><span class="line">pip install scipy	#又一个依赖的库</span><br><span class="line">yum install -y <span class="title class_">Tkinter</span>	#如果是python3，那么就是yum install -y tkinter</span><br></pre></td></tr></table></figure></p>
<h2 id="脚本内容"><a href="#脚本内容" class="headerlink" title="脚本内容"></a>脚本内容</h2><p>由于我是在<code>centos 7</code>里进行脚本操作，而linux服务器有没有安装图像，所以在执行<code>import matplotlib.pyplot as plt</code>的时候可能会爆错：<code>RuntimeError: could not open display</code>，这个时候需要在前面改成如下样式（注意先后顺序）：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line">mpl.<span class="title function_">use</span>(<span class="string">&#x27;Agg&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> matplotlib.<span class="property">pyplot</span> <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure></p>
<p>举一个简单的脚本例子如下，就是给予（x,y）然后连成曲线图的效果，脚本里数字的部分不加引号也是可以识别的，当然使用变量也可以。<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/usr/</span>bin/env python</span><br><span class="line"># -*- <span class="attr">coding</span>: utf-<span class="number">8</span> -*-</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line">mpl.<span class="title function_">use</span>(<span class="string">&#x27;Agg&#x27;</span>)	</span><br><span class="line"><span class="keyword">import</span> matplotlib.<span class="property">pyplot</span> <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"><span class="keyword">import</span> pylab <span class="keyword">as</span> pl  </span><br><span class="line"> </span><br><span class="line">x=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>]</span><br><span class="line">#横坐标的内容</span><br><span class="line">labels=[<span class="string">&#x27;10&#x27;</span>,<span class="string">&#x27;11&#x27;</span>,<span class="string">&#x27;12&#x27;</span>,<span class="string">&#x27;13&#x27;</span>,<span class="string">&#x27;14&#x27;</span>,<span class="string">&#x27;15&#x27;</span>,<span class="string">&#x27;16&#x27;</span>,<span class="string">&#x27;17&#x27;</span>,<span class="string">&#x27;18&#x27;</span>,<span class="string">&#x27;19&#x27;</span>,<span class="string">&#x27;20&#x27;</span>,<span class="string">&#x27;21&#x27;</span>,<span class="string">&#x27;22&#x27;</span>,<span class="string">&#x27;23&#x27;</span>,<span class="string">&#x27;24&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;9&#x27;</span>]</span><br><span class="line"></span><br><span class="line">a = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">b = <span class="string">&#x27;2&#x27;</span></span><br><span class="line">c = <span class="string">&#x27;3&#x27;</span></span><br><span class="line">d = <span class="string">&#x27;4&#x27;</span></span><br><span class="line"></span><br><span class="line">#y1是延迟</span><br><span class="line">y1=[<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;5&#x27;</span>]</span><br><span class="line"></span><br><span class="line">#y2是同步速率</span><br><span class="line">y2=[a,b,c,d,<span class="number">0.13</span>,<span class="number">0.12</span>,<span class="number">0.14</span>,<span class="number">0.14</span>,<span class="number">0.14</span>,<span class="number">0.16</span>,<span class="number">0.15</span>,<span class="number">0.13</span>,<span class="number">0.12</span>,<span class="number">0.14</span>,<span class="number">0.14</span>,<span class="number">0.14</span>,<span class="number">0.16</span>,<span class="number">0.15</span>,<span class="number">0.13</span>,<span class="number">0.12</span>,<span class="number">0.14</span>,<span class="number">0.22</span>,<span class="number">0.18</span>,<span class="number">0.11</span>]</span><br><span class="line"></span><br><span class="line">#输入对应的坐标，后面是颜色</span><br><span class="line">plot1,=pl.<span class="title function_">plot</span>(x,y1,<span class="string">&#x27;r&#x27;</span>)	#这里是有逗号的，用于参数解包</span><br><span class="line">plot2,=pl.<span class="title function_">plot</span>(x,y2,<span class="string">&#x27;b&#x27;</span>)  </span><br><span class="line">pl.<span class="title function_">xticks</span>(x,labels)</span><br><span class="line"></span><br><span class="line">#图片的标题以及对应的字号大小</span><br><span class="line">pl.<span class="title function_">title</span>(<span class="string">&#x27;The DTS status of Shenzhen VPC&#x27;</span>,size=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">#X轴的标题和字号大小</span><br><span class="line">pl.<span class="title function_">xlabel</span>(<span class="string">&#x27;Time&#x27;</span>, size=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">#Y轴的标题，字号大小和长度</span><br><span class="line">pl.<span class="title function_">xlabel</span>(<span class="string">&#x27;Time&#x27;</span>, size=<span class="number">14</span>)</span><br><span class="line">pl.<span class="title function_">ylim</span>(<span class="number">0.0</span>,<span class="number">5.0</span>)</span><br><span class="line"></span><br><span class="line">#曲线对应注释</span><br><span class="line">pl.<span class="title function_">legend</span>([plot1,plot2],(<span class="string">&#x27;Delay&#x27;</span>,<span class="string">&#x27;Sync rate&#x27;</span>),<span class="string">&#x27;best&#x27;</span>,numpoints=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">#图片保存路径</span><br><span class="line">plt.<span class="title function_">savefig</span>(<span class="string">&#x27;/tmp/dts.png&#x27;</span>, format=<span class="string">&#x27;png&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>脚本执行效果之后，会在对应的路径里生成一个图片文件，然后把这个图片转移到windows，打开就看到效果了，如图：<br><img data-src="/images/dts.png" alt="paradin"></p>
<p>这个图是全英文的，如果是中文的话，就会出现乱码，研究了半天也没搞明白，这一点让我很郁闷。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://python.jobbole.com/81182/">http://python.jobbole.com/81182/</a><br><a href="https://absentm.github.io/2017/03/18/Python-matplotlib-%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/">https://absentm.github.io/2017/03/18/Python-matplotlib-数据可视化/</a><br><a href="https://liam0205.me/2014/09/11/matplotlib-tutorial-zh-cn/">https://liam0205.me/2014/09/11/matplotlib-tutorial-zh-cn/</a><br><a href="https://morvanzhou.github.io/tutorials/data-manipulation/plt/1-1-why/">https://morvanzhou.github.io/tutorials/data-manipulation/plt/1-1-why/</a><br><a href="https://www.lookfor404.com/%E8%BF%90%E8%A1%8Cggplot%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98no-display-name-and-no-display-environment-variable/">https://www.lookfor404.com/%E8%BF%90%E8%A1%8Cggplot%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98no-display-name-and-no-display-environment-variable/</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Python GUI去创建阿里云负载均衡</title>
    <url>/2019/05/07/%E4%BD%BF%E7%94%A8python-GUI%E5%8E%BB%E5%88%9B%E5%BB%BA%E9%98%BF%E9%87%8C%E4%BA%91%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近闲来无事研究了一下python3的gui，就用最基础的tkinter去做了一个购买阿里云负载均衡的脚本，先看一下效果：<br><img data-src="/images/tkinter1.png" alt="akb48" title="在对应的栏目里输入相应的值"></p>
<p>点击“确认”按钮之后，就会出现这样一个谈话框：<br><img data-src="/images/tkinter2.png" alt="akb48"></p>
<p>确认参数完毕之后，若点击取消则返回上一层页面修改，如果点击确认则进行购买。</p>
<p>这个脚本需要的基础知识可以去看一下莫烦大大的tkinter教学系列，地址是<a href="https://morvanzhou.github.io/tutorials/python-basic/tkinter/">https://morvanzhou.github.io/tutorials/python-basic/tkinter/</a> ，B站有全部的视频，不到10分钟一节课，还是很棒的。</p>
<h2 id="脚本正文"><a href="#脚本正文" class="headerlink" title="脚本正文"></a>脚本正文</h2><p>脚本内容如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python </span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment">#作者：ChrisChan</span></span><br><span class="line"><span class="comment">#用途：py3脚本，使用GUI购买阿里云SLB脚本</span></span><br><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk</span><br><span class="line"><span class="keyword">import</span> tkinter.ttk <span class="keyword">as</span> ttk	<span class="comment">#下拉式菜单</span></span><br><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> messagebox  <span class="comment">#弹窗</span></span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.client <span class="keyword">import</span> AcsClient</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.acs_exception.exceptions <span class="keyword">import</span> ClientException</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.acs_exception.exceptions <span class="keyword">import</span> ServerException</span><br><span class="line"><span class="keyword">from</span> aliyunsdkslb.request.v20140515.CreateLoadBalancerRequest <span class="keyword">import</span> CreateLoadBalancerRequest</span><br><span class="line"></span><br><span class="line"><span class="comment">#秘钥集合</span></span><br><span class="line">aksk_A = [<span class="string">&quot;第一个账号的ak&quot;</span>,<span class="string">&quot;第一个账号的sk&quot;</span>]</span><br><span class="line">aksk_B = [<span class="string">&quot;第2个账号的ak&quot;</span>,<span class="string">&quot;第2个账号的sk&quot;</span>]</span><br><span class="line">aksk_C = [<span class="string">&quot;第3个账号的ak&quot;</span>,<span class="string">&quot;第3个账号的sk&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个类可以建立负载均衡</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CreateSlb</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,ak,sk,domain</span>):</span><br><span class="line">        <span class="variable language_">self</span>.ak = ak</span><br><span class="line">        <span class="variable language_">self</span>.sk = sk</span><br><span class="line">        <span class="variable language_">self</span>.domain = domain</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">self,name,nettype</span>):</span><br><span class="line">        client = AcsClient(<span class="variable language_">self</span>.ak,<span class="variable language_">self</span>.sk,<span class="variable language_">self</span>.domain)</span><br><span class="line">        request = CreateLoadBalancerRequest()</span><br><span class="line">        request.set_accept_format(<span class="string">&#x27;json&#x27;</span>)</span><br><span class="line">        request.set_LoadBalancerSpec(<span class="string">&quot;slb.s1.small&quot;</span>)	<span class="comment">#这里是负载均衡的规格，</span></span><br><span class="line">        request.set_LoadBalancerName(name)</span><br><span class="line">        request.set_AddressType(nettype)</span><br><span class="line">        response = client.do_action_with_exception(request)</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">str</span>(response, encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">window = tk.Tk()	<span class="comment">#建立一个窗体</span></span><br><span class="line">window.title(<span class="string">&quot;购买阿里云负载均衡&quot;</span>)   <span class="comment">#窗体的标题</span></span><br><span class="line"></span><br><span class="line">Label1 = tk.Label(window, text=<span class="string">&#x27;请输入负载均衡名称:&#x27;</span>).grid(row=<span class="number">0</span>, column=<span class="number">0</span>)</span><br><span class="line">v1 = tk.StringVar()</span><br><span class="line">e1 = tk.Entry(window, textvariable=v1)</span><br><span class="line">e1.grid(row=<span class="number">0</span>,column=<span class="number">1</span>,padx=<span class="number">10</span>,pady=<span class="number">5</span>)  <span class="comment"># 设置输入框显示的位置，以及长和宽属性</span></span><br><span class="line"></span><br><span class="line">l = tk.Label(window,bg=<span class="string">&quot;yellow&quot;</span>,width=<span class="number">20</span>,text=<span class="string">&quot;默认值是1&quot;</span>)</span><br><span class="line">l.grid(row=<span class="number">1</span>,column=<span class="number">1</span>,padx=<span class="number">10</span>,pady=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">parameter1 = tk.StringVar()</span><br><span class="line">l1 = tk.Label(window,bg=<span class="string">&#x27;pink&#x27;</span>,width=<span class="number">20</span>,height=<span class="number">5</span>,text=<span class="string">&quot;请选择对应的阿里云账号&quot;</span>)</span><br><span class="line">l1.grid(row=<span class="number">2</span>,column=<span class="number">1</span>,rowspan=<span class="number">3</span>,padx=<span class="number">10</span>,pady=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">parameter2 = tk.StringVar()</span><br><span class="line">l2 = tk.Label(window,bg=<span class="string">&#x27;yellow&#x27;</span>,width=<span class="number">20</span>,text=<span class="string">&quot;请选择实例所在的地域&quot;</span>)</span><br><span class="line">l2.grid(row=<span class="number">5</span>,column=<span class="number">1</span>,padx=<span class="number">10</span>,pady=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">parameter3 = tk.StringVar()</span><br><span class="line">l3 = tk.Label(window,bg=<span class="string">&#x27;green&#x27;</span>,width=<span class="number">20</span>,height=<span class="number">3</span>,text=<span class="string">&quot;请选择网络类型&quot;</span>)</span><br><span class="line">l3.grid(row=<span class="number">10</span>,column=<span class="number">1</span>,rowspan=<span class="number">2</span>,padx=<span class="number">10</span>,pady=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clickMe</span>():</span><br><span class="line">    result = messagebox.askokcancel(<span class="string">&quot;请确认&quot;</span>, <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    负载均衡名称是：%s,对应账号是：%s,所在区域是：%s,网络类型是：%s</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span> % (v1.get(),parameter1.get(),region1.get(),parameter3.get())) <span class="comment">#前面是弹窗主题，后面是弹窗内容</span></span><br><span class="line">    name = v1.get()</span><br><span class="line">    nettype = parameter3.get()</span><br><span class="line">    domain = region1.get()</span><br><span class="line">    account = parameter1.get()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;负载均衡名称是：%s&quot;</span> % name)  <span class="comment"># 获取用户输入的信息</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;所在区域是：%s&quot;</span> % domain)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;对应账号是：%s&quot;</span> % account)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;网络类型是：%s&quot;</span> % nettype)</span><br><span class="line">    <span class="keyword">if</span> result <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> account == <span class="string">&quot;A&quot;</span>:</span><br><span class="line">            ak = aksk_A[<span class="number">0</span>]</span><br><span class="line">            sk = aksk_A[<span class="number">1</span>]</span><br><span class="line">            getSLB = CreateSlb(ak,sk,domain)    <span class="comment">#将类实例化</span></span><br><span class="line">            getSLB.create(name,nettype)	<span class="comment">#执行购买函数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> account == <span class="string">&quot;B&quot;</span>:</span><br><span class="line">            ak = aksk_B[<span class="number">0</span>]</span><br><span class="line">            sk = aksk_B[<span class="number">1</span>]</span><br><span class="line">            getSLB = CreateSlb(ak, sk, domain)  <span class="comment"># 将类实例化</span></span><br><span class="line">            getSLB.create(name,nettype)	<span class="comment">#执行购买函数</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ak = aksk_C[<span class="number">0</span>]</span><br><span class="line">            sk = aksk_C[<span class="number">1</span>]</span><br><span class="line">            getSLB = CreateSlb(ak, sk, domain)  <span class="comment"># 将类实例化</span></span><br><span class="line">            getSLB.create(name,nettype)	<span class="comment">#执行购买函数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;购买完毕！&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_selection</span>(<span class="params">v</span>):</span><br><span class="line">    l.config(text=<span class="string">&quot;当前选择的值是：&quot;</span> + v)   <span class="comment">#V就是传入值也是获取的长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_env</span>():</span><br><span class="line">    l1.config(text=<span class="string">&quot;你选择了&quot;</span>+parameter1.get())  <span class="comment">#使用config功能去改变原有l的参数,把text变成了提取var1里的值</span></span><br><span class="line">    <span class="comment">#print(parameter1.get())</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_region</span>():</span><br><span class="line">    l2.config(text=<span class="string">&quot;你选择了&quot;</span>+region1.get())</span><br><span class="line">    <span class="comment">#print(parameter2.get())</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_network</span>():</span><br><span class="line">    l3.config(text=<span class="string">&quot;你选择了&quot;</span>+parameter3.get())</span><br><span class="line">    <span class="comment">#print(parameter3.get())</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#选择环境</span></span><br><span class="line">env1 = tk.Radiobutton(window,text=<span class="string">&quot;第一个账号&quot;</span>,variable=parameter1,value=<span class="string">&#x27;A&#x27;</span>,command=get_env)</span><br><span class="line">env2 = tk.Radiobutton(window,text=<span class="string">&quot;第2个账号&quot;</span>,variable=parameter1,value=<span class="string">&#x27;B&#x27;</span>,command=get_env)</span><br><span class="line">env3 = tk.Radiobutton(window,text=<span class="string">&quot;第3个账号&quot;</span>,variable=parameter1,value=<span class="string">&#x27;C&#x27;</span>,command=get_env)</span><br><span class="line">env1.grid(row=<span class="number">2</span>, column=<span class="number">0</span>, padx=<span class="number">10</span>, pady=<span class="number">5</span>)</span><br><span class="line">env2.grid(row=<span class="number">3</span>, column=<span class="number">0</span>, padx=<span class="number">10</span>, pady=<span class="number">5</span>)</span><br><span class="line">env3.grid(row=<span class="number">4</span>, column=<span class="number">0</span>, padx=<span class="number">10</span>, pady=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#选择地域，使用下拉列表</span></span><br><span class="line">number = tk.StringVar()</span><br><span class="line">region1 = ttk.Combobox(window,width=<span class="number">12</span>,textvariable=number,state=<span class="string">&#x27;readonly&#x27;</span>)    <span class="comment">#加入readonly，使下拉列表设置成为只读模式</span></span><br><span class="line">region1[<span class="string">&#x27;values&#x27;</span>] = (<span class="string">&quot;cn-hangzhou&quot;</span>,<span class="string">&quot;cn-shenzhen&quot;</span>,<span class="string">&quot;eu-central-1&quot;</span>,<span class="string">&quot;ap-southeast-1&quot;</span>,<span class="string">&quot;cn-hongkong&quot;</span>)   <span class="comment">#下拉列表里面具体的元素</span></span><br><span class="line">region1.grid(row=<span class="number">5</span>,column=<span class="number">0</span>)</span><br><span class="line">region1.current(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#选择内/外网</span></span><br><span class="line">network1 = tk.Radiobutton(window,text=<span class="string">&quot;内网&quot;</span>,variable=parameter3,value=<span class="string">&#x27;intranet&#x27;</span>,command=get_network)</span><br><span class="line">network2 = tk.Radiobutton(window,text=<span class="string">&quot;外网&quot;</span>,variable=parameter3,value=<span class="string">&#x27;internet&#x27;</span>,command=get_network)</span><br><span class="line">network1.grid(row=<span class="number">10</span>, column=<span class="number">0</span>, padx=<span class="number">10</span>, pady=<span class="number">5</span>)</span><br><span class="line">network2.grid(row=<span class="number">11</span>, column=<span class="number">0</span>, padx=<span class="number">10</span>, pady=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#尺度区间</span></span><br><span class="line">s = tk.Scale(window,label=<span class="string">&quot;想要多少台?&quot;</span>,from_=<span class="number">1</span>,to=<span class="number">20</span>,orient=tk.HORIZONTAL,resolution=<span class="number">1</span>,command=print_selection)   </span><br><span class="line"><span class="comment">#HORIZONTAL横向,length的单位是像素,resolution单位是取小数还是取整</span></span><br><span class="line">s.grid(row=<span class="number">1</span>, column=<span class="number">0</span>, padx=<span class="number">10</span>, pady=<span class="number">5</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">#提交按钮</span></span><br><span class="line">action = tk.Button(window, text=<span class="string">&#x27;确认提交&#x27;</span>,width=<span class="number">10</span>,command=clickMe)</span><br><span class="line">action.grid(row=<span class="number">12</span>, column=<span class="number">0</span>, sticky=tk.W, padx=<span class="number">10</span>, pady=<span class="number">5</span>)</span><br><span class="line">tk.Button(window, text=<span class="string">&#x27;退出程序&#x27;</span>,width=<span class="number">10</span>,command=window.quit).grid(row=<span class="number">12</span>, column=<span class="number">1</span>, sticky=tk.E, padx=<span class="number">10</span>, pady=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">tk.mainloop()</span><br></pre></td></tr></table></figure></p>
<p>基本脚本的注释就已经讲明白了整个脚本执行的过程，简单说来就是界面输入对应的选项，再把这些选项传入到阿里云的api里达到购买负载均衡的目的。这里要注意一下，<code>thinker</code>布局只能从<code>pack</code>,<code>grid</code>,<code>place</code>里选择一种。</p>
<p>脚本就到此结束，后期再给这个脚本添加到对应的端口监听功能就完美了！</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.mierhuo.com/code/106">https://www.mierhuo.com/code/106</a><br><a href="https://www.jianshu.com/p/5dfeb29aed7b">https://www.jianshu.com/p/5dfeb29aed7b</a><br><a href="https://www.cnblogs.com/ruo-li-suo-yi/p/7425307.html">https://www.cnblogs.com/ruo-li-suo-yi/p/7425307.html</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>阿里云</tag>
        <tag>python3</tag>
        <tag>tkinter</tag>
      </tags>
  </entry>
  <entry>
    <title>使用pycurl来模拟curl效果</title>
    <url>/2019/07/11/%E4%BD%BF%E7%94%A8pycurl%E6%9D%A5%E6%A8%A1%E6%8B%9Fcurl%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>centos下安装pycurl，如果直接使用<code>pip install pycurl</code>的话，可能会有<code>ERROR: Command &quot;python setup.py egg_info&quot; failed with error code 1 in /tmp/pip-install-hb0k0rkr/pycurl/</code>的错误，那么需要先安装一下<code>yum install python-devel curl-devel</code>就解决问题了。</p>
<p>如果是windows下安装pycurl就比较麻烦一点，需要先<code>pip install wheel</code>安装wheel，然后去<a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/">http://www.lfd.uci.edu/~gohlke/pythonlibs/</a> 下载对应python版本的编译包到本地，然后在cmd命令行里<code>pip install 对应的.whl</code>就好了。但是注意<a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/">http://www.lfd.uci.edu/~gohlke/pythonlibs/</a> 是需要翻墙登录的。</p>
<h2 id="python3脚本"><a href="#python3脚本" class="headerlink" title="python3脚本"></a>python3脚本</h2><p>pycurl的常用的常量列表可以看一下<a href="https://izsk.me/2017/12/27/%E4%BD%BF%E7%94%A8python%E5%BA%93pycurl%E6%9D%A5%E6%A3%80%E6%B5%8Bweb%E6%9C%8D%E5%8A%A1%E8%B4%A8%E9%87%8F/">https://izsk.me/2017/12/27/%E4%BD%BF%E7%94%A8python%E5%BA%93pycurl%E6%9D%A5%E6%A3%80%E6%B5%8Bweb%E6%9C%8D%E5%8A%A1%E8%B4%A8%E9%87%8F/</a> 这个文章，我这里就直接写一下我的脚本：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pycurl</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">c = pycurl.Curl()</span><br><span class="line">url = <span class="string">&#x27;http://X.X.X.X:对应端口号&#x27;</span></span><br><span class="line">c.setopt(c.URL, url)</span><br><span class="line">c.setopt(c.HEADER, <span class="literal">True</span>)</span><br><span class="line">c.setopt(pycurl.CONNECTTIMEOUT, <span class="number">5</span>)    <span class="comment"># 连接的等待时间，设置为0则不等待</span></span><br><span class="line">c.setopt(pycurl.TIMEOUT, <span class="number">5</span>)           <span class="comment"># 请求超时时间</span></span><br><span class="line">c.getinfo(pycurl.HTTP_CODE)             <span class="comment"># 返回的HTTP状态码</span></span><br><span class="line"><span class="comment">#c.setopt(c.POST,1)     #是否是post，默认是get</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    c.perform()     <span class="comment">#提交请求</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;连接异常！&quot;</span> + <span class="built_in">str</span>(e))</span><br><span class="line">    c.close()</span><br><span class="line">    sys.exit()</span><br><span class="line"></span><br><span class="line">HTTP_CODE = c.getinfo(c.HTTP_CODE)                  <span class="comment">#获取 HTTP 状态码</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;HTTP状态码: %s&#x27;</span> %(HTTP_CODE))</span><br><span class="line">c.close()</span><br></pre></td></tr></table></figure></p>
<p>不过pycurl有两个缺点，第一,整个请求头都会输出；第二,无法摘取到http协议版本号。</p>
<h2 id="GO脚本"><a href="#GO脚本" class="headerlink" title="GO脚本"></a>GO脚本</h2><p>如果是想用go语言来实现curl效果，脚本如下：<br>	<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/mikemintang/go-curl&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	url := <span class="string">&quot;http://目标路径:目标端口&quot;</span></span><br><span class="line"></span><br><span class="line">	headers := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;User-Agent&quot;</span>:    <span class="string">&quot;Sublime&quot;</span>,</span><br><span class="line">		<span class="string">&quot;Authorization&quot;</span>: <span class="string">&quot;Bearer access_token&quot;</span>,</span><br><span class="line">		<span class="string">&quot;Content-Type&quot;</span>:  <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cookies := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;userId&quot;</span>:    <span class="string">&quot;12&quot;</span>,</span><br><span class="line">		<span class="string">&quot;loginTime&quot;</span>: <span class="string">&quot;15045682199&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	queries := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;page&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">		<span class="string">&quot;act&quot;</span>:  <span class="string">&quot;update&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	postData := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">		<span class="string">&quot;name&quot;</span>:      <span class="string">&quot;mike&quot;</span>,</span><br><span class="line">		<span class="string">&quot;age&quot;</span>:       <span class="number">24</span>,</span><br><span class="line">		<span class="string">&quot;interests&quot;</span>: []<span class="type">string</span>&#123;<span class="string">&quot;basketball&quot;</span>, <span class="string">&quot;reading&quot;</span>, <span class="string">&quot;coding&quot;</span>&#125;,</span><br><span class="line">		<span class="string">&quot;isAdmin&quot;</span>:   <span class="literal">true</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 链式操作</span></span><br><span class="line">	req := curl.NewRequest()</span><br><span class="line">	resp, err := req.</span><br><span class="line">		SetUrl(url).</span><br><span class="line">		SetHeaders(headers).</span><br><span class="line">		SetCookies(cookies).</span><br><span class="line">		SetQueries(queries).</span><br><span class="line">		SetPostData(postData).</span><br><span class="line">		Post()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> resp.IsOk() &#123;</span><br><span class="line">			fmt.Println(resp.Body)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Println(resp.Raw)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述脚本执行效果：<br><img data-src="/images/go8.png" alt="抱光妹"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://pycurl.io/docs/latest/index.html">http://pycurl.io/docs/latest/index.html</a> (官方文档)<br><a href="https://www.twilio.com/blog/2016/12/http-requests-in-python-3.html">https://www.twilio.com/blog/2016/12/http-requests-in-python-3.html</a><br><a href="https://stackoverflow.com/questions/472179/how-to-read-the-header-with-pycurl">https://stackoverflow.com/questions/472179/how-to-read-the-header-with-pycurl</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>curl</tag>
        <tag>端口探测</tag>
      </tags>
  </entry>
  <entry>
    <title>使用python调用echart画图</title>
    <url>/2018/03/22/%E4%BD%BF%E7%94%A8python%E8%B0%83%E7%94%A8echart%E7%94%BB%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前说了如何使用阿里云的SDK获取云存储的值然后发送表格邮件，但是最近领导又发话了，说这个邮件每天一封看的有点审美疲劳，要顺应“数据可视化”的趋势，于是就要求画图，力求直观，要做到“从众多数据中突出特别数据，从特别数据中突出高价值数据”。我之前用<code>python</code>的<code>matplotlib</code>画过，这一次尝试用<code>echart</code>来做图！</p>
<p><code>echart</code>是不太良心的百度良心的开源作品，提供各种各样精美的作图方案，分分钟把图片做的高大上，吸引周围人的目光。不过我对前端的了解非常浅薄，但是没关系。这次使用<code>pyechart</code>插件！这个插件可以让<code>python</code>直接调用<code>echart</code>接口，选择需要的图形之后，直接往里查数据就好，简单粗暴见效快，而且支持3D，可以说是居家旅行常备物品。可以说，有了它，作图能力顶呱呱。感谢开发者大神们的辛苦工作！</p>
<h2 id="作图"><a href="#作图" class="headerlink" title="作图"></a>作图</h2><p>首先先需要安装<code>pyecharts</code>插件，命令是<code>pip install pyecharts</code>。</p>
<p>然后我们就可以写一个简单的案例，如下：<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/usr/</span>bin/env python</span><br><span class="line">#coding=utf-<span class="number">8</span></span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> <span class="title class_">Bar</span>    #导入第三方库</span><br><span class="line"></span><br><span class="line">#attr = [<span class="string">&quot;&#123;&#125;day&quot;</span>.<span class="title function_">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="title function_">range</span>(<span class="number">1</span>, <span class="number">8</span>)]    #这样的话X坐标就是1day、2day、3day...</span><br><span class="line">attr = [<span class="string">&quot;Mon&quot;</span>, <span class="string">&quot;Feb&quot;</span>, <span class="string">&quot;Wed&quot;</span>, <span class="string">&quot;Thu&quot;</span>, <span class="string">&quot;Fri&quot;</span>, <span class="string">&quot;Sat&quot;</span>, <span class="string">&quot;Sun&quot;</span>]    #这样X坐标就是星期</span><br><span class="line">v1 = [<span class="number">1.49</span>, <span class="number">2.09</span>, <span class="number">4.03</span>, <span class="number">2.23</span>, <span class="number">5.26</span>, <span class="number">7.71</span>, <span class="number">7.56</span>]        </span><br><span class="line">v2 = [<span class="number">0.3</span>, <span class="number">0.9</span>, <span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.7</span>, <span class="number">0.7</span>, <span class="number">0.6</span>]</span><br><span class="line">v3 = [<span class="number">18.15</span>, <span class="number">13.22</span>, <span class="number">11.28</span>, <span class="number">17.99</span>, <span class="number">18.7</span>, <span class="number">19.7</span>, <span class="number">15.6</span>]</span><br><span class="line"></span><br><span class="line">bar = <span class="title class_">Bar</span>(<span class="string">&quot;乐橙云存储情况总览&quot;</span>, <span class="string">&quot;本图表展示过去一周的云存储情况&quot;</span>)        #这里是主标题和副标题</span><br><span class="line">bar.<span class="title function_">add</span>(<span class="string">&quot;录像分享文件&quot;</span>, attr, v1, mark_line=[<span class="string">&quot;average&quot;</span>], mark_point=[<span class="string">&quot;max&quot;</span>, <span class="string">&quot;min&quot;</span>])    #每一个值的名称以及要展现平均值和最大最小值</span><br><span class="line">bar.<span class="title function_">add</span>(<span class="string">&quot;视频直播文件&quot;</span>, attr, v2, mark_line=[<span class="string">&quot;average&quot;</span>], mark_point=[<span class="string">&quot;max&quot;</span>, <span class="string">&quot;min&quot;</span>])</span><br><span class="line">bar.<span class="title function_">add</span>(<span class="string">&quot;云录像、报警图片、全景图片&quot;</span>, attr, v3, mark_line=[<span class="string">&quot;average&quot;</span>], mark_point=[<span class="string">&quot;max&quot;</span>, <span class="string">&quot;min&quot;</span>])    </span><br><span class="line">bar.<span class="title function_">render</span>(<span class="string">&#x27;/tmp/111.html&#x27;</span>)        #在/tmp文件夹里生成一个<span class="number">111.</span>html文件</span><br></pre></td></tr></table></figure></p>
<p>如果服务器里有<code>nginx</code>，那么把这个html文件放到<code>nginx/html</code>路径里，再在浏览器里打开就会看到这样的图：<br><img data-src="/images/pyechart.png" alt="paradin"></p>
<p>而且还可以通过点击网页上“A值”、“B值”、“C值”就可以达到屏蔽相应值的效果，而且如果点击红色箭头的“数据视图”，还可以直接看到对应的数据，非常贴心非常屌，如图：<br><img data-src="/images/pyechart2.png" alt="paradin"></p>
<p>如果你觉得图片有点小，那么可以修改这个地方：<code>bar = Bar(&quot;XXX情况总览&quot;, &quot;本图表展示过去一周的ABC情况&quot;，width=1000,height=900)</code>，我这里把宽和高分别从默认值调成了1000和900。</p>
<p>如果想要在一个html里做多个图，比如要做三个柱状图，那么example如下：<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/usr/</span>bin/env python</span><br><span class="line">#coding=utf-<span class="number">8</span></span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> <span class="title class_">Bar</span>, <span class="title class_">Grid</span></span><br><span class="line"></span><br><span class="line">attr = [<span class="string">&quot;一班&quot;</span>, <span class="string">&quot;二班&quot;</span>, <span class="string">&quot;三班&quot;</span>, <span class="string">&quot;四班&quot;</span>]</span><br><span class="line">v1 = [<span class="number">54</span>, <span class="number">81</span>, <span class="number">32</span>, <span class="number">32</span>] </span><br><span class="line">v2 = [<span class="number">68</span>, <span class="number">69</span>, <span class="number">27</span>, <span class="number">32</span>] </span><br><span class="line">bar = <span class="title class_">Bar</span>(<span class="string">&quot;赞成票&quot;</span>,<span class="string">&quot;本图表展示赞成票情况&quot;</span>)</span><br><span class="line">bar.<span class="title function_">add</span>(<span class="string">&quot;年纪长&quot;</span>, attr, v1, mark_point=[<span class="string">&quot;max&quot;</span>, <span class="string">&quot;min&quot;</span>])</span><br><span class="line">bar.<span class="title function_">add</span>(<span class="string">&quot;副年纪长&quot;</span>, attr, v2, mark_point=[<span class="string">&quot;max&quot;</span>, <span class="string">&quot;min&quot;</span>])</span><br><span class="line"></span><br><span class="line">attr2 = [<span class="string">&quot;一班&quot;</span>, <span class="string">&quot;二班&quot;</span>, <span class="string">&quot;三班&quot;</span>, <span class="string">&quot;四班&quot;</span>]</span><br><span class="line">x1 = [<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">x2 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>]</span><br><span class="line">bar2 = <span class="title class_">Bar</span>(<span class="string">&quot;反对票&quot;</span>,<span class="string">&quot;本图表展示反对票情况&quot;</span>,title_top=<span class="string">&#x27;bottom&#x27;</span>,title_color=<span class="string">&#x27;#1d12eb&#x27;</span>)            #title_color是标题颜色，这个跟html的颜色取值一样</span><br><span class="line">bar2.<span class="title function_">add</span>(<span class="string">&quot;年纪长&quot;</span>, attr2, x1, mark_point=[<span class="string">&quot;max&quot;</span>, <span class="string">&quot;min&quot;</span>])</span><br><span class="line">bar2.<span class="title function_">add</span>(<span class="string">&quot;副年纪长&quot;</span>, attr2, x2, mark_point=[<span class="string">&quot;max&quot;</span>, <span class="string">&quot;min&quot;</span>])</span><br><span class="line"></span><br><span class="line">attr3 = [<span class="string">&quot;一班&quot;</span>, <span class="string">&quot;二班&quot;</span>, <span class="string">&quot;三班&quot;</span>, <span class="string">&quot;四班&quot;</span>]</span><br><span class="line">y1 = [<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">y2 = [<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">bar3 = <span class="title class_">Bar</span>(<span class="string">&quot;弃权票&quot;</span>,<span class="string">&quot;本图表展示弃权票情况&quot;</span>,title_pos=<span class="string">&#x27;right&#x27;</span>,title_color=<span class="string">&#x27;#eb1212&#x27;</span>)             #title_pos是标题的位置，如果不特殊说明，会重叠</span><br><span class="line">bar3.<span class="title function_">add</span>(<span class="string">&quot;年纪长&quot;</span>, attr3, y1, mark_point=[<span class="string">&quot;max&quot;</span>, <span class="string">&quot;min&quot;</span>])    </span><br><span class="line">bar3.<span class="title function_">add</span>(<span class="string">&quot;副年纪长&quot;</span>, attr3, y1, mark_point=[<span class="string">&quot;max&quot;</span>, <span class="string">&quot;min&quot;</span>])</span><br><span class="line"></span><br><span class="line">grid = <span class="title class_">Grid</span>()    </span><br><span class="line">grid.<span class="title function_">add</span>(bar, grid_width=<span class="string">&quot;40%&quot;</span>, grid_height=<span class="string">&quot;30%&quot;</span>, grid_bottom=<span class="string">&quot;60%&quot;</span>, grid_right=<span class="string">&quot;55%&quot;</span>)        #grid_height和grid_width是每一个小图的大小</span><br><span class="line">grid.<span class="title function_">add</span>(bar2, grid_width=<span class="string">&quot;40%&quot;</span>, grid_height=<span class="string">&quot;30%&quot;</span>, grid_bottom=<span class="string">&quot;60%&quot;</span>, grid_left=<span class="string">&quot;55%&quot;</span>)        #grid_bottom和grid_top是垂直位置</span><br><span class="line">grid.<span class="title function_">add</span>(bar3, grid_width=<span class="string">&quot;40%&quot;</span>, grid_height=<span class="string">&quot;30%&quot;</span>, grid_top=<span class="string">&quot;60%&quot;</span>, grid_right=<span class="string">&quot;55%&quot;</span>)        #grid_right和grid_left是水平位置</span><br><span class="line">grid.<span class="title function_">render</span>(<span class="string">&#x27;/tmp/grid.html&#x27;</span>)    #在/tmp文件夹里生成一个grid.<span class="property">html</span>文件</span><br></pre></td></tr></table></figure></p>
<p><img data-src="/images/pyechart3.png" alt="paradin"></p>
<p>例子中的数字都是我虚拟的，实际情况中，这些数字都应该是存储在redis这样的数据库里，然后取出来使用。</p>
<p>上面的两个例子仅仅是<code>pyechart</code>使用的冰山一角，如果想更多的了解，请去看一下文末<code>pyechart</code>的中文说明文档，无论是柱状图、雷达图、曲线图、3D图都有相关的使用讲解，内容特别丰富！</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://echarts.baidu.com/">http://echarts.baidu.com</a><br><a href="http://pyecharts.org/#/zh-cn/prepare">http://pyecharts.org/#/zh-cn/prepare</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>echart</tag>
      </tags>
  </entry>
  <entry>
    <title>使用seleium+python模拟登陆鉴权网页</title>
    <url>/2021/03/02/%E4%BD%BF%E7%94%A8seleium+python3%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86%E9%89%B4%E6%9D%83%E7%BD%91%E9%A1%B5/</url>
    <content><![CDATA[<p>先上代码：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">chrome_path = <span class="string">r&#x27;/usr/local/bin/chromedriver&#x27;</span>  <span class="comment">#这里是chromedriver的安装路径</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login_buc</span>(<span class="params">username, password, login_url</span>):</span><br><span class="line">    <span class="comment"># driver = webdriver.PhantomJS()</span></span><br><span class="line">    chrome_options = Options()</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--headless&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-gpu&#x27;</span>)</span><br><span class="line">    driver = webdriver.Chrome(executable_path=chrome_path, options=chrome_options)</span><br><span class="line">    driver.get(login_url)</span><br><span class="line">    driver.refresh()</span><br><span class="line">    <span class="built_in">print</span>(driver.title)</span><br><span class="line"></span><br><span class="line">    driver.find_element_by_name(<span class="string">&#x27;domainAccount&#x27;</span>).send_keys(username)   	    <span class="comment"># 输入用户名</span></span><br><span class="line">    driver.find_element_by_name(<span class="string">&#x27;password&#x27;</span>).send_keys(password)   	    <span class="comment"># 输入密码</span></span><br><span class="line"></span><br><span class="line">    driver.execute_script(<span class="string">&#x27;document.getElementsByClassName(&quot;kuma-button kuma-button-primary sso-btn-submit kuma-button-lg&quot;)[0].click()&#x27;</span>)   	    <span class="comment"># 点击登录</span></span><br><span class="line">    <span class="comment"># 多账号场景</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        driver.execute_script(<span class="string">&#x27;document.getElementsByClassName(&quot;kuma-button kuma-button-primary&quot;)[0].click()&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e :</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ERROR:&quot;</span>, e)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    driver.get(login_url)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;===&gt;&quot;</span>,driver.title)</span><br><span class="line">    driver.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    login_buc(<span class="string">&#x27;登陆账号&#x27;</span>, <span class="string">&#x27;登陆密码&#x27;</span>, <span class="string">&#x27;目标网址&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>我这里的selenium使用的是最新的3.141.0版本，这里要注意一下，selenium早就已经放弃PhantomJS了，建议使用firefox或者chrome，我这里在本地安装一个<code>chromedriver</code>。由于这个机器是苹果mac，就需要在终端里输入<code>brew install --cask chromedriver</code>即可安装，然后等待安装完毕之后，使用<code>which chromedriver</code>来获取chromedriver的安装路径，如图：<br><img data-src="/images/chromedriver%E4%B8%8B%E8%BD%BD.png"></p>
<p>然后在脚本里体现出来就行，即脚本里的<code>chrome_path</code>，不然执行后会爆<code>Message: &#39;chromedriver&#39; executable needs to be in PATH.</code>这个错误。上述脚本执行效果如下：</p>
<p>如果执行出现了<code>NoSuchElementException: Unable to locate element</code>这个错误，建议适度调大time.sleep的时间，因为开启页面后，并不是元素都一次性加载完成的，客观依赖于网速和电脑。</p>
<p><img data-src="/images/%E5%90%B4%E5%AD%9F%E8%BE%BE.jpg"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>测试技术</tag>
        <tag>浏览器模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>使用python去做一个生成随机码的页面</title>
    <url>/2018/03/13/%E4%BD%BF%E7%94%A8python%E5%8E%BB%E5%81%9A%E4%B8%80%E4%B8%AA%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E7%A0%81%E7%9A%84%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<h2 id="先说一下mkpasswd"><a href="#先说一下mkpasswd" class="headerlink" title="先说一下mkpasswd"></a>先说一下mkpasswd</h2><p>linux里是自带生成密码的命令的，比较出名的一个是<code>mkpasswd</code>，另一个是<code>passwdgen</code>。</p>
<p><code>mkpasswd</code>命令是附属在<code>expect</code>模块里的，如图<br><img data-src="/images/mkpasswd.png" alt="paradin" title="使用yum whatprovides *&#x2F;mkpasswd去查找依附yum包"></p>
<p><code>passwdgen</code>的话也要手动执行一下<code>yum install -y passwdgen</code>来安装命令。</p>
<p>这里主要说说<code>mkpasswd</code>，它支持如下几个参数：<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">-<span class="title function_">l</span>       (length <span class="keyword">of</span> password, <span class="keyword">default</span> = <span class="number">7</span>)        指定密码的长度，默认是<span class="number">7</span>位数</span><br><span class="line">-<span class="title function_">d</span>       (min # <span class="keyword">of</span> digits, <span class="keyword">default</span> = <span class="number">2</span>)           指定密码中数字最少位数，默认是<span class="number">2</span>位</span><br><span class="line">-<span class="title function_">c</span>       (min # <span class="keyword">of</span> lowercase chars, <span class="keyword">default</span> = <span class="number">2</span>)  指定密码中小写字母最少位数，默认是<span class="number">2</span>位</span><br><span class="line">-<span class="title function_">C</span>       (min # <span class="keyword">of</span> uppercase chars, <span class="keyword">default</span> = <span class="number">2</span>)  指定密码中大写字母最少位数，默认是<span class="number">2</span>位</span><br><span class="line">-<span class="title function_">s</span>       (min # <span class="keyword">of</span> special chars, <span class="keyword">default</span> = <span class="number">1</span>)    指定密码中特殊字符最少位数，默认是<span class="number">1</span>位</span><br></pre></td></tr></table></figure></p>
<p>比如现在要生成一个含有“六位数字而且5位特殊字符的总共16位”的密码，那么命令就是：<code>mkpasswd -l 16 -d 5 -s 5</code>，再聚几个其他的例子，感受一下：<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@zabbix <span class="title class_">General</span>_LeChange_Chn_IS_V5<span class="number">.8</span><span class="number">.00</span>.<span class="property">R</span><span class="number">.20170814</span>]# mkpasswd -l <span class="number">16</span> -d <span class="number">5</span> -s <span class="number">5</span></span><br><span class="line">g]7Hu-<span class="variable constant_">L5</span>,t+<span class="number">32</span>%0m</span><br><span class="line">[root@zabbix <span class="title class_">General</span>_LeChange_Chn_IS_V5<span class="number">.8</span><span class="number">.00</span>.<span class="property">R</span><span class="number">.20170814</span>]# mkpasswd -l <span class="number">16</span> -C <span class="number">5</span></span><br><span class="line"><span class="title class_">YvjtFWaV5</span>jr8h%<span class="title class_">Wy</span></span><br><span class="line">[root@zabbix <span class="title class_">General</span>_LeChange_Chn_IS_V5<span class="number">.8</span><span class="number">.00</span>.<span class="property">R</span><span class="number">.20170814</span>]# mkpasswd -l <span class="number">16</span> -s <span class="number">10</span></span><br><span class="line">qoB#^<span class="variable constant_">V_</span>=/!??*<span class="number">59</span>:</span><br><span class="line">[root@zabbix <span class="title class_">General</span>_LeChange_Chn_IS_V5<span class="number">.8</span><span class="number">.00</span>.<span class="property">R</span><span class="number">.20170814</span>]# mkpasswd -l <span class="number">16</span> -c <span class="number">4</span> </span><br><span class="line">9mJOqymatvg*n9sl</span><br></pre></td></tr></table></figure></p>
<h2 id="脚本在此"><a href="#脚本在此" class="headerlink" title="脚本在此"></a>脚本在此</h2><p>这个生成随机码的算法部分就使用上面那个<code>mkpasswd</code>了，省了我们不少事。</p>
<p>整个html界面的代码如下：<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span>随机密码生成器<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/cgi-bin/dropdown.py&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;dropdown&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>密码长度：<span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;8&quot;</span> <span class="attr">selected</span>&gt;</span>8<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;16&quot;</span>&gt;</span>16<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>&gt;</span>20<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;24&quot;</span>&gt;</span>24<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;48&quot;</span>&gt;</span>48<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">select</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;runoob&quot;</span> <span class="attr">value</span>=<span class="string">&quot;on&quot;</span> /&gt;</span> 包含小写字母 <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;google&quot;</span> <span class="attr">value</span>=<span class="string">&quot;on&quot;</span> /&gt;</span> 包含大写字母 <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;runoob&quot;</span> <span class="attr">value</span>=<span class="string">&quot;on&quot;</span> /&gt;</span> 包含数字 <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;google&quot;</span> <span class="attr">value</span>=<span class="string">&quot;on&quot;</span> /&gt;</span> 包含特殊字母 <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>密码：<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>再分享一个python生成密码的代码，但是这个密码不含特殊字符：<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/usr/</span>bin/env python</span><br><span class="line"># -*- <span class="attr">coding</span>: utf-<span class="number">8</span> -*-</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">salt = <span class="string">&#x27;&#x27;</span>.<span class="title function_">join</span>(random.<span class="title function_">sample</span>(string.<span class="property">ascii_letters</span> + string.<span class="property">digits</span>, <span class="number">8</span>))</span><br><span class="line">print salt</span><br></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://balajiommudali.wordpress.com/2015/11/27/unable-to-install-mkpasswd-on-centos-6-4/">https://balajiommudali.wordpress.com/2015/11/27/unable-to-install-mkpasswd-on-centos-6-4/</a><br><a href="http://www.runoob.com/python/python-cgi.html">http://www.runoob.com/python/python-cgi.html</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用tqdm制作下载进度条</title>
    <url>/2018/07/24/%E4%BD%BF%E7%94%A8tqdm%E6%B7%BB%E5%8A%A0%E4%B8%8B%E8%BD%BD%E7%9A%84%E8%BF%9B%E5%BA%A6%E6%9D%A1/</url>
    <content><![CDATA[<h2 id="制作进度条"><a href="#制作进度条" class="headerlink" title="制作进度条"></a>制作进度条</h2><p>既然接手了国内专有云，就要写一个“自动化部署脚本”。于是我就把整个部署的安装包放到阿里云的bucket，用脚本去<code>wget</code>这个部署包，然后进行脚本部署。但是由于这个安装包比较大，&#96;于是就打算在脚本里添加一个“下载进度条”，这样就能了解到当前的下载情况。</p>
<p>google了一下，就发现了<code>tqdm</code>这个库，它声称比老版的progressbar库的单次响应时间提高了10倍以上，安装的方法很简单：<code>pip install tqdm</code>。</p>
<p>具体的用途和参数可以去看<a href="https://lorexxar.cn/2016/07/21/python-tqdm/">https://lorexxar.cn/2016/07/21/python-tqdm/</a> 这篇文章。</p>
<p>从tqdm的几个参数可见要使用tqdm做下载进度条首先需要整个文件的大小。整个文件的大小可以用<code>requests.get</code>方法获取，获取到<code>header</code>里就有目标的大小。在使用<code>requests</code>模块下载大文件&#x2F;数据时，建议使用使用<code>stream</code>模式。如果是<code>stream=False</code>，它会立即开始下载文件并放到内存中，如果文件过大，有可能导致内存不足。然后就是把目标文件拆成一个一个的小块，逐步的写入一个文件，这样达到了下载文件的目的。整个脚本如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/usr/</span>bin/env python</span><br><span class="line"># -*- <span class="attr">coding</span>: utf-<span class="number">8</span> -*-</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line">def <span class="title function_">downloadFILE</span>(url,name):</span><br><span class="line">    resp = requests.<span class="title function_">get</span>(url=url,stream=<span class="title class_">True</span>)</span><br><span class="line">	#stream=<span class="title class_">True</span>的作用是仅让响应头被下载，连接保持打开状态，</span><br><span class="line">    content_size = <span class="title function_">int</span>(resp.<span class="property">headers</span>[<span class="string">&#x27;Content-Length&#x27;</span>])/<span class="number">1024</span>		#确定整个安装包的大小</span><br><span class="line">    <span class="keyword">with</span> <span class="title function_">open</span>(name, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> <span class="attr">f</span>:</span><br><span class="line">        print <span class="string">&quot;安装包整个大小是：&quot;</span>,content_size,<span class="string">&#x27;k，开始下载...&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> <span class="title function_">tqdm</span>(iterable=resp.<span class="title function_">iter_content</span>(<span class="number">1024</span>),total=content_size,unit=<span class="string">&#x27;k&#x27;</span>,desc=name):</span><br><span class="line">	#调用iter_content，一块一块的遍历要下载的内容，搭配stream=<span class="title class_">True</span>，此时才开始真正的下载</span><br><span class="line">	#iterable：可迭代的进度条 total：总的迭代次数 desc：进度条的前缀</span><br><span class="line">            f.<span class="title function_">write</span>(data)</span><br><span class="line">        print name + <span class="string">&quot;已经下载完毕！&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    url = <span class="string">&quot;需要下载的文件的地址&quot;</span></span><br><span class="line">    name = url.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]		#截取整个url最后一段即文件名</span><br><span class="line">    <span class="title function_">downloadFILE</span>(url,name)</span><br></pre></td></tr></table></figure></p>
<p><img data-src="/images/bpython1.png" alt="paradin" title="脚本执行效果"><br>注意！下载文件所在的bucket要设置成“公有读”而不能是“私有”。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ol>
<li>解压缩的脚本： <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line">filename = <span class="string">&#x27;要解压包的路径&#x27;</span></span><br><span class="line">fz = zipfile.<span class="title class_">ZipFile</span>(filename, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> fz.<span class="title function_">namelist</span>():</span><br><span class="line">    fz.<span class="title function_">extract</span>(file, path)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这个脚本即使没有unzip命令也可以执行的。</p>
<ol start="2">
<li><p>获取本地IP地址的脚本：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">def <span class="title function_">get_local_ip</span>(ifname = <span class="string">&#x27;eth0&#x27;</span>):</span><br><span class="line">    <span class="keyword">import</span> socket, fcntl, struct</span><br><span class="line">    s = socket.<span class="title function_">socket</span>(socket.<span class="property">AF_INET</span>, socket.<span class="property">SOCK_DGRAM</span>)</span><br><span class="line">    inet = fcntl.<span class="title function_">ioctl</span>(s.<span class="title function_">fileno</span>(), <span class="number">0x8915</span>, struct.<span class="title function_">pack</span>(<span class="string">&#x27;256s&#x27;</span>, ifname[:<span class="number">15</span>]))</span><br><span class="line">    ret = socket.<span class="title function_">inet_ntoa</span>(inet[<span class="number">20</span>:<span class="number">24</span>])</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">print <span class="title function_">get_local_ip</span>()</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>bpython</code>，这是一个好东西，可以在linux环境下实现类似<code>pycharm</code>的提示功能,搭配tab键补全。安装方法就是<code>pip install bpython</code>，然后启动python的时候直接bpython即可。效果如图：<br><img data-src="/images/bpython.gif" alt="paradin"></p>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/qq_40666028/article/details/79335961">https://blog.csdn.net/qq_40666028/article/details/79335961</a><br><a href="http://blog.topspeedsnail.com/archives/9075">http://blog.topspeedsnail.com/archives/9075</a><br><a href="https://www.168seo.cn/python/24286.html">https://www.168seo.cn/python/24286.html</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>使用stable diffusion的txt2jpg让ai画图</title>
    <url>/2023/04/10/%E4%BD%BF%E7%94%A8stable-diffusion%E5%81%9Aai%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h2 id="安装stable-diffusion-UI"><a href="#安装stable-diffusion-UI" class="headerlink" title="安装stable-diffusion UI"></a>安装stable-diffusion UI</h2><p>系统：windows</p>
<p>要用stable-diffusion画图，就需要先安装<code>Python 3.10.11</code>,这里Python的大版本必须是3.10，不然就会出现<code>https://github.com/AUTOMATIC1111/stable-diffusion-webui/issues/7166</code> 这个issue里的错误。</p>
<p>stable-diffusion-webui的git地址是 <code>https://github.com/AUTOMATIC1111/stable-diffusion-webui</code>,clone 到本地解压缩就行。解压缩之后，执行<code>你的文件夹/stable-diffusion-webui/webui.bat</code>，这里需要一个翻墙的网络，不然的话安装起来就会很痛苦，需要一会时间，把需要的配件全部<code>pip install</code>之后，就会看到在本地启动了7860端口。如图：<br><img data-src="/images/ai%E7%94%BB%E5%9B%BE6.JPG"></p>
<p>此时在浏览器里打开<code>127.0.0.1:7860</code>就会看到<code>stable-diffusion-webui</code>(简称SDwebui)这个WEB页面，也就是生成AI图片的控制台。</p>
<p>注意！<code>webui.bat</code>不要关闭，这个是UI的后台。</p>
<p>然后我们可以去<code>civitai.com</code>去下载<code>lora</code>和<code>stable-diffusion</code>，这里要先做一个普及：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stable-diffusion：这个是模型（checkpoint），也就是作画的画风，比如写实风，或者动漫风，古典风。这些都是网友自己做的，目前比较火的几个是chillmix、dosmix、perfectWorld等等。</span><br><span class="line">lora：微调，如果你有一些效果，用语言描述又比较麻烦，那么可以搭配这个lora，比如一个模仿逆转裁判著名手势的lora，搭配了这个lora之后，你用上面stable-diffusion风格画出来的画都会搭配上lora这个动作。</span><br></pre></td></tr></table></figure></p>
<p>那么我们先去<code>https://civitai.com/models/8281/perfect-world</code> 下载一个这个叫<code>perfect-world</code>的<code>stable-diffusion</code>，如图：<br><img data-src="/images/ai%E7%94%BB%E5%9B%BE.JPG"></p>
<p>下载到的地址一定要是<code>你的文件夹/stable-diffusion-webui/models/stable-diffusion</code>。这个文件很大，要下一会。</p>
<h2 id="界面介绍"><a href="#界面介绍" class="headerlink" title="界面介绍"></a>界面介绍</h2><p>下载完毕之后，我们来到<code>127.0.0.1:7860</code>,此时刷新一下左上角的<code>stable diffusion checkout</code>，就会看到<code>perfect-world</code>已经能成功被发现了。然后我们就直接用<code>txt2img</code>这个标签页，这个标签页主要就是用文字来描述图片，目前只能支持英文和emoji表情。<br><img data-src="/images/ai%E7%94%BB%E5%9B%BE7.JPG"></p>
<p>这里上面是写prompt（正向提示符），也就是你希望出现的元素，比如有阳光，有沙滩，人穿什么衣服，长头发短头发，头发是湿的是干的等等。下面是写negative prompt(反向提示符)避免的东西，AI不善于画手是出名的，现在用<code>stable-diffusion-webui</code>依旧不善于画手（偶尔会有成功的时候，大约10次里有一次），所以很多人都会在这里写上<code>too many fingers</code>、<code>long neck</code>、<code>missing arms</code>、<code>extra arms</code>这样的词来避免出现乱手、少胳膊、多胳膊等畸形的情况。其实没啥大用，即使你写了，AI依旧有可能把手画成六指、猪蹄子甚至八臂哪吒…所以有些人就干脆在prompt里写<code>arms behind back</code>等词语来避免画手。</p>
<p>对了，写完后请检查一下prompt有没有违反物理定律的搭配，不然AI画出来的图也肯定会逻辑不通。举个简单的例子，你在prompt里即要求人<code>smiling</code>，又要求<code>tongue out</code>，那么产出的图里吐出来舌头就不太自然。</p>
<p>然后再说说界面上其他的东西：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sampling method:这个是采样方法，是用一套算法得到期望值的。这里提供了很多种算法，但是没有完美的，需要你多试几次然后比较一下。</span><br><span class="line"></span><br><span class="line">sampling steps:这个是采样步长，AI画画跟人画画不一样，人画画先是一个白纸，然后一点点的丰富上色。而AI是上来一个很模糊的东西（噪音很大的画布），然后一点点精细（去噪），所以这个值如果是1或者很小，那么你得到的可能就是一坨乱呼呼的东西，即噪音最大的样子。这个值默认是20，分辨率不太高的画是够用了，值越大耗费时间越多，这个值最高是150，越高的画就越精细，但是也是有临界值的，过了临界值就没啥显著变化了。我试了几下，150的话，每张1024*1024的图就要好几分钟才能出图，六指的几率小了一丢丢，但是还是有六指...</span><br><span class="line"></span><br><span class="line">batch count：一次生成多少图片。</span><br><span class="line"></span><br><span class="line">batch size：一次生成几组图片，如果你要画一个九宫格，那么就是上面选3，这里也是3。这俩值和下面的width height都跟显存有关。</span><br><span class="line"></span><br><span class="line">CFG Scale：图像跟提示符的一致程度。越高的话AI就越严格听你的prompt描述，但是前提是你的prompt足够标准，足够全面，而越低AI就越放飞自我。默认的7~11基本就是比较平衡的。</span><br><span class="line"></span><br><span class="line">SEED:这个是随机数种子，如果你看到网上有些图画的很好看，也想画出它的效果，那么你就选择它的种子，相似的概率会高，但是肯定不会是一模一样的。</span><br></pre></td></tr></table></figure></p>
<p>那么我们现在就用下载好的<code>perfect-world</code>,画一个蝙蝠侠在香港的夜里骑自行车的图吧。</p>
<p>prompt很简单，就是:<code>a batman driving a bicycle,in HONGKONG,at night</code>，负面negative prompt我们写：<code>worst quality,logo,watermark</code>，就是避免水印，避免低质量输出等等。点击<code>generate</code>按钮就能产出图片了，如图：<br><img data-src="/images/ai%E7%94%BB%E5%9B%BE4.JPG" title="perfect-world基本都是正面照，所以产出肯定也是正面照"></p>
<p>再看一下搭配lora的场景，我们下载一个<code>https://civitai.com/models/7692/objection-ace-attorney-lora</code> 的lora。使用这个lora，你生成的图片都会是这个《逆转裁判》里“异议”指人的造型。把这个lora下载到<code>你的文件夹/stable-diffusion-webui/models/Lora</code>这个文件夹里。<br><img data-src="/images/ai%E7%94%BB%E5%9B%BE2.JPG"></p>
<p>此时我们把promot改成：batman,objection,countroom,pointing。同时点击这个红色有个小白点的图标，选择LORA标签页，点击一下refresh就会扫描出来刚刚下载的<code>objectionAceAttorney</code>,如图：<br><img data-src="/images/ai%E7%94%BB%E5%9B%BE5.JPG"></p>
<p>当你点击它的时候，就发现上面的promot变成了<code>batman,objection,countroom,pointing，&lt;lora:objectionAceAttorney_objection:1&gt;</code>,多了后面这个lora，这里的1就是权重，lora在promot是可以多个的，用权重来突出重点。点击<code>Generate</code>，产出图片如图：<br><img data-src="/images/ai%E7%94%BB%E5%9B%BE3.JPG" title="用perfect-world产出底图，然后搭配lora的动作"></p>
<p>如果你有比较不错的prompt，可以点击<code>generate</code>下面的保存图标，然后起一个名，这个prompt就被保存了。如果同名就是覆盖，这里不会有提示，直接覆盖。</p>
<p>这样，当你搭配<code>lora</code>和<code>stable-diffusion</code>以及其他的参数就可以随心所欲的创作了。如果觉得英文吃力，可以用<code>chatgpt</code>来帮忙写prompt。如果你有搞<code>lora</code>和<code>stable-diffusion</code>的想法，那么可以去<code>huggingface.co</code>里找到素材和锻炼<code>lora</code>。</p>
<p>AI产出的图是默认存储到<code>你的文件夹/stable-diffusion-webui/out-put/tet2img-images/今天日期</code>的文件夹里，想修改存储地址，就在settings这个tab里的<code>paths for saving</code>里修改。然后你可以把生成的图上传到<code>civitai.com</code>对应的页面给大伙看看效果，最好带上你的prompt，让大家给你点个赞一起交流学习。</p>
<h2 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h2><p>AI画图的效果目前惊艳了不少人，很多插画师因此感受到了饭碗不保，但是如果说艺术性，那AI还是跟画家没法比。现在AI的作品是批量的，流水线的，而画家们虽然风格会固定，但是每一幅画都是一副新画，会有小心思在里面。所以说如果画家技术够牛逼、有思想、有人文精神，肯定是不怕AI的。AI更多适合出那种数码效果，而不是油画效果。</p>
<p>而且AI现在手和脚还是关节错位的，比如prompt里加一个<code>peace sign</code>，即想要一个剪刀手的手势，产出的100张图里能有一个合格就算不错了。所以插画师们可以考虑学习一下ai，然后自己只负责后期PS手脚就行，这样可以极大提升工作效率。</p>
<p>AI目前虽然能作画，但是学习的例子还是比较依赖人为性的输入，还没有自主学习的意识。而且AI画图目前来看还缺乏做动态视频的能力，就比如<code>civitai.com</code>现在完全就是一个18禁的静态画廊了（拿<code>civitai.com</code>练爬虫估计是一个不错的选择）。而且同一个AI模型产出的图看多了，对脸盲患者来说就麻木了。</p>
<p>我玩了这个sdwebui两天，觉得借着prompt来学英语单词还是挺不错的，而且一个图一个图的<code>generate</code>还挺上瘾。但是还是要吐槽一下，<code>civitai.com</code>总挂，一个周末挂了几乎20多个小时，估计厂家目前还是一个小团队，维护经费不足。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>lora的原理：<a href="https://huggingface.co/datasets/HuggingFace-CN-community/translation/blob/main/lora_cn.md">https://huggingface.co/datasets/HuggingFace-CN-community/translation/blob/main/lora_cn.md</a><br>写prompt的教学：<a href="https://gooptions.cc/stable-diffusion-prompt%E6%95%99%E5%AD%B8/">https://gooptions.cc/stable-diffusion-prompt%E6%95%99%E5%AD%B8/</a><br>写prompt的网站：<a href="https://mpost.io/best-100-stable-diffusion-prompts-the-most-beautiful-ai-text-to-image-prompts/">https://mpost.io/best-100-stable-diffusion-prompts-the-most-beautiful-ai-text-to-image-prompts/</a><br>炼丹记：<a href="https://www.bilibili.com/read/cv19927143?from=articleDetail">https://www.bilibili.com/read/cv19927143?from=articleDetail</a> （国内安装法这里有）</p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>AI</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>使用python调用redis的基本操作</title>
    <url>/2018/03/26/%E4%BD%BF%E7%94%A8python%E8%B0%83%E7%94%A8redis%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近有一个需求，里面涉及到把<code>python</code>获取到的数值存储到<code>redis</code>里，于是就简单研究一下<code>python</code>调用<code>redis</code>的方法。</p>
<p><code>python</code>要调用redis的时候，需要先安装redis模块，有两个方法。第一个方法就是<code>pip install redis</code>，第二个方法就是<code>easy_install redis</code>，模块装完之后，就可以创建redis连接了。</p>
<p><code>redis-py</code>提供两个类<code>Redis</code>和<code>StrictRedis</code>来实现Redis的命令，<code>StrictRedis</code>用于实现大部分官方的命令，并使用官方的语法和命令（比如，<code>SET</code>命令对应与<code>StrictRedis.set</code>方法）。 <code>Redis</code>是<code>StrictRedis</code>的子类，用于向后兼容旧版本的<code>redis-py</code>。 <font color=red>官方推荐使用<code>StrictRedis</code>方法，所以我这里只说<code>StrictRedis</code></font>。</p>
<h2 id="如何连接"><a href="#如何连接" class="headerlink" title="如何连接"></a>如何连接</h2><p>连接的代码如下：<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line">#这里是redis的基本情况</span><br><span class="line">&gt;&gt;&gt; host = <span class="string">&#x27;这里填写redis的host地址&#x27;</span></span><br><span class="line">&gt;&gt;&gt; port = <span class="number">6379</span>        #根据实际情况更改端口</span><br><span class="line">&gt;&gt;&gt; password = <span class="string">&#x27;redis对应的密码&#x27;</span></span><br><span class="line"></span><br><span class="line">#使用<span class="title class_">StrictRedis</span>去连接到目标redis</span><br><span class="line">&gt;&gt;&gt; r = redis.<span class="title class_">StrictRedis</span>(host=host, port=<span class="number">6379</span>, password=password, db=<span class="number">0</span>) #db为选定的数据库，db=<span class="number">0</span>代表选择了<span class="number">0</span>号数据库。redis默认有<span class="number">16</span>个数据库，在conf里面可以配置。如果没有指定的数据库，可以不写。</span><br><span class="line">&gt;&gt;&gt; r.<span class="title function_">set</span>(<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;88&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt; r.<span class="title function_">get</span>(<span class="string">&#x27;age&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;88&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>关系型数据库都有一个<code>连接池</code>的概念：对于大量redis连接来说，如果使用直接连接redis的方式的话，将会造成大量的TCP的重复连接，所以，就引入<code>连接池</code>来解决这个问题。在使用连接池连接上redis之后，可以从该连接池里面生成连接，调用完成之后，该链接将会返还给连接池，供其他连接请求调用，这样将减少大量redis连接的执行时间，那么使用<code>StrictRedis</code>的连接池的实现方式如下：<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pool = redis.<span class="title class_">ConnectionPool</span>(host=host, port=<span class="number">6379</span>, password=password)</span><br><span class="line">r = redis.<span class="title class_">StrictRedis</span>(connection_pool=pool</span><br></pre></td></tr></table></figure></p>
<p>或者使用<code>pipeline</code>（管道），通过<code>缓冲多条命令，然后一次性执行</code>的方法减少<code>服务器-客户端</code>之间TCP数据库包，从而提高效率，方法如下：<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">接上文</span><br><span class="line">pipe = r.<span class="title function_">pipeline</span>()</span><br><span class="line">#插入数据</span><br><span class="line">&gt;&gt;&gt; pipe.<span class="title function_">hset</span>(<span class="string">&quot;hash_key&quot;</span>,<span class="string">&quot;leizhu900516&quot;</span>,<span class="number">8</span>)</span><br><span class="line"><span class="title class_">Pipeline</span>&lt;<span class="title class_">ConnectionPool</span>&lt;<span class="title class_">Connection</span>&lt;host=<span class="number">192.168</span><span class="number">.8</span><span class="number">.176</span>,port=<span class="number">6379</span>,db=<span class="number">0</span>&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; pipe.<span class="title function_">hset</span>(<span class="string">&quot;hash_key&quot;</span>,<span class="string">&quot;chenhuachao&quot;</span>,<span class="number">9</span>)</span><br><span class="line"><span class="title class_">Pipeline</span>&lt;<span class="title class_">ConnectionPool</span>&lt;<span class="title class_">Connection</span>&lt;host=<span class="number">192.168</span><span class="number">.8</span><span class="number">.176</span>,port=<span class="number">6379</span>,db=<span class="number">0</span>&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; pipe.<span class="title function_">hset</span>(<span class="string">&quot;hash_key&quot;</span>,<span class="string">&quot;wanger&quot;</span>,<span class="number">10</span>)</span><br><span class="line"><span class="title class_">Pipeline</span>&lt;<span class="title class_">ConnectionPool</span>&lt;<span class="title class_">Connection</span>&lt;host=<span class="number">192.168</span><span class="number">.8</span><span class="number">.176</span>,port=<span class="number">6379</span>,db=<span class="number">0</span>&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; pipe.<span class="title function_">execute</span>()</span><br><span class="line">[1L, 1L, 1L]</span><br></pre></td></tr></table></figure><br><img data-src="/images/redis1.png" alt="paradin" title="查看插入的结果"></p>
<p>批量读取数据的方法如下:<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; pipe.<span class="title function_">hget</span>(<span class="string">&quot;hash_key&quot;</span>,<span class="string">&quot;leizhu900516&quot;</span>)</span><br><span class="line"><span class="title class_">Pipeline</span>&lt;<span class="title class_">ConnectionPool</span>&lt;<span class="title class_">Connection</span>&lt;host=<span class="number">192.168</span><span class="number">.8</span><span class="number">.176</span>,port=<span class="number">6379</span>,db=<span class="number">0</span>&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; pipe.<span class="title function_">hget</span>(<span class="string">&quot;hash_key&quot;</span>,<span class="string">&quot;chenhuachao&quot;</span>)</span><br><span class="line"><span class="title class_">Pipeline</span>&lt;<span class="title class_">ConnectionPool</span>&lt;<span class="title class_">Connection</span>&lt;host=<span class="number">192.168</span><span class="number">.8</span><span class="number">.176</span>,port=<span class="number">6379</span>,db=<span class="number">0</span>&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; pipe.<span class="title function_">hget</span>(<span class="string">&quot;hash_key&quot;</span>,<span class="string">&quot;wanger&quot;</span>)</span><br><span class="line"><span class="title class_">Pipeline</span>&lt;<span class="title class_">ConnectionPool</span>&lt;<span class="title class_">Connection</span>&lt;host=<span class="number">192.168</span><span class="number">.8</span><span class="number">.176</span>,port=<span class="number">6379</span>,db=<span class="number">0</span>&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; result = pipe.<span class="title function_">execute</span>()</span><br><span class="line">&gt;&gt;&gt; print result</span><br><span class="line">[<span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;10&#x27;</span>]   #有序的列表</span><br></pre></td></tr></table></figure></p>
<p><code>pipeline</code>的命令可以写在一起，如<code>p.set(&#39;hello&#39;,&#39;redis&#39;).sadd(&#39;faz&#39;,&#39;baz&#39;).incr(&#39;num&#39;).execute()</code>，其实它的意思等同于是：<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; p.<span class="title function_">set</span>(<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;redis&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt; p.<span class="title function_">sadd</span>(<span class="string">&#x27;faz&#x27;</span>,<span class="string">&#x27;baz&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt; p.<span class="title function_">incr</span>(<span class="string">&#x27;num&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt; p.<span class="title function_">execute</span>()</span><br><span class="line">[<span class="title class_">True</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<p>利用<code>pipeline</code>取值3500条数据，大约需要900ms，如果配合线程or协程来使用，每秒返回1W数据是没有问题的，基本能满足大部分业务。</p>
<h2 id="如何存储"><a href="#如何存储" class="headerlink" title="如何存储"></a>如何存储</h2><p>上面已经举了一个<code>age：88</code>的例子，可见创建一个<code>string</code>类型的key并放入value是使用<code>set</code>方法，比如再多存几个名字：<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; r.<span class="title function_">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;lilei&#x27;</span>)</span><br><span class="line"><span class="title class_">True</span></span><br><span class="line">&gt;&gt;&gt; r.<span class="title function_">get</span>(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;lilei&#x27;</span></span><br><span class="line">&gt;&gt;&gt; r.<span class="title function_">set</span>(<span class="string">&#x27;name2&#x27;</span>, <span class="string">&#x27;zhaowei&#x27;</span>)</span><br><span class="line"><span class="title class_">True</span></span><br><span class="line">&gt;&gt;&gt; r.<span class="title function_">set</span>(<span class="string">&#x27;name3&#x27;</span>, <span class="string">&#x27;james&#x27;</span>)</span><br><span class="line"><span class="title class_">True</span></span><br><span class="line">&gt;&gt;&gt; r.<span class="title function_">set</span>(<span class="string">&#x27;name4&#x27;</span>, <span class="string">&#x27;yaoming&#x27;</span>)</span><br><span class="line"><span class="title class_">True</span></span><br><span class="line">#列出以name开头的所有key</span><br><span class="line">&gt;&gt;&gt; print r.<span class="title function_">keys</span>(<span class="string">&quot;name*&quot;</span>)</span><br><span class="line">[<span class="string">&#x27;name3&#x27;</span>, <span class="string">&#x27;name4&#x27;</span>, <span class="string">&#x27;name2&#x27;</span>, <span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">#列出所有key</span><br><span class="line">&gt;&gt;&gt; print r.<span class="title function_">keys</span>()</span><br><span class="line">&gt;&gt;&gt; r.<span class="title function_">dbsize</span>()         #当前数据库包含多少条数据       </span><br><span class="line">4L</span><br><span class="line">&gt;&gt;&gt; r.<span class="title function_">delete</span>(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">&gt;&gt;&gt; r.<span class="title function_">save</span>()               #执行“检查点”操作，将数据写回磁盘。保存时阻塞</span><br><span class="line"><span class="title class_">True</span></span><br><span class="line">&gt;&gt;&gt; r.<span class="title function_">get</span>(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt; r.<span class="title function_">flushdb</span>()        #清空r中的所有数据</span><br><span class="line"><span class="title class_">True</span></span><br></pre></td></tr></table></figure></p>
<p>还有其他类型的存储方法，简单举例子如下：<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#创建一个hash</span><br><span class="line">r.<span class="title function_">hset</span>(<span class="string">&#x27;abc:def&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&quot;abcde&quot;</span>)</span><br><span class="line">#获取一个hash的所有值</span><br><span class="line">print r.<span class="title function_">hgetall</span>(<span class="string">&#x27;abc:def&#x27;</span>)</span><br><span class="line">#获取一个hash的所有key    </span><br><span class="line">print r.<span class="title function_">hkeys</span>(<span class="string">&#x27;abc:def&#x27;</span>) </span><br><span class="line">#创建list</span><br><span class="line">r.<span class="title function_">sadd</span>(<span class="string">&#x27;abcd:ef&#x27;</span>,<span class="string">&#x27;nihao&#x27;</span>)</span><br><span class="line">r.<span class="title function_">sadd</span>(<span class="string">&#x27;abcd:ef&#x27;</span>,<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">r.<span class="title function_">sadd</span>(<span class="string">&#x27;xxxx&#x27;</span>,<span class="string">&#x27;nihao&#x27;</span>)</span><br><span class="line">r.<span class="title function_">sadd</span>(<span class="string">&#x27;xxxx&#x27;</span>,<span class="string">&#x27;good&#x27;</span>)</span><br><span class="line">#打印出该key中的值 list</span><br><span class="line">print r.<span class="title function_">smembers</span>(<span class="string">&#x27;abcd:ef&#x27;</span>)</span><br><span class="line">#查询两个list中相同的值</span><br><span class="line">print r.<span class="title function_">sinter</span>(<span class="string">&#x27;abcd:ef&#x27;</span>, <span class="string">&#x27;xxxx&#x27;</span>)</span><br><span class="line">#给两个list取并集</span><br><span class="line">print r.<span class="title function_">sunion</span>(<span class="string">&#x27;abcd:ef&#x27;</span>, <span class="string">&#x27;xxxx&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p><code>setnx</code>是<code>SET if Not eXists</code>的缩写，也就是只有不存在的时候才设置，可以利用它来实现锁的效果。python要使用它也是<code>r.setnx(key,value)</code>，当发现没有这个key的时候，就会插入这个新的key以及对应的value，如果发现有了个这个key了，那这条就等于没加。</p>
<h2 id="如何删除"><a href="#如何删除" class="headerlink" title="如何删除"></a>如何删除</h2><p><code>py-redis</code>中有个<code>delete</code>接口，既可以删除单个key，也可以全删除key，如果要删除几个key，用法是:<code>r.delete(&#39;age&#39;)</code>、<code>r.delete(&#39;sex&#39;, &#39;age&#39;)</code>，如果要全删除，那就是<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">keys = r.<span class="title function_">keys</span>()</span><br><span class="line">r.<span class="title function_">delete</span>(*keys)</span><br></pre></td></tr></table></figure></p>
<p>执行之后的效果等于<code>flushall</code>。</p>
<p>redis里默认情况下是不支持通配符的，那么要批量删除key怎么做呢？答案就是搭配<code>xargs</code>，比如要删除掉所有<code>2018-03-</code>开头的key：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">redis-cli -hredis地址 -a密码 keys <span class="string">&quot;2018-03-*&quot;</span>|xargs redis-cli -hredis地址 -a密码 del</span><br></pre></td></tr></table></figure></p>
<h2 id="python将两个list元素一一对应转换为dict"><a href="#python将两个list元素一一对应转换为dict" class="headerlink" title="python将两个list元素一一对应转换为dict"></a>python将两个list元素一一对应转换为dict</h2><p>使用python的<code>zip</code>函数和强大的集合操作可以方便的将两个list元素一一对应转换为dict，如下示例代码：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">&#x27;n1&#x27;</span>,<span class="string">&#x27;n2&#x27;</span>,<span class="string">&#x27;n3&#x27;</span>]</span><br><span class="line">values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]	</span><br><span class="line">nvs = <span class="title function_">zip</span>(names,values)</span><br><span class="line">nvDict = <span class="title function_">dict</span>( (name,value) <span class="keyword">for</span> name,value <span class="keyword">in</span> nvs)</span><br></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/andymccurdy/redis-py">https://github.com/andymccurdy/redis-py</a><br><a href="http://xiaorui.cc/2014/11/10/%E4%BD%BF%E7%94%A8redis-py%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%B1%BBredis%E5%92%8Cstrictredis%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/">http://xiaorui.cc/2014/11/10/%E4%BD%BF%E7%94%A8redis-py%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%B1%BBredis%E5%92%8Cstrictredis%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</a><br><a href="http://debugo.com/python-redis/">http://debugo.com/python-redis/</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Shell做一个跳板机菜单</title>
    <url>/2019/08/06/%E4%BD%BF%E7%94%A8shell%E5%81%9A%E4%B8%80%E4%B8%AA%E8%B7%B3%E6%9D%BF%E6%9C%BA%E8%8F%9C%E5%8D%95/</url>
    <content><![CDATA[<p>跳板机虽然可以无密码登录，但是IP毕竟不好记，之前的方法就是在xshell做快速命令，可是后来IP越来越多，xshell界面弄得不太够用。于是就抽个空，做了一个ssh连接菜单，选择题总比填空题好嘛！</p>
<p>执行效果如下：<br><img data-src="/images/gateone19.gif" alt="抱光妹"></p>
<h2 id="脚本正文"><a href="#脚本正文" class="headerlink" title="脚本正文"></a>脚本正文</h2><p>shell脚本如下：<br>	<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">clear</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">options=(<span class="string">&quot;Option 1&quot;</span> <span class="string">&quot;Option 2&quot;</span> <span class="string">&quot;Option 3&quot;</span> <span class="string">&quot;Quit&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">select</span> opt <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;options[@]&#125;</span>&quot;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">quickssh是菜单文件，格式如下===&gt;ip:端口(用途)，比如：172.31.0.66:22(ec1)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">若有新增服务器，直接添加/root/quickssh文件即可</span></span><br><span class="line"></span><br><span class="line">HOSTS=$(cat /root/quickssh|sort)        #读取菜单</span><br><span class="line">NUM=$(cat /root/quickssh|wc -l)</span><br><span class="line">SSH=&quot;ssh -A -o ConnectTimeOut=5 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null&quot;</span><br><span class="line">user=root</span><br><span class="line">usual_port=34872</span><br><span class="line"></span><br><span class="line">select line in $HOSTS ; do</span><br><span class="line">    if [ $REPLY -le $NUM ]</span><br><span class="line">        then</span><br><span class="line">            echo &quot;$line 准备连接...&quot;</span><br><span class="line">            ip=$(echo $line |cut -d &#x27;:&#x27; -f 1)</span><br><span class="line">            unusual_port=$(echo $line | awk &#x27;&#123;split($0,a,&quot;[:(]&quot;);print a[2]&#125;&#x27;)</span><br><span class="line">            port=$&#123;unusual_port:-$usual_port&#125;</span><br><span class="line">            echo ip是：$ip </span><br><span class="line">            echo port是: $port</span><br><span class="line">            $SSH -p $port &quot;$user@$ip&quot;</span><br><span class="line">            xit 0</span><br><span class="line">        else</span><br><span class="line">            echo &quot;请输入一个正确的序号：&quot;</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>这里使用了<code>$(a:-b)</code>给<code>变量预赋值</code>：若a为空或者null，则得到的是b。但是要注意这里面的a如果是变量的话，前面是不能加$的，会爆格式错误。把执行脚本命令做成alias写进<code>~/.bashrc</code>里，再<code>source ~/.bashrc</code>，以后就快速调用，更加方便。</p>
<p>这个脚本还有可以改进的地方，就是不只是输入序号，还可以通过输入服务器名称快速找到目标服务器，这样达到更高效！</p>
<p>不过如果服务器过多，还是推荐用mysql来记录。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://liam.page/2016/11/08/Shell-variable-reference-and-string-cut-off/">https://liam.page/2016/11/08/Shell-variable-reference-and-string-cut-off/</a><br><a href="https://blog.csdn.net/x1269778817/article/details/46535729">https://blog.csdn.net/x1269778817/article/details/46535729</a></p>
<p><img data-src="/images/%E8%8F%9C%E8%8F%9C%E7%BB%AA.jpg" alt="抱光妹"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>ssh</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>使用yum安装软件爆No such file or directory</title>
    <url>/2018/05/17/%E4%BD%BF%E7%94%A8yum%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E7%88%86No-such-file-or-directory/</url>
    <content><![CDATA[<p>今天开发反馈说<code>yum install redis</code>报错<code>-bash: /usr/bin/yum: /usr/bin/python: bad interpreter: No such file or directory</code>，于是我就登上服务器，使用python一看，反馈<code>-bash: python: command not found</code>，原来这个机器的python被人改动了，用<code>whereis python</code>查了一下，原来python的地址被人改成了<code>/usr/bin/python2.7</code>，于是就手动更改了一下<code>/usr/bin/yum</code>，把<code>#!/usr/bin/python</code>改成了<code>#!/usr/bin/python2.7</code>。但是使用<code>yum install -y redis</code>发现虽然可以连接到库但是会报<code>No such file or directory</code>，如图：<br><img data-src="/images/nofile.png" alt="paradin"></p>
<p>原来光改了<code>/usr/bin/yum</code>还没用，还要改<code>/usr/libexec/urlgrabber-ext-down</code>这个文件，同样也是把python改成<code>/usr/bin/python2.7</code>说明python的路径才可以。</p>
<p>改了上面两个文件之后，又加上了<code>yum clean all</code>和<code>yum makecache</code>，清除一下缓存，一切恢复了正常。</p>
<p><img data-src="/images/slamdunk.jpg" alt="paradin"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>yum</tag>
      </tags>
  </entry>
  <entry>
    <title>使用zabbix去监控docker容器</title>
    <url>/2018/05/17/%E4%BD%BF%E7%94%A8zabbix%E5%8E%BB%E7%9B%91%E6%8E%A7docker%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现在容器技术越来越普遍，那么搭建了容器肯定要监控起来，监控方法有两种，一种是做一个zabbix-agent容器去监控容器，还有一个是升级原有的zabbix-agent，这里说第一种。</p>
<p>这里先交代一下环境：zabbix-server的ip是10.244.48.42，要监控的机器ip是10.244.34.79，这个机器里面装了一个容器在运行gitlab，如图：<br><img data-src="/images/gitlab20.png" alt="paradin"></p>
<p>事前检查两台服务器是否互通，而且10050和10051端口是否standby。还要在zabbix-server端做好<code>auto-discovery</code>，等等等等准备工作。</p>
<h2 id="使用Zabbix-Agent-Docker进行监控"><a href="#使用Zabbix-Agent-Docker进行监控" class="headerlink" title="使用Zabbix Agent Docker进行监控"></a>使用Zabbix Agent Docker进行监控</h2><p>在10.244.34.79这个机器上先安装zabbix-agent容器：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run \		</span><br><span class="line">  --name=dockbix \	#这个是容器的名称</span><br><span class="line">  --net=host \	#容器可以直接访问主机上所有的网络信息</span><br><span class="line">  --privileged \		#容器内的root拥有真正的root权限</span><br><span class="line">  -v /:/rootfs \		#这个是对应宿主机的映射盘</span><br><span class="line">  -v /var/run:/var/run \</span><br><span class="line">  --restart unless-stopped \	 	#不管退出状态码是什么始终重启容器，不过当daemon启动时，如果容器之前已经为停止状态，不要尝试启动它。</span><br><span class="line">  -e &quot;ZA_Server=10.244.48.42&quot; \		#这里就填写zabbix-server的ip地址</span><br><span class="line">  -e &quot;ZA_ServerActive=10.244.48.42&quot; \</span><br><span class="line">  -d hub.c.163.com/canghai809/dockbix-agent-xxl-limited:latest		#这里使用了网易蜂巢镜像</span><br></pre></td></tr></table></figure><br>但是反馈给我<code>docker: invalid restart policy unless-stopped.</code>这样的错误信息，原来这个gitlab这台服务器的docker版本较老，而<code>unless-stopped</code>这个是在1.9.0版本才加入的，所以对于旧版的docker环境需要改成<code>always</code>。</p>
<p>更改docker run的命令之后重新执行效果如下：<br><img data-src="/images/gitlab21.png" alt="paradin"></p>
<p>可见容器启动成功，<code>docker logs -f 容器ID号</code>看一下日志是否正常。如果正常的话，应该在zabbix-server端是可以看到这个10.244.34.79已经被添加到控制台里了，如图：<br><img data-src="/images/gitlab22.png" alt="paradin"></p>
<h2 id="导入监控docker的模版"><a href="#导入监控docker的模版" class="headerlink" title="导入监控docker的模版"></a>导入监控docker的模版</h2><p>在zabbix server上导入监控docker的模版，一共2个模版,下载后解压。模版下载地址: <a href="https://dl.cactifans.com/zabbix/Zabbix-Template-App-Docker.tar.gz">https://dl.cactifans.com/zabbix/Zabbix-Template-App-Docker.tar.gz</a> 。</p>
<p>我使用主动模式，因此导入<code>Zabbix-Template-App-Docker-active.xml</code>这个模版，如图：<br><img data-src="/images/gitlab23.png" alt="paradin"></p>
<p><img data-src="/images/gitlab24.png" alt="paradin" title="将这个模板应用到10.244.34.79上"></p>
<p>此时可以去zabbix-server这个机器上验证一下是否监控成功，在zabbix-server上执行<code>zabbix_get -s 10.244.34.79 -k docker.discovery</code>，效果如下：<br><img data-src="/images/gitlab25.png" alt="paradin"></p>
<p>可见已经成功获取到了那两个容器的名称，这就代表zabbix-server已经监控到位了。</p>
<h2 id="验证数据"><a href="#验证数据" class="headerlink" title="验证数据"></a>验证数据</h2><p>首先现在10.244.34.79里执行<code>docker stats 容器1的ID 容器2的ID...</code>，看一下当前运行的所有容器的状态，如下：<br><img data-src="/images/gitlab26.png" alt="paradin"></p>
<p>与zabbix-server的<code>latest data </code>做一下对比，由于被监控机的docker版本较老，<code>docker stats</code>结果不是那么的精准，不过用来监控参考还是OK的…如果docker是最新版的，那么监控值是很准的。<br><img data-src="/images/gitlab28.png" alt="paradin" title="docker 18.04.0版本的stats跟zabbix获取值一致"></p>
<p>剩下的就是慢慢添加triggers了…</p>
<p>补充一句，<code>zabbix-agent 3.2</code>的rpm安装方法：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -ivh http://repo.zabbix.com/zabbix/3.2/rhel/7/x86_64/zabbix-release-3.2-1.el7.noarch.rpm </span><br><span class="line">yum -y install zabbix-agent zabbix-sender</span><br><span class="line">service zabbix-agent start</span><br><span class="line">chkconfig zabbix-agent on</span><br></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/monitoringartist/zabbix-docker-monitoring">https://github.com/monitoringartist/zabbix-docker-monitoring</a> （墙裂推荐！）<br><a href="https://blog.codeship.com/ensuring-containers-are-always-running-with-dockers-restart-policy/">https://blog.codeship.com/ensuring-containers-are-always-running-with-dockers-restart-policy/</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>使用xshell做代理查看无公网服务器的WEB界面</title>
    <url>/2018/06/30/%E4%BD%BF%E7%94%A8xshell%E5%81%9A%E4%BB%A3%E7%90%86%E6%9F%A5%E7%9C%8B%E6%97%A0%E5%85%AC%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84WEB%E7%95%8C%E9%9D%A2/</url>
    <content><![CDATA[<p>在工作中经常有一些服务器是高机密的，那么这样的服务器就要与外网隔离。但是没有公网的服务器如果也没有连入到局域网的话，按常理来说是无法打开程序的Web界面。这里则分享一个黑科技—使用xshell做代理然后用浏览器去查看Web界面。</p>
<p>首先要在Xshell顶端菜单栏选择<code>查看</code>—<code>隧道窗格</code>。如图：<br><img data-src="/images/xshell1.png" alt="paradin"></p>
<p>此时Xshell的底端就出来一个窗口，然后选择<code>转移规则</code>，如图：<br><img data-src="/images/xshell2.png" alt="paradin"></p>
<p>在<code>转移规则</code>右键，选择<code>添加</code>，在添加的窗口里，<code>类型(方向）</code>选择<code>Dynamic(SOCKS4/5)</code>，端口就用默认的1080，备注爱写不写，如图：<br><img data-src="/images/xshell3.png" alt="paradin"></p>
<p>来到windows桌面，点击<code>我的电脑</code>—<code>控制面板</code>—<code>Internet选项</code>，打开<code>连接</code>这个标签页，选择下面的<code>局域网设置</code>。如图：<br><img data-src="/images/xshell4.png" alt="paradin"></p>
<p>在<code>局域网（LAN）设置</code>里，先在<code>为LAN使用代理服务器</code>前面打勾，然后点击<code>高级</code>，在套接字那里输入<code>127.0.0.1</code>，端口就是刚刚默认的1080，点击确定保存，如图：<br><img data-src="/images/xshell5.png" alt="paradin"></p>
<p>此时在浏览器里输入内网的IP地址就能打开这个服务器里Web界面了，比如我公司内部的云存储界面：<br><img data-src="/images/xshell6.png" alt="paradin"></p>
<p>不过此时你是完全属于LAN环境，公网是无法访问的。如果要恢复访问公网，那么就要返回到<code>局域网（LAN）设置</code>里，把<code>为LAN使用代理服务器</code>前面的勾点掉就OK。<br><img data-src="/images/%E5%A4%A7%E5%B2%9B%E4%BC%98%E5%AD%90.gif" alt="paradin" title="优叔赛高！！！"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>xshell</tag>
      </tags>
  </entry>
  <entry>
    <title>使用zabbix去监控网站和tcp连接</title>
    <url>/2018/04/02/%E4%BD%BF%E7%94%A8zabbix%E5%8E%BB%E7%9B%91%E6%8E%A7%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h2 id="网页状态码监控"><a href="#网页状态码监控" class="headerlink" title="网页状态码监控"></a>网页状态码监控</h2><p>在zabbix的web界面，<code>配置</code>–<code>主机</code>–选择一个有外网权限的服务器，比如选择zabbix server–<code>Web检测</code>，如图：<br><img data-src="/images/checkweb1.png" alt="paradin"></p>
<p>然后点击右上角的<code>创建Web场景</code>，然后依次填入<code>名称</code>，<code>间隔</code>，<code>客户端</code>等等，如图：<br><img data-src="/images/checkweb2.png" alt="paradin"></p>
<p>然后编辑<code>步骤</code>，先<code>添加</code>，填入对应的url，然后写上200状态码，意思就是返回200是OK的。<br><img data-src="/images/checkweb4.png" alt="paradin"><br>保存即可，如果还有http认证，那么就继续填写认证。</p>
<p>至此，一个简单的监控官网状态码的配置过程就结束了，剩下就是增添一下触发器，如下：<br><img data-src="/images/checkweb3.png" alt="paradin"></p>
<h2 id="tcp连接监控"><a href="#tcp连接监控" class="headerlink" title="tcp连接监控"></a>tcp连接监控</h2><p>首先在<code>zabbix-agentd.conf</code>里添加一个新的自定义监控项：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">UserParameter</span>=tcp.<span class="property">status</span>[*],netstat -a | awk <span class="string">&#x27;/^tcp/ &#123;++y[$NF]&#125; END &#123;for(i in y) print i,y[i]&#125;&#x27;</span> |  grep $1 | awk <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>然后<code>service zabbix-agent restart</code>重启客户端，模板就是<a href="https://gitee.com/careyjike_173/zabbix/tree/master/template">https://gitee.com/careyjike_173/zabbix/tree/master/template</a> 里的<code>zbx_tcp_status_templates.xml</code>，直接导入即可。如图：<br><img data-src="/images/checkweb5.png" alt="paradin"></p>
<p>然后自己配置一下<code>time_wait</code>&#x2F;<code>close_wait</code>的告警阈值。</p>
<p><img data-src="/images/%E8%A3%A4%E5%AD%90%E5%8D%A1%E4%B8%96%E7%95%8C%E6%B3%A2.gif" alt="akb48" title="裤子卡中圈世界波"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
        <tag>web监控</tag>
        <tag>tcp连接</tag>
      </tags>
  </entry>
  <entry>
    <title>使用zabbix去监控nginx</title>
    <url>/2018/04/02/%E4%BD%BF%E7%94%A8zabbix%E5%8E%BB%E7%9B%91%E6%8E%A7nginx/</url>
    <content><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>zabbix监控nginx，首先要确认nginx里是否有<code>http_stub_status_module</code>这个模块，一般来说，这个模块是自动安装的，<code>nginx -V</code>如下图：<br><img data-src="/images/checknginx1.png" alt="paradin"></p>
<p>如果你的nginx没有这个模块，请去看<a href="https://rorschachchan.github.io/2018/01/03/Nginx%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91%E6%96%B0%E7%9A%84%E6%A8%A1%E5%9D%97/">https://rorschachchan.github.io/2018/01/03/Nginx动态编译新的模块/</a> 。</p>
<p>然后在<code>nginx.conf</code>里添加一段话：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> location = /nginx-status  &#123;</span><br><span class="line">    stub_status   on;</span><br><span class="line">    access_log   off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>nginx -s reload</code>一下，然后在命令行输入<code>curl http://127.0.0.1/nginx-status</code>，就会看到如下的界面：<br><img data-src="/images/checknginx2.png" alt="paradin"></p>
<p>这样就可以通过<code>http_stub_status_module</code>检查nginx情况了！</p>
<h2 id="nginx-status详解"><a href="#nginx-status详解" class="headerlink" title="nginx status详解"></a>nginx status详解</h2><p>以上图的<code>nginx status</code>来做例子说明一下各个数字的意思：<br><code>active connections</code> – 活跃的连接数量<br><code>accepts</code> — 总共处理了3832000个连接<br><code>handled</code> — 成功创建3832000次握手<br><code>requests</code> —  总共处理了3295877个请求<br><code>reading</code> — 读取客户端的连接数<br><code>writing</code> — 响应数据到客户端的数量<br><code>waiting</code> — 开启<code>keep-alive</code>的情况下,这个值等于<code>active – (reading+writing)</code>, 意思就是 Nginx 已经处理完正在等候下一次请求指令的驻留连接</p>
<h2 id="配置监控"><a href="#配置监控" class="headerlink" title="配置监控"></a>配置监控</h2><p>有了模块，还需要添加一个脚本，然后就可以获取上面的数值了，脚本如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/bin/</span>bash</span><br><span class="line"># <span class="title class_">Method</span> <span class="keyword">of</span> use</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">HOST</span>=<span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line"><span class="variable constant_">PORT</span>=<span class="string">&quot;80&quot;</span>	#这个根据实际情况填写</span><br><span class="line"><span class="variable constant_">URL</span>=<span class="string">&quot;http://$&#123;HOST&#125;:$&#123;PORT&#125;/nginx-status&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">active</span>(<span class="params"></span>) &#123;</span><br><span class="line">       curl <span class="string">&quot;$&#123;URL&#125;&quot;</span> <span class="number">2</span>&gt;<span class="regexp">/dev/</span><span class="literal">null</span> | grep  <span class="string">&quot;Active&quot;</span> | awk <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">reading</span>(<span class="params"></span>) &#123;</span><br><span class="line">       curl <span class="string">&quot;$&#123;URL&#125;&quot;</span> <span class="number">2</span>&gt;<span class="regexp">/dev/</span><span class="literal">null</span> | grep <span class="string">&quot;Reading&quot;</span> | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">writing</span>(<span class="params"></span>) &#123;</span><br><span class="line">       curl <span class="string">&quot;$&#123;URL&#125;&quot;</span> <span class="number">2</span>&gt;<span class="regexp">/dev/</span><span class="literal">null</span> | grep <span class="string">&quot;Writing&quot;</span> | awk <span class="string">&#x27;&#123;print $4&#125;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">waiting</span>(<span class="params"></span>) &#123;</span><br><span class="line">       curl <span class="string">&quot;$&#123;URL&#125;&quot;</span> <span class="number">2</span>&gt;<span class="regexp">/dev/</span><span class="literal">null</span> | grep <span class="string">&quot;Waiting&quot;</span> | awk <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">accepts</span>(<span class="params"></span>) &#123;</span><br><span class="line">       curl <span class="string">&quot;$&#123;URL&#125;&quot;</span> <span class="number">2</span>&gt;<span class="regexp">/dev/</span><span class="literal">null</span> | awk <span class="variable constant_">NR</span>==<span class="number">3</span> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">handled</span>(<span class="params"></span>) &#123;</span><br><span class="line">       curl <span class="string">&quot;$&#123;URL&#125;&quot;</span> <span class="number">2</span>&gt;<span class="regexp">/dev/</span><span class="literal">null</span> | awk <span class="variable constant_">NR</span>==<span class="number">3</span> | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">requests</span>(<span class="params"></span>) &#123;</span><br><span class="line">       curl <span class="string">&quot;$&#123;URL&#125;&quot;</span> <span class="number">2</span>&gt;<span class="regexp">/dev/</span><span class="literal">null</span> | awk <span class="variable constant_">NR</span>==<span class="number">3</span> | awk <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">ping</span>(<span class="params"></span>) &#123;</span><br><span class="line">       ps -ef | grep nginx | grep -v grep -c</span><br><span class="line">&#125;</span><br><span class="line">$1</span><br></pre></td></tr></table></figure></p>
<p>然后再去<code>zabbix_agentd.conf</code>里添加一句话:<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">UserParameter</span>=nginx.<span class="property">status</span>[*],<span class="regexp">/usr/</span>local/zabbix/script/nginx_status.<span class="property">sh</span> $1</span><br></pre></td></tr></table></figure></p>
<p>然后<code>service zabbix-agent restart</code>，自定义项就搞定了。</p>
<p>如果要导入模板，<a href="https://gitee.com/careyjike_173/zabbix">https://gitee.com/careyjike_173/zabbix</a> 这个朋友的模板已经非常全面了，根据实际情况修改之后再导入他的xml就好，感谢前人付出！</p>
<p><img data-src="/images/%E5%9F%83%E9%87%8C%E5%85%8B%E6%A3%AE%E8%90%BD%E5%8F%B6%E7%90%83.gif" alt="paradin" title="埃尔克森远射破蓝军"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>使用zabbix去监控php-fpm</title>
    <url>/2018/04/02/%E4%BD%BF%E7%94%A8zabbix%E5%8E%BB%E7%9B%91%E6%8E%A7php-fpm/</url>
    <content><![CDATA[<h2 id="开启状态统计"><a href="#开启状态统计" class="headerlink" title="开启状态统计"></a>开启状态统计</h2><p>nginx有一个status来获取nginx处理信息的总览情况，php-fpm也有一个状态统计。要打开这个状态统计，需要先打开php-fpm.conf，将<code>pm.status_path = /status</code>前面的注释去掉。</p>
<p>然后跑到nginx里，在<code>nginx.conf</code>里添加一个location：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">   location ~ ^/(status|ping) &#123;	</span><br><span class="line">       fastcgi_pass <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9000</span>;</span><br><span class="line">       include fastcgi.<span class="property">conf</span>;</span><br><span class="line">       access_log off;</span><br><span class="line">       allow <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>;</span><br><span class="line">       deny all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后重启一下php-fpm和nginx，在命令行里输入<code>curl -s http://127.0.0.1:80/status</code>，就会看到php的状态统计，如下图：<br><img data-src="/images/checkphp.png" alt="paradin"></p>
<h2 id="php-fpm-status详解"><a href="#php-fpm-status详解" class="headerlink" title="php-fpm status详解"></a>php-fpm status详解</h2><p><code>pool</code> - fpm池子名称，大多数为www<br><code>process manager</code> – 进程管理方式,值：static, dynamic<br><code>start time </code>– 启动日期,如果reload了php-fpm，时间会更新<br><code>start since</code> – 运行时长<br><code>accepted conn</code> – 当前池子接受的请求数<br><code>listen queue</code> – 请求等待队列，如果这个值不为0，那么要增加FPM的进程数量<br><code>max listen queue</code> – 请求等待队列最高的数量<br><code>listen queue len</code> – socket等待队列长度<br><code>idle processes</code> – 空闲进程数量<br><code>active processes</code> – 活跃进程数量<br><code>total processes</code> – 总进程数量<br><code>max active processes</code> – 最大的活跃进程数量（FPM启动开始算）<br><code>max children reached</code> - 大道进程最大数量限制的次数，如果这个数量不为0，那说明你的最大进程数量太小了，请改大一点。<br><code>slow requests</code> – 启用了php-fpm slow-log，缓慢请求的数量 </p>
<h2 id="配置监控"><a href="#配置监控" class="headerlink" title="配置监控"></a>配置监控</h2><p>跑到<code>zabbix-agentd.conf</code>里添加一个自定义监控项，如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">UserParameter</span>=php-fpm.<span class="property">status</span>[*],<span class="regexp">/usr/</span>bin/curl -s <span class="string">&quot;http://127.0.0.1/php-fpm_status?xml&quot;</span> | grep <span class="string">&quot;&lt;$1&gt;&quot;</span> | awk -F<span class="string">&#x27;&gt;|&lt;&#x27;</span> <span class="string">&#x27;&#123; print $$3&#125;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>然后重启一下<code>zabbix-agent</code>，模板就是<a href="https://gitee.com/careyjike_173/zabbix/tree/master/template">https://gitee.com/careyjike_173/zabbix/tree/master/template</a> 里的<code>zbx_php-fpm_templates.xml</code>，直接导入即可！</p>
<p>效果如下图：<br><img data-src="/images/checkphp2.png" alt="paradin"></p>
<h2 id="没有监控到进程？"><a href="#没有监控到进程？" class="headerlink" title="没有监控到进程？"></a>没有监控到进程？</h2><p>zabbix有时候会在监控进程出现不太准的情况，比如我这个机器的php。配置了<code>proc.num[php-fpm,,,]</code>这个key，但是在zabbix-server死活都取不到值，如图：<br><img data-src="/images/checkphp3.png" alt="paradin"></p>
<p>但是在被监控机器里，进程是明明存在的：<br><img data-src="/images/checkphp4.png" alt="paradin"></p>
<p>这特么的是为啥？</p>
<p>这就是因为<code>proc.num[进程名,,,]</code>里面的进程名是在<code>/proc/进程PID/status</code>里的name一栏获得的，比如我这个机器的php情况：<br><img data-src="/images/checkphp5.png" alt="paradin"></p>
<p>name里写的是php-fpm56，所以key也要改成<code>proc.num[php-fpm56,,,]</code>，这个时候在zabbix-server就成功取值了，如图：<br><img data-src="/images/checkphp6.png" alt="paradin"></p>
<p>注意！<code>/proc/进程PID/status</code>的name会被截断为15个字符。所以在配置时要事前检查一下。</p>
<p><img data-src="/images/%E7%99%BE%E5%B9%B4%E7%BE%8E%E6%B4%B2%E6%9D%AF%E5%AF%B9%E5%A7%94%E5%86%85%E7%91%9E%E6%8B%89%E5%8A%A9%E6%94%BB%E4%BC%8A%E7%93%9C%E5%9B%A0.gif" alt="paradin" title="梅西百年美洲杯对委内瑞拉助攻伊瓜因"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
        <tag>php-fpm</tag>
      </tags>
  </entry>
  <entry>
    <title>俄乌之战碎碎念2</title>
    <url>/2022/04/09/%E4%BF%84%E4%B9%8C%E4%B9%8B%E6%88%98%E7%A2%8E%E7%A2%8E%E5%BF%B52/</url>
    <content><![CDATA[<p>俄乌之战已经持续了40多天，我开始以为这场战争半个月在20天左右就会进一个低谷期，目前实际的局势只能说“上半场结束了”。这里我想我个人还真的是不专业，低估了俄罗斯的经济能力（西方机构估计目前俄罗斯已经支出了400亿美元左右的军事费用），我原本以为以老毛子的战争费用能维持1个月就会叫哎呦，不过现在他们依旧可以围着乌东继续狂轰滥炸，可见家底还是很厚。</p>
<p>这里要奇怪一下，这估计是第一场两个国家对打，但是打了40多天连双方前线总指挥官是谁都不知道的战争。</p>
<h2 id="战争仍继续"><a href="#战争仍继续" class="headerlink" title="战争仍继续"></a>战争仍继续</h2><p>俄乌打了六周，很多的中国网友都过了当初了吃瓜热情。俄军发现自己拿不下基辅后紧急止损，借和谈的机会宣布将军事重点转到顿巴斯和马里乌波尔，毕竟攻打这俩地区于情于理都更好：首先占领亚速营的老家马里乌波尔的“去纳粹化”比打基辅看上去使这次“军事行动”有了正当性，而且俄军已经把马里乌波尔炸了个底朝天，几乎唾手可得。拿下了这俩地方又可以打通了乌东与克里米亚对俄来说也是一个比较体面的结束，比拿下基辅让泽林斯基流亡更实际。</p>
<p>但是原来还和谈的乌克兰在“布查屠杀事件”之后，看上去完全没有要和谈的意思了。最近乌克兰总统泽林斯基的态度也愈发强硬了起来，两边也几乎一周没有再有和谈会议的信息放出。一直不声不响的捷克和斯洛伐克却率先给乌克兰提供了坦克和S300防空系统，八竿子打不到的澳大利亚也交付了20辆新战车。这几个国家在前打了样，可见现在北约对乌克兰的援助已经不再是“标枪”、“毒刺”这种单兵作战武器，而是更加机械化和重型的装备。所以乌克兰现在底气很足，现在最新状态就是敖德萨的乌克兰军队开始进攻已经被俄军占领大约一个月的赫尔松，而且乌克兰的军队对马里乌波尔的援助通道也通了。但俄罗斯总统发言人佩斯科夫在天空新闻频道里说了“目前俄军的伤害是一个比较大的悲剧”的同时，也强调了“希望未来几天俄罗斯能实现战争目标”。那么我想在未来的双周双方会继续在这两点进行厮杀。双方“你炸了我一个油库”、“我崩了你一架飞机”、“你杀了我平民”、“你杀了我俘虏”这样的新闻会继续上演。</p>
<p>虽然乌克兰后面有北约的战备物资源源不绝的提供，但是俄罗斯的战力不是吃素的，而且俄罗斯最新民意对普京的支持率达到八成以上，所以两边在顿巴斯的决战肯定会非常的持久又惨烈。不过俄乌双方应该依旧不会有大规模的对抗作战，依旧还是“小兵团+无人机VS俄军”的场景，而且俄罗斯会在已经占领的区域扎篱笆做防守，乌克兰成了攻方。俄军的防守能力还是强大的，预计这场俄乌之战保守估计要打很久。</p>
<p>除了战场上的刀光剑影，还有其他地方看不见的经济战，俄罗斯把卢布捆绑了能源之后，卢布汇率也恢复到了战前的状态，可见普京的经济自救是有一定的效果的。俄罗斯是能源大国，俄乌之战导致原油、煤炭、化肥等等的价格飙升，同时俄罗斯也主动打折降价，让印度第一时间购买了低价的俄罗斯石油。而且据中国外交部发言人说，美国还趁机抄底了一波。最近日本放出来1000万桶国家储备油来稳定世界油价，英美也去跟中东国家游说让他们增产，但是布林肯和约翰逊的斋月之行结束，并没有新闻说中东国家有增产的承诺。但是我个人觉得，应该是有承诺的，只是现在不适合放出。不然要否决的话肯定早就在电话里就说了，干嘛要跑过去见了面再吵架否决？美俄两边这一系列的拉拢动作，可见这俩阵营在能源经济战上的对抗会愈发升级。</p>
<h2 id="欧洲的下一步？"><a href="#欧洲的下一步？" class="headerlink" title="欧洲的下一步？"></a>欧洲的下一步？</h2><p>在斯洛伐克援助给乌克兰S300之后，美国拜登也第一时间“对斯洛伐克表示感谢，同时宣布赞助给斯洛伐克一套爱国者防空系统作为S300的补偿”。话说，利用这次的俄乌战争，北约的东欧国家其实都可以借此机会悄然完成“军事装备去苏联化，统一北约化”的目标。</p>
<p>芬兰跟北约目前越走越近，大概率要先于瑞典加入北约了，不过芬兰加入了，瑞典加入也不会太晚。德国舒尔茨去了伦敦跟硬派英国约翰逊会面之后，也表态要给乌克兰捐助武器。英美澳又此时宣布要联合研发超音速导弹。法国也进行了一轮超音速核弹演习。看到这些军事上的威胁，现在的普京除了核弹，还有战争牌可以打么？<br><img data-src="/images/%E8%8A%AC%E5%85%B0%E5%8C%97%E7%BA%A6.JPG" title="芬兰国内六成支持加入北约"></p>
<p>现在民意调查有点跌又谋求连任的马克龙应该还是会给普京打电话，虽然波兰总理怼了马克龙“你打了那么多电话有啥用啊？”，但是要知道人每天24小时，除去吃喝拉撒睡就算还剩下16个小时，马克龙一个电话1小时，也算占据了普京每天清醒的1&#x2F;16的时间，这是对乌克兰变相的帮助啊！马克龙那可是在第五层！</p>
<p>当然，欧洲一直都不是铁板一块，各种利益交错复杂。现在欧洲内部法国、德国、匈牙利等国都是“温和派”，英国、波兰等等都是“激进派”，不过普京集团想内部瓦解他们绝不是一个简单的事儿。4月1日中国再与欧盟的会面里，也提到了“希望欧盟自主做决定”，言外之意就是不要考虑美国的感受，来分化欧洲跟美国，但是现在欧洲的民意很明显—“支持乌克兰是正统，不支持就是投降派”，所以即使“温和派”对内安抚，也是要顶着民众很大的压力。</p>
<p>法国的大选第一次投票马上开始了，马克龙VS勒温，这俩一个右，一个更右，不过目前来看马克龙稍微领先。可以说对俄态度会是他们获票的一个重要点，之前韩国大选，对共产主义强硬派的尹锡悦最后时刻逆转险胜就是一个例子。而且法国的大选结果也会影响美国的大选，现在美国在这次俄乌战争里是尝到甜头的，如果能进一步的扩大胜利果实，即“对外控制了乌克兰削弱了俄罗斯，对内转移通货膨胀失业率持枪伤人等案件的注意力”，那么就证明拜登的“对俄强硬”相比较川普的“安抚俄对欧强硬”更受美国主流的喜欢。</p>
<h2 id="乌克兰的外交胜利"><a href="#乌克兰的外交胜利" class="headerlink" title="乌克兰的外交胜利"></a>乌克兰的外交胜利</h2><p>小国打不过大国是一个很正常的事儿，当年刘备被曹操打的满地乱串，靠诸葛亮去游说孙权，进而联吴抗魏。抗日战争的时候，我们也是四处求人，花了15年抗战磨败了当时的日本帝国主义。所以“打不过求助”一点都不丢人，“留得青山在不愁没柴烧”。现在乌克兰的总统泽林斯基也在发挥他的演员所长，四处争取机会演讲，用他的老专业去感染每一个听众。目前看来效果不错，基本在他每一处演讲之后，就会得到该地方的援助以及下一个地方的演讲邀约。</p>
<p>现在乌克兰就是要进一步给俄罗斯按上“种族灭绝”的罪名，不过这个应该不会太可能。当年苏联、日本帝国主义杀死的无辜人更多都没有按上“种族灭绝”，这时候联合国更不会了。但是乌克兰现在拿到了其他国家更多的军事援助，这是实实在在的收获。</p>
<p>今天欧盟的主席冯德莱恩到访基辅访问，她应该是开战以来第五位到达基辅的欧洲领导人了。让乌克兰加入欧盟的事儿看上去一切都很顺利，以现在欧盟的体量，对乌克兰日后的重建还是挺客观的。但是真有人若要较真战后的乌克兰能不能一举成为发达国家，话说苏联解体的那帮国家里，三十多年了哪个成为了真正富裕的国家呢？</p>
<p>目前为止，乌克兰的外交真的是很成功，给很多小国树立了一个榜样。小国就是小国，抱大国大腿被大国利用是在所难免的，这是无法改变的事实，那么在无法改变的事实里“怎么聪明的当棋子，同时尽可能多的拿到自己的好处”才是一门高智慧，而且这场仗打完了，乌克兰军队的战斗力将会成为世界一流之列，他们对北约武器的熟悉度也是最高的，到时候加不加入北约其实不重要，有一个安心的大国保护才是更实际的。但是白俄罗斯你就别来保护了，让黄鼠狼看鸡笼子，这不扯淡么？</p>
<h2 id="远交近攻的俄罗斯"><a href="#远交近攻的俄罗斯" class="headerlink" title="远交近攻的俄罗斯"></a>远交近攻的俄罗斯</h2><p>俄罗斯这个“远交近攻”的策略其实布局了很久，因为远交近攻是需要时间积累的，一方面要“交”德国法国这样的欧洲老牌国家以及中国，一遍要发展生产力准备“攻”周边的小国。也正是有了这几年还是十年的努力，让俄罗斯一点一点把他的战略实现。不过远交近攻只能适合于本身生产力已经很强大的国家，小国家没有财力和作战能力，交也交不到人，攻也谁都打不过。</p>
<p>俄罗斯在4月7日被暂停了联合国人权理事会的身份，据说他们也顺势愤而退出这个鸟会。虽说这个“人权理事会”这个身份没啥特别的含金量，而且这个理事会的很多成员办的事儿一点都不“人权”。但是让安理会五常之一的俄罗斯被“人权理事会”暂停会员身份，无疑是乌克兰的重大外交胜利，这代表了俄罗斯军队的行为是“不人权”的战争罪，那么反抗战争罪是合情合理的，而且会引申国际社会对俄罗斯更加重的经济制裁。<br><img data-src="/images/%E8%81%94%E5%90%88%E5%9B%BD%E6%8A%95%E7%A5%A8.JPG" title="塞尔维亚投了赞成票，第三行第六列"></p>
<p>在联合国人权理事会的投票里，“与俄友谊上不封顶”的中国毫无疑问的投了“反对暂停俄罗斯出人权理事会”，其余的投反对票国还有玻利维亚、阿尔及利亚、朝鲜、古巴、加蓬、哈萨克斯坦、伊朗、马里、塔吉克斯坦、越南等等国家，相反一直跟俄罗斯很麻吉的印度、巴基斯坦和塞维利亚两个弃权一个赞成。不过他们几个说实话对俄罗斯在军事上其实没什么大的帮助，他们跟俄罗斯的交易量占俄罗斯对外的贸易里其实不算多，只能帮喊喊。</p>
<p>所以俄罗斯既然已经被制裁了，既然已经撕破脸了，就干脆靠战争结果来说话吧，或者尽快老套路安排顿巴斯公投，此时的服软就会动摇普京的威信进而影响他的统治，这条路只能走下去。专制国家里打输了仗的后果，我想能给马克龙讲5个小时俄罗斯历史的普京本人心里应该最有数。万一真的要败，反正俄军已经从基辅附近撤出了，普京可以直接一发核弹扔过去，放一个大烟花作为ENDING。</p>
<p>而之前中国两次援助乌克兰1500万人民币折合240万美元的人道物资，我想之后，中国就应该不会再对乌克兰有援助了，首先上海吉林等地还在疫情封锁之中，此时对外援助应该适度。其次中欧班列依旧畅通无阻，直达莫斯科，所以现在中国会维持目前的局势，不会主动在外交出击。</p>
<p>其实俄乌战争以来，中国国家媒体很聪明，他们直接拿来塔斯社、卫星社这样俄政府控制的媒体信息和视频在大陆花联网媒体上几乎原封不动播出，去引导民众讽刺美国和反对乌克兰，哪怕被什么翻译运动揭皮，也可以解释“我这是援引消息”。不过现在国内防疫政策严峻，看了看最近的新浪微博热搜，我觉得，一直都说“历史是任人打扮的小姑娘”，这话是有点绝对主义了，相比较而言，热搜才真的是“任人打扮的小姑娘”。<br><img data-src="/images/%E6%96%B0%E6%B5%AA%E7%83%AD%E6%90%9C.JPG" title="4月7日的微博热搜"></p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>俄罗斯</tag>
        <tag>乌克兰</tag>
        <tag>普京</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Zabbix监控logstash</title>
    <url>/2019/06/11/%E4%BD%BF%E7%94%A8zabbix%E7%9B%91%E6%8E%A7logstash/</url>
    <content><![CDATA[<h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><p>logstash常规的监控项可以去移步 <a href="https://github.com/fredprod/logstash-zabbix">https://github.com/fredprod/logstash-zabbix</a> ，有模板有脚本，可以说是非常全面、服务到家了。</p>
<p>本文主要是要监控logstash的tps，先说一下tps的定义：它是Transactions Per Second（每秒传输的事物处理个数），即服务器每秒处理的事务数。TPS包括一条消息入和一条消息出，加上一次用户数据库访问。我们从TPS里反馈出logstash的实时工作状态。</p>
<p>首先先要安装<code>logstash-output-zabbix</code>，安装方法很简单：在logstash&#x2F;bin目录下执行<code>./logstash-plugin install logstash-output-zabbix</code>，如图：<br><img data-src="/images/logstash.png" alt="akb48"></p>
<p>然后在启动logstash对应的conf文件里，新增如下的配置：<br>	<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">  ...原有配置略</span><br><span class="line"></span><br><span class="line">  metrics &#123;</span><br><span class="line">    meter =&gt; <span class="string">&quot;events&quot;</span>	#这里统计经过filter的事件</span><br><span class="line">    add_tag =&gt; <span class="string">&quot;metric&quot;</span></span><br><span class="line">    add_field =&gt; &#123;<span class="string">&quot;[@metadata][zabbix_key]&quot;</span> =&gt; <span class="string">&quot;logstash_events&quot;</span>&#125;	 #zabbix item的key，这个要和zabbix-server的配置一致</span><br><span class="line">    add_field =&gt; &#123; <span class="string">&quot;[@metadata][zabbix_host]&quot;</span> =&gt; <span class="string">&quot;被监控机器名&quot;</span> &#125;	 	#zabbix写入的主机</span><br><span class="line">    flush_interval =&gt; <span class="number">30</span>	#设定写入频率，我这里是<span class="number">30</span>秒一次</span><br><span class="line">  &#125; </span><br><span class="line">&#125;   </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">	...原有配置略</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> <span class="string">&quot;metric&quot;</span> in [tags] &#123;</span><br><span class="line">    zabbix &#123; </span><br><span class="line">      zabbix_server_host =&gt; <span class="string">&quot;172.31.0.77&quot;</span>	#这里是zabbix-server的地址</span><br><span class="line">      zabbix_host =&gt; <span class="string">&quot;[@metadata][zabbix_host]&quot;</span></span><br><span class="line">      zabbix_key =&gt; <span class="string">&quot;[@metadata][zabbix_key]&quot;</span></span><br><span class="line">      zabbix_value =&gt; <span class="string">&quot;[events][count]&quot;</span>   #[events][count] 是事件统计数据，</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>保存之后，来到zabbix-server的web端，新增一个items，如下：<br><img data-src="/images/logstash2.png" alt="akb48"></p>
<p><font color=red>注意！这个items的类型是<code>zabbix-trapper</code>（Zabbix采集器）！同时设定<code>Preprocessing steps</code>为<code>simple change</code>。</font></p>
<p>然后重启logstash即可。重启之后，如果出现了如下的错误：<br>	<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[<span class="number">2019</span><span class="number">-06</span><span class="number">-11</span>T15:<span class="number">53</span>:<span class="number">33</span>,<span class="number">789</span>][WARN ][logstash.outputs.zabbix  ] Zabbix server at ZABBIXIP地址 rejected all items sent. &#123;:zabbix_host=&gt;<span class="string">&quot;被监控机器名&quot;</span>&#125;</span><br><span class="line">[<span class="number">2019</span><span class="number">-06</span><span class="number">-11</span>T15:<span class="number">53</span>:<span class="number">43</span>,<span class="number">797</span>][WARN ][logstash.outputs.zabbix  ] Zabbix server at ZABBIXIP地址 rejected all items sent. &#123;:zabbix_host=&gt;<span class="string">&quot;被监控机器名&quot;</span>&#125;</span><br></pre></td></tr></table></figure><br>检查一下<code>zabbix_key</code>、<code>zabbix_host</code>是否与<code>zabbix-server</code>网页端配置的完全一致，而且<code>zabbix_value</code>也最好不要是具体值，<code>[events][count]</code>就可以了。</p>
<p>然后在zabbix-server端就可以看到tps结果了：<br><img data-src="/images/logstash3.png" alt="akb48"></p>
<h2 id="使用systemctl启动logstash"><a href="#使用systemctl启动logstash" class="headerlink" title="使用systemctl启动logstash"></a>使用systemctl启动logstash</h2><p>我这个logstash是tar包安装的，每一次杀死启动都是敲命令，看上去很挫，于是就要转成systemctl的方式。首先先创建logstash用户和用户组，确认logstash用户在logstash用户组里。然后需要改几个地方：</p>
<p>先去<code>pipelines.yml</code>里修改path.config: “&#x2F;logstash路径&#x2F;config&#x2F;*.conf”，改成实际的配置文件。然后再在同文件夹的<code>startup.options</code>里修改<br>	<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">LS_HOME=/usr/share/logstash<span class="number">-6.2</span><span class="number">.3</span>  项目目录</span><br><span class="line">LS_SETTINGS_DIR=<span class="string">&quot;$LS_HOME/config&quot;</span></span><br><span class="line">LS_OPTS=<span class="string">&quot;--path.settings $&#123;LS_SETTINGS_DIR&#125;&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>再logstash安装路径下执行<code>./bin/system-install /logstash安装路径/config/startup.options systemd</code>。一会就能看到一个成功的字样，去<code>/etc/systemd/system/logstash.service</code>目录可以看到配置文件。此时就是可使用<code>systemctl enable/start/stop/restart logstash.service</code>来操作了！</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.zabbix.com/cn/integrations/logstash">https://www.zabbix.com/cn/integrations/logstash</a><br><a href="https://notes-by-yangjinjie.readthedocs.io/zh_CN/latest/service/elk/08-logstash-output-zabbix.html">https://notes-by-yangjinjie.readthedocs.io/zh_CN/latest/service/elk/08-logstash-output-zabbix.html</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
        <tag>elk</tag>
        <tag>tps</tag>
      </tags>
  </entry>
  <entry>
    <title>使用zabbix监控memcache</title>
    <url>/2018/04/03/%E4%BD%BF%E7%94%A8zabbix%E7%9B%91%E6%8E%A7memcache/</url>
    <content><![CDATA[<p>监控memcache的原理跟监控redis差不多，都是通过一个类似info的东西可以查询到memcache的状态值，然后通过脚本去获取这些值给zabbix，当发现某值不正常就发出告警。</p>
<p>查询当年memcache状态的命令是<code>echo stats |nc 127.0.0.1  11211</code>，如果没有<code>nc</code>命令，那就<code>yum install -y nc</code>。</p>
<p>获得到的结果是这个样子的：<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@lconline-ec2 ~]# echo stats |nc <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>  <span class="number">11211</span></span><br><span class="line"><span class="variable constant_">STAT</span> pid <span class="number">1859</span>        memcache服务进程<span class="variable constant_">ID</span></span><br><span class="line"><span class="variable constant_">STAT</span> uptime <span class="number">491093</span>    服务器已运行秒数</span><br><span class="line"><span class="variable constant_">STAT</span> time <span class="number">1522740969</span>    服务器当前<span class="title class_">Unix</span>时间戳</span><br><span class="line"><span class="variable constant_">STAT</span> version <span class="number">1.4</span><span class="number">.25</span>        memcache版本</span><br><span class="line"><span class="variable constant_">STAT</span> libevent <span class="number">1.4</span><span class="number">.13</span>-stable</span><br><span class="line"><span class="variable constant_">STAT</span> pointer_size <span class="number">64</span>        操作系统指针大小</span><br><span class="line"><span class="variable constant_">STAT</span> rusage_user <span class="number">14.321822</span>        进程累计用户时间</span><br><span class="line"><span class="variable constant_">STAT</span> rusage_system <span class="number">14.095857</span>        进程累计系统时间</span><br><span class="line"><span class="variable constant_">STAT</span> curr_connections <span class="number">5</span>        当前连接数量</span><br><span class="line"><span class="variable constant_">STAT</span> total_connections <span class="number">51010</span>    <span class="title class_">Memcached</span>运行以来连接总数</span><br><span class="line"><span class="variable constant_">STAT</span> connection_structures <span class="number">8</span>    <span class="title class_">Memcached</span>分配的连接结构数量</span><br><span class="line"><span class="variable constant_">STAT</span> reserved_fds <span class="number">20</span></span><br><span class="line"><span class="variable constant_">STAT</span> cmd_get <span class="number">0</span>        get命令请求次数</span><br><span class="line"><span class="variable constant_">STAT</span> cmd_set <span class="number">0</span>        set命令请求次数</span><br><span class="line"><span class="variable constant_">STAT</span> cmd_flush <span class="number">0</span>    flush命令请求次数</span><br><span class="line"><span class="variable constant_">STAT</span> cmd_touch <span class="number">0</span>    touch命令请求次数</span><br><span class="line"><span class="variable constant_">STAT</span> get_hits <span class="number">0</span>        get命令命中次数</span><br><span class="line"><span class="variable constant_">STAT</span> get_misses <span class="number">0</span>    get命令未命中次数</span><br><span class="line"><span class="variable constant_">STAT</span> delete_misses <span class="number">0</span>    <span class="keyword">delete</span>命令未命中次数</span><br><span class="line"><span class="variable constant_">STAT</span> delete_hits <span class="number">0</span>        <span class="keyword">delete</span>命令命中次数</span><br><span class="line"><span class="variable constant_">STAT</span> incr_misses <span class="number">0</span>        incr命令未命中次数</span><br><span class="line"><span class="variable constant_">STAT</span> incr_hits <span class="number">0</span>        incr命令命中次数</span><br><span class="line"><span class="variable constant_">STAT</span> decr_misses <span class="number">0</span>        decr命令未命中次数</span><br><span class="line"><span class="variable constant_">STAT</span> decr_hits <span class="number">0</span>        decr命令命中次数</span><br><span class="line"><span class="variable constant_">STAT</span> cas_misses <span class="number">0</span>        cas命令未命中次数</span><br><span class="line"><span class="variable constant_">STAT</span> cas_hits <span class="number">0</span>            cas命令命中次数</span><br><span class="line"><span class="variable constant_">STAT</span> cas_badval <span class="number">0</span>        使用擦拭次数</span><br><span class="line"><span class="variable constant_">STAT</span> touch_hits <span class="number">0</span></span><br><span class="line"><span class="variable constant_">STAT</span> touch_misses <span class="number">0</span></span><br><span class="line"><span class="variable constant_">STAT</span> auth_cmds <span class="number">0</span>        认证命令处理的次数    </span><br><span class="line"><span class="variable constant_">STAT</span> auth_errors <span class="number">0</span>        认证失败数目</span><br><span class="line"><span class="variable constant_">STAT</span> bytes_read <span class="number">357040</span>        读取总字节数    </span><br><span class="line"><span class="variable constant_">STAT</span> bytes_written <span class="number">60197691</span>        发送总字节数</span><br><span class="line"><span class="variable constant_">STAT</span> limit_maxbytes <span class="number">1073741824</span>        分配的内存总大小（字节）</span><br><span class="line"><span class="variable constant_">STAT</span> accepting_conns <span class="number">1</span>        服务器是否达到过最大连接（<span class="number">0</span>/<span class="number">1</span>）</span><br><span class="line"><span class="variable constant_">STAT</span> listen_disabled_num <span class="number">0</span>        失效的监听数</span><br><span class="line"><span class="variable constant_">STAT</span> time_in_listen_disabled_us <span class="number">0</span></span><br><span class="line"><span class="variable constant_">STAT</span> threads <span class="number">4</span>        当前线程数</span><br><span class="line"><span class="variable constant_">STAT</span> conn_yields <span class="number">0</span>        连接操作主动放弃数目</span><br><span class="line"><span class="variable constant_">STAT</span> hash_power_level <span class="number">16</span></span><br><span class="line"><span class="variable constant_">STAT</span> hash_bytes <span class="number">524288</span>        当前存储占用的字节数</span><br><span class="line"><span class="variable constant_">STAT</span> hash_is_expanding <span class="number">0</span></span><br><span class="line"><span class="variable constant_">STAT</span> malloc_fails <span class="number">0</span>    </span><br><span class="line"><span class="variable constant_">STAT</span> bytes <span class="number">0</span>        当前存储占用的字节数</span><br><span class="line"><span class="variable constant_">STAT</span> curr_items <span class="number">0</span>        当前存储的数据总数</span><br><span class="line"><span class="variable constant_">STAT</span> total_items <span class="number">0</span>        启动以来存储的数据总数</span><br><span class="line"><span class="variable constant_">STAT</span> expired_unfetched <span class="number">0</span>    </span><br><span class="line"><span class="variable constant_">STAT</span> evicted_unfetched <span class="number">0</span></span><br><span class="line"><span class="variable constant_">STAT</span> evictions <span class="number">0</span>        <span class="variable constant_">LRU</span>释放的对象数目</span><br><span class="line"><span class="variable constant_">STAT</span> reclaimed <span class="number">0</span>        已过期的数据条目来存储新数据的数目</span><br><span class="line"><span class="variable constant_">STAT</span> crawler_reclaimed <span class="number">0</span></span><br><span class="line"><span class="variable constant_">STAT</span> crawler_items_checked <span class="number">0</span></span><br><span class="line"><span class="variable constant_">STAT</span> lrutail_reflocked <span class="number">0</span>    </span><br><span class="line"><span class="variable constant_">END</span></span><br></pre></td></tr></table></figure></p>
<p>修改<code>zabbix_agentd.conf</code>，添加一个新的自定义项：<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">UserParameter</span>=memcached.<span class="property">stat</span>[*],(echo stats; sleep <span class="number">1</span>) | telnet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">11211</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span> | awk <span class="string">&#x27;/STAT $1 / &#123;print $NF&#125;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>然后重启<code>zabbix-agent</code>，模板就用github里的就好，看到的效果如下：<br><img data-src="/images/check-memcached.png" alt="paradin"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
        <tag>memcached</tag>
      </tags>
  </entry>
  <entry>
    <title>用非root用户启动tomcat进程</title>
    <url>/2018/04/18/%E4%BD%BF%E7%94%A8%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E5%90%AF%E5%8A%A8tomcat/</url>
    <content><![CDATA[<p>使用非root用户启动进程是运维安全的一个主要环节，拿tomcat进程来说，如果是使用root用户去启动了tomcat，那么有一个严重的问题，那就是tomcat具有root权限。这意味着你的任何一个jsp脚本都具有root权限，所以那些不怀好意的人可以轻易地用jsp脚本去搞破坏，甚至删除你整个硬盘里的东西！所以为了活着，我们要极力避免这种现象。很多的软件都自带的用户&#x2F;用户组，比如nginx、zabbix、elasticsearch，但是也有很多的软件没有这么贴心的服务，这就需要我们手动的更改了。</p>
<h2 id="使用非root用户启动tomcat"><a href="#使用非root用户启动tomcat" class="headerlink" title="使用非root用户启动tomcat"></a>使用非root用户启动tomcat</h2><p>以tomcat为例，打算用chris账号(属于chen这个group)启动。那么首先先创建账号和组，如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@chen-docker ~]groupadd chen    #创建chen这个组</span><br><span class="line">[root@chen-docker ~]useradd -s /bin/bash -g chen chris    #在这个组里面添加chris这个用户</span><br><span class="line">[root@chen-docker ~]passwd chris    #给这个用户设定密码</span><br><span class="line">[root@chen-docker ~]# id chris</span><br><span class="line">uid=<span class="number">1000</span>(chris) gid=<span class="number">1002</span>(chen) groups=<span class="number">1002</span>(chen)    #可见添加成功</span><br></pre></td></tr></table></figure></p>
<p><code>su chris</code>切换到chris用户，在<code>/home/chris</code>里使用<code>wget http://apache.fayea.com/tomcat/tomcat-9/v9.0.7/bin/apache-tomcat-9.0.7.tar.gz</code>下载tomcat。然后解压缩在&#x2F;home&#x2F;chris里，因为chris用户在这里是有权限的。然后进行如下的操作：<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cd  ~/ 代表用户所在目录</span><br><span class="line">mkdir -p ~/shell-script</span><br><span class="line">cd ~<span class="regexp">/shell-script/</span></span><br><span class="line">touch start.<span class="property">sh</span></span><br><span class="line">toush stop.<span class="property">sh</span></span><br></pre></td></tr></table></figure></p>
<p>这个<code>start.sh</code>的内容很简单，如下：<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#/bin/bash</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;root&quot;</span> == <span class="string">&quot;$USER&quot;</span> ]    #不让root启动</span><br><span class="line">then</span><br><span class="line">    echo <span class="string">&quot;can&#x27;t start with user &#x27;root&#x27;,retry after change user!&quot;</span></span><br><span class="line">    exit <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cd /home/chris/apache-tomcat-<span class="number">9.0</span><span class="number">.7</span>/bin/    &amp;&amp; ./start.<span class="property">sh</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p><code>shutdown.sh</code>的内容同理：<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#/bin/bash</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;root&quot;</span> == <span class="string">&quot;$USER&quot;</span> ]    #不让root启动</span><br><span class="line">then</span><br><span class="line">    echo <span class="string">&quot;can&#x27;t start with user &#x27;root&#x27;,retry after change user!&quot;</span></span><br><span class="line">    exit <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cd /home/chris/apache-tomcat-<span class="number">9.0</span><span class="number">.7</span>/bin/    &amp;&amp; ./shutdown.<span class="property">sh</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p><code>chmod +x *.sh</code>给上面两个脚本可执行权限，但是现在执行startup.sh或者shutdown.sh会出现一个问题：<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Neither</span> the <span class="variable constant_">JAVA_HOME</span> nor the <span class="variable constant_">JRE_HOME</span> environment variable is defined</span><br><span class="line"><span class="title class_">At</span> least one <span class="keyword">of</span> these environment variable is needed to run <span class="variable language_">this</span> program</span><br></pre></td></tr></table></figure></p>
<p>这是因为chris用户没有权限去启动java这个可执行程序，如果使用<code>java -version</code>回答是<code>bash: java: command not found</code>，这个时候怎么办？</p>
<p>编辑<code>~/.bash_profile</code>，在末尾处加上如下的内容：<br><img data-src="/images/noroot2.png" alt="paradin"></p>
<p>然后<code>source .bash_profile</code>，再使用<code>java -version</code>确认一下应该是OK了。这个时候也是可以使用chris用户去启动刚刚的那个start.sh和shutdown.sh的。<br><img data-src="/images/noroot3.png" alt="paradin"></p>
<p>由于我们的tomcat是源码解压缩，所以要使用root用户去创建一下<code>/etc/init.d/tomcat</code>。里面内容如下：<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/bin/</span>bash</span><br><span class="line"><span class="keyword">case</span> $1 <span class="keyword">in</span></span><br><span class="line">start)</span><br><span class="line">su - chris -lc <span class="string">&quot;sh /home/chris/shell-script/start.sh&quot;</span>;;     #如果要root启动，那就是su - root -lc <span class="string">&quot;sh /home/utomcat/shell-script/start.sh&quot;</span>;;</span><br><span class="line">stop)</span><br><span class="line">su - chris -lc <span class="string">&quot;sh /home/chris/shell-script/shutdown.sh&quot;</span>;;</span><br><span class="line">*)</span><br><span class="line">echo <span class="string">&quot;parameter error, usage:(start|stop)&quot;</span>;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></p>
<p>保存之后，执行一下<code>service tomcat start</code>看看效果。<br><img data-src="/images/noroot4.png" alt="paradin"></p>
<p>如果要设置开机自启动，别忘了<code>chkconfig --add tomcat</code>和<code>chkconfig tomcat on</code>，在浏览器打开<code>ip:8080</code>看见汤姆猫~<br><img data-src="/images/noroot5.png" alt="paradin"></p>
<h2 id="当普通用户要使用1024以下的端口"><a href="#当普通用户要使用1024以下的端口" class="headerlink" title="当普通用户要使用1024以下的端口"></a>当普通用户要使用1024以下的端口</h2><p>众所周知，linux默认是不准许普通用户调用1024以下的端口的，那么遇到这样的需求怎么办呢？最好的方法是使用iptables。</p>
<p>首先让程序运行在非root帐户下，并绑定高于1024的端口，在确保能正常工作的时候，将低端口通过端口转发，将低端口转到高端口，从而实现非root运行的程序绑定低端口。要使用此方法可以使用下面的方式：<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sysctl -w net.<span class="property">ipv4</span>.<span class="property">ip_forward</span>=<span class="number">1</span>        #要长久保存，需要在/etc/sysctl.<span class="property">conf</span>文件内修改，然后sysctl -p /etc/sysctl.<span class="property">conf</span></span><br><span class="line">iptables -F -t nat</span><br><span class="line">iptables -t nat -A <span class="variable constant_">PREROUTING</span> -p tcp --dport <span class="number">80</span> -j <span class="variable constant_">DNAT</span> --<span class="attr">to</span>:<span class="number">8088</span>    #将<span class="number">80</span>端口转发到<span class="number">8088</span></span><br><span class="line">iptables -t nat -A <span class="variable constant_">PREROUTING</span> -p tcp --dport <span class="number">80</span> -j <span class="variable constant_">REDIRECT</span> --to-port <span class="number">8080</span>    #这句话也可以</span><br></pre></td></tr></table></figure></p>
<p>这么操作在速度上没有任何影响。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>运维安全</tag>
      </tags>
  </entry>
  <entry>
    <title>修复底座安全漏洞引发的ADB PG实例不可用</title>
    <url>/2024/06/11/%E4%BF%AE%E5%A4%8D%E5%BA%95%E5%BA%A7%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E5%BC%95%E5%8F%91%E7%9A%84ADB-PG%E5%AE%9E%E4%BE%8B%E4%B8%8D%E5%8F%AF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="一、故障背景"><a href="#一、故障背景" class="headerlink" title="一、故障背景"></a>一、故障背景</h2><p>在描述背景前，先补充点基础知识，以便理解下<code>ADB PG</code>的定位和架构：<br>ADB PG的定位：<br><img data-src="/images/adb-1.png" title="这是阿里云官网数据库产品家族介绍"></p>
<p>这里说一下，<code>ADB PG</code>全称是<code>AnalyticDB PostgreSQL</code>，基于开源项目<code>Greenplum</code>构建，由阿里云深度扩展。<code>Analytic</code>是一个形容词，主要用于描述与分析（Analysis）相关的特性或方法。</p>
<p>参考资料来源：<br><a href="https://www.aliyun.com/product/outline/index?spm=5176.28508143.0.0.e939154aeSDRwA&scm=20140722.X_model-category-instance-9e6c8b1b87e83616c97a._.V_1">https://www.aliyun.com/product/outline/index?spm=5176.28508143.0.0.e939154aeSDRwA&amp;scm=20140722.X_model-category-instance-9e6c8b1b87e83616c97a._.V_1</a></p>
<p>故障背景：<br>1、dbstack作为阿里云数据库产品族的快速输出方案已经在多个局点部署。<br>2、某局点修复dbstack底座<code>kubelet</code>组件安全漏洞会重启<code>kubelet</code>，因为未知原因（日志被滚动清理了，复盘后提供了排查方向，但无法100%确定），导致部分节点上的pod被重建。<br>3、重建后的pod挂载了宿主机上容器自身的<code>cgroup</code>文件系统，未重建的pod挂载的是宿主机自身的<code>cgroup</code>文件系统，挂载行为发生变化。<br>4、重建后的pod的<code>cgroup</code>关于<code>cpuset.cpus</code>的设置值超过了20个字符，触发ADB PG的已知缺陷。<br>5、ADB PG集群状态异常，使用psql命令行数据库连接工具去连接数据库卡住。<br>6、基础知识：<br>	a.默认情况下Pod 默认不会直接挂载宿主机上的 cgroup 文件系统，因为这样做可能会带来安全风险。如果非要挂载可以用<code>privileged: true</code>（很危险不推荐），或者<code>卷挂载</code>的方式（只需要挂载特定的目录，推荐）。<br>	b.Kubelet 是<code>Kubernetes</code>集群中的一个重要组件，负责在一个节点上运行 Pod 容器。它是集群中最底层的代理，与<code>Kubernetes API Server</code> 通信，并确保容器按预期运行。Kubelet 负责监控和维护节点上的 Pod 状态，确保它们处于期望的状态。</p>
<h2 id="二、故障排查过程"><a href="#二、故障排查过程" class="headerlink" title="二、故障排查过程"></a>二、故障排查过程</h2><p>1、夜里10点，也就是<code>修复dbstack底座变更</code>开始后1小时。值班长接到数据库“业务读写不可用”告警，开始调度产研一起排查。<br>一开始并不能明确是什么原因导致的集群异常，所以登陆到Master节点，尝试使用psql连接集群，看看有哪些计算组进程down了，但是<code>psql</code>卡住了，无法成功登陆。<br><img data-src="/images/adb-2.png" title="报错cannot write data"></p>
<p>2、<code>ps -ef | grep -i postgres</code>这个命令就是查看PostgreSQL 相关的所有进程，发现大量<code>backend</code>进程处于<code>startup</code>状态，此现象其实属于常见现象，平时在其他故障场景下也有遇到。</p>
<p>如果一个backend进程长时间停留在<code>startup</code>状态，可能表明存在以下问题：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">认证延迟：身份验证服务或配置问题导致认证过程变慢。</span><br><span class="line">资源争抢：系统资源紧张（如CPU、内存、I/O），导致进程等待资源分配。</span><br><span class="line">配置错误：数据库或客户端连接参数配置不当，导致初始化过程卡住。</span><br><span class="line">网络问题：网络延迟或不稳定，影响连接建立或认证信息的交换。</span><br><span class="line">系统问题：Greenplum内部问题，如bug，或者系统级的锁冲突。</span><br></pre></td></tr></table></figure><br>此时产研根据经验判断，应该是计算组进程有什么异常。</p>
<p>3、kill掉任意一个backend进程，让Master进入recovery模式，会释放相关的数据库连接，然后就可以使用psql连接到数据库中，查询到有大量的计算组进程down。</p>
<p>4、尝试用<code>gpstop -af</code>命令手动停止集群，但是发现已经存在新启动任务，说明管控探测Master异常，触发了重启，这里为了避免管控干扰问题修复，去杜康临时关闭HA检查。</p>
<p>5、等管控的启动任务结束后，进入集群，找到任意一个down的计算组进程，查看日志发现，很清楚的不停打印cgroup相关错误，此时原因基本定位到了，但是如何解决又让众人没有思路，只能各种尝试，这部分工作耗费了大量时间。</p>
<p>6、当时做的尝试有：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）手动delete某个pod，pod重建后，cgroup错误依然存在。</span><br><span class="line"><span class="number">2</span>）切换到root用户下，手动写入 cpuset.cpus 相关参数值，手动重启计算组进程， cgroup 错误依然存在。</span><br></pre></td></tr></table></figure></p>
<p>7、经过各方协调，最后在产研的建议下，修改<code>pod</code>的<code>yaml</code>里面关于<code>cgroup</code>的设置，修改后计算组进程立刻恢复正常，然后进行故障计算组所在pod批量修改，此步骤前后耗时不超过30min，解决问题的终极办法有时候就是很朴素，只是要找到正确的办法。命令如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kubectl -n dbstack-dbaas annotate pod $podname cgroup.ark.alibabacloud.com/detail=<span class="string">&#x27;&#123;&quot;engine&quot;:&#123;&quot;cpuset&quot;:&quot;-1&quot;&#125;&#125;&#x27;</span> --overwrite</span><br><span class="line"></span><br><span class="line">这里解释一下上面命令：</span><br><span class="line">kubectl: 这是 Kubernetes 的命令行工具，用于与 Kubernetes API 服务器进行交互。</span><br><span class="line">-n dbstack-dbaas: 这个选项指定了命名空间（namespace），这里是 dbstack-dbaas。</span><br><span class="line">annotate: 这个子命令用于添加或更新 Pod 的注解。</span><br><span class="line">pod $podname: 指定要操作的 Pod 名称，这里的 $podname 是一个变量，代表具体的 Pod 名称。</span><br><span class="line">cgroup.ark.alibabacloud.com/detail=<span class="string">&#x27;&#123;&quot;engine&quot;:&#123;&quot;cpuset&quot;:&quot;-1&quot;&#125;&#125;&#x27;</span>: 这是要添加或更新的注解及其值。注解名称是 cgroup.ark.alibabacloud.com/detail，值是一个 JSON 字符串 &#123; <span class="string">&quot;engine&quot;</span>: &#123; <span class="string">&quot;cpuset&quot;</span>: <span class="string">&quot;-1&quot;</span> &#125; &#125;。</span><br><span class="line">--overwrite: 这个标志表示如果注解已经存在，则覆盖原有的值。</span><br></pre></td></tr></table></figure><br>命令输入后，返回<code>pod/my-pod annotated</code>这表明注解已被成功添加或更新。当然，在修改前，同时对dbaas库里面的cgroup相关配置做了备份，防止需要回滚。</p>
<p>8、至此，时间已经是凌晨2点。集群恢复可用状态，虽然有部分计算组进程down，集群性能下降，但是可以开始承接业务读写。<code>不过问题到此，远远没有结束，更刺激的还在后面。</code></p>
<p>9、时间来到故障发生后凌晨4点，现场反馈大量跑批任务报错，相关人员立即介入排查。问题报错是<code>相关任务要读取某些表，提示底层文件不存在！</code>发现是因为故障的时候，计算组主备切换，其实备节点顶替主节点行使主节点的职责的时候，当时备节点和主节点并不完全同步，存在<code>部分内容主节点有，但是备节点没有</code>的情况。</p>
<p>10、尝试将报错中提示的表不存在的文件从计算组的主节点拷贝到备节点的数据目录，手动跑了相关的任务，提示运行成功。</p>
<p>11、但是报错的任务太多，涉及到的表也太多，一个个手动拷贝报错的文件显然是不可取的，所以决定手动进行故障的计算组主备重新切换，让原先的主节点重新顶替备节点进行工作。切换后任务继续运行，直至早上9点，全部任务结束，赶在客户使用数据前输出，紧张的应急只是告一段落，问题还没有完全结束。</p>
<p>12、时间来到故障发生后第二日10点，现场反馈，业务人员读取外部表报错，开发和DBA继续介入排查。</p>
<p>13、现场使用的是pxf访问hadoop外表，报错提示和pxf认证相关，krb5问题，问题很明确，重新初始化pxf的krb5相关配置即可，但是如何重新初始化呢？经过现场排查，的确凡是被新建的计算组pod里面关于krb5的认证相关配置文件均不存在，未重建的计算组pod里面是有相关配置文件的。</p>
<p>14、此时要么手动拷贝相关配置文件，要么批量重新生成配置文件，很显然手动拷贝工作量大，还有可能遗漏，也很耗费时间。随后决定走批量重新生成的办法，正好现场之前处理过类似问题，在产研的建议下排查到pxf初始化任务被实例的主备切换任务阻塞，把杜康上相关中断的任务处理掉以后，pxf开始自动初始化，初始化正常后业务读写正常。</p>
<p>15、时间来到故障发生后第二日11点，现场反馈，业务人员表示数据库查询缓慢。其实这个问题很明确，集群有部分计算组down，在修复中，在没有完全修复完毕，集群处于平衡状态下，集群性能会有很大折扣，同时叠加夜间进行了大量跑批，修复速度会进一步被拖慢。</p>
<p>16、同时产研提醒，因为down的计算组进程过多，需要注意并行修复，避免串行修复，时间进一步拉长。给现场重新分发了新的修复脚本后，按照预期进行修复，但是因为要修复的太多，同时有业务读写，修复进度一直不太理想。</p>
<p>17、时间来到故障发生后第二日23点，现场各方沟通后，决定停止业务读写，全力保障修复进度。</p>
<p>18、时间来到故障发生后第三日7点，集群修复结束，重新回归平衡，问题算是彻底修复完成。随后针对此次应急，内部进行了深入复盘。</p>
<h2 id="三、故障解析-事后思考"><a href="#三、故障解析-事后思考" class="headerlink" title="三、故障解析 &amp; 事后思考"></a>三、故障解析 &amp; 事后思考</h2><p>1、此故障属于<code>ADB PG-6.3.10.14</code>之前版本的缺陷，我们后来也在dbstack环境实例化一个和现场同版本的实例。此处得到了产研同学的大力支持，通过手动准备相关版本镜像、修改dbaas相关表的办法，成功实例化了和现场同样版本的实例。</p>
<p>2、因为现场是大量计算组进程的pod被重建，所以事后我们认为cgroup初始化出错问题只会出现在计算组相关进程，其实不是的，Master节点也会出现。</p>
<p>正好新实例化的实例Master节点的cpu核心是8核心，也使用了超过20字符的方式设置cgroup，在按照演练方案，执行ADB PG开启<code>cgroup</code>功能后，问题直接复现，还没到如何解决计算组进程cgroup初始化异常那一步，比现场遇到的场景更加复杂，也是比较出乎意料。</p>
<p>开启cgroup就是修改ADB PG的参数<code>gp_resource_manager</code>从queue改为group，修改完重启生效。如图：<br><img data-src="/images/adb-3.png"></p>
<p>出现故障的实例的Master的cgroup设置：<br><img data-src="/images/adb-4.png"></p>
<p>3、<code>cpuset.cpus</code>的设置值超过20个字符触发缺陷的详细描述如下：<br>假如服务器有64核心（编号从0-64），计算组分配了32核心，<code>cpuset.cpus</code>里面的值就是这样：<code>0,1,2-3,4-6,11-13,15-18,...</code>。这些字符串表示绑定到32个cpu核心，但是字符（逗号、横线）加起来超过了20个字符，导致容器启动后，cgroup关于<code>cpuset.cpus</code>的设置失败，如下图：<br><img data-src="/images/adb-5.png"></p>
<p>4、出现这种问题的临时解法如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）先订正slave的cgroup，缩小到<span class="number">20</span>字符以内，命令：kubectl -n dbstack-dbaas annotate pod $podname cgroup.ark.alibabacloud.com/detail=<span class="string">&#x27;&#123;&quot;engine&quot;:&#123;&quot;cpuset&quot;:&quot;-1&quot;&#125;&#125;&#x27;</span> --overwrite</span><br><span class="line"><span class="number">2</span>）再订正master的cgroup，缩小到<span class="number">20</span>字符以内，命令参考第一步命令即可</span><br><span class="line"><span class="number">3</span>）剩余计算组进程所在pod，如果有cgroup设置超过<span class="number">20</span>个字符的，依次订正cgroup到<span class="number">20</span>字符以内</span><br></pre></td></tr></table></figure></p>
<p>永久性解法还是推进项目进行内核升级。</p>
<p>5、为什么使用psql工具去连接数据库会卡住？因为有大量的<code>ADB PG</code>的计算组进程处于非正常状态，ADB PG的Master去探测计算组进程是否正常无法得到响应，Master不停的探测，就会不断消耗数据库可用连接直至耗尽。最后给运维人员的直观感受就是使用psql工具以管理员用户去连接数据库会卡住，同时提示数据库连接数不足。</p>
<p>6、 集群异常后修复效率问题：如果发现集群有大面积计算组进程down，需要和业务方第一时间进行沟通，争取能及时停止业务读写，全力保障修复工作高优先级顺利进行，边修复边使用，不光修复的慢，使用方体验也不佳。</p>
<p>7、升级过程中常见的组件间配合问题:底层组件升级，忽略了上层应用的拓扑，有可能会触发<code>ADB PG</code>同一个主备组的进程同一时刻被重建，导致集群不可用。<br>之前也遇到过类似故障，升级过程中调用方未检查被调用方状态，未检查调用执行是否成功，最终双方均未及时抛错，显示升级过程一切正常，直至业务真实调用的时候，才发现其实有故障隐患。</p>
<p>目前我司的产品组件众多，调用关系复杂，尤其是在升级这种大变更场景下，相对完善的检查机制和及时抛错机制可以及时发现升级的异常，将故障前移。这块儿只能依靠告警来发现问题，然后上有经验的人来及时剖析问题，不断完善产品。或者现场升级后及时关注业务指标变化，在故障发生后，及时介入处理，将影响降到最低。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>k8s</tag>
        <tag>AnalyticDB PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>使用模板嵌套来精简html代码</title>
    <url>/2018/11/02/%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E6%A0%87%E7%AD%BE%E6%9D%A5%E7%B2%BE%E7%AE%80html%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>在编写django的时候，前端html文件里经常会遇到很多有大量重复代码的情况出现，为了代码精简好看以及后期维护的方便，就需要把那些重复的代码统一放到一个文件里去，不重复的部分自然保留，文件到时直接调用重复模板就好，不同的部分对应填充。</p>
<p>举个例子，有一个代码是<code>templates/aaa.html</code>：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">        &lt;meta charset=&#x27;UTF-8&#x27;&gt;</span><br><span class="line">        &lt;title&gt;&#123;&#123; blog.title &#125;&#125;&lt;/title&gt;		&lt;!-- blog.title就是文章标题，从数据库中提取，使用vender映射出来 --&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">                &lt;a href=&quot;&#123;% url &#x27;home&#x27; %&#125;&quot;&gt;</span><br><span class="line">                        &lt;h2&gt;BACK TO HOMEPAGE&lt;/h2&gt;	&lt;!-- 这部分是重复的 --&gt;</span><br><span class="line">                &lt;/a&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;h3&gt;&#123;&#123; blog.title &#125;&#125;&lt;/h3&gt;	&lt;!-- 这一部分也是同样用vender映射，展现每一篇文章对应的作者和内容 --&gt;</span><br><span class="line">        &lt;p&gt;作者：&#123;&#123; blog.author &#125;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;分类：</span><br><span class="line">                &lt;a href=&quot;&#123;% url &#x27;blogs_with_type&#x27; blog.blog_type.pk %&#125;&quot;&gt;</span><br><span class="line">                        &#123;&#123; blog.blog_type &#125;&#125;</span><br><span class="line">                &lt;/a&gt;</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;p&gt; &#123;&#123; blog.blog_type.pk &#125;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;发表时间：&#123;&#123; blog.created_time|date:&quot;Y-m-d H:i:s&quot;&#125;&#125;&lt;/p&gt;  &lt;!-- 这里规定了时间格式 --&gt;</span><br><span class="line">        &lt;hr&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123; blog.content &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>假设<code>aaa.html</code>里”BACK TO HOMEPAGE”这个部分是重复的，即每一个页面都有返回主页的点击。既然都有这个功能，那么就单独做一个<code>base.html</code>文件当框架，把重复的部分写进去：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">        &lt;meta charset=&#x27;UTF-8&#x27;&gt;</span><br><span class="line">        &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125;&lt;/title&gt;	&lt;!--这里加入了一个block(块），块的名字叫title--&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">                &lt;a href=&quot;&#123;% url &#x27;home&#x27; %&#125;&quot;&gt;</span><br><span class="line">                        &lt;h2&gt;BACK TO HOMEPAGE&lt;/h2&gt;</span><br><span class="line">                &lt;/a&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;hr&gt;</span><br><span class="line">        &#123;% block content%&#125; &#123;% endblock %&#125;		&lt;!--这里又加入了一个block，块的名字叫content--&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>现在的<code>base.html</code>就是一个框架，里面有了两个block，这两个块有各自的名称，因为这两个块的内容是变化的。再把<code>aaa.html</code>里需要对应配置的部分定义成对应的变量，并且引入这个<code>base.html</code>即可。重新修理后的<code>aaa.html</code>就长这个样子了：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% extends &#x27;base.html&#x27; %&#125;	&lt;!--首先引入同目录下的base.html--&gt;</span><br><span class="line"></span><br><span class="line">&#123;% block title%&#125;</span><br><span class="line">        &#123;&#123; blog.title &#125;&#125;	&lt;!--这部分就是title块的内容--&gt;</span><br><span class="line">&#123;% endblock%&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;  &lt;!--这一段就是content块的内容--&gt;</span><br><span class="line">        &lt;h3&gt;&#123;&#123; blog.title &#125;&#125;&lt;/h3&gt;</span><br><span class="line">        &lt;p&gt;作者：&#123;&#123; blog.author &#125;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;分类：</span><br><span class="line">                &lt;a href=&quot;&#123;% url &#x27;blogs_with_type&#x27; blog.blog_type.pk %&#125;&quot;&gt;</span><br><span class="line">                        &#123;&#123; blog.blog_type &#125;&#125;</span><br><span class="line">                &lt;/a&gt;</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;p&gt; &#123;&#123; blog.blog_type.pk &#125;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;发表时间：&#123;&#123; blog.created_time|date:&quot;Y-m-d H:i:s&quot;&#125;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;hr&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123; blog.content &#125;&#125;&lt;/p&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p>
<p>将<code>aaa.html</code>保存之后，刷新对应的页面，会发现依旧可以成功读取而且界面没有任何的变化。</p>
<p>可是在实际操作中也会出现这样的需求：多个不同的django APP可能会要访问同一个模板文件（即base.html），那么就要每一个app都复制一遍base.html吗？其实大可不必。这里可以修改一下<code>setting.py</code>，在里面设置一下公共的模板文件路径。</p>
<p>首先我们现在project根目录下建立一个base文件夹，把<code>base.html</code>复制进去，然后修改一下<code>setting.py</code>如下的字段：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TEMPLATES = [</span><br><span class="line">   &#123;</span><br><span class="line">       &#x27;BACKEND&#x27;: &#x27;django.template.backends.django.DjangoTemplates&#x27;,</span><br><span class="line">       &#x27;DIRS&#x27;: [</span><br><span class="line">           	os.path.join(BASE_DIR，&#x27;base&#x27;),		#BASE_DIR是在文件最开始定义的，即project的根目录</span><br><span class="line">           ],</span><br><span class="line">       &#x27;APP_DIRS&#x27;: True,		#这句话的意思是templates文件夹里所有的文件都可以访问</span><br><span class="line">       &#x27;OPTIONS&#x27;: &#123;</span><br><span class="line">           &#x27;context_processors&#x27;: [</span><br><span class="line">               &#x27;django.template.context_processors.debug&#x27;,</span><br><span class="line">               &#x27;django.template.context_processors.request&#x27;,</span><br><span class="line">               &#x27;django.contrib.auth.context_processors.auth&#x27;,</span><br><span class="line">               &#x27;django.contrib.messages.context_processors.messages&#x27;,</span><br><span class="line">           ],</span><br><span class="line">       &#125;,</span><br><span class="line">   &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>保存之后，再次刷新界面，发现界面没变化。这里django在寻找页面的时候，就会去project的路径&#x2F;base下先找对应的文件，如果没有，会再去自己应用下的templates文件夹里找。如果两个都没有，那就会报错<code>base.html is not exist</code>。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>关于DEPENDENT SUBQUERY的优化</title>
    <url>/2021/06/16/%E5%85%B3%E4%BA%8EDEPENDENT-SUBQUERY%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>有一个条件查询同步的SQL，内容如下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update naxxramas_coreapp_status a set a.post_num = (select count(b.publish_id) from naxxramas_app_publish b where b.app_name=a.app_name and b.env_type = &#x27;production&#x27; and b.status = &#x27;SUCCESS&#x27; and DATE_SUB(CURDATE(), INTERVAL 30 DAY) &lt;= date(b.gmt_end) GROUP BY b.app_name) where exists (select null from naxxramas_app_publish b where b.app_name=a.app_name)</span><br></pre></td></tr></table></figure></p>
<p>这个语句比较简单，主要就是把<code>naxxramas_coreapp_status</code>这个表里的<code>post_num</code>字段更新成<code>naxxramas_app_publish</code>这个表里的符合条件的<code>publish_id</code>的个数。但是这个SQL却执行失败，原因如图：<br><img data-src="/images/%E4%BC%98%E5%8C%96SQL1.png" title="执行失败的原因"></p>
<p>可见是SQL语句执行时间过长，需要优化，<code>explain</code>一下看一下结果，发现有<br><img data-src="/images/%E4%BC%98%E5%8C%96SQL2.png" title="可见有DEPENDENT SUBQUERY"></p>
<p>这个<code>Dependent Subquery</code>是啥？官方含义为：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SUBQUERY：子查询中的第一个SELECT，</span><br><span class="line">DEPENDENT SUBQUERY：子查询中的第一个SELECT，取决于外面的查询。 </span><br></pre></td></tr></table></figure></p>
<p>结合这个例子来说，就是子查询对b表的查询方式依赖于外层表a的查询，从<code>explain</code>的结果看，意味着这三步都走完，需要查询3751乘以36471乘以36471乘以0.01这么多行，不慢才怪呢。</p>
<p>这里补充一下，<code>filtered</code>是啥意思，它的意思是符合某条件的记录数百分比。其实只要执行两条sql语句，一条有<code>where</code>，一条无<code>where</code>，就可以看出<code>filtered</code>的作用。</p>
<p>最后优化的结果如下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update naxxramas_coreapp_status a </span><br><span class="line">inner join</span><br><span class="line">(select count(publish_id) as num,app_name FROM naxxramas_app_publish WHERE env_type = &#x27;production&#x27; and status = &#x27;SUCCESS&#x27; and DATE_SUB(CURDATE(), INTERVAL 30 DAY) &lt;= date(gmt_end) GROUP BY app_name) b</span><br><span class="line">on a.app_name=b.app_name</span><br><span class="line">set a.post_num = b.num;</span><br></pre></td></tr></table></figure></p>
<p>效果如图：<br><img data-src="/images/%E4%BC%98%E5%8C%96SQL3.png" title="用了1000多毫秒"></p>
<p>再次<code>explain</code>一下看看：<br><img data-src="/images/%E4%BC%98%E5%8C%96SQL4.png"></p>
<p>这里我主要是“使用连接查询+放弃了判断b表、a表是否有各自不存在的记录”，而且没有触发子查询，可以从执行计划中看到执行计划已经从<code>DEPENDENT SUBQUERY</code>变成了<code>DERIVED</code>，以驱动表去关联查询了，没有完全的扫描行，这省去了较多的IO。 </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/kk185800961/article/details/49340589">https://blog.csdn.net/kk185800961/article/details/49340589</a><br><a href="https://juejin.cn/post/6844904007228456974">https://juejin.cn/post/6844904007228456974</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>全链路压测中遇到的一个奇葩问题</title>
    <url>/2025/05/15/%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E5%A5%87%E8%91%A9%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="事情回溯"><a href="#事情回溯" class="headerlink" title="事情回溯"></a>事情回溯</h2><p>这几年618大促越来越早了，5月14日集团决定要加一场全链路压测用于验证16日的618付尾款的链路稳定性。</p>
<p>于是我们白天就准备好了晚上压测用到的数据预热任务：预热任务是12点启动，数据的缓存过期时间是43200秒，即12个小时，也就是晚上12点数据过期，足够覆盖压测的时间段了。<br><img data-src="/images/%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F3.png" alt="paradin" title="缓存时间12小时"></p>
<p>我们的预热逻辑是这样的：从odps离线表里拿到key，然后预热接口会请求这些key，如果没有的话，就会去数据库里查，然后再put到缓存里，逻辑很简单。</p>
<p>然后整个预热过程非常顺利，命中率和成功率都满足要求：<br><img data-src="/images/%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F2.png" alt="paradin" title="预热效果达到了预期"></p>
<p>晚上压测分为几个阶段：20点压“现货+尾款”阶段，系统表现正常符合预期。然后21点休息半小时，21点半开始脉冲流量压“纯现货交易”阶段，而这一波流量刚起来，上游就在群里反馈由于我们系统挂了导致他们出现了大量错误：<br><img data-src="/images/%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F.png" alt="paradin" title="上游看就是unsh有大量的timeout，center的少一点"><br><img data-src="/images/%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F7.png" alt="paradin" title="从我们的角度看就是大量数据不存在"><br><img data-src="/images/%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F8.png" alt="paradin" title="数据库出现了大量的读"></p>
<p>然后我们一看错误细节，发现是缓存有大量的写操作，即数据库被打爆了。换言之就是缓存数据过期了，但是不应该呀，上面说过了，我们的数据应该是晚上12点过期的，为什么21点半就过期了？<br><img data-src="/images/%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F9.png" alt="paradin" title="因为21点32分的压测脉冲压垮的上游，所以中途停掉了压测，21点55又重新打了一波流量"></p>
<p>再针对一个key，看了一下具体的put时间和失效时间：<br><img data-src="/images/%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F1.png" alt="paradin" title="发现果然是新插入的"></p>
<p>先去tair里，发现一天内并没有逐出的现象，而且tair的容量也没有满：<br><img data-src="/images/%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F4.png" alt="paradin" title="2天缓存都没有任何的逐出"></p>
<p>然后预热的离线表内容也没有任何的变化，前几天也用的同样的预热数据压测却没有任何的问题，可见不是因为预热数据发生了变更，导致有数据漏掉了：<br><img data-src="/images/%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F6.png" alt="paradin" title="数据条数是一样的"></p>
<p>后来把这个缓存的写入时间拉长发现了一点端倪：<br><img data-src="/images/%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F5.png" alt="paradin" title="早上9点多的时候发现有数据写入，unsh单元写的少，center单元写的多"></p>
<p>后来问了一下负责压测的同学，他早上9点上班之后，会用压测流量走一下“渲染这个应用的接口”拉一把最新的偏移好的营销压测数据，防止这个营销数据过期导致压测的时候出现下单阻断的情况，这个是常规的操作。而我们这个应用是在渲染这个应用的下游，所以早上他跑接口的时候也会请求到我们这个应用。</p>
<p>结论就是：早上压测同学试跑的时候，压测流量击穿到DB的请求实际没有影子数据，会通过空保护对象进行缓存，这类对象无法通过主动预热任务写进缓存，依赖JIT压测流量自然预热。早上09:10到09:50有压测试跑流量，这时会将这些流量的空保护对象写进缓存，压测数据过期时间统一设置为12h +（1min内随机时间），因此晚上21点到21点30期间这些空保护对象会集中失效，从而导致21:31分脉冲时缓存击穿到DB，进而引起DB抖动。</p>
<p>事后action：<br>	1. 这个过程太强依赖负责压测同学在构造url时打的流量和压测前的jit流量，如果将来他们技术进步了，不再有这个步骤的话，那么我们这个流量就无法被预热到缓存里，所以还需要把预热的主动权掌握在自己手里。<br>	2. 将缓存失效时间打散，不要一批全部失效，打散时间从原来的1分钟延长到1个小时内随机失效。<br>	3. 同时减少tair调用量，降低空查询比例，提升主动预热任务的有效性。</p>
<h2 id="空保护"><a href="#空保护" class="headerlink" title="空保护"></a>空保护</h2><p>啥是空保护呢？是一种通过缓存“空值”来防止缓存穿透的策略。它的核心目标是避免因查询不存在的数据而导致数据库或后端服务被频繁访问，从而保护系统稳定性。</p>
<p>例如用户恶意构造不存在的ID，导致每次请求都会穿透到数据库，可能引发数据库压力激增甚至崩溃。举个例子：用户频繁查询 ID&#x3D;99999999 的数据（该ID在数据库中不存在）→ 缓存中没有该ID → 请求穿透到数据库 → 数据库返回空 → 重复触发。这样就会产生一些到服务端不必要的调用以及产生了很多不必要的日志，直到数据库or服务端嗝屁。</p>
<p>所以就通过缓存“空值”（如 null 或特定标记），将不存在的数据结果缓存一段时间，避免重复请求穿透到数据库。</p>
<p>实现流程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>查询缓存：</span><br><span class="line">	a.如果缓存中有数据（命中），直接返回。</span><br><span class="line">	b.如果缓存中没有数据（未命中），继续查询数据库。</span><br><span class="line"><span class="number">2.</span>查询数据库：</span><br><span class="line">	a.如果数据库中存在数据，将数据写入缓存并返回。</span><br><span class="line">	b.如果数据库中不存在数据，将空值（null）写入缓存，并设置较短的TTL（过期时间）。</span><br><span class="line"><span class="number">3.</span>后续请求：</span><br><span class="line">	a.相同请求会直接从缓存中获取空值，不再访问数据库。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>缓存</tag>
        <tag>空保护</tag>
        <tag>全链路压测</tag>
      </tags>
  </entry>
  <entry>
    <title>关于logrotate的额外补充</title>
    <url>/2018/02/12/%E5%85%B3%E4%BA%8Elogrotate%E7%9A%84%E9%A2%9D%E5%A4%96%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<p><code>https://rorschachchan.github.io/2018/02/12/日志文件管理者：Logrotate/</code> 里面已经简单介绍了logrotate命令，这里还有一些额外补充的东西：</p>
<p>1）查看logrotate对log文件的具体执行情况的语句是<code>cat /var/lib/logrotate.status</code>，效果如图：<br><img data-src="/images/logrotate6.png" alt="paradin"></p>
<p>2）使用<code>-v</code>或<code>-d</code>参数时，显示<code>log does not need rotating</code>，这是因为logrotate在对status未记录的文件进行转储时，会在status添加一条该文件的记录，并将操作时间设为当天。之后程序再次对此文件进行转储时发现这个文件今天已经操作过，就不再进行相关操作。要是想解决这个问题可以使用<code>-s</code>指定logrotate状态文件；</p>
<p>3）分割日志时报错：<code>error: skipping &quot;/var/log/nginx/test.access.log&quot; because parent directory has insecure permissions (It&#39;s world writable or writable by group which is not &quot;root&quot;) Set &quot;su&quot; directive in config file to tell logrotate which user/group should be used for rotation.</code>这是当前用户不是root，需要添加<code>su root list</code>这个语句到对应的logrotate配置文件里，比如：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/<span class="keyword">var</span>/log/nginx<span class="comment">/*.log &#123;</span></span><br><span class="line"><span class="comment">       su root list	#第一句添加</span></span><br><span class="line"><span class="comment">       daily</span></span><br><span class="line"><span class="comment">       missingok</span></span><br><span class="line"><span class="comment">       rotate 52</span></span><br><span class="line"><span class="comment">       compress</span></span><br><span class="line"><span class="comment">       delaycompress</span></span><br><span class="line"><span class="comment">       notifempty</span></span><br><span class="line"><span class="comment">       #ifempty</span></span><br><span class="line"><span class="comment">       create 0640 www-data adm</span></span><br><span class="line"><span class="comment">       sharedscripts</span></span><br><span class="line"><span class="comment">       postrotate</span></span><br><span class="line"><span class="comment">               [ ! -f /var/run/nginx.pid ] || kill -USR1 `cat /var/run/nginx.pid`</span></span><br><span class="line"><span class="comment">       endscript</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>4）如果觉得使用<code>logrotate</code>很麻烦，而当某个文件过大的时候，要实现把该文件压缩并且拆成若干个指定大小的文件，怎么办？<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">tar -zcvf 新文件名.<span class="property">tar</span>.<span class="property">gz</span> 原文件名 | split -b 每个分格包大小 -d -a <span class="number">1</span> - 新文件名.<span class="property">tar</span>.<span class="property">gz</span></span><br></pre></td></tr></table></figure></p>
<p>比如：<code>tar -zcvf ABC.tar.gz ABC | split -b 4000M -d -a 1 - ABC.tar.gz</code>。这个命令就是把ABC这个文件压缩成ABC.tar.gz，但是如果ABC大于4000M就会切块，切成ABC.tar.gz.0,ABC.tar.gz.1,ABC.tar.gz.2……这个样子。<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用split命令，-b 4000M 表示设置每个分割包的大小，单位还是可以k</span></span><br><span class="line"><span class="comment">// -d 参数指定生成的分割包后缀为数字的形式</span></span><br><span class="line"><span class="comment">//-a x来设定序列的长度(默认值是2)，这里设定序列的长度为1</span></span><br></pre></td></tr></table></figure></p>
<p>如果要把这一堆已经切块的文件重新接压缩的命令：<code>cat ABC.tar.gz.* | tar -zxv</code>;</p>
<p>5）如果用<code>kill -HUP</code>来重启一个包含守护进程的进程，比如httpd，一条语句搞定：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ps -ef | grep httpd | grep -v grep | awk <span class="string">&#x27;&#123; print $2; &#125;&#x27;</span> | xargs -L <span class="number">1</span> sudo kill -<span class="variable constant_">HUP</span></span><br></pre></td></tr></table></figure></p>
<p>这里面首先用awk获取到httpd的pid进程号，然后把这个进程号传给了xargs，通过<code>-L 1</code>来一次提取一行pid值，然后分批进行<code>kill -HUP</code>;如果想要更改配置而不需停止并重新启动服务，请使用<code>kill -HUP</code>。在对配置文件作必要的更改后，发出该命令以动态更新服务配置。</p>
<p>6）想更多的了解守护进程，参看<code>http://www.cnblogs.com/mickole/p/3188321.html</code>；</p>
<p><img data-src="/images/slamdunk.jpg" alt="paradin"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>logrotate</tag>
      </tags>
  </entry>
  <entry>
    <title>关于HTTP-Alive应该知道的事</title>
    <url>/2018/03/11/%E5%85%B3%E4%BA%8EHTTP-Alive%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B/</url>
    <content><![CDATA[<h2 id="总体概述"><a href="#总体概述" class="headerlink" title="总体概述"></a>总体概述</h2><p>七层协议是一个广为人知的协议，<code>tcp</code>协议是在传输层，<code>http</code>协议是在应用层，也就是说客户端与服务器端先建立<code>tcp</code>连接，然后在<code>tcp</code>连接的基础上传送<code>http</code>报文。</p>
<p><code>http</code>协议是一个<code>请求-应答</code>的模式，也就是当没有启动<code>keep-alive</code>的时候，每一次建立<code>http</code>连接都是<code>现用现建立，用完就断开</code>的工作样式。而如果开启了<code>keep-alive</code>模式的话，客户端和服务器之间<code>http</code>连接就会被保持，不会断开（超过<code>Keep-Alive</code>规定的时间，意外断电等情况除外），当客户端发送另外一个请求时，就使用这条已经建立的连接。</p>
<p><code>Keep-Alive</code>的规定时间在客户端（浏览器里）是如何确定的呢？例如<code>Keep-Alive: timeout=5, max=100</code>，表示这个<code>TCP</code>通道可以保持5秒，<code>max=100</code>表示这个长连接最多接收100次请求就断开。</p>
<p><code>Keep-alive</code>在<code>http 1.1</code>版本里是默认开启的，只有加入<code>Connection: close</code>才会关闭，现在大部分浏览器都是使用<code>http 1.1</code>协议，所以说在客户端已经是默认发起<code>keep-alive</code>的连接请求。但是能否会完成一个完整的<code>keep-alive</code>还要看服务器端的具体配置情况。</p>
<p>在<code>nginx</code>里就直接支持<code>keepalive_timeout</code>指令，其使用0值来停用<code>keep-alive</code>，举例配置如下:<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">location /<span class="variable constant_">XXX</span>/ &#123;   </span><br><span class="line">   	alias /url/<span class="keyword">var</span>/www/html/;   </span><br><span class="line">   	keepalive_timeout  <span class="number">75</span>;  	</span><br><span class="line">   	expires 5m;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用长连接之后，客户端和服务端怎么知道本次传输结束呢？两部分：1. 判断传输数据是否达到了<code>Content-Length</code>指示的大小，这个是最简单的最傻瓜的，普遍应用于静态的图片或者页面；2. 往往动态生成的文件没有<code>Content-Length</code>，它是分块传输<code>（chunked）</code>，这时候怎么办呢？就要根据<code>chunked</code>编码来判断，<code>chunked</code>编码的数据在最后有一个空<code>chunked</code>块，表明本次传输数据结束，这种情况更多应用于动态的页面。</p>
<h2 id="进一步的说chunked"><a href="#进一步的说chunked" class="headerlink" title="进一步的说chunked"></a>进一步的说chunked</h2><p>HTTP请求报文的格式是这样的：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;method&gt; &lt;request-<span class="variable constant_">URL</span>&gt; &lt;version&gt;</span><br><span class="line">&lt;headers&gt;</span><br><span class="line"></span><br><span class="line">&lt;entity-body&gt;</span><br></pre></td></tr></table></figure></p>
<p>其中在请求头的地方有一个叫<code>Content-Length</code>的字段，如果没有这个字段那么就会有叫<code>Transfer-encoding</code>的字段，它用来表示<code>http</code>报文的传输格式，这个字段的取值有很多，但是真正有意义的只有一个—<code>chunked</code>。</p>
<p>如果一个<code>HTTP</code>消息（请求消息或应答消息）的<code>Transfer-Encoding</code>消息头的值为<code>chunked</code>，那么，消息体由数量未定的块组成，并以最后一个大小为0的块为结束。</p>
<p>每一个非空的块都以该块包含数据的字节数（字节数以十六进制表示）开始，跟随一个<code>CRLF</code>（回车及换行），然后是数据本身，最后块<code>CRLF</code>结束。在一些实现中，块大小和<code>CRLF</code>之间填充有白空格（0x20）。</p>
<p>最后一块是单行，由块大小（0）、一些可选的填充白空格、以及<code>CRLF</code>组成。最后一块不再包含任何数据，但是可以发送可选的尾部，包括消息头字段。消息最后以<code>CRLF</code>结尾。</p>
<p>注意1.<code>chunked</code>和<code>multipart</code>两个名词在意义上有类似的地方，不过在<code>HTTP</code>协议当中这两个概念则不是一个类别的。<code>multipart</code>是一种<code>Content-Type</code>，标示<code>HTTP</code>报文内容的类型，而<code>chunked</code>是一种传输格式，标示报头将以何种方式进行传输；</p>
<p>注意2.<code>chunked</code>传输不能事先知道内容的长度，只能靠最后的空<code>chunk</code>块来判断，因此对于下载请求来说，是没有办法实现进度的。在浏览器和下载工具中，偶尔我们也会看到有些文件是看不到下载进度的，即采用<code>chunked</code>方式进行下载；</p>
<p>注意3.<code>chunked</code>的优势在于，服务器端可以边生成内容边发送，无需事先生成全部的内容。<code>HTTP/2</code>不支持<code>Transfer-Encoding: chunked</code>，因为<code>HTTP/2</code>有自己的<code>streaming</code>传输方式。</p>
<h2 id="http-keep-alive与tcp-keep-alive"><a href="#http-keep-alive与tcp-keep-alive" class="headerlink" title="http keep-alive与tcp keep-alive"></a>http keep-alive与tcp keep-alive</h2><p>http的<code>keep-alive</code>与tcp的<code>keep-alive</code>可不是同一回事，意图也不一样。http的<code>keep-alive</code>是为了让tcp活得更久一点，以便在同一个连接上传送多个http，提高<code>socket</code>的效率。而tcp的<code>keep-alive</code>是tcp的一种检测tcp连接状况的保鲜机制。tcp的<code>keep-alive</code>是一个保鲜定时器，支持三个系统内核配置参数：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">echo <span class="number">1800</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/tcp_keepalive_time</span><br><span class="line">echo <span class="number">15</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/tcp_keepalive_intvl</span><br><span class="line">echo <span class="number">5</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/tcp_keepalive_probes</span><br></pre></td></tr></table></figure></p>
<p><code>keepalive</code>是TCP保鲜定时器，当网络两端建立了tcp连接之后，闲置idle（双方没有任何数据流发送往来）了<code>tcp_keepalive_time</code>后，服务器内核就会尝试向客户端发送侦测包，来判断TCP连接状况(有可能客户端崩溃、强制关闭了应用、主机不可达等等)。如果没有收到对方的回答(ack包)，则会在<code>tcp_keepalive_intvl</code>后再次尝试发送侦测包，直到收到对对方的<code>ack</code>,如果一直没有收到对方的<code>ack</code>,一共会尝试<code>tcp_keepalive_probes</code>次，每次的间隔时间在这里分别是<code>15s、30s、45s、60s、75s</code>。如果尝试<code>tcp_keepalive_probe</code>s,依然没有收到对方的ack包，则会丢弃该TCP连接。TCP连接默认闲置时间是2小时，一般设置为30分钟足够了。</p>
<p>也就是说，仅当<code>nginx</code>的<code>keepalive_timeout</code>值设置高于<code>tcp_keepalive_time</code>，并且距此tcp连接传输的最后一个<code>http</code>响应，经过了<code>tcp_keepalive_time</code>时间之后，操作系统才会发送侦测包来决定是否要丢弃这个TCP连接。一般不会出现这种情况，除非你需要这样做。</p>
<h2 id="keep-alive与TIME-WAIT"><a href="#keep-alive与TIME-WAIT" class="headerlink" title="keep-alive与TIME_WAIT"></a>keep-alive与TIME_WAIT</h2><p>使用http的<code>keep-alive</code>，可以减少服务端<code>TIME_WAIT</code>数量(因为由服务端<code>httpd</code>守护进程主动关闭连接)。道理很简单，相较而言，启用<code>keep-alive</code>，建立的<code>tcp</code>连接更少了，自然要被关闭的<code>tcp</code>连接也相应更少了。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>建议在服务器提供Web站点服务时(一个页面除了动态内容，还包含非常多的JS、图片、css文件等)开启<code>keep-alive</code>。在“服务器提供的是一个接口服务，除了动态内容，几乎没有引用任何静态内容”这样的场景，不建议开启<code>keep-alive</code>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.cnblogs.com/skynet/archive/2010/12/11/1903347.html">http://www.cnblogs.com/skynet/archive/2010/12/11/1903347.html</a><br><a href="https://hit-alibaba.github.io/interview/basic/network/HTTP.html">https://hit-alibaba.github.io/interview/basic/network/HTTP.html</a><br><a href="http://51write.github.io/2014/04/09/keepalive/">http://51write.github.io/2014/04/09/keepalive/</a><br><a href="http://www.nowamagic.net/academy/detail/23350305">http://www.nowamagic.net/academy/detail/23350305</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>大牛之路</tag>
        <tag>http协议</tag>
      </tags>
  </entry>
  <entry>
    <title>关于HTTP 2.0应该知道的事</title>
    <url>/2018/03/16/%E5%85%B3%E4%BA%8EHTTP-2%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B/</url>
    <content><![CDATA[<h2 id="HTTP-2-0的优势"><a href="#HTTP-2-0的优势" class="headerlink" title="HTTP 2.0的优势"></a>HTTP 2.0的优势</h2><p>相比<code>HTTP/1.x</code>，<code>HTTP/2</code>在底层传输做了很大的改动和优化：<br>1.每个服务器只用一个连接：<code>HTTP/2</code>对每个服务器只使用一个连接，而不是每个文件一个连接。这样，就省掉了多次建立连接的时间，这个时间对TLS尤其明显，因为TLS连接费时间;<br>2.加速TLS交付：<code>HTTP/2</code>只需一次耗时的TLS握手，并且通过一个连接上的多路利用实现最佳性能。<code>HTTP/2</code>还会压缩首部数据，省掉<code>HTTP/1.x</code>时代所需的一些优化工作，比如拼接文件，从而提高缓存利用率;<br>3.简化Web应用：使用<code>HTTP/2</code>可以让Web开发者省很多事，因为不用再做那些针对<code>HTTP/1.x</code>的优化工作了;<br>4.适合内容混杂的页面：<code>HTTP/2</code>特别适合混合了HTML、CSS、JavaScript、图片和有限多媒体的传统页面。浏览器可以优先安排那些重要的文件请求，让页面的关键部分先出现、快出现，而且根本不会发生“浏览器明明在等关键的CSS和JS，而服务器还在发送黄图”的尴尬局面;<br>5.更安全：通过减少TLS的性能损失，可以让更多应用使用TLS，从而让用户信息更安全。</p>
<h2 id="HTTP-2-0性能增强之二进制分帧"><a href="#HTTP-2-0性能增强之二进制分帧" class="headerlink" title="HTTP 2.0性能增强之二进制分帧"></a>HTTP 2.0性能增强之二进制分帧</h2><p>HTTP的定义大家都知道，叫<code>超文本协议</code>，也就是说<code>http1.x</code>的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多。但是在<code>HTTP/2</code>里这里做了比较重大的改动—<code>二进制分帧</code>，<code>HTTP/2</code>在应用层(HTTP)和传输层(TCP or UDP)之间增加一个二进制分帧层。在这个新增的二进制分帧层里<code>HTTP/2</code>会将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码 ，其中<code>HTTP1.x</code>的首部信息会被封装到<code>Headers</code>帧，而我们的<code>request body</code>则封装到<code>Data</code>帧里面。二进制与之前的文本不同，二进制只认0和1的组合。基于这种考虑<code>http2.0</code>的协议解析决定采用二进制格式，实现方便且健壮。<br><img data-src="/images/http2-1.png" alt="paradin" title="对比一下http1.x和http2的报文格式"></p>
<p><code>HTTP/2</code>的格式定义十分高效且精简。<code>length</code>定义了整个<code>frame</code>的大小，<code>type</code>定义<code>frame</code>的类型（一共10种），<code>flags</code>用<code>bit</code>位定义一些重要的参数，<code>stream id</code>用作流控制，<code>payload</code>就是<code>request</code>的正文，如下图：<br><img data-src="/images/http2-2.png" alt="paradin" title="二进制层是夹在回话层和应用层之间的"></p>
<h2 id="HTTP-2-0性能增强之首部压缩"><a href="#HTTP-2-0性能增强之首部压缩" class="headerlink" title="HTTP 2.0性能增强之首部压缩"></a>HTTP 2.0性能增强之首部压缩</h2><p>虽然<code>HTTP/2</code>引入了二进制分帧的概念，但是试想如果所有的二进制帧都会带上<code>Headers</code>帧，这是多大的数据冗余传送啊。于是<code>HTTP/2</code>针对这个需求又搞出来一个东东—“首部表”。</p>
<p>“首部表”来跟踪和存储之前发送的<code>键-值</code>对，对于相同的数据，不再通过每次请求和响应发送；通信期间几乎不会改变的通用<code>键-值</code>对(用户代理、可接受的媒体类型等等)只需发送一次。事实上,如果请求中不包含首部(例如对同一资源的轮询请求)，那么首部开销就是零字节。此时所有首部都自动使用之前请求发送的首部。如果首部发生变化了，那么只需要发送变化了数据在<code>Headers</code>帧里面，新增或修改的首部帧会被追加到“首部表”。首部表在<code>HTTP/2</code>的连接存续期内始终存在,由客户端和服务器共同渐进地更新。</p>
<h2 id="HTTP-2-0性能增强之TCP请求集中"><a href="#HTTP-2-0性能增强之TCP请求集中" class="headerlink" title="HTTP 2.0性能增强之TCP请求集中"></a>HTTP 2.0性能增强之TCP请求集中</h2><p>TCP的优势是很直白的：面向连接、提供可靠的数据传输服务、流量控制。那么有效地使用TCP连接的方法就是<strong>长时间连接传输大块数据</strong>。于是<code>HTTP/2</code>就尽大化的把这一特点发扬：所有<code>HTTP/2</code>通信都是在一个TCP连接上完成。前面说过，HTTP&#x2F;2把HTTP协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息，并行地在同一个TCP连接上双向交换消息(注意这个“双向交换消息”)。举个例子，请求一个页面<code>https://www.google.com</code>，页面上所有的资源请求都是客户端与服务器上的一条TCP上请求和响应的！</p>
<p>这样“单链接多资源”的方式，使到至上而下的层面都得到了好处：<br>    1.可以减少服务链接压力,内存占用少了,连接吞吐量大了；<br>    2.由于TCP连接减少而使网络拥塞状况得以改观;<br>    3.慢启动时间减少,拥塞和丢包恢复速度更快。</p>
<p>综上所述，“资源合并减少请求”对于<code>HTTP/2</code>是无用的优化手段。</p>
<p>上面的文字说了要注意“双向交换消息”，那么啥是“双向交换消息”？</p>
<p>就是把HTTP消息分解为独立的帧,交错发送,然后在另一端重新组装。专业一点说就是“一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的id将request再归属到各自不同的服务端请求里面”。这是<code>HTTP/2</code>重要的一项增强。事实上,这个机制会在整个Web技术栈中引发一系列连锁反应, 从而带来巨大的性能提升,因为：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">可以并行交错地发送请求,请求之间互不影响;</span><br><span class="line">可以并行交错地发送响应,响应之间互不干扰;</span><br><span class="line">只使用一个连接即可并行发送多个请求和响应;</span><br><span class="line">消除不必要的延迟,从而减少页面加载的时间;</span><br></pre></td></tr></table></figure><br><img data-src="/images/http2-3.png" alt="paradin" title="“域名分区”这种优化手段对于HTTP2.0是无用的，因为资源都是并行交错发送，且没有限制，不需要额外的多域名并行下载"></p>
<h2 id="Keep-Alive与HTTP-2集中TCP的区别"><a href="#Keep-Alive与HTTP-2集中TCP的区别" class="headerlink" title="Keep Alive与HTTP&#x2F;2集中TCP的区别"></a>Keep Alive与HTTP&#x2F;2集中TCP的区别</h2><p><code>HTTP1.1</code>的<code>keep-alive</code>是为了尽可能使用持久链接，以消除TCP握手和慢启动。但是<code>keep-alive</code>使用多了同样会给服务端带来大量的性能压力，并且对于单个文件被不断请求的服务(例如图片存放网站)，<code>keep-alive</code>可能会极大的影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。</p>
<p>举个例子：下载<code>a.js</code>创建一个TCP链接，就会需要TCP握手和慢启动而产生了约300ms下载延迟。当<code>a.js</code>下载完成后这时候<code>b.js</code>也要下载，如果<code>a.js</code>创建TCP链接是<code>keep-alive</code>的，<code>b.js</code>就可以复用其TCP而不需要重新TCP握手和慢启动（没有了那300ms）。</p>
<p>而<code>HTTP/2</code>是使用一个TCP链接的，其慢启动和握手只在第一次链接的时候产生一次，其后面链接都是持久化的。并且一个TCP下载多个资源，可以将TCP吞吐量最大化来提升性能，这方面可以参考一下TCP的拥塞预防及控制。<br><img data-src="/images/http2-4.png" alt="paradin"></p>
<p><img data-src="/images/http2-5.png" alt="paradin"></p>
<h2 id="NGINX上如何配制HTTP-2"><a href="#NGINX上如何配制HTTP-2" class="headerlink" title="NGINX上如何配制HTTP&#x2F;2"></a>NGINX上如何配制HTTP&#x2F;2</h2><p>上面说了这么多HTTP&#x2F;2这个好那个好，是未来的趋势blablabla，但是要实现<code>HTTP/2</code>，还是需要“客户端和服务器都开启了HTTP&#x2F;2”这一个首要条件。不过现在客户端（浏览器）大多数都已经支持<code>HTTP/2</code>，那么主要就是在服务器端如何开启<code>HTTP/2</code>，nginx的配置方法请见：<a href="https://rorschachchan.github.io/2018/03/16/%E4%BD%BF%E7%94%A8nginx%E5%BC%80%E5%90%AFhttp2%E5%8D%8F%E8%AE%AE/">https://rorschachchan.github.io/2018/03/16/使用nginx开启http2协议/</a> 。</p>
<p>按照这样的操作下来，服务器就开了<code>HTTP/2</code>协议，那些支持<code>HTTP/2</code>的浏览器在请求页面的时候就会走<code>HTTP/2</code>模式，而不支持HTTP&#x2F;2的浏览器会议就按照<code>HTTP/1.X</code>的方式发送请求，如图：<br><img data-src="/images/http2-7.png" alt="paradin"></p>
<p><img data-src="/images/http2-8.png" alt="paradin" title="如果nginx是一个代理服务器的话，就是这图的传输方式"></p>
<p>支持<code>HTTP/2</code>的Web Server基本都支持<code>HTTP/1.1</code>。这样，即使浏览器不支持<code>HTTP/2</code>，双方也可以协商出可用的<code>HTTP</code>版本，没有兼容性问题。<br><img data-src="/images/http2-6.png" alt="paradin" title="使用HTTP&#x2F;2其实还是服务器说的算"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.alloyteam.com/2015/03/http2-0-di-qi-miao-ri-chang/comment-page-1/#comments">http://www.alloyteam.com/2015/03/http2-0-di-qi-miao-ri-chang/comment-page-1/#comments</a><br><a href="https://segmentfault.com/a/1190000007637735">https://segmentfault.com/a/1190000007637735</a><br><a href="https://github.com/creeperyang/blog/issues/23">https://github.com/creeperyang/blog/issues/23</a><br><a href="https://www.nginx.com/blog/nginx-1-9-5/">https://www.nginx.com/blog/nginx-1-9-5/</a><br><a href="https://ye11ow.gitbooks.io/http2-explained/content/part6.html">https://ye11ow.gitbooks.io/http2-explained/content/part6.html</a></p>
]]></content>
      <categories>
        <category>大牛之路</category>
      </categories>
      <tags>
        <tag>http协议</tag>
      </tags>
  </entry>
  <entry>
    <title>再见，魔兽世界</title>
    <url>/2018/02/01/%E5%86%8D%E8%A7%81%EF%BC%8C%E9%AD%94%E5%85%BD%E4%B8%96%E7%95%8C/</url>
    <content><![CDATA[<p>这张月卡马上就要用完了，我想我的《魔兽世界》生涯也要到头了。</p>
<h2 id="地球时代"><a href="#地球时代" class="headerlink" title="地球时代"></a>地球时代</h2><p>我是从大学的时候就开始接触《魔兽世界》，当时是在同寝的xur同学的推荐下，注册账号买了CDKey，然后跟着他在六区黑翼之巢创建了角色，那是一个留着武士头和山羊胡的暗夜精灵德鲁伊，起了个带有劲舞团性质的ID叫“删除过去”。记得德鲁伊刚出生是人形态，泰达希尔里背着一个木棒棒，靠着“愤怒”这个技能打人。于是乎，我就搓出了一个又一个原谅色的冲击波，波遍了泰达希尔的每一个角落，波倒了一个又一个萨特和野熊。当时我作为一个萌新，什么都不懂，后来在一个另外的德鲁伊的帮助下，开始做任务升级，顺便粗略的了解了魔兽最基本的操作。这个德鲁伊是我在游戏里认识的第一个朋友，是一个萌妹子，ID叫什么我忘了，不过后来她游戏上的很少了，依稀记得后来某一个半夜我在西瘟疫之地变成小豹子一个一个挠亡灵的时候，她上过一次线，等级好像是20~30级的样子，我俩说了一会话，具体说的是什么我已经记不清了，那就是我俩最后一次说话。</p>
<p>从泰达希尔港出来，我就开始了艾泽拉斯的冒险之路：去月光林地学变熊变豹子，拖尸到血色修道院，打过那么一两次诺莫瑞根，在荆棘谷的森林里穿梭，长期蹲在塔纳利斯刷“XD求组祖尔法拉克”。</p>
<p>当时寝室里没有电脑装wow，总去学府三和学府四那两条街的网吧玩，就这样我成了被盗号的重灾户。记得最过分的那次上号发现角色干脆消失了，还有一回上号发现，角色被扒的就剩下一个裤衩、一个披风和一个狼头样子的皮甲头，还别说，这造型跑出去比较拉风。后来九城推出了密保卡，就是充值卡后面的8x8的数字卡，虽然有一小段时间遏制了盗号，不过缺点就是要随身带着密保卡。在网吧开机坐下了发现没带密保卡，又跑回寝室取卡的事情，我当初可没少干。</p>
<p>这个德鲁伊就这样摸爬滚打到了六十级满级的时候，开始刷三大本（前后斯坦索姆，通灵学院，黑石塔上层），那时候的黑下是一个冷门本，黑石深渊更不要说了，打一次就花费了几乎一下午的时光。那段反复的刷斯坦索姆和通灵学院的日子给银色十字军捐过不少亡灵印记。后来加入了工会跟工会开始打熔火之心，记得公会团长叫火枪队长，一个男人类战士，其他的一团的队员我现在还能记住名字的有：京乐春水（德鲁伊）、Hater（女人类牧师），魂之血杀（暗夜大元帅战士）。那时候的MC已经没有DOT限制了，但是还要做水元素任务，带着圣水去灭火。MC通了后，公会团开始打黑翼之巢，我记得当时的BWL老1还有BUG，远程和治疗可以跳在窗户上。到了老2就卡的死去活来，好不容易过了老2，接下来的三个就一片通途。然后又花了一个晚上打掉了克洛玛古斯。我那时候奈法利安和克洛玛古斯打得不多，仅有的几次击杀也没有掉落怒风胸和怒风肩，这成了我60级的一个怨念。</p>
<p>那时候我们工会不怎么组织祖尔格拉布，所以祖尔格拉布成了我接触的第一个G团，惊讶原来团队副本还可以这么玩。当时德鲁伊可是一个稀缺职业，我就开始去打工兼消费挣俩小钱，用那点G去买拍爪子的材料。在祖格G团认识了同大学的一个哥们，叫阿尔萨斯之心，是一个女人类圣骑士，他那个时候就有祖格龙了，但是没玩太久，60级没完事就把号给卖了…</p>
<p>工会后来打BWL的时候，安其拉版本已经开始了。G团也开始做安其拉废墟的生意，我也在其中一次无疤者奥斯利安的身上得到了废墟法杖，换掉了之前埃克索图斯的挖掘锤，为了这个废墟法杖我还卖了一张卡，那时候一张卡是300金币，那次好像是我唯一的一次卖卡。说到卖卡我想起来，我人生的第一只千金虎是一个暗夜盗贼赞助的，ID好像叫小什么哥，当时的金币真的很值钱，非常非常感谢他。</p>
<p>我在地球时代RAID的最高纪录就是安其拉神殿到公主、NAXX打了蜘蛛区前二、DK区到了老1、憎恶区的帕奇维克好像是没过，反正就是一个很一般的进度啦。然后公会团就有了一些动荡，我个人总觉得德鲁伊打人不爽，还是拿起大刀砍人过瘾，于是就开始了玩战士小号的生涯，ID叫燕小鱼。战士满级后不久就开了“远征前夕”，也就是那个全民刷战场换大元帅的时代。我那时候也在YY里加入了联盟军校，开始了没日没夜刷大奥的日子，先换了猪头锤，又换了雷矛羊，最后拿着一堆牌子去换一身漂亮的大元帅，直到现在我的YY名称依旧是以“联盟军校”开头。</p>
<p>我玩战士的时候还认识了一个男矮人牧师，叫赤红丹朱，这个哥们手法很骚，以前是玩部落的，记得有一次我俩要去荒芜之地，在莫高雷的高原上，他说这里曾经是他玩部落开始的地方，然后看着脚下这片大草原心潮澎湃，我俩一起战斗过不少副本，从斯坦索姆到祖尔格拉布，他没有坚持到70级就不玩了，账号也给我了…我后来去他的新浪博客看过，背景音乐是王若琳的《有你的快乐》，后来的某一天，发现他的新浪博客内容就被全删光了。</p>
<h2 id="燃烧的远征"><a href="#燃烧的远征" class="headerlink" title="燃烧的远征"></a>燃烧的远征</h2><p>记得那是7月份，大二刚开学没多久，我就穿过黑暗之门开始了燃烧的远征。那时候我先升的是战士，在地狱火堡垒里面拿大砍刀砍来砍去，在纳格兰的草地上跑来跑去，在影月谷的火山口上飞来飞去。七十级的raid就是先从卡拉赞开始，当时我的小战士就当主t，当时跟的团团长ID是叫小豆宝宝，一个侏儒术士。那时候卡拉赞的bug很多，埃兰可以卡门，马克扎尔王子也可以卡地点。我个人对于卡拉赞比较有印象的是虚空龙，那是这个十人小团队的一个比较有成就感的boss。</p>
<p>往后就是打格鲁尔，那个时候我记得隔壁寝室的老朱已经开始练他的女暗夜盗贼了，那个时候我俩开始比较频繁的厮混在一起，肩并肩的不上课跑去网吧打魔兽，我印象最深的一次就是他当时为了刷一个午夜护腿在沙塔斯找了一个猎人，但是这个猎人不是很靠谱，在奴里围栏一个人忙乎从早上八点到晚上八点，结果还没出，给老朱气得牙痒痒。</p>
<p>TBC的时候，就有了日常任务的概念，每天早上要做奥格瑞拉和虚空龙任务，后来又有了奎岛日常，日复一日的刷声望。玛瑟里顿这个副本公会团当时没有正经打，直接就开始打风暴要塞，当时打掉了凤凰、奥术师和机器人。而毒蛇神殿我跟公会打得不多，记得有打过瞎子外加鱼斯拉。这个时候，邪神禁地祖阿曼上线了，开始了有事没事冲箱子的新征程。我印象里整个70级就是一个很多bug的版本，祖阿曼体现的尤为明显，里面BUG有术士副本拉人以及祖尔金跳柱子。但是即使这样我也只冲成功过一次四箱，那一次是t6级别队伍带队，完全没用bug。除了那一次剩下的基本就是两箱，三箱屈指可数。</p>
<p>然后我现实的一个的哥们由于学业的问题不能继续跟团队RAID无奈只能把账号暂给我打理，于是我改玩了他的暗夜女精灵牧师，ID叫外面下雨了（后面简称下雨）。我开始跟《荣耀》公会活动，会长就是鼎鼎有名的震撼。荣耀公会最早是桑德兰服务器的，后来由于想当联通区的第一工会，就集体转服到泰拉尔。当时我也是第一次接触牧师，完全是抱大腿的姿势跟他们一团打掉阿克和伊利丹。他们打阿克因为要录视频所以是不用bug的，真的要考验跑火的功力。第一次打伊利丹我印象很深，当时寝室里有电脑了，由于很多人当时进度很慢，所以打伊利丹的时候，全楼道的wower都来看，然后啧啧惊叹。</p>
<p>跟着震撼一边打进度团也一边打公会的G团，记得当时t5一套是五万金，t6一套是十五万金。再加上卖武器饰品，一趟下来也分到不少，而且还能直接跟老板换卡，据说公会当时用的付费ts语音也是用老板的钱买的。</p>
<p>那时候打进度团主要就是开荒太阳井，我用那个牧师号拿了全服第一个t6鞋，首down双子的战报也上了nga，地址在：<a href="http://nga.178.com/read.php?tid=1644774">http://nga.178.com/read.php?tid=1644774</a> ，视频也被传上了优酷，但是现在那个视频找不到了，不过记得BGM还是很好听的。当时进度团活动时间是晚上七点到早上五点，真的很累人，最后击杀基尔加丹我并没有参与。但是震撼的指挥和语音口头禅给我留下了很深的记忆，他的确是一个很赞的指挥。</p>
<p>燃烧的远征也是我寝室山哥沉迷魔兽并且活跃的日子，当时山哥投奔了部落玩德鲁伊。我记得他们团第一次过血沸很惊险，当时血沸还有大约5%的血，T都躺光了，就在BOSS准备大肆屠杀的时候，结果血沸那时候触发了点名，好巧不巧的点名了一个盗贼，那贼开着闪避上去顶掉了最后5%的血。其实FD就是这样，需要实力的同时也需要那么一点运气。</p>
<h2 id="巫妖王之怒"><a href="#巫妖王之怒" class="headerlink" title="巫妖王之怒"></a>巫妖王之怒</h2><p>当时由于大陆魔兽推迟开巫妖王，那时候我跟老朱、涛哥、永森、老刘、阿俊、小勇几个寝室的哥们还有那个下雨一起转战去了台服，改玩部落。当时我是防骑，老朱改玩牧师，涛哥是法师，老刘是盗贼兼指挥，小勇是术士、阿俊是德鲁伊、永森是萨满，下雨依旧是牧师，不过老朱主要玩的是神牧，下雨主要是暗牧，必要的时候会切奶。</p>
<p>老朱的魔兽之路开始于60级，当时他第一个职业是法师，最开始的时候他跟xur打赌会尽快的把等级练到骑小马的等级，话说老朱练号的速度是很快的，他也是我们几个人里玩职业好象最多的。从法师到萨满，然后还有盗贼，但是直到这次玩上了牧师，他终于找到了灵魂的归属，发现原来牧师才是他的本命。</p>
<p>除了老朱我多说说老刘，老刘原名刘义超，是我们年级的一个牛人，很瘦，戴个眼镜，走路有点发飘。用他话说从小身体就不好，所以不是很喜欢运动，除了打魔兽打dota就是看漫画再不然就是用psp打麻将，老刘的经典语录就是“对于我来说，每一把DOTA都是一把新的DOTA”。老刘是一个很聪明的人，打游戏思路很清晰，很少反重复的错误。他为了游戏也肯砸钱，那时候都是老刘给我们搞代理。老刘巅峰的时候在第七天堂打主力牧师，我也亲眼见过他那时候打便当二十五人英雄十字军，后来由于要带我们几个就放弃了第七天堂，转来跟我们一起组团队。当时我们几个人一边小团队打十人icc，一边也跟个工会活动。 不过后来老刘觉得公会团打得不爽，揭竿而起，自立门户开起了25人H ICC金团。每周四，都会看到一个叫德意忘形的德鲁伊在达拉然喊人刷屏，喊满了就向冰冠堡垒浩浩荡荡的出发，由老刘带队指挥，当然我们也会偷偷摸摸的黑下几件装备和一点金。老刘指挥虽然不如震撼激情，但是思路很有条理，基本上战斗力不算很差的团一个下午就打掉2到3个区。当时我已经大四下半学期了，由于有驾校考试，所以当时老刘的金团我参与了也就一半，不过在金团里我得到了大盾冰冠冰川之墙，当时好像是花了4万金。最可惜的一次就是他们有一次开出了英雄的异物逐除，卖了17万金，按当时的物价换算是二千多块人民币!那次的金团真是赚翻了。</p>
<p>我们十人团的进度是“十人十字军试炼最高差两次就大十字军”、“ICC普通全通”、“h我记得没过冰龙”，因为不久就要毕业了，就没有很全力的去开荒。毕业后从此我们几个战友就四散天涯：老刘回齐齐哈尔，永森和阿俊回佳木斯，涛哥留在哈尔滨，我、小勇和老朱回大庆上班，而下雨就一直在国外，直到现在也没有回来。</p>
<p>现在除了涛哥和老朱，我还有联系之外，其他人我已经联系不上了，也不知道他们过得好不好。</p>
<p>魔兽的八十级之前的版本可以说陪伴了我在大学的大多数时光，那也是我魔兽生涯唯一玩部落的时光。</p>
<h2 id="大地的裂变"><a href="#大地的裂变" class="headerlink" title="大地的裂变"></a>大地的裂变</h2><p>到了八十五级我又回归国服了，重返联盟。由于大学里各位同学都开始了新的生活，我也开始直到现在的魔兽独行侠之路，独自练级独自打战场。 也从此之后，我就再也没有正经的跟过公会团，要么是打随机本看看剧情，要么就是打金团。其实我对八十五级的印象不多了。不过要说一下，八十五刚开始的5h真的很难，经常小怪的治疗一个打断不到就满血了，记得那时候打一个影牙城堡就累的死去活来。硬要说大裂变里印象比较深的，也就是打托尔巴拉德和打巨龙之魂，比如很多战士一起开剑刃风暴一起命令怒吼，场面非常壮观。那个时候我也把战士的种族转成了狼人，也背上了触手剑爬在地上跑来跑去。最后没事干，就趁此机会又练起来一个牧师和一个女人类圣骑士，开始了我的圣光追寻之旅。</p>
<h2 id="熊猫人之谜"><a href="#熊猫人之谜" class="headerlink" title="熊猫人之谜"></a>熊猫人之谜</h2><p>到了九十级，朋友也多了起来。主要是跟单位里的磊哥、建哥、亮哥和迪哥一起在奥拉基尔服务器玩。磊哥原先是亡灵贼，后来投奔了联盟转了女人类，但是一直都纠结女人类的动作不如男亡灵飘逸。磊哥自封外号“阿拉希小王子”，长期在农场神出鬼没，也善于在战歌抗旗。迪哥是男德莱尼萨满，满地插柱子，他是一个有个性的男人，死活不去网吧，坚持就在家里玩。不过迪哥玩魔兽的时间并不长，也就几个月的时间他就投奔去三国杀和单机游戏了。健哥是一个猎人，单刷无敌，他那时候是我们几个里最有G的，输出也最为残暴，不过后来他由于工作原因也忍痛割爱了。亮哥是血DK，号称“通信公司第一DK”，不过我们四个很少玩在一起，毕竟上线时间其实是错开的。</p>
<p>熊猫人的本我印象比较深的就是“攻打奥格瑞玛”，至于之前的恐惧之心、永春台神马的我压根就没参与过。当时我的小牧师也算练的不错了，主要得益于我下班没事经常混迹在NGA看帖子，再加上那个版本对戒律牧也特别的友好，偶尔在金团也能拿到治疗第一的补助。而磊哥一直想要箱子BOSS的马刀，最后他也算圆梦了。至于建哥一直眼馋的火鹰，好像一直都是没有达成。</p>
<p>这里我要感谢磊哥，当时我俩在祖尔格拉布翻新之前去刷过祖格虎，结果出虎的时候，磊哥高风亮节让给我了，满足了我开上“红色法拉利”的梦想。</p>
<h2 id="德拉诺之王"><a href="#德拉诺之王" class="headerlink" title="德拉诺之王"></a>德拉诺之王</h2><p>一百级给我的游戏感觉就是高开低走，尤其是要塞，从最开始新鲜成了后期的累赘。虽然它给了我很多战火装备，但是也让我越来越少出去。整个德拉诺之王我最喜欢的副本就是黑石铸造厂，很有六十级副本的味道，容错率很低。那个时候也认识了以骄傲纹身为首的几个朋友，也打了金团攒了不少钱，这些钱后来也都被我换成了点卡。</p>
<p>至于地狱火堡垒这个副本我印象不多，翻来覆去就打了两三遍h，还都是跟G团，最后过了h的阿克蒙德，m难度我压根没尝试，后来由于公司里各个朋友们由于现实各种情况AFK，我也开始改玩单机游戏，上号就是刷刷阿什兰和四本刷金，消磨时间休闲娱乐。</p>
<h2 id="军团再临"><a href="#军团再临" class="headerlink" title="军团再临"></a>军团再临</h2><p>到了一百一十级，几乎整个一百级都没玩的老朱重返魔兽，一口气练了牧师、死骑和恶魔猎手三个职业，我俩也配合打了几个高层大秘境，没有老朱的日子就是我自己慢慢肝神器，每周争取打一次低保，再混一次世界BOSS。也就是这张点卡玩完，我觉得魔兽已经对于我来说没有什么留恋的了，该体验的我差不多都体验过了，没体验到了我也不在乎了。我把牧师停在暴风大教堂，把战士停在暴风要塞，把圣骑士停在激流堡，下线。</p>
<p>至此，我整个魔兽的生涯就算总结完了。</p>
<h2 id="PVP有关"><a href="#PVP有关" class="headerlink" title="PVP有关"></a>PVP有关</h2><p>地球时代的野德不算很强，除了战歌抗旗好像就是补刀了。那时候我看过一个叫dazeroth的暗夜德鲁伊Unstoppable系列视频，觉得很吊，他的视频不算很多，但是打得很棒，然后再看德鲁伊就是一个中国风很浓的暗夜德鲁伊视频，但是我忘了他的名字了。改玩了战士之后，就看Swifty的视频和苹果牛的视频，看直播就看太极龙。牧师的话，看Hydra是最多的。</p>
<p>我个人认为PVP是魔兽的一个重要的玩法，不过这种玩法随着玩家属性暴涨而变得不再公平（不过有几个乱斗还是挺好玩的）。我竞技场打得不算多，从70年代组织55战队去每周去混10场到现在，加起来不超过200场的JJC实战经验。不过战场混得经验丰富，打一些战场也有自己的心得，比如征服之岛要上来抢车间，大奥如果速推不成功就要抢冰雪墓地耐心打平推，打战歌中场压制住了等于赢了8成，风暴之眼先抢墓地再抢骑，控制了地盘后第一时间去墓地堵人等等等等。但是战场毕竟各位玩家PK水平参差不齐，打战场其实更多就是一个图个乐。</p>
<p>至于搏击俱乐部，我没玩太多，不过金牌挑战我还是很喜欢的。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>魔兽世界陪伴了我12年的时光，现在回首来看，我个人最喜欢的是WLK，因为那个版本装备比较好看，其次相对来说各个职业的能力都比较平均，最重要的就是身边有一堆战友并肩作战；其次就是TBC，他在一定程度上弥补了很多60级的缺陷，而且极大地提升了惩戒骑、野德、元素萨等混合职业的存在感，不过TBC的BUG实在太多（我重复几次了？），光一个阿克我就见识过不下4种BUG打法，这一点是TBC的败笔；再其次就是90级和地球时代；大灾变和军团再临他们俩并列再后面一点。</p>
<p>魔兽我觉得在网络游戏里是一个里程碑式的作品，我印象里是它虽然不是“副本”的发明者，但是是它把“副本”这个概念发扬光大的。同时它也将插件的重要性提升了起来，有插件的魔兽跟没有插件的魔兽简直就是两个游戏，难度上也就有很大的差别。它同时也发明出来“每日任务”这个设定来增加用户的粘性度。不过它后期由于玩家的流失，也开始逐渐便当化，很多新人在组队的时候就要面临那些一味追求效率的老玩家的PUA，可见太过追求效率其实会让人失去很多乐趣。</p>
<p>我爱魔兽，他是我的另一个世界，因为我觉得在现实世界里能做的事情，在魔兽世界能做的更多。不可否认，我曾经在魔兽世界上投入了大量的时间，这耽误了我很多现实中的事儿，不过我还是认可它给我带来了不少的快乐。我还记得在06年的路边书摊会买魔兽世界带副本地图和掉落的攻略的那个宅男；我也记得当初那个小德鲁伊在灰谷，一边看着新浪魔兽任务详解，一边在地图上费劲的查找线索；我也记得当初圣骑士到了查索拉盆地的时候，被那种仙剑风的音乐陶醉；我也记得在阿什兰和奥特兰克山谷，战士那一身部落血的豪爽。但是一切缘分都有到头的时候（或许我将来会有机会到网易的魔兽世界部门上班，不过这个暂且不提），虽然我不能亲眼看见联盟一统艾泽拉斯，但是我还是要说，谢谢暴雪做的这款精良的游戏，感谢你陪我走过的这12年，谢谢跟我并肩作战过的战友，没有你们，我也无法享受这段丰富而美好的时光。</p>
<p>最后，我要用《军团再临》里面伊利丹的那个口信内容作为我整个魔兽世界生涯的结尾：</p>
<blockquote>
<p>我留下的水晶里其实有三条口信</p>
</blockquote>
<blockquote>
<p>最后一条是给你的，勇士</p>
</blockquote>
<blockquote>
<p>你证明了你对艾泽拉斯的忠诚</p>
</blockquote>
<blockquote>
<p>你的奉献和牺牲都足以与我媲美</p>
</blockquote>
<blockquote>
<p>但你还得付出许多，更多!</p>
</blockquote>
<blockquote>
<p>此刻敌人正在集结，阴云正在汇聚</p>
</blockquote>
<blockquote>
<p>从今天起，守护我们的世界和亲人的重任</p>
</blockquote>
<blockquote>
<p>就交给你了</p>
</blockquote>
<p>再见了，那些一路陪伴我的NPC们，我要离开你们了，去开始新的征程。<br><img data-src="/images/wowsq.jpg" alt="paradin" title="See you..."></p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>魔兽世界</tag>
      </tags>
  </entry>
  <entry>
    <title>冬奥的感觉</title>
    <url>/2022/02/19/%E5%86%AC%E5%A5%A5%E7%9A%84%E6%84%9F%E8%A7%89/</url>
    <content><![CDATA[<h2 id="东三省发展"><a href="#东三省发展" class="headerlink" title="东三省发展"></a>东三省发展</h2><p>这次成功举办了冬奥会，也让北京成为了双奥之城。而且在宣传里也说了要让三亿人喜欢上冰雪运动。王濛在咪咕的短道速滑解说的时候，却说了这样一个观点：“其他国家举办冬奥会或者世界杯分站都是在一些相对的二线城市：盐湖城、平昌、索契、温哥华、都灵、长野，这些城市的规模跟北京肯定不是一个级别。只有我们的二线城市都能普及冰雪运动的基础措施，那么三亿人才会真实的感受到冰雪运动”。其实说的有道理，毕竟下一届意大利的科尔蒂纳丹佩佐也是一个很多人没听说过的名字。</p>
<p>那么为什么冬季奥运会在发达国家都不在大城市里办？</p>
<p>首先大城市，比如罗马、纽约、伦敦、东京地价很贵，而且发展已经很成熟了。没有更多的地方专门搞像“首钢大滑梯”那种，而且他们在二线城市就已经具备冰场场地的硬件条件了。不过国外这种毕竟是二线城市，机场、奥运村以及交通情况肯定不会像北京那么豪华，不能让外国运动员那么的舒服，据说北京还特意准备了冬奥专线，马路上如果其他车辆占道了就罚200块钱。<br><img data-src="/images/%E5%86%AC%E5%A5%A5%E4%B8%93%E7%BA%BF.PNG" title="新闻出处：http:&#x2F;&#x2F;bj.news.cn&#x2F;2022-01&#x2F;15&#x2F;c_1128264674.htm"></p>
<p>我们东三省最近经济疲软，大量年轻人外流，养老金都岌岌可危，要举办这种国际级别赛事更是难上加难。今年张家口降水量一般，为了冬奥，每天都要大量的人造雪，而恰恰今年哈尔滨的降雪量是很丰富的，可惜了这样的天气条件都不能帮助哈尔滨获得一次主办权。话说亚冬会哈尔滨到是举办过，不过那是遥远的1996年的事儿了，当时也办的很费财力。那个吉祥物豆豆不像冰墩墩，它没火起来，有点大头儿子的感觉。</p>
<p>最后说一下，本次北京冬奥会，很多西方国家都是“国家抵制，远动员参加”。但是韩国派来了国会议长朴炳锡来参加了开幕式，毕竟平昌奥运会的时候，我们也派了韩正去现场。这也算是礼尚往来了。</p>
<p>普京来北京可以说让中国国民欢心鼓舞，这哥们第二天就签了字然后看了表演，没吃国宴就走了。话说他不用隔离的么？</p>
<h2 id="谷爱凌"><a href="#谷爱凌" class="headerlink" title="谷爱凌"></a>谷爱凌</h2><p>谷爱凌无疑是今年东奥最火的那个崽，比起国足那些规划，谷爱凌更讨网民们的欢心。她的身世、发言和场外新闻无疑每次都是场外的流量担当。据说谷爱凌代言的滑雪板在淘宝3000多一个，雪上运动果然都是贵族运动。</p>
<p>别的东西不好说，但是有一件事我知道，人为的选择国籍，肯定是从自身利益考虑的。那些高尚的人设就算了吧，糊弄小孩么？</p>
<h2 id="中国记者与中国故事"><a href="#中国记者与中国故事" class="headerlink" title="中国记者与中国故事"></a>中国记者与中国故事</h2><p>在东奥会有一个事儿还蛮有意思的，就是一个外国记者吐槽中国记者在奥委会的记者招待会上的任务就是“和稀泥”，因为俄罗斯选手瓦利耶娃涉入了禁药风波，所以在每次记者招待会上，外国记者的提问焦点就是“禁药”、“处罚”、“争议”、“药怎么发现的？”、“为什么现在会发现？”等等问题，而这些问题都让新闻发言人很难堪。但是往往此时就会有中国记者举手提问，中国记者问的问题是“本次冬奥会屡屡打破世界记录和奥运记录，您觉得是不是主要是北京的场地比较好？”“本次冬奥会奥运健儿表现突出，是不是因为北京奥组会的后勤做的很到位？”</p>
<p>这种基本问出来就知道答案的问题，自然让新闻发言官轻松作答，而且也让中国媒体记者很容易的写出稿子：“北京奥运村一天消耗了70多只烤鸭和100多斤饺子”,“奥委会官员对北京奥组会后勤点赞”，这些稿子里的“豆包妹”、“饺子哥”当然会出现在微博热搜里，激起了无数网民的自豪，同时也招来了外国记者无情的嘘声。</p>
<p>记者不去揭露制度问题，不去跟进问题，只是一味的赞美和唱赞歌，这种行为叫“宣传”。当然说中国记者不揭露问题也太片面了，至少他们可以从外国记者的问题里，摘抄出来结果让国内网民看到外国的问题…</p>
<p>话说如果想了解中国的事儿，每天去外交部网站看华春莹他们的记者会实录就好了，也有不少我们中国记者“精彩提问”的瞬间。</p>
<h2 id="热带国家的冬奥精神"><a href="#热带国家的冬奥精神" class="headerlink" title="热带国家的冬奥精神"></a>热带国家的冬奥精神</h2><p>今年的开幕式上，中国观众看到了很多热带国家—巴西、墨西哥、沙特、牙买加、泰国、澳大利亚等等。当然这些一个两个的国家很多都是参加高山滑雪，不由得让人觉得这个“高山滑雪”是不是一个混子项目，啥人都能上去走一圈。</p>
<p>其实看完了开幕式，我晚上又看了那部迪士尼的电影《冰上轻驰》，也是几个牙买加人参加冬奥雪车比赛的励志故事。</p>
<p>其实大量的国外冬奥运动员他们平时更多的是参与健身房训练，以及相关的夏季项目训练，比如短道速滑的人也会玩旱冰，只不过达不到世界冠军的水平，但是可以帮助他们维持状态。然后在奥运会即将开始的4个月左右开始带雪环境的集训，然后争取到奥运会资格。对于国外远动员，非体制内的他们，很多都是“无雪模拟、有雪突击”的训练方式，这个跟我们的体制运动员其实也差不多。但是论环境和场外物质条件的支持，我们体制内冰上运动员可强他们不止一点半点。</p>
<p>国外很多国家真的是体育大国，项目玩的很混杂。我记得以前看美国队踢足球，解说就说美国的足球不纯正，很多少年都是玩橄榄球，棒球，皮划艇啥的，足球也是他们一个爱好之一，这些混杂的运动锻炼了协调性，也导致他们基本功并不好。不过运动嘛，身体强健之余，获得物质奖励才是最重要的，而且每次奥运冠军大肆宣传各种物质奖励也是常见镜头。但是相比较歌星影星小鲜肉，给这些辛苦训练的奥运健儿物质奖励还是值得！</p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>体育</tag>
        <tag>奥运会</tag>
      </tags>
  </entry>
  <entry>
    <title>写在世界杯小组赛第三轮之前</title>
    <url>/2022/11/28/%E5%86%99%E5%9C%A8%E4%B8%96%E7%95%8C%E6%9D%AF%E5%B0%8F%E7%BB%84%E8%B5%9B%E7%AC%AC%E4%B8%89%E8%BD%AE%E4%B9%8B%E5%89%8D/</url>
    <content><![CDATA[<h2 id="世界杯的意义"><a href="#世界杯的意义" class="headerlink" title="世界杯的意义"></a>世界杯的意义</h2><p>世界杯是每四年一次的球迷和非球迷的狂欢，这么有话题性的东西，“外资大量外逃”但是还要挣钱的中国企业还在努力，这届世界杯也是一个“除了中国队没去，其他都去了”的局面。今年国内依旧严控疫情，而卡塔尔的赛场里人山人海不见口罩，这无疑对国内观众是一个刺激。正因如此，今年国内对世界杯的宣传也下降了一个温度，据说国内的信号要掐掉所有球迷的镜头了，减少这方面的刺激。但是动态清零3年了，每年的冬天都是疫情高峰，这一点没有任何进步，搞得世界杯在户外大屏上不得不也下降了一个温度。</p>
<p>世界杯的主题歌也逐渐抖音化，在歌词展现团结这一点没变的基础上，以前是力量雄性，或者展现神圣信仰，而现在是电子洗脑韵律为主。这比较符合当下年轻人碎片化快餐化的接受心态。但是这种歌曲能有几个流传下来就不晓得了。</p>
<p><img data-src="/images/%E6%8B%89%E4%BC%8A%E5%8D%9C.png" title="吉祥物拉伊卜还是挺可爱的"></p>
<p>本届世界杯还有不少的场外风波，比如人权问题和彩虹袖标问题。今年卡塔尔世界杯，早在伊蒂哈德集团收购曼城那一刻就开始布局，为时间展现强大的财力和管理实力。不过由于多哈需要短时间内建立大量符合FIFA标准的体育场，有不少的人权问题暴露，引来了人权组织的一阵声讨。但是财大气粗的卡塔尔人貌似都用钱抚恤解决了，算是平息了一些风波。而欧洲球队的彩虹袖标之所以遭到了东道主卡塔尔人的反对，这就涉及到了文化的差异上。欧洲人有他们的一套文化理念，他们认为应该把自己的理念传递给其他地区，当然以现在开放程度来看同性恋不应该是罪过，但是在保守的卡塔尔却不能接受这一点，于是金主要挟FIFA，FIFA要挟欧洲球队让他们放弃彩虹袖标。其实就是东道主花了两几千多亿来让欧洲球队暂时在这个问题闭嘴，欧洲球队也不得不暂时就范。可见谁有钱谁是老大，把金主爸爸惹毛了，FIFA还是不好办的。毕竟现在的世界杯也不挣钱了，能有这么大气的金主爸爸肯办已经很不错了，双方各取所需，所以欧洲球队先“为五斗米折腰”一下。</p>
<p>世界杯目前已经出了不少的冷门比赛，可见杯赛、尤其是代表国家的比赛是难以用纸面实力来预测结果的。哥斯达黎加虽然首轮被西班牙打得比较惨，但是要知道世界杯影响力很大，也代表着国家荣誉，承载着国民的期望，一次被打爆不代表未来两场就一定是人见人欺的送分童子。而且在南美洲是有因为世界杯而犯下凶杀案的前科，所以哪怕是为了活着，在世界杯上的爆冷还是很大概率的。</p>
<h2 id="不可少的预测"><a href="#不可少的预测" class="headerlink" title="不可少的预测"></a>不可少的预测</h2><p>今年的世界杯跟以往来说补时时间长，以往一场比赛上下半场各补时2~3分钟，一共95分钟，现在一场比赛超出100分钟不是啥稀罕事。原本赛程就密集，而且5个换人名额的改变让板凳深度的队伍更加得利。而且这届裁判的判罚非常严格，体毛越位会被检查之外，对肢体的动作也明察秋毫。不管是板凳深度还是打法越位容错率，外加过去四届都是欧洲球队夺冠（2006意大利，2010西班牙，2014德国，2018法国），所以这届巴西是很有希望的。当然我情感还是支持阿根廷。</p>
<p>除了巴西，我个人觉得英格兰跟法国也是有利的冠军争夺者，尤其是英格兰跟法国大概率要在半决赛碰面，今年法国中场比较挫，但是前锋尤其是姆巴佩实力跟表现欲都比四年前更盛，而且回到国家队的格里兹曼也是如鱼得水。但是法国的左边是有不小的问题的，这一点跟德国有点像。</p>
<p>对于很多球员来说，这次世界杯是他们最后的一届世界杯了，比如梅西和C罗。目前阿根廷踢了两场，又跟以前的阿根廷一样—严重的梅西依赖症，全队的晴雨表就是看梅西当天的状态，这无疑是走不远的。目前看阿根廷最后一轮打同样是一人球队的波兰队，主动权还是在自己手里。作为小组第一出线，对手大概率是丹麦，丹麦不是那么好打的，估计要付出核心球员黄牌甚至下一轮停赛的代价，打完丹麦大概率打的就是A组第一荷兰，阿根廷现在的尴尬是“老的很重要，但是更老了”和“边后卫不太行”的问题，所以在世界杯里调整是有点晚的，所以阿根廷本次的预期是4强，但是8强是一个比较正常的表现，至于冠军需要全队爆种，这几乎是不可能的。不过比较可能得是，已经在世界杯进了8个球了梅西有希望世界杯决赛圈进球突破两位数。但是世界杯的金靴应该是姆巴佩。毕竟现在足球相比较层层推进，“后场直接大脚越过中场打身后”的得分方式其实在杯赛的效率不低，而姆巴佩比较适合。</p>
<h2 id="亚洲团灭？"><a href="#亚洲团灭？" class="headerlink" title="亚洲团灭？"></a>亚洲团灭？</h2><p>今年世界杯头两轮，亚洲球队表现很好：沙特2:1阿根廷，日本2:1德国，伊朗2:0威尔士，澳大利亚1:0突尼斯，韩国2:3惜败加纳，东道主卡塔尔则已经确认剩下的比赛只能“把自己家房子借给别人结婚用了”。目前亚洲球队获得的胜利是4场球，跟南美球队一样多（而欧洲目前赢了11场球！非洲球队首轮2平3负，本轮是3胜1平1负）。自古以来，东道主所在的大洲的国家队都会表现的更好一点：2010年南非世界杯，加纳四强；2014年巴西世界杯，阿根廷亚军；2018年俄罗斯世界杯更别提了，那么今年在亚洲办世界杯，按理说亚洲球队雄起应该也不是什么奇怪的事儿。</p>
<p>不过冷静的看，“亚洲之光”的赞美很棒，但是实际是可能小组赛结束后亚洲球队团灭。这里要先说明一下世界杯小组赛的晋级规则：<br>	1. 积分<br>	2. 净胜球<br>	3. 总进球数<br>	4. 胜负关系<br>	5. 等等，基本上都是用不到的关系了，不过2018年日本晋级是靠黄牌少这么一个比较不常用的规则</p>
<p>现在B组，伊朗跟美国两个人直面竞争出现名额，伊朗净胜球是-2，而美国净胜球是0，同时美国无法接受平局，肯定要拼个你死我活，这就比较考验双方硬实力了，伊朗跟垂垂老矣的威尔士都是补时进球，面对能冲的美国，说实话比较难。但是我个人希望伊朗能出线，现在伊朗国内比较动乱，希望用一场世界杯的胜利，让他们的国民尤其是女性国民开心一下。足球本身就是一个空前团结国民的运动。</p>
<p>C组，沙特最后一轮打一球没进的墨西哥，这场为了出线双方也是必须要拼高下的，墨西哥在面对阿根廷上半场前场逼抢体力消耗很大，面对沙特会不会依旧前场逼抢不好说，但是从硬实力来说，墨西哥的侵略性和冲击力是不会次于沙特的，预测这场会是一个犯规大战，全场30个犯规起步的那种。个人觉得沙特不会在墨西哥身上讨到什么便宜，可能会输球。甚至这组，搞不好波兰以净胜球的优势小组晋级。</p>
<p>D组，澳大利亚要打丹麦，丹麦是必须求胜的，虽然今年丹麦的前锋比较挫，但是面对澳大利亚是够了，而且澳大利亚进攻能力一般，面对丹麦的防线还是很吃力的，感觉澳大利亚也会沉船，丹麦小组第二晋级。</p>
<p>E组更别提了，日本一把好牌打稀烂，我开始怀疑森保一第一轮赢德国是蒙的。目前的局势，日本要最后一轮面对状态不错的西班牙，而且日本几乎没有小组第二的机会，如果能晋级就是小组第一，但是面对西班牙日本可真的没实力赢球。反观德国现在掌握了自己的主动权，虽然他现在净胜球-1，但是哥斯达黎加不是什么强队，以德国的攻城锤能力，砸哥斯达黎加3~4个以小组第二出线没问题。</p>
<p>H组是韩国，韩国已经过了难缠但是已经老化的乌拉圭，结果打加纳，全场围着打却只能遗憾落败，而且主教练红牌，最后一轮打葡萄牙大概率要吃瘪，哀兵不一定会必胜。其实H组四个队实力差不多，葡萄牙其实是搅局者，因为从历史来看，葡萄牙是遇实力比自己强的不胜，但是可能会平，遇实力明显比自己弱的，还是能吃得下的（补，写完此文后第二天看到了葡萄牙2:0乌拉圭，韩国胜利大逃亡）。</p>
<p>这么一看，亚洲球队基本是各个没把握，个人比较有信心的是沙特，其次是伊朗，最后是日本&#x2F;澳大利亚&#x2F;韩国，这哥三基本已经可以买机票了，早买还能抢到好位置。</p>
<p>如果真的是“亚洲团灭”这个结果，那可见亚洲足球其实没什么特别的进步，只能说亚洲球队跟欧洲球队在某一场战斗中会获得胜利，而且这场里是对方的下限和亚洲球队的上限，但是在一系列的战役中上有一定的差距，还需要冷水泼一下。各位球队该换人换人，该换血换血吧，下届继续努力。</p>
<h2 id="12月5日的补充"><a href="#12月5日的补充" class="headerlink" title="12月5日的补充"></a>12月5日的补充</h2><p>距离前文过了一周，我预测的最没信心的三支队伍反而都小组赛出线了，而沙特伊朗都跪了。虽然在今早日本和韩国争夺八强失败，亚洲团灭，不过还是要为所有亚洲球队们点赞，他们战斗到了最后一刻，即使出局也是昂首出局的。</p>
<p>日本队和主教练森保一这一路走过来，各路弹幕不断。今凌晨他们点球惜败给克罗地亚，整个过程输的也不算丢人。日本队虽然没有达成他们自己说的“八强”目标，但是赢得了全世界的尊重，蓝武士这四场比赛总体来说，表现的非常好，超出了很多人的期待，森保一也获得了2+2的续约合同。</p>
<p>但是这支日本队也有不少的问题，其中最现实的问题就是“这批人4年后还能更好吗？”，我个人觉得下一次美国世界杯里，日本队的大名单会换掉一批人的，这批球员的实力已经到头了。在世界杯这样的杯赛里，最核心的比较就是“看对方谁的短板更短”，这个更具体一点说就是“看谁的体能分配管理做的更好”、“看谁防守反击做得好”和“看谁破大巴能力强”，而日本队在“防守反击”上无疑是满分，但是在“破大巴”上还是有很大的进步空间。他们在跟克罗地亚的比赛里，上半场两个边路尤其是伊东纯也那边很活跃，但是下半场伊东纯也就累的看不到人了，几次高球传中也都石沉大海。中路传不进去，三笘薰边路下底也被克罗地亚赛前重点研究了，田中碧更是原来不在计划里，100多分钟才出场，跟浅野拓磨跟南野拓实一样，效果平平。正常比赛，日本跟克罗地亚的进攻都很沉闷，我开始以为他俩就是研究好了要去打点球，但是到了点球大战才发现，日本队这压根就没练点球啊！</p>
<p>而且我觉得，日本队研究欧洲队比研究美洲队下的功夫要多的多。日本队25人里能稳定出场的15人左右的综合战力可以说是亚洲尖子的存在了，如果他们能在未来四年里，再出来像本田圭佑那个级别的单打手，配上一个好的世界杯签运，八强梦会成真！<br><img data-src="/images/%E6%97%A5%E6%9C%AC%E7%90%83%E8%BF%B7.png" title="日本对克罗地亚这一场，央视信号再次屏蔽了场外观众"></p>
<p>除了日本是赢家，我觉得孙兴慜跟莱万也是赢家。韩国和波兰这俩都是“一人球队”，波兰队在世界杯所有的三个进球跟莱万都有关，韩国最后绝杀葡萄牙的进球也是孙兴慜策划的。这一次他俩也算带队突破了自己在国家队的表现了，无需过多苛责，应该给予掌声。</p>
<p>阿根廷下一场是打荷兰的，这绝对会是一场硬仗。这俩都是边路策应中路的主儿，邓弗里斯VS阿库尼亚和迪玛利亚VS小布林德，真是想想就刺激。但是阿根廷是需要劳塔罗的，他是阿根廷里少数能本身扛人能转身的球员，阵地战需要他这样的来搅局。我猜测劳塔罗还是会替补出战，接替搅和半天内线的阿尔瓦雷斯。但是现在劳塔罗需要调整一下心态，他现在是立功心切导致有点浮躁了。荷兰的中卫组合“范戴克+阿克&#x2F;德里赫特”看起来强大，但是也有一定的问题，我觉得以劳塔罗的能力是能进球的，但是这一场估计双方是不会打加时赛的，抢开局是重点，但是阿根廷又玩不了前场紧逼，所以还是要抓机会打防守反击。话说阿迪达斯赞助的国家队，现在就剩下阿根廷跟西班牙了。西班牙还好说，但是阿根廷这个全球人气大户要是折戟四强战，耽误阿迪达斯卖球衣，阿迪得多心疼啊！</p>
<p>至于另一边英法大战，我个人觉得英格兰这一次有戏。</p>
<p>最后为贝利祈祷，希望他挺过难关。</p>
<h2 id="12月12日的补充"><a href="#12月12日的补充" class="headerlink" title="12月12日的补充"></a>12月12日的补充</h2><p>英法大战，我满怀期待的英格兰没有得到上天的眷顾，不过英格兰是目前为止第一个在数据上压制法国的队伍，这也给了其他球队一些启示：姆巴佩甚至包括另一边的登贝莱是可以被限制死的，但是前提是你得有一个像萨卡一样的边锋，同时给格里兹曼施加压力，让格里兹曼更多的去防守。</p>
<p>不过可惜的是无论是阿根廷&#x2F;克罗地亚还是摩洛哥，这条启示是没用的，因为他们本身的边锋并不强。</p>
<p>英格兰的出局也印证了一个道理：要低调攒人品。你看开场进7个的西班牙滚蛋了，进瑞士队6个的葡萄牙也滚蛋了，半场进韩国4个的巴西滚蛋了，这次轮到了开场进伊朗6个的英格兰滚蛋。冥冥之中，不要透支自己的进球账户。如长者说得好：闷声发大财。</p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>足球</tag>
        <tag>世界杯</tag>
      </tags>
  </entry>
  <entry>
    <title>写在阿根廷出局之后</title>
    <url>/2018/07/03/%E5%86%99%E5%9C%A8%E9%98%BF%E6%A0%B9%E5%BB%B7%E5%87%BA%E5%B1%80%E4%B9%8B%E5%90%8E/</url>
    <content><![CDATA[<h2 id="桑保利的无奈"><a href="#桑保利的无奈" class="headerlink" title="桑保利的无奈"></a>桑保利的无奈</h2><p>阿根廷在俄罗斯世界杯的征程结束了，3:4输给法国看上去好像不那么糟糕，但是在姆巴佩下半场的2球时间里，阿根廷的后防线的的确确崩溃了。</p>
<p>一天之后的凌晨，俄罗斯靠点球大战送西班牙回家。很多阿根廷的球迷说阿根廷应该效仿俄罗斯，跟法国摆大巴，靠着偷鸡或者点球胜利。</p>
<p>我个人认为，此方法不可取。虽然阿根廷2014年是靠防守进了决赛，但是这支阿根廷老人更老，新人不牛，而且整支队伍缺乏磨合，纪律性也不够。桑保利深知阿根廷无法保持90分钟的高质量大巴，最多三十分钟。而且大巴阵需要一个高点去压迫对方的后卫，比如穆里尼奥的德罗巴、科斯塔、卢卡库，至少也得有一个能跳又壮的C罗在禁区里搅合，但是伊卡尔迪这次没来，所以桑保利无论是防守还是进攻都无法选择大巴。</p>
<p>所以说，“攻出去”是桑保利无奈的选择，至少这样能死的还壮烈一点。当然，桑保利换上法齐奥是一个败笔，但是最根本的原因还是阿根廷人才断档造成的阵容畸形。</p>
<h2 id="梅西的困局"><a href="#梅西的困局" class="headerlink" title="梅西的困局"></a>梅西的困局</h2><p>梅西在国家队是不是过得不爽？这是必然的。因为他在巴萨得到的支持远大于他在国家队得到的支持，但是这种支持差以肉眼可见的速度缩小。而且阿根廷的媒体对梅西也是比较苛刻，这就吃了没有好公关团队的亏。</p>
<p>让梅西去踢中场是很暴殄天物的行为，但是现在中场式微，梅西不得不去后撤拿球，甚至还要在边路拿球。我曾经说过，梅西后撤拿球就是慢性自杀，首先他不靠近禁区就无法高质量的射门，其次后撤拿球会让对手更多的容错率去包夹他进而消耗他的体力。这样下来不仅场面不好看，梅西的数据更难看，难免被人黑。不过我还是不明白为什么迪巴拉与梅西无法共存，他俩是位置冲突没错，但是梅西可以踢边路，让迪巴拉去踢前腰&#x2F;影锋，这个从理论上来说是可行的。</p>
<p>反正在俱乐部解决梅西的问题很简单，砸钱买人即可，但是在国家队，估计要费桑保利的脑细胞了（前提是他不下课），所以说足球是和平年代的战争，表面拼的是场上比分，实际拼的是场下准备。</p>
<p>很多球迷反应说梅西在世界杯上没什么笑容，这让我想起来中日甲午战争的时候，中国船上的洋水手回忆说“中国的海员战斗前摩拳擦掌跃跃欲试，但是中国的军官则是一脸忧虑、若有所思”。事实说明，其实军官是更了解敌我实力差距的，梅西也是如此。但是没有办法，他必须要做打一个很难打赢的战争。</p>
<h2 id="梅罗之争"><a href="#梅罗之争" class="headerlink" title="梅罗之争"></a>梅罗之争</h2><p>可以说这两个人在俄罗斯的表现都是他们各自在俱乐部七层左右的功力（C罗要高一点），但是这两个人都踢飞了点球，而那个点球原本都可以把他们队伍带到下半区去面对较弱对队伍从而提高晋级的概率，可以说国家队过早出局跟他们有直接关系。</p>
<p>梅西在淘汰赛表现还可以但是在0:3输克罗地亚那一场太过失常，但是C罗这一边也是“高开低走”，不过同样四届世界杯，梅西世界杯6球3助攻，C罗是7球1助攻，大家都没有在淘汰赛进球，的确很巧合。</p>
<p>不过皇马三连冠外加葡萄牙拿到了欧洲杯冠军，让C罗的生涯看起来比梅西完美了很多。明年是巴西美洲杯，现在美洲杯的竞争完全不逊于欧洲杯，小马哥离开的阿根廷想夺冠并不乐观，梅西估计注定无法作为领袖为阿根廷带来一个洲际冠军了。</p>
<p>这两个人都是超级射手，而且不可否认的是他们都需要优秀的中场作为火力支持，以前梅西有“哈白布”大杀四方，而C罗现在有了“克卡莫”也逆转了金球奖总数，所以作为球迷，要认识到这一点：现代足球单打一场或许可以，连续独斗五场以上就是天神下凡了。</p>
<p>不过客观的说，除非内马尔等人能拿到世界杯，不然今年的金球奖还是C罗的，梅西和巴萨需要尽快加油，而加油最有效的方法就是补强中场，加强控制。</p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>足球</tag>
        <tag>世界杯</tag>
        <tag>阿根廷</tag>
      </tags>
  </entry>
  <entry>
    <title>创建Mysql容器过程</title>
    <url>/2018/05/12/%E5%88%9B%E5%BB%BAMysql%E5%AE%B9%E5%99%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h2><p>先<code>docker pull mysql</code>，当前最近的版本是8.0，然后<code>docker images</code>查看一下效果。</p>
<p>然后就是启动一个容器，命令是：<code>docker run --name test-mysql -p 3306:3306 -e MYSQL\_ROOT\_PASSWORD=123456 -d mysql</code>,这句话的意思是：启动一个叫test-mysql的容器， 端口影射是3306到宿主机的3306，同时设置root的密码是123456，然后以守护进程的形式启动。</p>
<p>但是如果在宿主机上使用<code>mysql -h127.0.0.1 -uroot -p123456</code>可能会报错，报错内容是：<code>Authentication plugin ‘caching_sha2_password’ cannot be loaded:</code></p>
<p>那么就<code>docker exec -it 容器ID号 env LANG=C.UTF-8 /bin/bash</code>进入到容器里，使用<code>mysql -uroot -p123456</code>，看一下在容器里是否可以正常登录，如果可以的话，那么就在mysql的命令行里执行<code>ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;;</code>。  </p>
<p>退出容器在宿主机上重新连接，这样就OK了。至于原因就是，mysql的客户端是yum安装的，虽然是centos 7，但是安装的版本也是5.5版本的，所以8.0的客户端有一个新的密码加密方式：<code>caching_sha2_password</code>，客户端不支持，所以需要手动到命令行里更改一下。</p>
<h2 id="mysql存储的坑"><a href="#mysql存储的坑" class="headerlink" title="mysql存储的坑"></a>mysql存储的坑</h2><p>先思考一个问题：假如某mysql容器里存储了100G的数据，那么这个容器关闭了，这100G的数据还在么？从宿主机是可以找到这100G的数据么？</p>
<p><code>docker inspect mysql-container-id</code>，找到里面的volume字段，这里也显示挂载的host路径，可以通过这个路径来备份数据。或者使用<code>docker cp mysql-container-id:/path/to/db-backup-file ./</code>，把容器内数据放到当前目录下。如果是生产环境，必须使用Volume或数据容器。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://binary-space.iteye.com/blog/2412769">http://binary-space.iteye.com/blog/2412769</a><br><a href="http://dockone.io/question/108">http://dockone.io/question/108</a><br><img data-src="/images/rondopass1.gif" alt="paradin"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>docker容器</tag>
      </tags>
  </entry>
  <entry>
    <title>Django制作前端页面生成yaml文件</title>
    <url>/2018/09/03/%E5%88%B6%E4%BD%9C%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%94%9F%E6%88%90yaml%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="整体流程与环境说明"><a href="#整体流程与环境说明" class="headerlink" title="整体流程与环境说明"></a>整体流程与环境说明</h2><p>整体流程如下图，请感受灵魂画师的功力：<br><img data-src="/images/django7.png" alt="paradin"></p>
<p>Django:<code>2.1.1</code>，阿里云服务器<br>Python:<code>3.6.4</code>，安装方法见：<a href="https://rorschachchan.github.io/2018/07/31/%E8%8E%B7%E5%8F%96%E7%BD%91%E7%AB%99title%E7%9A%84%E8%84%9A%E6%9C%AC/">https://rorschachchan.github.io/2018/07/31/获取网站title的脚本/</a></p>
<h2 id="Django启动"><a href="#Django启动" class="headerlink" title="Django启动"></a>Django启动</h2><p>由于是python3，所以直接<code>pip install django</code>就安装最新的Django版本。<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">django-admin startproject <span class="title class_">Kubernetes</span>		#如果提示django-admin命令不存在可以做一个软连接到/usr/local/bin/目录下</span><br><span class="line">cd <span class="title class_">Kubernetes</span></span><br><span class="line">python manage.<span class="property">py</span> startapp createyaml 	#创建<span class="variable constant_">APP</span></span><br><span class="line">python manage.<span class="property">py</span> migrate</span><br><span class="line">python manage.<span class="property">py</span> createsuperuser</span><br></pre></td></tr></table></figure></p>
<p>app创建完毕之后，在<code>Kubernetes/settings.py</code>的<code>INSTALLED_APPS</code>字段添加<code>createyaml</code>，此时就创建好了项目和app。<code>python manage.py runserver 0.0.0.0:8000</code>启动django，然后浏览器地址栏输入<code>外网IP：8000</code>，就会看到django正常启动了，如图：<br><img data-src="/images/django6.png" alt="paradin"></p>
<h2 id="Django准备"><a href="#Django准备" class="headerlink" title="Django准备"></a>Django准备</h2><p>首先我们先准备一个脚本<code>111.sh</code>，这个脚本很简单，就是接收到前端传入的数值然后加工成一个yaml文件，如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/bin/</span>bash</span><br><span class="line">#用来生成对应的yaml文件</span><br><span class="line">cat &lt;&lt; <span class="variable constant_">EOF</span></span><br><span class="line">=============================</span><br><span class="line">===   <span class="variable constant_">HERE</span> <span class="variable constant_">IS</span> <span class="variable constant_">YOUR</span> <span class="variable constant_">YAML</span>   ===</span><br><span class="line">=============================</span><br><span class="line"><span class="variable constant_">EOF</span></span><br><span class="line"></span><br><span class="line">echo <span class="attr">apiVersion</span>: v1</span><br><span class="line">echo <span class="attr">kind</span>: $1</span><br><span class="line">echo <span class="attr">metadata</span>:</span><br><span class="line">echo <span class="attr">name</span>: $2</span><br><span class="line">echo <span class="attr">labels</span>:</span><br><span class="line">echo <span class="attr">app</span>: web</span><br><span class="line">echo <span class="attr">spec</span>:</span><br><span class="line">echo <span class="attr">containers</span>:</span><br><span class="line">echo -- <span class="attr">name</span>: front-end</span><br><span class="line">echo <span class="attr">image</span>: $5</span><br><span class="line">echo <span class="attr">ports</span>:</span><br><span class="line">echo -- <span class="attr">containerPort</span>: $3</span><br><span class="line">echo -- <span class="attr">name</span>: rss-reader</span><br><span class="line">echo <span class="attr">image</span>: nickchase/rss-php-<span class="attr">nginx</span>:v1</span><br><span class="line">echo <span class="attr">ports</span>:</span><br><span class="line">echo - <span class="attr">containerPort</span>: $4</span><br></pre></td></tr></table></figure></p>
<p>可以看出上面这个生成yaml脚本太粗糙了，很多地方还有待改进，但是这仅仅是一个小例子而已。再去<code>/django/Kubernetes/createyaml/templates</code>里准备一个比较简单的前端页面脚本，内容如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">        &lt;head&gt;</span><br><span class="line">                &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">                &lt;title&gt;创建yaml文件&lt;/title&gt;</span><br><span class="line">        &lt;/head&gt;</span><br><span class="line">        &lt;body&gt;</span><br><span class="line">                &lt;h1&gt;创建YAML文件用于K8s部署&lt;/h1&gt;</span><br><span class="line">                &lt;h2&gt;请根据实际情况填写以下内容&lt;/h2&gt;</span><br><span class="line">                &lt;form method=&quot;post&quot; action=&quot;/create_yaml/&quot;&gt;</span><br><span class="line">                        &lt;input type=&quot;text&quot; name=&quot;kind&quot; placeholder=&quot;类型&quot;&gt;&lt;br&gt;</span><br><span class="line">                        &lt;input type=&quot;text&quot; name=&quot;name&quot; placeholder=&quot;名称&quot;&gt;&lt;br&gt;</span><br><span class="line">                        &lt;input type=&quot;text&quot; name=&quot;containerPort1&quot; placeholder=&quot;容器端口1&quot;&gt;&lt;br&gt;</span><br><span class="line">                        &lt;input type=&quot;text&quot; name=&quot;containerPort2&quot; placeholder=&quot;容器端口2&quot;&gt;&lt;br&gt;</span><br><span class="line">                        &lt;input type=&quot;text&quot; name=&quot;mirror&quot; placeholder=&quot;镜像&quot;&gt;&lt;br&gt;</span><br><span class="line">                        &#123;&#123; error &#125;&#125;&lt;br&gt;</span><br><span class="line">                        &lt;button id=&quot;btn&quot; type=&quot;submit&quot;&gt;生成yaml&lt;/button&gt;</span><br><span class="line">                        &#123;% csrf_token %&#125;	</span><br><span class="line">			&lt;!-- 标签添加CSRF令牌，这是因为django针对CSRF(跨站请求伪造)有保护措施，没有这句话就是403 --!&gt; </span><br><span class="line">                &lt;/form&gt;</span><br><span class="line">        &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>有了页面，还需要一个域名指向这个页面，修改一下<code>/django/Kubernetes/Kubernetes/urls.py</code>，改成如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.<span class="property">contrib</span> <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.<span class="property">urls</span> <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> createyaml <span class="keyword">import</span> views		#将createyaml这个app的views引进</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="title function_">path</span>(<span class="string">&#x27;admin/&#x27;</span>, admin.<span class="property">site</span>.<span class="property">urls</span>),</span><br><span class="line">    <span class="title function_">path</span>(r<span class="string">&#x27;create_yaml/&#x27;</span>, views.<span class="property">create_yaml</span>),	#新版的这里不再是url了，把这个url指向views.<span class="property">py</span>里的create_yaml函数</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>再继续，写一下<code>views.py</code>里的<code>create_yaml</code>函数：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess		#引入这个库</span><br><span class="line"></span><br><span class="line">#创建yaml</span><br><span class="line">def <span class="title function_">create_yaml</span>(request):</span><br><span class="line">    <span class="keyword">if</span> request.<span class="property">method</span> == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        kind = request.<span class="property">POST</span>.<span class="title function_">get</span>(<span class="string">&#x27;kind&#x27;</span>, <span class="string">&#x27;&#x27;</span>)		#后面的<span class="string">&#x27;&#x27;</span>是默认值的意思</span><br><span class="line">        name = request.<span class="property">POST</span>.<span class="title function_">get</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        containerPort1 = request.<span class="property">POST</span>.<span class="title function_">get</span>(<span class="string">&#x27;containerPort1&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        containerPort2 = request.<span class="property">POST</span>.<span class="title function_">get</span>(<span class="string">&#x27;containerPort2&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        mirror = request.<span class="property">POST</span>.<span class="title function_">get</span>(<span class="string">&#x27;mirror&#x27;</span>, <span class="string">&#x27;&#x27;</span>)	</span><br><span class="line">        result = subprocess.<span class="title class_">Popen</span>(args=[<span class="string">&#x27;bash&#x27;</span>,<span class="string">&#x27;/docker/111.sh&#x27;</span>,name,mirror,containerPort1,containerPort2],stdout = subprocess.<span class="property">PIPE</span>,shell = <span class="title class_">False</span>).<span class="property">stdout</span>.<span class="title function_">read</span>()	#在这里通过subprocess去启动<span class="number">111.</span>sh这个脚本</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">HttpResponse</span>(result,content_type=<span class="string">&quot;text/plain&quot;</span>)</span><br><span class="line">    <span class="attr">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">render</span>(request,<span class="string">&#x27;createyaml.html&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>以上函数多说几句：</p>
<ol>
<li>首先判断请求的方法是否是<code>POST</code>，不是的话返回该页面;</li>
<li><code>request.POST.get</code>方法获取前端传入的名称或者端口等值，此处的<code>kind</code>、<code>name</code>、<code>mirror</code>和<code>containerPort</code>就是html文件里form表单部分那两个<code>input</code>标签的<code>name</code>属性；</li>
<li>获取到了变量，然后就让<code>subprocess</code>来调用111.sh来用这些变量去运行脚本，执行的结果就是<code>result</code>，然后<code>return</code>这个<code>result</code>结果；</li>
<li>使用subprocess最好不打开<code>shell = True</code>，因为这样的话，要是不小心<code>rm -rf /</code>，你就gg了，但是如果<code>shell = False</code>的话，就会把刚才的命令看成<code>rm</code>和<code>-rf /</code>两部分，也就是不能成功，这样也免去了别人恶意注入的危险；</li>
</ol>
<h2 id="实际操作效果"><a href="#实际操作效果" class="headerlink" title="实际操作效果"></a>实际操作效果</h2><p><img data-src="/images/django8.gif" alt="akb48" title="本gif是用LICEcap录制的"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/xiaoyaozizai017/article/details/72794469">https://blog.csdn.net/xiaoyaozizai017/article/details/72794469</a><br><a href="http://lipeilipei.top/2018/02/07/python+django%E5%AE%9E%E7%8E%B0%E7%99%BB%E9%99%86%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%8B%E7%AF%87%EF%BC%89/">http://lipeilipei.top/2018/02/07/python+django%E5%AE%9E%E7%8E%B0%E7%99%BB%E9%99%86%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%8B%E7%AF%87%EF%BC%89/</a><br><a href="https://blog.csdn.net/bjbz_cxy/article/details/79358718">https://blog.csdn.net/bjbz_cxy/article/details/79358718</a>	(如果不想用django就可以看看这个cgi方法)<br><a href="http://blog.51cto.com/laomomo/2163399">http://blog.51cto.com/laomomo/2163399</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>加载css样式的两个方法</title>
    <url>/2018/05/12/%E5%8A%A0%E8%BD%BDcss%E6%A0%B7%E5%BC%8F%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h2><p>环境： <code>django 2.0</code>+<code>python 3.6</code>+<code>pycharm 2018</code><br>project名称: <code>blog</code></p>
<h2 id="普通的网页加载css"><a href="#普通的网页加载css" class="headerlink" title="普通的网页加载css"></a>普通的网页加载css</h2><p>网页使用了css才会更好看更炫酷，一般情况下的网页是这样的：<br><img data-src="/images/css0.png" alt="akb48"></p>
<p>上面这个html文件里用到了模板，而且又对div和 a标签做了class定义，最后分别对各自的class进行了css说明。整个文档看下来比较直观。</p>
<p>但是这样就会有一个问题，就是把html内容和css内容写到了一起，一般来说为了后期维护，都会把css单独写到一个文件夹里，然后让这个html来引用这个css文件夹的具体某个css文件。</p>
<p>于是，我们就在<code>blog</code>这个project目录下建立一个叫static的文件夹，用它来专门装<code>css\js</code>这样的静态文件。</p>
<p>首先，建立了这个static文件，肯定就涉及到引用的问题，而如何让django可以识别static呢？</p>
<p>打开<code>blog/settings.py</code>这个文件，这个文件是整个project的配置文件，在文件末尾加上这样的话，如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">	#将项目根目录里的<span class="keyword">static</span>制定成项目的静态文件夹,这样django就可以识别</span><br><span class="line">	#注意，<span class="keyword">static</span>前面没有<span class="string">&#x27;/&#x27;</span></span><br><span class="line">	<span class="variable constant_">STATICFILES_DIRS</span> = [os.<span class="property">path</span>.<span class="title function_">join</span>(<span class="variable constant_">BASE_DIR</span>, <span class="string">&#x27;static&#x27;</span>),]</span><br><span class="line">​	<span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">这样blog这个根目录就可以识别了`</span><span class="keyword">static</span><span class="string">`文件夹了。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">然后在pycharm里新建一个css文件叫`</span>base.css`<span class="language-css">，如果是专业版的pycharm是可以直接建立css类型文件的，免费社区版是没有这个功能。再将原文里面的所有关于css的内容拷贝到这个`</span>base.css`<span class="language-css">里，如下：</span></span><br></pre></td></tr></table></figure><br>		*{<br>		margin: 5px;<br>		padding: 10px;<br>		}<br>	<br>		div.nav {<br>		background-color: gold;<br>		border-bottom: 2px solid #ccc;<br>		}<br>	<br>		div.nav a{<br>		text-decoration:none;<br>		color: blue;<br>		padding: 5px 10px;<br>		}<br>	<br>		div.nav a.logo{<br>		display: inline-block;<br>		font-size: 120%;<br>		}	<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">保存之后，为了验证django是否成功的识别此文件，可以在浏览器里输入`外网IP：端口号/static/base.css`查看是否返回就是上面内容，如果是就代表识别成功，如果是404就要重新检查`settings.py`了。</span><br><span class="line"></span><br><span class="line">在原有的html里删除掉`&lt;style&gt;`标签内css内容，还要在head里添加一句话：`&lt;link  rel=&quot;stylesheet&quot; href=&quot;/static/base.css&quot;&gt;`,如下：</span><br><span class="line">![akb48](/images/css1.png)</span><br><span class="line"></span><br><span class="line">这样就达到了引用css所在的static文件夹的目的。</span><br><span class="line"></span><br><span class="line">## Django内部的加载css方法 ##</span><br><span class="line">上面说的是普通html加载css的方法，而django内部也有自己的一套方法，再次打开settings.py里看到有如下的内容：</span><br><span class="line">	```js</span><br><span class="line">	INSTALLED_APPS = [   </span><br><span class="line">		 &#x27;django.contrib.admin&#x27;,   </span><br><span class="line">		 &#x27;django.contrib.auth&#x27;,   </span><br><span class="line">		 &#x27;django.contrib.contenttypes&#x27;,   </span><br><span class="line">		 &#x27;django.contrib.sessions&#x27;,   </span><br><span class="line">		 &#x27;django.contrib.messages&#x27;,    </span><br><span class="line">		 &#x27;django.contrib.staticfiles&#x27;,   </span><br><span class="line">		 &#x27;blog&#x27;,</span><br><span class="line">	]</span><br></pre></td></tr></table></figure></p>
<p>上面的<code>django.contrib.staticfiles</code>就是django的css加载方法，使用这个方法也很简单。</p>
<p>首先要在html文件最上面先声明要调用这个方法:<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% load staticfiles %&#125;</span><br><span class="line">&#123;# 这个staticfiles是django自带的，可以在settings文件里看到 #&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后把link标签改成如下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;link  rel=&quot;stylesheet&quot; href=&quot;&#123;% static &#x27;base.css&#x27; %&#125;&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>保存文件刷新即可，而且用了这种方法，在chrome浏览器里F12 查看，会解析成普通模式的方法，如图：<br><img data-src="/images/css2.png" alt="akb48"></p>
<p><font color=red>在django项目里，还是更推荐用django的方法。</font></p>
<h2 id="额外补充"><a href="#额外补充" class="headerlink" title="额外补充"></a>额外补充</h2><p>如果html文件开头声明引用了某个模板，比如：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% extends &#x27;base.html&#x27; %&#125;	#声明引用了base.html这个模板</span><br><span class="line">&#123;% load staticfiles %&#125;	</span><br></pre></td></tr></table></figure></p>
<p>那么<code>extends</code>语句必须在最上面，不然就会报错：<code>TemplateSyntaxError at /&lt;ExtendsNode: extends &#39;base.html&#39;&gt; must be the first tag in the template.</code></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>前端技术</tag>
      </tags>
  </entry>
  <entry>
    <title>在Django2的前台页面里比较日期先后</title>
    <url>/2020/12/09/%E5%87%A0%E4%B8%AADjango%E9%97%AE%E9%A2%98%E8%A7%A3%E6%B3%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>背景交代:由<code>Django2.1</code> + <code>Python 3.8</code> + <code>AdminLTE3</code> 构建的一个“风险大盘”首页，页面最后效果如下：<br><img data-src="/images/%E9%A3%8E%E9%99%A9%E5%A4%A7%E7%9B%98%E9%A6%96%E9%A1%B5.png" alt="akb48" title="一个收集大盘的页面"></p>
<p>现在有一个需求，就是比较当前日期和“预计完结日期”，如果“超过了预计完结日期，风险还没完成”就是红色，反之就绿色。</p>
<p>在python里比较日期如果在同一个时区是很简单的，直接大于小于就可以实现。在Django里比较日期也差不多用这个方式，而template里默认的内置的模板标签语言表示今天的方法是<code>now &quot;Y-m-d&quot;</code>，但是这个不能用于比较里，会报错<code>Could not parse the remainder: &#39;%&#39; from &#39;%&#39;</code>。</p>
<p>用一个比较简单的方法，就是在<code>views.py</code>里<code>import datetime</code>，然后传入<code>context[&#39;today&#39;] = date.today()</code>通过<code>render_to_response</code>到前端页面,或者直接<code>return render_to_response(&#39;template.html&#39;, &#123;&#39;today&#39;: date.today()&#125;)</code>，然后:<br>	<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">&quot;color:&#123;% if risk.risk_time|date:&quot;</span><span class="attr">Y-m-d</span>&quot; &lt;= <span class="string">today|date:</span>&quot;<span class="attr">Y-m-d</span>&quot; <span class="attr">and</span> <span class="attr">risk.risk_stat</span> == <span class="string">&#x27;未达标&#x27;</span> %&#125; <span class="attr">red</span> &#123;% <span class="attr">else</span> %&#125; <span class="attr">green</span> &#123;% <span class="attr">endif</span> %&#125;&quot;&gt;</span></span><br><span class="line">                 <span class="comment">&lt;!-- 这里的today是后台views.py里传进来的今天的日期 --&gt;</span></span><br><span class="line">       &#123;&#123; risk.risk_time|date:&quot;Y-m-d&quot; &#125;&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>还有一个比较骚的方法，将类似<code>in_the_past</code>（布尔值）的内容传递给<code>extra_context</code>，或者最好将其作为属性添加到模型中：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line"></span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_past_due</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> date.today() &gt; <span class="variable language_">self</span>.date</span><br></pre></td></tr></table></figure></p>
<p>然后在前端页面：<br>	<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if listing.is_past_due %&#125;</span><br><span class="line">    In the past</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">    &#123;&#123; listing.date|date:&quot;d M Y&quot; &#125;&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p>
<p>不过我个人还是觉得第一个比较好，简单粗暴。</p>
<h2 id="render-to-response多个参数问题"><a href="#render-to-response多个参数问题" class="headerlink" title="render_to_response多个参数问题"></a>render_to_response多个参数问题</h2><p>Django2的<code>render_to_response</code>是可以带多个参数的，比如：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑风险事件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update_stresstest</span>(<span class="params">request</span>):</span><br><span class="line">	context = <span class="built_in">dict</span>()</span><br><span class="line">   	context[<span class="string">&quot;activities&quot;</span>] = Promotion.objects.<span class="built_in">all</span>().order_by(<span class="string">&#x27;-id&#x27;</span>)		<span class="comment"># 从Promotion数据库里获取所有</span></span><br><span class="line">   	error = <span class="string">&#x27;&#x27;</span>  <span class="comment"># 错误提示</span></span><br><span class="line">   	risk_pk = request.GET.get(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">   	risk_lists = Risk.objects.<span class="built_in">filter</span>(pk=risk_pk)</span><br><span class="line">   	obj = risk_lists[<span class="number">0</span>]  <span class="comment"># 获取到具体对应的那个任务</span></span><br><span class="line">   	<span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">   		obj.risk_name = request.POST.get(<span class="string">&quot;risk_name&quot;</span>, <span class="literal">None</span>)  <span class="comment"># 风险名称</span></span><br><span class="line">   		obj.risk_level = request.POST.get(<span class="string">&quot;risk_level&quot;</span>, <span class="literal">None</span>)  <span class="comment"># 风险级别</span></span><br><span class="line">   		        <span class="keyword">if</span> <span class="built_in">all</span>([obj.risk_name, obj.risk_pm, obj.risk_domain, obj.risk_level, obj.risk_detail]):  <span class="comment"># 判断获取到的值同时不为空</span></span><br><span class="line">           obj.save()  <span class="comment"># 保存到数据库里</span></span><br><span class="line">           <span class="keyword">return</span> redirect(<span class="string">&#x27;/naxx/risk&#x27;</span>)  <span class="comment"># 使用redirect如果后面直接加.html就是在原有路径上加，所以这直接写路径，注意后面没有/</span></span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           error = <span class="string">&quot;有必写数据为空，请重新检查&quot;</span></span><br><span class="line">   <span class="keyword">return</span> render_to_response(<span class="string">&#x27;edit_risk.html&#x27;</span>, &#123;<span class="string">&#x27;obj&#x27;</span>: obj, <span class="string">&#x27;error&#x27;</span>: error, <span class="string">&#x27;context&#x27;</span>:context&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这里就用了字典的形式给<code>render_to_response</code>返回了多个参数，但是此时在前端页面直接调用<code>&#123;&#123; error &#125;&#125;</code>和<code>&#123;&#123; obj.XXX &#125;&#125;</code>是没问题的，但是要直接调用<code>&#123;&#123; activities &#125;&#125;</code>就是空白，要在<code>templates</code>里这么用：<br>	<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;form-inline&quot;</span>&gt;</span>*所属活动:</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-sm-7&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">select</span> <span class="attr">data-placeholder</span>=<span class="string">&quot;选择大促项目...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">name</span>=<span class="string">&quot;promotion_name&quot;</span> <span class="attr">id</span>=<span class="string">&quot;promotion_name&quot;</span> <span class="attr">required</span>=<span class="string">&quot;required&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>请选择...<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        &#123;% for activity in context.activities %&#125;</span><br><span class="line">          <span class="tag">&lt;<span class="name">option</span>&gt;</span>&#123;&#123; activity.promotionname &#125;&#125;<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这个就是一个下拉页，可以查询到历次的大促事件。可见这里要用<code>context.activities</code>，而不能直接像<code>obj</code>直接用，因为传入的是<code>context</code>，而如果是只传入一个<code>context</code>是不用写成<code>context.activities</code>的，直接写<code>activities</code>就行。</p>
<p>补充一句，<code>context_instance=RequestContext(request)</code>方法我是不好使了，可以直接不用考虑了。</p>
<h2 id="AdminLTE3下拉菜单无法点击问题"><a href="#AdminLTE3下拉菜单无法点击问题" class="headerlink" title="AdminLTE3下拉菜单无法点击问题"></a>AdminLTE3下拉菜单无法点击问题</h2><p>AdminLTE3里的给下拉菜单的demo是这样的：<br>	<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;btn-group&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-default&quot;</span>&gt;</span>Action<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-default dropdown-toggle dropdown-hover dropdown-icon&quot;</span> <span class="attr">data-toggle</span>=<span class="string">&quot;dropdown&quot;</span>&gt;</span></span><br><span class="line">	  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;sr-only&quot;</span>&gt;</span>Toggle Dropdown<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">	  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;dropdown-menu&quot;</span> <span class="attr">role</span>=<span class="string">&quot;menu&quot;</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;dropdown-item&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>第一个链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;dropdown-item&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>第二个链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;dropdown-item&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>第三个链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;dropdown-divider&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;dropdown-item&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>特殊的链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">	  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>效果如图：<br><img data-src="/images/bootstrap%E9%BB%98%E8%AE%A4%E4%B8%8B%E6%8B%89%E6%95%88%E6%9E%9C.png" alt="akb48"></p>
<p>但是这个是不好使的，点击了链接<code>href</code>并不会生效，而右键“在新的标签页打开”是可以的。于是我改成这样：<br>	<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;btn-group&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;dropdown-toggle btn btn-warning&quot;</span> <span class="attr">data-toggle</span>=<span class="string">&quot;dropdown&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span></span><br><span class="line">    操作... <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;caret&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;dropdown-menu&quot;</span> <span class="attr">role</span>=<span class="string">&quot;menu&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;dropdown-item&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/naxx/edit_risk/?id=&#123;&#123; risk.id &#125;&#125;&quot;</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;dropdown-item&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/naxx/del_risk/?id=&#123;&#123; risk.id &#125;&#125;&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这样直接点击就OK了。</p>
<p>补充一下，如果使用Django的ORM实现，以某列为准，某行出现的次序排序的语句是：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Risk.objects.<span class="built_in">filter</span>(risk_stat=<span class="string">&#x27;未达标&#x27;</span>).values(<span class="string">&#x27;risk_domain&#x27;</span>).annotate(total=Count(<span class="string">&#x27;risk_domain&#x27;</span>)).order_by(<span class="string">&#x27;-total&#x27;</span>)[<span class="number">0</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure></p>
<p>这句话的意思是：在<code>Risk</code>数据表里，以<code>risk_stat=&#39;未达标&#39;</code>为准找出<code>risk_domain</code>出现的从高到低最多的列，同时只截取了前三名。</p>
<p><img data-src="/images/%E6%B1%89%E6%B5%B7%E5%85%AC%E5%9B%AD%E5%BC%82%E5%9E%8B%E6%88%98%E5%A3%AB.jpg" alt="akb48" title="重庆汉海海洋公园的异型战士雕塑"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Django2</tag>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title>利用金山云SDK获取KS3存储值的办法</title>
    <url>/2019/03/31/%E5%88%A9%E7%94%A8%E9%87%91%E5%B1%B1%E4%BA%91SDK%E8%8E%B7%E5%8F%96KS3%E5%AD%98%E5%82%A8%E5%80%BC%E7%9A%84%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>之前曾经写过获得金山云云存储KS3的方法，<a href="http://chenx1242.blog.51cto.com/10430133/1968857">http://chenx1242.blog.51cto.com/10430133/1968857</a> 但是这个方法的缺点很明显，就是“要先list再算值”，消耗时间太多。于是乎还是得用SDK来达到获取值得目的。</p>
<p>比如说我现在想的到js-online-private这个bucket里的”9.29TB”这个值，如图：<br><img data-src="/images/%E9%87%91%E5%B1%B1%E4%BA%91SDK1.png"></p>
<p>使用adk之前，需要先<code>pip install ksc-sdk-python</code>，整个脚本内容如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- encoding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> kscore.session <span class="keyword">import</span> get_session</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment">#密钥</span></span><br><span class="line">ACCESS_KEY_ID = <span class="string">&quot;这里填写帐号ak&quot;</span></span><br><span class="line">SECRET_ACCESS_KEY = <span class="string">&quot;这里填写帐号sk&quot;</span></span><br><span class="line">s = get_session()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gettodayoss</span>():</span><br><span class="line">        client = s.create_client(<span class="string">&quot;monitor&quot;</span>,<span class="string">&quot;区域名称&quot;</span>,ks_access_key_id=ACCESS_KEY_ID, ks_secret_access_key=SECRET_ACCESS_KEY)</span><br><span class="line">        m=client.get_metric_statistics(InstanceID=<span class="string">&quot;这里填写bucket名&quot;</span>,Namespace=<span class="string">&quot;ks3&quot;</span>,MetricName=<span class="string">&quot;ks3.bucket.capacity.total.sd&quot;</span>,StartTime=<span class="string">&quot;2017-10-22T10:00:00Z&quot;</span>,EndTime=<span class="string">&quot;2017-10-23T11:00:00Z&quot;</span>,Period=<span class="string">&quot;86400&quot;</span>,Aggregate=<span class="string">&quot;sum&quot;</span>)</span><br><span class="line">        data=json.dumps(m,sort_keys=<span class="literal">True</span>,indent=<span class="number">4</span>)</span><br><span class="line">        <span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">        gettodayoss()</span><br></pre></td></tr></table></figure></p>
<p>执行效果如图：<br><img data-src="/images/%E9%87%91%E5%B1%B1%E4%BA%91SDK2.png"></p>
<p>单位换算一下：<br><img data-src="/images/%E9%87%91%E5%B1%B1%E4%BA%91SDK3.png"></p>
<p>metric支持如下几个参数:<br>	ks3.bucket.capacity.total： 总容量（存储量）<br>    ks3.bucket.capacity.add：增加容量（存储量）<br>    ks3.bucket.capacity.del： 删除容量（存储量）<br>    ks3.bucket.flow.up： 上传流量（外网）<br>    ks3.bucket.flow.down：下载流量（外网）<br>    ks3.bucket.bandwidth：下载带宽<br>    ks3.bucket.getcount： get次数<br>    ks3.bucket.putcount：put次数</p>
<p>这里有几点注意！</p>
<p>1）密钥一定是要填写帐号的ak&#x2F;sk，而不是云存储权限的ak&#x2F;sk，我也知道这样填写权限过大，是一个很危险的事儿，但是没办法，金山云就是这么设计的；<br>2）查看云存储的话，区域名称一定要写cn-beijing-6，因为ks3的监控数据都在北京存储；<br>3）StartTime和EndTime之间一定要大于24小时；<br>4）金山云的云存储统计跟阿里云的云存储统计一样都是有延迟的，不过金山云的延迟是一天，也就是说StartTime和EndTime要至少写昨天的；</p>
<h2 id="新的知识点"><a href="#新的知识点" class="headerlink" title="新的知识点!"></a>新的知识点!</h2><p>例子脚本获到的是一个json的数据结构，那么如何从那一大串内容里得到sum这个值呢？</p>
<p>json的数据结构其实是一个str类型，而它基本上是key&#x2F;value的，这个类型在python里就是字典，那么就应该有字典的方式去读取。</p>
<p>将json转化成字典类型，一般来说用json模块的read方法。</p>
<pre><code><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=json.read(data)</span><br></pre></td></tr></table></figure>
</code></pre>
<p>如果发现使用read方法出现了“AttributeError: ‘module’ object has no attribute ‘read’”这个错误，那么就改成loads方法：</p>
<pre><code><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=json.loads(data)</span><br></pre></td></tr></table></figure>
</code></pre>
<p>那么返回来看一下我们得到的这个<code>json</code>字符串，它最外的一层是<code>getMetricStatisticsResult</code>，然后<code>datapoints</code>，再然后<code>member</code>，然后就是两个值，分别是<code>sum</code>和<code>timestamp</code>，而我们要的是<code>sum</code>。于是乎，经过这一层层好像剥洋葱的过程，要得到sum这个值结尾处应该这么写：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data=json.dumps(m,sort_keys=<span class="literal">True</span>,indent=<span class="number">4</span>)</span><br><span class="line">today_storage=json.loads(data)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;today:&quot;</span> +  today_storage[<span class="string">&#x27;getMetricStatisticsResult&#x27;</span>][<span class="string">&#x27;datapoints&#x27;</span>][<span class="string">&#x27;member&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;sum&#x27;</span>]</span><br></pre></td></tr></table></figure><br>	<br>这样得到的就是单纯的sum值了，如图：<br><img data-src="/images/%E9%87%91%E5%B1%B1%E4%BA%91SDK4.png"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>金山云</tag>
      </tags>
  </entry>
  <entry>
    <title>动手做一个网络简历并且保存成PDF</title>
    <url>/2018/03/02/%E5%8A%A8%E6%89%8B%E5%81%9A%E4%B8%80%E4%B8%AA%E7%BD%91%E7%BB%9C%E7%AE%80%E5%8E%86%E5%B9%B6%E4%B8%94%E4%BF%9D%E5%AD%98%E6%88%90PDF/</url>
    <content><![CDATA[<h2 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h2><p>服务器:<code>nginx</code><br>浏览器:<code>firefox</code></p>
<h2 id="制作网页简历过程"><a href="#制作网页简历过程" class="headerlink" title="制作网页简历过程"></a>制作网页简历过程</h2><p>首先先下载简历的模板文件，过程如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wget <span class="attr">http</span>:<span class="comment">//labfile.oss.aliyuncs.com/courses/624/cv-template.zip</span></span><br><span class="line">unzip cv-template</span><br><span class="line">mv cv-template<span class="comment">/* .</span></span><br><span class="line"><span class="comment">rm -rf cv-template* __MACOSX*</span></span><br></pre></td></tr></table></figure></p>
<p>然后在浏览器里的地址栏里输入<code>服务器外网IP</code>，就可看到下面的界面，如图：<br><img data-src="/images/jianli.png" alt="paradin"></p>
<p>我们发现这个界面是可以编辑的，于是就在前人的基础上修改即可，这里感谢前人栽树！！！</p>
<p>但是修改了并不是就保存了，如果你刷新这个界面发现又变成了初始的界面。所以这个时候我们要把修改过的网页的前端代码拷贝下来。</p>
<p>在firefox浏览器的<code>配置</code>里选择<code>WEB开发者</code>，如图：<br><img data-src="/images/jianli5.png" alt="paradin"></p>
<p>然后选择<code>查看器</code>：<br><img data-src="/images/jianli1.png" alt="paradin"></p>
<p>这个时候在页面就出现了整个网页的代码，选择<code>复制</code>—<code>HTML外面</code>：<br><img data-src="/images/jianli2.png" alt="paradin"></p>
<p>然后把这个html代码拷贝到nginx服务器里的<code>index.html</code>里覆盖原有的内容，再重新刷新浏览器，就会成为已经保存过的界面了！<br><img data-src="/images/jianli6.png" alt="paradin"></p>
<h2 id="将网页保存成PDF"><a href="#将网页保存成PDF" class="headerlink" title="将网页保存成PDF"></a>将网页保存成PDF</h2><p>在浏览器里的<code>配置</code>里选择<code>打印</code>，然后现在<code>页面设置</code>里的勾选<code>打印背景（颜色和图片）</code>再修改一下<code>页眉和页脚</code>。再点击打印，默认情况就会保存成<code>PDF</code>文件了。<br><img data-src="/images/jianli4.png" alt="paradin"><br><img data-src="/images/jianli3.png" alt="paradin"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://segmentfault.com/a/1190000006820290">https://segmentfault.com/a/1190000006820290</a></p>
<p><img data-src="/images/guangmei1.gif" alt="paradin"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>十六年，九个队，一份爱</title>
    <url>/2018/02/07/%E5%8D%81%E5%85%AD%E5%B9%B4%EF%BC%8C%E4%B9%9D%E4%B8%AA%E9%98%9F%E4%BC%8D%EF%BC%8C%E4%B8%80%E4%BB%BD%E7%88%B1/</url>
    <content><![CDATA[<p>原文地址：<a href="https://www.theplayerstribune.com/caron-butler-retiring/">https://www.theplayerstribune.com/caron-butler-retiring/</a></p>
<p>我妈第一次坐飞机的时候可真心把她吓得不行，我想她那时候肯定对Pat Riley有一些悄悄的不满。</p>
<p>那是2002年NBA选秀后的一天，我们乘Pat Riley派来的球队机飞翔在30000英尺的高空，从威斯康辛出发到佛罗里达的迈阿密热火队报到。我现在一闭上眼也能想起当时我妈妈Mattie坐在一个宽敞的椅子里，时而看看我时而看看窗外，前后张望的样子。她的脸上交织出坐飞机的恐惧，但又很自豪的复杂表情。</p>
<p>“这整个飞机只为我们几个服务的么?”她简直难以置信，要知道整个飞机上的乘客只有我、我的家人和两个热火队的工作代表。</p>
<p>我其实也是觉得如此的不可思议，但是我要管理好自己的神态，让自己显得比较酷。我坐在的位置上，平复自己的心情，保持正常的呼吸。球队代表给我展示了属于Alonzo Mourning和LaPhonso Ellis的专位，这看上去太梦幻了。</p>
<p>我对我母亲说“这一切太梦幻了”。</p>
<p>我一直在告诉我自己，现在我已经是热火队的一份子了。不是我吹牛，我也曾经在康大的时候也坐过飞机去打比赛，但是从来没做过头等舱，这在那个时刻我就坐在这架专机比头等舱还要牛逼的地方。那是Pat Riley级别的仓位。我一直让自己尝试冷静，“Caron，冷静，你很棒，你是个爷们，你要表现的就像以前那样从容。”</p>
<p>当我回忆起来当时的情景，觉得实在太滑稽了。我一直试图去安抚我那位紧张的老妈，而其实我内心的紧张不比她少多少。</p>
<p>这就是16年前我去迈阿密热火队报到的情景，从此开始了我的NBA生涯。如果那时候你跟我说我要在十多年的职业生涯里为9个队伍打球，我想我的表情会跟当时飞机上我的老妈一样。</p>
<p>但是事情就这么发生了，顺其自然，这16年真是一段棒极了的旅行。而今天，我宣布正式从NBA退役。</p>
<p>你知道，我其实很想写一封信给年轻时候的自己，不过我想12岁的我应该压根不会理会这封穿越时空的信。如果他发现信封里没有钞票，可能就会直接把它扔进垃圾桶里。然后会嘲笑我现在的光头并且补上一刀“哥们，你真老”。</p>
<p>但我现在就想告诉你那些让我NBA梦成真的人和故事。而这一切的一切都要从当时热火队总裁Pat Riley开始。</p>
<p>我出生在威斯康星州的拉辛，在18岁之前我没有踏出过那里半步，不过我有听说过芝加哥，也见过有人在迈阿密的海滩上放风筝。除了康涅狄格州那两年，拉辛就是我的全部。大城市？我只有在电影和电视里看到他们的样子。</p>
<p>然后就是参加NBA选秀，不久我就接到Pat Riley总裁的电话，然后我成了迈阿密的一份子，那一切的一切彷佛是发生在我身体之外的。我觉得我可牛逼了，你知道么？我那时候简直是全世界最幸福的人，我准备把人生最好的青春时光投身于职业篮球，我要让家族骄傲，要让整个拉辛骄傲。</p>
<p>但我第一天踏进热火队训练馆的时候迎接我的不是派对，生活也不想在海边抽雪茄那么潇洒，迎接我的是“你的更衣间在这里，你迟到了，你应该早来一个小时的，明天开始训练，对了，你叫啥来着？”</p>
<p>这就是我到训练馆听到的第一句话，这就是热火给我的第一感觉。它让我停止了“从专机到专车，全家在迈阿密的豪华旅行，每个人都以我为豪”的感觉，开始了真刀真枪的训练—-我看到Pat Riley就站在训练场场边，他手上带着总冠军戒指，他很正经的跟你说，马上去好好训练或者从训练馆出去。</p>
<p>迈阿密的纸醉金迷让很多年轻人迷失，不过那种夜生活对我没有什么侵蚀力。我14岁的时候就有了我第一个儿子，我年少的时候可没少蹲过号子，记得我16岁的时候，警察曾经在我学校的储物柜里搜出来了毒品和手枪，我也被拘留了一段时间。我出自黑人街头，小时候经历了很多哥们朋友死掉。所以我没有期待过什么幸福温暖的日子，那时候，篮球是我唯一守护的东西。我尽力的不让那些声色犬马去分散我的注意力。</p>
<p>不过那时候我毕竟还是一个小孩，虽然我心态还算端正，但是我却不知道如何百分百的把精力都投入到训练里去。</p>
<p>最开始的几个月对于我整个职业生涯来说是非常重要的，热火队从一开始培养我的比赛观和胜负观，你把它想像成是一个称之为愿望也好，意志力也好，反正就是一个坚定的信念，我想正是这个信念让我能在NBA待这么久。我们为热火队打球，为Pat Riley总裁和Stan Van教练卖命。他俩教会了我如何正确的身体训练，正确的战术训练，叮嘱我们正确的去准备比赛，告诫我们细节决定成败。而这些都是你每晚在TNT直播中看那些NBA球员时所看不见的。</p>
<p>幸运的是，我很早就领悟到“天赋并没有你想象的那么重要”这个道理，当然，有天赋肯定很赞，但是如果你在比赛里倾尽所有、全力以赴，哪怕你的对手比你能跳能跑，但是你也有很大的几率赢球。钻研，不断地打磨技术，这才是赢球的不二法则。如果有人说“在NBA这么高水平的比赛里，基本功并不是重要”，这话简直就是痴人说梦。</p>
<p>Pat Riley教练会以各种不同的方式教我事情，我永远不会忘记他会在我的更衣柜上留下字条，我会在训练前看到这些字条，上面有些写的是我技术上缺陷和需要进步的地方，有些写的是励志的话语。那虽然只是简单的一两句话的便条，但是每一句话都对我有着绝大的影响，这就是我跟我篮球教父之前所建的秘密联系通道—用我们自己的语言去彼此沟通，正是这每一张字条让我成为了一个更好的篮球选手。多年之后，我转会去了雷霆队。我开始效仿当年Pat Riley给我留字条那样的给Kevin Durant留字条，KD是我的小兄弟。我很惊讶和感激在他的MVP的获奖演讲里他特别提到了这个事儿。但是我看来，我只是做了我的篮球恩师Pat Riley做的事情。</p>
<p>第二年，当我得知被交易去湖人队的时候，我很受伤，我以为Pat Riley跟我在篮球层面的之间是有特殊关系的。我的意思是说，如果我当时在Pat Riley的位置上也会把自己拿去交易Shaq的。如果你看着镜子中自己，然后说你比Shaq对这个队伍更有价值，那我无话可说，因为我实在不想打击你的自尊心。</p>
<p>不过那种失落并没有持续很久啦，这就是在联盟里生存的学费。就像我前面说的，我在拉辛住了十多年，我也希望终老迈阿密。我还记得跟D-Wade、Brian Grant、Eddie Jones、Alonzo这些家伙一起打球的日子，那是一段令人难以置信的学习经历，我会永远记得和那些家伙一起玩的开心时光。但是这就是生意，不久后我就动身出发去洛杉矶报到，身边的人从Dwyane Wade变成了Kobe Bryant，Dwyane Wade是我的铁哥们，但是这个世界也没几个人会拒绝跟Kobe联手。当我到了洛杉矶也就大约一周的时间吧，当初到迈阿密的紧张感觉被我忘个干净。</p>
<p>我仅仅在湖人效力了一个球季就被交易去了华盛顿奇才，有趣的是，那个交易对我来说没什么伤害。我认为那是一个很好的决定，当时的奇才队有很多年轻的充满天赋的选手，我很高兴有机会成为他们的一员。</p>
<p>华盛顿的六年是我一生中最棒的时光，在奇才队我两次入选全明星赛。我和Antawn Jamison、Brendan Haywood、以及当时还没有称呼自己是“Hibachi”的Gilbert Arenas在东部打出了一片天,我永远记得华盛顿人民是多么的热爱那支奇才队。纵然迈阿密和洛杉矶都是超级大城市，但是华盛顿却是我职业生涯效力时间最长的地方，那是我第二个篮球之家。<br><img data-src="/images/caron1.jpg" alt="paradin"></p>
<p>交易帮助我学习到了篮球生意的真相，我不论到哪个球队，都试图在训练里做一个榜样，就用当初在迈阿密学到的那套。我在健身房里专注训练，总是要求自己做的更好，总是要求自己记住细节。在每一支队伍里我都与队友们打成一片，我的意思是，换做是你整天跟这帮队友们泡在一起，如果你不是太拘谨的话，会很容易融入这个集体的。</p>
<p>不过我毕竟辗转了九个城市，这漂泊的生活对我的家庭来说是很困难的。要知道，我那时仅仅在菲尼克斯就待了一个月左右的时间，我的妻子Andrea又不得不收拾行李搬家去下一站，所以我的孩子们总是在不停的转学转学。我妈–她一直以我为荣，即使我不是比赛中的MVP，但是只要我命中投篮但是没有拿下比赛最佳球员她都会在场边不爽（谢谢你，老妈）。但我也深知，为了我的篮球生涯，其实我的家庭牺牲了很多。</p>
<p>我现在感谢上苍，我依旧活着，这简直是一个奇迹。我现在想谈谈生与死，上周，我回拉辛去参加一个葬礼，那是一个26岁的小伙子，从他的车上逃离的时候被警察连开数枪。我本人不认识他，但是我理解那种感觉。因为我和那些在拉辛长大的朋友，我们都知道死亡随时都降临的恐惧感。我深深地理解被困在那里是一种什么滋味，我很幸运我走出来了。我知道那些被杀或者误入歧途的人没有离开那座城市。我参加过很多个葬礼，那很难受。不过很奇怪，在生活中你会像我一样已经达到了一定的高度，当周围人告诉你你已经挺过来了，你也会想“我真的做到了”，就是这样，但是并不是那么简单。我想我还是回回到家乡来看看的，以后也常回来。</p>
<p>对于现在的我来说那些拉辛的孩子就跟曾经的我一样，我也出生在这里，我也曾经是拉辛的孩子，我也做过各式各样的蠢事。但是我从中交了学费，要知道从教训里学习的确不是一个容易的事儿，我花的时间比我母亲期望的时间要长，但是我最终还收获了经验。一旦我有一个目标，就要付出全部，我不想让那些相信我的人失望。我能拥有如此多的东西，我已经很知足了。</p>
<p>文章的最后我想说几个人，这可能会像是一连串名单，毕竟我在联盟里摸爬滚打了这么多年，肯定有很多人要去感谢，如果我忘记了提到某人，那请准许我提前道歉。</p>
<p>在我开始第一场NBA比赛之前，我的妻子就对我说无论我去哪里她都会跟着，这么些年，她一直信守当初的承诺。这辈子讨到她做老婆真是我的福气，无论是现在还是将来她都会是我生命里最棒的那部分。</p>
<p>感谢BJ Evans、Rob Wilson、Tim Donovan、Andy Elisberg、Jay Sabol、Marjie Kates、Shivani Desai、Tim Grover 和整个Arison家族在我职业生涯初期给我的帮助。</p>
<p>我要感谢Buss 家族、Mitch Kupchak、Magic Johnson、Alison Bogli和Eugenia Chow在洛杉矶给我的支持。</p>
<p>感谢Ernie Grunfeld、Milt Newton、Tommy Amaker、Sashia Jones、Candace、Susan O’Malley在华盛顿给我的帮助。</p>
<p>感谢老板Mark Cuban和主教练Rick Carlisle在达拉斯给我的帮助。</p>
<p>还有我在快船队的队友们：Blake Griffin、DeAndre Jordan、CP3–正是你们让我从重伤中走出来，重获新生。<br><img data-src="/images/caron2.jpg" alt="paradin"></p>
<p>Matt Barnes、Lamar Odom、Chauncey Billups还有我的偶像Grant Hill，我不会忘记跟你们一起的那段日子。</p>
<p>我一直都梦想能穿着雄鹿队的队服打球，感谢John Hammond和Senator Kohl，你们圆了我的梦，说实话在家乡打球的感觉真好！谢谢你们。</p>
<p>在雷霆队，我要感谢总经理Sam Presti、KD和Russell Westbrook。</p>
<p>在活塞队，我要感谢Tom Gores，而且在底特律能跟Stan Van重聚，并且与我的哥们Andre Drummond、Reggie Jackson和Caldwell-Pope一起打球。</p>
<p>Vlade Divac，是你在2016年给那个躺在沙发里以为生涯到此结束了的我打了电话，让我再去国王队跟Rajon Rondo和DeMarcus Cousins打了一年球。</p>
<p>还有一个需要特别说的，那就是刚刚去世的我永远的哥们Rasual Butler，我俩同一年进入联盟。像我一样，Rasual Butler也是一个辗转多队的浪人，但他身上有我敬佩的一切特征—勤奋、专业、积极、体育精神。他是一个人民交口称赞的好队友。哥们，NBA的家人们会想你的。</p>
<p>我的粉丝们，你永远不会知道你们曾经带给我的快乐。谢谢你们的支持!我希望每当你想到Caron Butler这个名字的时候，你会记得我曾经是多么的热爱和尊重比赛，我也希望你们会记住我付出所有时的那个形象。我知道这是一个陈词滥调，但那个形象对我来说要比比赛还要重要–这让我可以去面对一个严峻的未来。</p>
<p>我现在仍然会深深地回想起2002年那次飞往迈阿密的情景，当时我和我的家人在热火队的飞机上—不是因为昂贵或奢侈，也不是因为我第一次去海边。而是因为那是我一生中第一次真的感觉要去某个地方。</p>
<p>在NBA打球是我的梦想，我和所有这些伟大的教练和队友们一起度过了这16年，那是一段比我想象的要好的时光。我虽然身体已经不适合打NBA的比赛，但是篮球依旧在我的生活里，我会以另外的一种形式继续跟它在一起。</p>
<p>我只想让你们都知道我拥有我自己的生命，但正是有了你们的帮助，这个生命才活的如此多姿多彩。<br><img data-src="/images/caron3.png" alt="paradin"></p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>NBA</tag>
      </tags>
  </entry>
  <entry>
    <title>唠唠全链路压测之前的事儿</title>
    <url>/2020/03/09/%E5%94%A0%E5%94%A0%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B%E4%B9%8B%E5%89%8D%E7%9A%84%E4%BA%8B%E5%84%BF/</url>
    <content><![CDATA[<p>全链路压测是一个比较牛逼的活儿，它可以直观的反应你的平台整条链路在设定的压力下哪个环节是瓶颈。但是它并不是一个人就能完成的事儿，整个全链路压测的过程是“开发+DBA+测试+运维+客服”等等工种集体努力去搞定的。这篇文章主要讲的是全链路压测前应该做哪些准备。而我们的视角就是大促负责压测的PM出发的。</p>
<p>这篇文章的前提就是你要大概明白“全链路压测”是一个怎么回事，用简单的话说，就是DBA或者其他模型人员去做效仿历年大促的真实数据做了一个假数据，然后把这些脱了敏的假数据一股脑再发到平台里，从页面到购物车再到下单再到分单和发货，从头模拟完整的一个大促过程。</p>
<p>既然如此就可知，全链路压测前的重点就是“压测影子数据”的准备。一般来说，大促KO（kick-off）会上会有主PM（主负责人)会在PPT里宣布本次大促重要事项，比如大促前会有几次全链路压测，封网几时开始几时结束，预案何时录入完毕等等核心问题，这里面还有比较重要的点，那就是“交易量级”，比如是20：20：10，这串数字的意思就是<code>主平台订单量：下单成功量：付款成功量</code>，单位是<code>万/秒</code>。</p>
<p>KO会上，主PM还会展示本次大促的时间轴，那么压测的PM就要依据这个总时间轴做一个自己的压测时间轴，如下：<br><img data-src="/images/%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B%E6%97%B6%E9%97%B4%E8%BD%B4.png" alt="akb48" title="实际中都会至少两轮压测"></p>
<p>有了这个时间轴，压测PM就要按部就班的完成各个时间的工作：首先在拿到量级后，压测PM就要去联系各位产品经理，咨询他们的业务是否要参与本次大促，比如“汽车配件是否要参与？水果生鲜是否要参与？国际商品是否要参与？”等等，一般来说，这个事情要贴合实际，比如现在疫情影响，很多线下的交易受到了影响，那么可能线下的服务就不会参与到本次大促里。</p>
<p>现在直播带货也成了一种新的电商玩法，那么如果有这个需求，还要评估一下直播间的量级—名气网红的直播间能同时支持多少在线量？这种业务也是在压测范围里的。</p>
<p>产品经理此时会回压测PM一个答复，“我所负责的业务会&#x2F;不会参加本次大促，大概的峰值QPS是XXX”，此时压测PM会根据产品经理的峰值QPS以及交易量级，自己从历史的数据订单里模仿一个数据模型，一般来说这个数据模型的背后是一整套相当复杂的算法，每个公司都会有自己的绝密算法和对应的格式，这个加工出来模型即要符合之前例子里“20-20-10”的大方向，也要满足各业务经理的要求。比如这个模型可能是“汽车产品3w+水果生鲜2w+服装10w+书籍2w+电子产品3w”这样的一个粗略的样子，而且这个粗略样子里面也要体现出爆款商品和热款商品，当然还会涉及到<code>具体策略+服务间依赖+业务配比</code>等等等等具体的因素。这样最后的模型才是一个近似真实客户下单的状态。</p>
<p>有了这个模型当然还不够，压测的PM还需要再去麻烦产品经理，问一下本次大促有没有什么新的玩法以及特殊的专业保障。如果有了新玩法，那么开发人员就要根据这些需求去修改模块功能，如果有了专业保障那么开发人员就要跟负责稳定性的同学一起研究一下保障方案。</p>
<p>产品经理这边的资料就先告于段落，剩下的时间压测PM就要跟开发同学们泡在一起了。主要就是从开发同学的手上收集“压测目标”和“压测风险”，最好再拿到完整的业务链路图，自己摸一遍完整的链路，然后登到堡垒机上去看一下当前的负载情况、DB压力情况等等，在压测前先判断一下哪些位置可能会有瓶颈。这样梳理出一套完整的业务链路是很必要的，举一个简单的例子：<br><img data-src="/images/%E7%94%B5%E5%95%86%E6%A0%B8%E5%BF%83%E9%93%BE%E8%B7%AF.png" alt="akb48" title="博客园老张的图，侵权则删"></p>
<p>但是要注意，在梳理的时候要分清哪些模块是<code>核心业务</code>，哪些是<code>高频业务</code>，哪些是<code>边缘业务</code>。因为在平台应急的时候，核心业务不能丢，但是高频的业务是可以适当做降级的。</p>
<p>压测PM倒数第二步就要完成压测过程的具体安排，先跟运营同事确认一个月黑风高的时刻，在那个时刻客户基本都不下单了。然后规定几点几分开始正式冲击，冲击多久；几点几分开始摸高，摸高多久；几点几分开始破坏性演练等等等，这个安排需要传达到各开发手里，让他们对日程有一个了解。</p>
<p>到了压测那一天，压测PM首先要先跟安全部门和客服同学报备今晚会有全链路压测，可能线上会有一些“疑似故障”，不要大惊小怪。报备完毕后，压测PM就要通知开发做好压测的准备，比如检查“监控权限、各系统水位、操作权限”等等，真实压测开始，压测PM开闸放流，开发们就要紧盯监控大屏，通过各云厂家的api、Zabbix、ELK、zipkin、skywalking等等工具获取到模块的各个状态。而压测PM就按照自己之前的压测日程表在压测平台上进行操作，此时除非测试员工反馈线上平台核心业务崩溃了，否则就不要理底下开发的叫唤，压塌了模块没事，开发会采取应急措施—降级 or 限流。压测PM则一定要按预期坚持到结束，本来目标就是要从压测中发现瓶颈和问题，而开发需要做的就是应急操作和记录各种问题，比如“缓存被打穿了；模块日志刷太多了，磁盘爆了；降级脚本失灵了”。在整个压测结束后，压测PM就要先问开发本次的压测模型是否oK，各接口的QPS是否达到预期目标，如果开发有疑问就要针对性的调整模型。此后压测PM还要组织做压测的review，大家一起把压测中发现的问题整理一下，拿出后续的action并解决之。</p>
<p>大促一般都会安排至少2轮压测，这样可以在第二轮压测时候验证第一轮的action是否生效，同时也让开发去可以尝试一些新的压测场景。如果最后一轮压测仍有开发反馈某些链路有问题，那么可以向公司申请单链路压测，重点去压测某个场景和对应的链路。</p>
<p>本文中并没有太多技术性的东西，更多的是流程上的东西。毕竟压测这套系统的搭建可不是一篇文章能说的明白，如果要看技术的话，个人推荐有赞分享的文章：<a href="https://mp.weixin.qq.com/s/0a-Sd_fCkE2mDFzNpKxf7A">https://mp.weixin.qq.com/s/0a-Sd_fCkE2mDFzNpKxf7A</a><br><img data-src="/images/VC152.gif" alt="akb48" title="老卡特的地板流"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>电商</tag>
        <tag>全链路压测</tag>
      </tags>
  </entry>
  <entry>
    <title>升级了tomcat8，日志文件没有读权限了</title>
    <url>/2020/03/07/%E5%8D%87%E7%BA%A7%E4%BA%86tomcat%EF%BC%8C%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E6%B2%A1%E6%9C%89%E8%AF%BB%E6%9D%83%E9%99%90%E4%BA%86/</url>
    <content><![CDATA[<p>同组新来的java开发突然发现一个问题来咨询，就是他的日志监控无法被监控平台识别：</p>
<p><img data-src="/images/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%900027.png"></p>
<p>明明配置路径都正确，监控平台也能获取到他的文件名。结果上去一看发现文件都是”-rw-r—–”的权限：</p>
<p><img data-src="/images/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%900027-3.png"></p>
<p>手动使用 <code>chmod -R 664 文件路径</code>临时解决了问题，果然，监控平台拿到了文件并展示了监控项：</p>
<p><img data-src="/images/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%900027-2.png" title="数据齐全度从2个多了1个"></p>
<p>于是就怀疑到底改了啥会发生这样的事儿，果然我发现<code>grep Umask /proc/进程PID/status</code>得到java进程是0027，其他进程是0002，既然是0027，那肯定默认相关的文件也就是640。于是就定位在tomcat上，发现tomcat的catalina.sh里写了权限是0027:</p>
<p><img data-src="/images/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%900027-4.png"></p>
<p>那就简单了，在引入tomcat8的时候，将catalina.sh改成0002就解决问题。可以说tomcat8这个umask的改动就是吃饱了撑的。</p>
<p>最后补上tomcat8的官方文档：<a href="https://tomcat.apache.org/tomcat-8.5-doc/security-howto.html">https://tomcat.apache.org/tomcat-8.5-doc/security-howto.html</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
        <tag>文件权限</tag>
      </tags>
  </entry>
  <entry>
    <title>唠唠同城容灾</title>
    <url>/2025/04/08/%E5%94%A0%E5%94%A0%E5%AE%B9%E7%81%BE/</url>
    <content><![CDATA[<p>作为一个SRE，其实要面对的故障原因主要就是这么几个：</p>
<ol>
<li>基础设施</li>
<li>生产系统</li>
<li>操作人</li>
<li>操作流程</li>
</ol>
<p>既然基础设施肯定会出问题（挖断光缆、火灾等等），那么容灾这个课题是每一个SRE必须要研究的事情。不过相比较火灾这种影响面是一栋楼的，洪水+大风这种影响一片楼的天灾更吓人。</p>
<p>此时SRE就要跟基础的同学一起制定演练规则、演练机制、容灾架构和具体的演练方案，通过定期的演练可以验收如下事情：<br>● 容灾能力检验：检验集团业务线核心业务的容灾能力（恢复能力、恢复时长）；<br>● 容灾预案有效性检验：检查核心业务机房级故障容灾预案有效性；<br>● 容灾风险透视：预先透视容灾风险，降低风险转化为线上故障的的机率；<br>● 容灾应急能力提升：通过演练，提升灾难场景下业务团队的协作能力；</p>
<p>这里本文先唠唠“同城容灾”。</p>
<p>首先同城要有多个机房，而且每个机房都要投入生产，而不是一个机房工作另一个机房闲着，这要做的目的第一是对成本友好，第二是确认两个机房都是能正常接入业务流量的。</p>
<p>其次业务应该优先接入同城容灾，同时接入层aserver、数据库（三节点）、Tair（缓存主备）、中间件早已标配同城容灾能力，因此对于业务而言接入同城容灾成本是非常低的，基本上只要应用容器在双机房部署，并且将HSF服务规则和VIPServer对称调用策略都开启同机房优先即可(非必选，可通过CDR执行CS拉黑预案；能接受更长RTO可等待中间件健康检测感知断网自动收敛)。</p>
<p>那么啥样的业务优先接入呢？肯定是核心链路，比如我司是负责电商的，那么“核心链路”指用户完成“选购，下单”这条动线上所必需的界面和功能，至少包括“首页、搜索、店铺、详情、购物车、下单页、支付、订单列表与详情”等。当出现区域或AZ类型的故障时，必须保证这些功能的迅速恢复和可用，同时不断提升其他增值功能的保障能力，逐步对齐核心链路。</p>
<p><img data-src="/images/%E5%AE%B9%E7%81%BE1.png" alt="paradin" title="日常态的架构"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">入口流量按照<span class="number">1</span>:<span class="number">1</span>均衡分布到两个机房的接入层，接入层通过VIPServer获取upstream列表，并按照同机房转发以保证入口流量尽量在机房内封闭。</span><br><span class="line">应用间HSF服务调用通过HSF服务接口的同机房优先策略保证RPC流量尽量在机房内封闭。</span><br><span class="line">Notify和MetaQ：消息双机房随机收发。</span><br><span class="line">MDB定制版：应用读写本机房的集群，两个机房的集群会双向同步删除操作。这里解释一下为啥要这样，因为降低延迟，提升性能。电商里很多的秒杀、实时风控的场景，这些都是对延迟敏感的业务，所以RT不能太高。同时每个机房也可以根据负载来独立扩容，比如增加只读实例。为啥要双向同步删除操作，是为了保障数据的一致性，用户在一个机房删除数据后，若另一机房未同步删除就会有数据不一致（重复订单）的问题。</span><br><span class="line">MDB标准版：应用跨机房读写。</span><br><span class="line">LDB：主备模式，其中一个机房的应用需要跨机房读写。</span><br><span class="line">数据库：主备模式，<span class="number">3</span>节点分布在张北 NA61 NA62 NA63 <span class="number">3</span>机房，<span class="number">3</span>节点强一致数据同步，由于同城机房网络时延&lt;1ms，因此对业务几乎无感知。</span><br></pre></td></tr></table></figure>

<p>当进入容灾态的时候，就是这样了：<br><img data-src="/images/%E5%AE%B9%E7%81%BE2.png" alt="paradin" title="接入层（例如aserver）、应用层都在演练范围、Tair部分加白，xdb数据库不在演练范围。"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">入口流量由GOC统一切到非故障机房的接入层，接入层通过VIPServer获取upstream列表，并按照同机房转发以保证入口流量尽量在机房内封闭。</span><br><span class="line">应用间HSF服务调用通过HSF服务接口的同机房优先策略保证RPC流量尽量在机房内封闭。如未设置同机房优先则会出现跨机房的HSF调用超时，需要等待CS感知心跳并自动收敛或者通过CDR主动拉黑断网容器IP。</span><br><span class="line">Notify和MetaQ：故障时变成同机房收发消息；如有消费者仅在故障机房部署，此时消息会堆积，但不会丢。</span><br><span class="line">MDB定制版：应用读写本机房的集群，两个机房的集群会双向同步删除操作。故障时无需切换，网络恢复后故障机房的缓存数据会被清空。</span><br><span class="line">MDB标准版：应用跨机房读写部分会失败，命中率下降超过<span class="number">50</span>%。</span><br><span class="line">LDB：主备模式，由GOC统一切到非故障机房进行读写。</span><br><span class="line">数据库：主备模式，<span class="number">3</span>节点分布在张北 NA61 NA62 NA63 <span class="number">3</span>机房，强一致数据同步，Leader节点所在机房故障会自动切到Follower节点进行读写。</span><br></pre></td></tr></table></figure>

<p>所以说整个同城容灾的精华就是“HSF同机房优先”，这里面还有一个Config server，这个Config server也是主备的，主down机之后，备cs会立即接管集群。数据库leader心跳异常后自动切到follower也是非常重要。</p>
<p>如果是要做容灾的演习，事前需要先跟业务约定，每次的断网只会断一个机房的网，同时发布演练计划。这样避免届时断网的时候有大量报警而产生不必要的惊慌。然后组织方需要发布演练公告，让参与的业务方SRE加入沟通群，方便及时交流。大部分SRE oncall 即可，核心领域的SRE需要现场值班。</p>
<p>然后组织方开始准备工作，比如白名单和打标。在注入故障的时候，就要应用的负责人和SRE通过日志和监控链接来确认“机房切换（DNS，tair和中间件）是否成功”、“自动容灾预案是否生效”、“业务的异常日志是否有预期内的收敛”以及“业务成功率是否在预期内恢复”。</p>
]]></content>
      <categories>
        <category>大牛之路</category>
      </categories>
      <tags>
        <tag>SRE</tag>
        <tag>容灾</tag>
        <tag>稳定性</tag>
      </tags>
  </entry>
  <entry>
    <title>双十一的个人感悟</title>
    <url>/2021/11/15/%E5%8F%8C%E5%8D%81%E4%B8%80%E7%9A%84%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%82%9F/</url>
    <content><![CDATA[<p>从9月13日双十一第一次建站压测开始到11月12号24点二峰值班彻底结束，这几乎2个月的双十一大促作战就算完成了90%，只剩下复盘总结和残余问题的处理。现在回首，那这真是即痛苦又繁忙还费肝的两个月啊！从“建站应用测试-混部机器确认-建站压测-跟进压测问题-考拉压测链路打通-重点数据库中间件信息收集-各种扫描巡检-全链路验收”最后到双十一大促实战值班。当零点的时刻在长春谷看到SDP和其他应用们成功的顶住了双十一一峰和二峰的流量，无论是单机还是缓存数据库的表现都在预期内，心里还是有那么一丢丢的兴奋。</p>
<p>2021年是我第二次参与集团双十一作战，本次主要负责内容是“全链路压测”、“BU内封网安排”、“容器管控”和“大促稳定性”。相比较去年，懵逼新人的我只是一路的follow，今年的我在双十一参与的更多，主动 or 被动的交流更多，经过这些锻炼自然也学习到了更多大促和稳定性相关的知识。本篇不是一个技术性很强的文章，更多的是一些总结和个人感悟。</p>
<p>作为稳定性负责人，最怕的是就是懵，最囧的时刻就是别人问你大促相关的比较基本的信息你却答不上来的时候。首先我要熟悉整个大促的里程碑和细节安排，不仅仅是几号有压测，几号正式开卖这些粗粒度的常规时间点。“几号几点预售付定金”，“几号几点开始付尾款”，“什么时候XXX禁写结束”，“一峰的尾款期到几号几点结束”等等这些精细到小时的安排都要熟记，都跟开发同学一起对比作战手册上的时间点check预案、预热等结果。做好这些工作，当你看着作战室交易大屏的时候，突然某些流量改变了，就不会奇怪了。</p>
<p>除了这些，集团的一些内部的安排和相关流程也要熟悉，以我这两个月跟的最多的sdp为例，sdp、mic、tsp三者合一之后，sdp成为了供应链在集团交易链路的独苗，仅有的能阻断交易下单的几个应用之一。它暂时还不具备单链路压测的能力，是因为它还不具单链路压测的能力，是因为它还不具备独立制造压测数据的条件，SDP的压测数据涉及到诸多的因素：商品中心、库存优惠等等诸多依赖，所以对于SDP的功能点验证就要珍惜每一次集团交易链路压测的机会。而且在压测前明确压测范围、压测单元、压测目标，提前圈好集团各种资源，做好上通下达，制定合理的时间步骤同步到群里，同时要确认压测的影响面，比如notify交易信息会不会走到中心，会不会影响到不需要参加压测的风控链路等等，避免不必要的误伤。</p>
<p>既然是大促，那么大促链路上涉及的应用也要有一个总体的list，我从aone离线表找出来供应链online的700多个应用，按照几次集团全链路验收和618实战的时间戳，通过sunfire的api拿到他们的cpu、流量等值，与他们日常同时间段的对比，凡是脉冲时间段这几个指标有明显上涨的，以及日常也不低的应用全部被我们圈定为大促链路上的应用，将他们做成了一个xflush看板，配上各种系统指标，成为了我在高峰期间除了BUY2错误码和duct平台之外，盯屏的又一部分。</p>
<p>除了上面这些，还要学会从系统水位看深度问题，哪怕是磁盘空间不足这个最简单的事儿也可以稍微深挖一下。比如我们有一个应用是uop-hkc，它只有10台机器，在一峰之后到二峰短短几天，数据量上涨迅猛，明明31号中午已经清理干净，但是9号巡检发现磁盘已用量逼近100%，不仅让人有点奇怪，后来经开发确认，它订阅的消息太多，而且有些日志埋点是完全不必要的。而这个uop-hkc本身只是一个工具应用，不应该承担业务侧大流量消息。跟它上游应用的开发商议，先确认二峰的时候这些消息能否先降级，双十一二峰之后会去掉这些日志埋点。类似这样的小线索，可以帮助我们挖出来几个这样“不合理调用”的稳定性小隐患。</p>
<p>实战中，合理分配容器额度也是很重要的一环。大促期间稳定性出了问题无非就那么几招：duct铲除抖动容器、紧急预案和扩容硬抗等等。预案对于开发同学来说他们更熟悉，而作为容器管理者的我就要提前把容器分配好。首先要知道了解大促0点链路应用的容器分布情况：目前供应链的交易链路已经全部上云，交易链路的容器量（含混部）已经在财年初就评估完毕，而且交易链路主要的任务就是抗0点脉冲和付尾款那几百秒，他们的资源一旦通过全链路验收后就不可再动，这里的“不可再动”不是单纯的减少，是不能减少也不能增加！因为集团会对交易和导购的应用做资源编排，扩容和缩容都会对编排造成影响，所以他们不会需要也不应该需要额外的容器紧急扩容。而供应链的发货链路、逆向退款链路和库存链路，普遍都是云下机房，那么就要提前给他们准备充足的机器备用，自己手里也握有公共资源池以防其他链路上的不测，同时安全生产同学时刻关注系统水位，一旦出现了预期之外的fullgc这样短时间内无法通过发布修复的问题，就直接Normandy扩容缓解达到临时止血的效果。</p>
<p>身为一个名安全生产同学，除了故障应急、跟进技改风险点等常规工作之外，横向协调工作也是我的本责，这也体现了供应链BU各同学对我的信任。我这两个月跟淘系、业务平台、菜鸟、GOC、中间件、数据库、容器平台、集团SRE等BU都刷了不少的脸，跟这些同学的交流中学习了很多，这些知识可以让我对内答疑，同时从他们各平台的某些“规矩”里也感受到了他们在稳定性上花费的良苦用心。</p>
<p>安全生产的定位就是“辅助”，目的就是让开发同学能全力的投入开发同时更要保障平台高可用，工作性质肯定是又杂又多，比较累心的，但是正是这种工作更要考验我化零为整，培养规划性的能力，这样才能做好下一次的双十一！</p>
<p>现在的双十一已经不如前几年那么强劲了，由于中国生育率连年走低和网民几乎饱和，导致这个蛋糕的量基本已经确定。ToC的分母也基本已经固化，所以现在双十一面临一个转型，由曾经靠各种“九块九”的低廉甚至高仿的日用品，通过短视频直播等形式转型成单价较高的产品。其实现在三线以上城市的中国大陆人民有钱，也需要培养他们提升生活品质的心智，那什么东西会提升生活品质呢？无疑就是电器—一个新手机、一个新电子书、一个switch、一个扫地机器人、一个按摩仪等等等等。那么维持当前的客户“分母”不变，同时增加他们在中高价钱上的消费，就是提升GMV的又一个好办法。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>大促</tag>
        <tag>方法论</tag>
        <tag>安全生产</tag>
      </tags>
  </entry>
  <entry>
    <title>京都大阪神户四月三地樱花行</title>
    <url>/2024/04/08/%E5%9B%9B%E6%9C%88%E5%A4%A7%E9%98%AA%E6%A8%B1%E8%8A%B1%E8%A1%8C/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>话说这是我第三次去大阪了，也是我两年内第二次去大阪，比我回老家次数都多了一次。</p>
<p>原本我是想去富士山的，但是杭州去东京的飞机班次很少。我做了很多个攻略比较了很多价格，发现都不行。无论是上海去东京，还是杭州去东京，还是“东进阪出”，还是“阪进东出”。毕竟如果住在大阪，坐高铁到富士山就要5个小时左右，这一来一回就要几乎10个小时！所以只能还是老老实实的选择了这次“大阪-京都-神户”的樱花之旅。开始心情还是有点小不爽，但是真去了发现樱花之旅还是很不错的，真香！</p>
<p>首先，订了票和酒店之后还是要做visit japan web的登记，到时候出关直接扫码搞定就不用手动填卡了。这次我没有带很多日元现金，因为无论是支付宝还是微信，扫6次之后就会升级，然后会拿到更加棒的汇率，所以平时喝水买零食就在他们的7-11和lawson扫码就好了，然后买大件的时候就用好的汇率结账，这样立省两杯星巴克的钱。</p>
<p>我在klook上买了从关西机场到京都站的haruka的车票（2个人216人民币），神户动物王国的门票（2个人212人民币）还有从难波返回关西机场的rapi:t的车票（2个人128人民币）。klook上的订票业务范围还挺广，可以订到足球赛的门票，不过可惜我们这次的计划里没有赶上神户胜利船和大阪钢巴的主场比赛，就无法现场感受了。<br><img data-src="/images/klook%E7%9A%84%E8%AE%A2%E5%8D%95.png" alt="paradin" title="klook还是挺靠谱的，而且支持支付宝"></p>
<h2 id="行程安排"><a href="#行程安排" class="headerlink" title="行程安排"></a>行程安排</h2><p>Day 1: 4月1日，中午从萧山机场出发，搭乘的是长龙航空。别看长龙航空飞机小，但是架不住飞得快。这次去和返回我都买的长龙航空，都比预期早到了30mins。这次出关的时候发现人好多，排队大约50分钟左右才出关。然后就拿着klook买的haruka的二维码去jr的机器上按照youtube的up主提供的教程操作拿纸质车票。但是发现机器的界面跟YouTube的视频里不一样了，就又折腾了一番，话说haruka换票还是挺麻烦的，它需要用二维码先扫一下，然后得到一个是票据然后一个是使用券，再插入使用券换出来对应的车票。这样拿到票了之后就出发去京都。</p>
<p>从关西机场到京都搭乘haruka大约70分钟，haruka是国内高铁二等座的水平。京都站很大，是京都当地的地标建筑之一，这里的老外就超级多。西亚的，欧洲的，非洲的反正各种肤色大杂烩在这里，可见京都的樱花季和寺院文化还是很受全世界的认可。酒店check-in之后，去吃“本家第一居”的拉面，网上看了攻略说此店营业到凌晨1点。但是去的时候发现这家在装修，就只能在京都站里随便找了一个店简单填饱肚子然后在京都站里逛了逛。<br><img data-src="/images/%E4%BA%AC%E9%83%BD%E5%A1%94.jpeg" alt="paradin" title="夜晚的京都塔"><br><img data-src="/images/%E4%BA%AC%E9%83%BD%E7%AB%99.jpeg" alt="paradin" title="这个大广场我上次来还坐在大台阶上听了交响乐"></p>
<p>Day 2:4月2日，当天早上吃了点面包就出发去了岚山，在岚山吃了新渡月拉面，话说这个拉面排队方式很有意思：你需要把你的名字写在门口的本上，然后服务员叫到你的名字就进去，过号就不算数了。所以你就会在门口听到日本店员喊着各种各样英文名韩国拼音和中文拼音。里面的辣白菜凉面还不错，菜码不算大。</p>
<p>吃好了就在岚山的渡月桥及两边的公园走了走，那里的樱花也开的有五成。渡月桥附近有不少的人力车，车夫会一点基础英语，会给你介绍景点甚至为你拍照。然后还去了天龙寺和竹林小径，竹林小径其实就是墓地旁边的一片竹林，也被不少电影拍摄作为景点。<br><img data-src="/images/%E5%B2%9A%E5%B1%B1%E5%BA%AD%E9%99%A2.jpeg" alt="paradin" title="这家奶油油条是招牌"></p>
<p>岚山这里还有一个小神社叫御发神社，保佑不脱发的，虽然神社很小，但是人气挺旺。<br><img data-src="/images/%E5%BE%A1%E5%8F%91%E7%A5%9E%E7%A4%BE.jpeg" alt="paradin"><br><img data-src="/images/%E5%BE%A1%E5%8F%91%E7%A5%9E%E7%A4%BE2.jpeg" alt="paradin"></p>
<p>从岚山回来，去了本能寺，话说这个本能寺已经不是当年信长公遇难的那个地方了，原来的那个地方现在已经盖了其他的建筑。这里依旧延续了本能寺的名字，然后里面也建立了织田信长和森兰丸等人的墓碑，寺里不太大，有付费观赏的区域。<br><img data-src="/images/%E6%9C%AC%E8%83%BD%E5%AF%BA.jpeg" title="这个寺全称是大本山本能寺，岚山的天龙寺全称是大本山天龙寺，这里的大本山是一个佛教级别的意思，大本上上面还有一个总本山"></p>
<p>然后往八坂神社方向走吃了土井活鳗，这家店17点才开门，无需预约早到就先吃。我要的是“极上”套餐，鳗鱼很肥。我坐的位置还是榻榻米，需要脱鞋上炕。<br><img data-src="/images/%E9%B3%97%E9%B1%BC%E9%A5%AD.jpeg" title="鳗鱼饭其实不便宜，但是真的很好吃"></p>
<p>下一站是圆山公园看了夜樱，圆山公园在八坂神社旁边，里面有很多樱花和垂樱。还有一个夜市卖烧笋子、章鱼丸等小吃，公园里那个C位的大樱花树无疑是全场的焦点，里三层外三层的人群包围着它按着闪光灯。我们刚到的时候，酒店里的樱花预测大屏还说它只开了10%，今天到了现场发现它已经满开，亭亭如盖，在照灯下更显美丽和雍容，可见樱花真的是说开就开，一夜之间就美丽无比。</p>
<p><img data-src="/images/%E5%A4%9C%E6%A8%B1.jpeg" alt="paradin" title="非常漂亮，非常震撼"></p>
<p><img data-src="/images/%E7%9F%A5%E6%81%A9%E9%99%A2.jpeg" alt="paradin" title="从圆山公园出来就是知恩院了，当天还有法事活动"></p>
<p>从圆山公园出来一路又走到白川，然后返回京都站。</p>
<p><img data-src="/images/%E5%A4%9C%E6%A8%B12.jpeg" alt="paradin" title="白川这里的夜樱也很好看，旁边都是西餐店"><br><img data-src="/images/%E8%89%BA%E4%BC%8E.jpeg" alt="paradin" title="在白川照相还看到了艺伎"></p>
<p>Day 3:4月3日，当天下雨，一早在京都站旁边的 すき家SUKIYA 吃了一顿。<br><img data-src="/images/%E6%89%93%E5%B7%A5%E4%BA%BA%E7%9A%84%E6%97%A9%E9%A4%90.jpeg" alt="paradin" title="石原里美代言的这家店好久了，广告里她吃的很香"></p>
<p>然后从京都站去了宇治，到了宇治怎么能不吃抹茶？宇治车站附近的中村藤吉本店排队的吓人，我们去的那天下雨都排了150位。不过在去平等院的路上还有一个中村藤吉本店，店里可以看对面一个不算很宽的小河，也没啥特别的景色。不过排队的人比车站那个少多了，但是也排了很久。我一口气点了很多：<br><img data-src="/images/%E4%B8%AD%E6%9D%91%E8%97%A4%E5%90%89%E6%9C%AC%E5%BA%97.jpeg" alt="paradin" title="我几乎把那里所有能点的甜点都点了，这一顿吃抹茶吃的都发腻了"></p>
<p>然后走了几步路就到了平等院。平等院里的凤凰堂是要额外收费的，这次我没买，就在平等院里逛了逛。话说平等院面积不大，现在的建筑是一个历经战火的残存建筑上重新修葺的，但是它整体的园艺很下功夫，这也是我喜欢的地方。觉得日本的园艺搭配的很好，尤其当天还有点小雨，把绿洗的更绿。<br><img data-src="/images/%E5%B9%B3%E7%AD%89%E9%99%A2.jpeg" alt="paradin"><br><img data-src="/images/%E5%B9%B3%E7%AD%89%E9%99%A22.jpeg" alt="paradin"></p>
<p>平等院后回京都站，吃了拉面小路里的拉面，然后就去了新风馆看看日潮店，鼎鼎大名的first arrows就在那附近，话说一根羽毛要几乎小20万日元也是挺贵的，三根羽毛外加一根链子大约就要大约3～5万人民币，没钱果然当不了潮男。但是做工真的漂亮，无论是羽毛还是鹰，都是浓浓的印第安风格。</p>
<p>从新风馆出来看到了他们的小蓝瓶咖啡，顺道也逛了逛他们的北面the north face，京都的北面店不小，里面好多国人在里面买紫标。我转来转去竟然到了寺町京极，两边好多购物的店，我逛了很久，尤其是big time，那是一个三层楼的复古时装店，看的人眼花缭乱。路边还有很帅气的吉他店，可以定制各种帅气的吉他。吉他我是买不起，只能在路边摊买了还算好吃的鲷鱼烧。</p>
<p>Day 4:4月4日，起床check-out，把箱子寄存在酒店后就去了山科，山科那里是日本的普通居民区，游客很少。附近还有一个山科疏水的樱花小路，旁边有一个高中叫“京都府立洛东高等学校”，这里樱花茂盛，看到好几对台湾的情侣来这里拍结婚照。我也在这里拍了很久的照片，感受到日本高中生的年轻气息和樱花飘落到水里的美丽，中午吃的是山科站里的汉堡。<br><img data-src="/images/%E5%B1%B1%E7%A7%91%E6%A8%B1%E8%8A%B1.jpeg" alt="paradin" title="居民区附近的樱花也很好看"><br><img data-src="/images/%E6%98%86%E6%B2%99%E9%97%A8%E5%A1%98%E9%99%84%E8%BF%91%E7%9A%84%E6%A8%B1%E8%8A%B1.jpeg" alt="paradin"><br><img data-src="/images/%E6%98%86%E6%B2%99%E9%97%A8%E5%A1%98%E9%99%84%E8%BF%91%E7%9A%84%E6%A8%B1%E8%8A%B12.jpeg" alt="paradin"></p>
<p>原本还想去哲学之道，但是时间不准许了。然后离开京都，拖着箱子就冲去了甲子园，今年是甲子园球场建成100周年。在地铁站就看到100周年的海报，宣传十分到位：<br><img data-src="/images/%E7%94%B2%E5%AD%90%E5%9B%AD%E6%B5%B7%E6%8A%A5.jpeg" alt="paradin" title="各种漫画人物大集合"></p>
<p>在甲子园存储箱子价格很贵，每个要900日元！而且只支持硬币，我的硬币没那么多，只能跑到附近的7-11让小哥破钱。然后就冲进甲子园啦！<br><img data-src="/images/%E7%94%B2%E5%AD%90%E5%9B%AD%E5%A4%A7%E9%97%A8.jpeg" alt="paradin" title="今年春季冠军是高崎健康福祉大学高崎高等学校，也是他们校史第一次拿优胜"></p>
<p>当天没有比赛，我只能甲子园博物馆参观+棒球购物。因为甲子园球场也是阪神虎职业棒球队的主场，所以博物馆里前一部分是展示阪神虎队的历史。对棒球不是很了解的我都能感受到全垒打和抢垒那股燃。<br><img data-src="/images/%E9%98%AA%E7%A5%9E%E8%99%8E%E6%B0%B8%E4%B9%85%E9%80%80%E5%BD%B9%E5%8F%B7%E7%A0%81.jpeg" alt="paradin" title="这些都是永久退役号码，都是阪神虎队的上古大神"></p>
<p>经过了阪神虎的荣光历史回顾，后面就是高中棒球比赛的部分了。这里能看到历年高中棒球比赛的冠军、优秀球员和经典比赛照片，甚至还看到了台湾嘉农棒球队的故事，这支棒球队的神奇经历也被改编成了电影《KANO》。<br><img data-src="/images/KANO%E7%94%B2%E5%AD%90%E5%9B%AD.jpeg" alt="paradin" title="甲子园还特意给了KANO几个位置来宣传"></p>
<p>博物馆出来之后，看了看附近的周边店，这段时间大谷翔平实在太火了，走到哪都是他的广告，我也跟风买了一件他的周边T恤。吃了隔壁的TSUNODA MEAT黑毛和牛烤肉，然后取了箱子在心斋桥下车办理入住，晚上在心斋桥逛了逛，再一次吃了将军汉堡，嗯，还是好味道！在堂吉柯德买了一个足贴，泡过澡后贴脚底好好放松一下这几天不停走路的足。</p>
<p>Day 5:4月5日，一早起床从大阪站出发去了神户，在神户三之宫站再转空轨去了神户动物王国，在王国里面各种撸动物。<br><img data-src="/images/%E7%A5%9E%E6%88%B7%E5%8A%A8%E7%89%A9%E7%8E%8B%E5%9B%BD1.jpeg" alt="paradin" title="这个大池子的鸟是可以随便飞的，池子里还有鱼，是一个很棒的模拟生态环境"><br><img data-src="/images/%E7%A5%9E%E6%88%B7%E5%8A%A8%E7%89%A9%E7%8E%8B%E5%9B%BD2.jpeg" alt="paradin" title="好哥们站排排"><br><img data-src="/images/%E5%8D%A1%E7%9A%AE%E5%B7%B4%E6%8B%891.jpeg" alt="paradin" title="摸到了卡皮巴拉！"><br><img data-src="/images/%E5%8D%A1%E7%9A%AE%E5%B7%B4%E6%8B%892.jpeg" alt="paradin" title="卡皮巴拉的毛是硬的，然后很呆萌"></p>
<p>不知不觉撸了3个小时的动物，里面的动物还是不少，而且能放出来跟人类互动的都放出来了，还有定时的动物表演。</p>
<p>原本还想去须磨海边吹吹海风，但是时间来不及了。去吃了nick meatshop，他家的牛排还不错，默认是7分熟的样子。出来路过了堂吉柯德就逛了一圈，然后意外发现一个足球店kamo，逛了一圈拍了不少照片，原本打算计划去三田outlets由于太远了也放弃了，要从三之宫站坐1个小时长途车，来回就2个小时。于是改回大阪心斋桥，买下了一款心心念念许久的canada goose，原本打算去吃日航酒店下面的但马屋，但是它是完全的预约制。于是改吃了隔壁的 きんのぶたPREMIUM 寿喜烧自助，我买的是7500随便吃的票，意外的吃的大满足！我好像吃了有十盘和牛，外加很多鲷鱼烧和烤鳕鱼，而且服务员态度十分好，让人感受到了尊贵。最后心斋桥附近走走消食。<br><img data-src="/images/%E4%B8%AD%E5%9B%BD%E5%BB%BA%E8%AE%BE%E9%93%B6%E8%A1%8C.jpeg" alt="paradin" title="意外的发现了一家国企！"></p>
<p>Day 6:4月6日，新闻里说大阪城的樱花满开。于是早上看天气晴朗就去了大阪城，果然人山人海，樱花盛开。眼睛看了个饱，爽！<br><img data-src="/images/%E5%A4%A7%E9%98%AA%E5%9F%8E%E6%A8%B1%E8%8A%B1.jpeg" alt="paradin"><br><img data-src="/images/%E5%A4%A7%E9%98%AA%E5%9F%8E%E6%A8%B1%E8%8A%B12.jpeg"><br><img data-src="/images/%E5%A4%A7%E9%98%AA%E5%9F%8E%E6%A8%B1%E8%8A%B13.jpeg"><br><img data-src="/images/%E7%88%B8%E7%88%B8%E7%BB%99%E5%A5%B3%E5%84%BF%E7%85%A7%E7%9B%B8.jpeg" title="最近好像是当地各年级学生的入学季，很多一家三口都穿着黑色正装来公园照相"></p>
<p>然后去了梅田逛街购物，中午吃了阪急32番街的鹤桥风月大阪烧。<br><img data-src="/images/%E5%A4%A7%E9%98%AA%E7%83%A7.jpeg" title="大阪烧这玩意下限还是很高的"></p>
<p>吃饱饱后买了lululemon，天猫上850的裤子卖660左右。又去看了堂吉柯德的梅田店和kamo的梅田店，这次拿下了巴塞罗那本赛季的球衣，天猫上599，我是花了6600日元左右，可惜这个衣服没有背号。在店里也拍了不少店里的精品：<br><img data-src="/images/%E6%A2%85%E8%A5%BF%E7%AD%BE%E5%90%8D%E7%90%83%E8%A1%A3.jpeg" title="梅西签名球衣是这家店的镇店之宝！"><br><img data-src="/images/%E5%8A%B3%E5%A1%94%E7%BD%97%E7%AD%BE%E5%90%8D%E7%90%83%E8%A1%A3.jpeg" title="据说这个是劳塔罗在国米日本行的时候签的"><br><img data-src="/images/%E5%AF%8C%E5%AE%89%E5%81%A5%E6%B4%8B%E7%90%83%E8%A1%A3.jpeg" title="富安健洋也是这里的爆款"></p>
<p>逛了一大圈，不知不觉到了晚饭时间，很想吃一兰拉面，就近找了一家，排队了50分钟左右终于吃上了。这也是我时隔5年再一次吃到一兰拉面，没办法，道顿堀的一兰排队太吓人了，虽然营业时间24小时，但是啥时候去都要排队2小时。<br><img data-src="/images/%E4%B8%80%E5%85%B0%E6%8B%89%E9%9D%A2.jpeg" title="话说在大陆开一个一兰拉面会怎么样？"></p>
<p>饭后在梅田大阪站里的书店里简单走走随便翻翻就回心斋桥了。<br><img data-src="/images/%E4%B8%89%E4%BD%93%E6%97%A5%E8%AF%AD%E4%B9%A6.jpeg" title="网飞热播的三体再次将这本书推向了热点，同时奥本海默相关书也在书店占据了一片地方"><br><img data-src="/images/%E8%BF%9B%E5%87%BB%E7%9A%84%E5%B7%A8%E4%BA%BA.jpeg"><br><img data-src="/images/%E6%82%BC%E5%BF%B5%E9%B8%9F%E5%B1%B1%E6%98%8E.jpeg" title="龙珠一直都有销量的保证"><br><img data-src="/images/%E6%82%BC%E5%BF%B5%E9%B8%9F%E5%B1%B1%E6%98%8E2.jpg" title="书店里也有一个很大的横幅，写着悼念鸟山明先生"></p>
<p>话说这天大阪还有女优的见面摄影会，比如渚恋生等都会身着旗袍或者清凉泳衣出场，但是我这次没有买到票…<br><img data-src="/images/%E8%A7%81%E9%9D%A2%E4%BC%9A.png"></p>
<p>Day 7：趁着最后的机会把心斋桥门口的大丸百货和parco里扫了一圈，看到了里面有denham的牛仔裤在卖，但是一想这个牌子双十一打折力度就作罢了，等双十一天猫下单吧。<br><img data-src="/images/parco%E9%87%8C%E7%9A%84%E5%8D%A1%E6%99%AE%E7%A9%BA.jpeg" alt="paradin" title="可惜店里没有街霸的手办"><br><img data-src="/images/%E6%96%87%E7%8F%AD%E4%BA%9A%E9%A9%AC%E7%AD%BE%E5%90%8D.jpeg" alt="paradin" title="文班亚马的签名现在已经13万日币了"></p>
<p>最后拎着箱子去了高岛屋，高岛屋7楼可以寄存行李，购物满6000日元就是免费寄存，在高岛屋买好了东西之后。拿出klook之前买的rapi:t凭证，然后选择日期、出发时间和座位生成一个二维码，rapi:t是半小时一班车，直接扫码进高岛屋下面的难波站就行。坐rapi:t到关西机场大约40分钟，在机场免税区又买了两条烟，撤退返回杭州，结束为期六天的关西樱花之旅。<br><img data-src="/images/%E9%9A%BE%E6%B3%A2%E7%AB%99.jpeg" alt="paradin" title="刷了二维码就能进难波站，然后9站台等rapi:t就行了，出站再刷一次二维码"></p>
<p>到家后算了算账，本次旅行大约总体消费3万左右：<br>    <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 住宿，总共<span class="number">6000</span>人民币左右：</span><br><span class="line">    京都：近铁京都站都城市酒店，主打交通方便因为就在京都站内，周边商铺丰富。缺点是不能开窗，但是隔音效果很好。不含早餐，两个单人床几乎<span class="number">15</span>平米几乎每晚<span class="number">1000</span>。</span><br><span class="line">    大阪：VIA INN心斋桥店，这是我第二次住这家店了，依旧是熟悉的感觉，含早餐，一张双人床几乎<span class="number">15</span>平米几乎每晚<span class="number">1000</span>,check-<span class="keyword">in</span>的时候还要交每人<span class="number">300</span>日元的税，浴缸比京都的要小，但是电视机的频道更有意思。</span><br><span class="line"><span class="number">2.</span> 交通，总共<span class="number">6700</span>人民币左右：</span><br><span class="line">    机票：在旅行社购买的长龙机票，<span class="number">2700</span>一个人，一共<span class="number">5400</span>。</span><br><span class="line">    高铁票：klook上购买的haruka 和 rapi:t，一共<span class="number">344</span>。</span><br><span class="line">    当地的地铁票：我们一共充值<span class="number">18000</span>日元，汇率折算大约<span class="number">900</span>左右。</span><br><span class="line"><span class="number">3.</span> 门票，总共<span class="number">392</span>人民币左右：</span><br><span class="line">    神户动物王国：<span class="number">212</span>人民币</span><br><span class="line">    甲子园博物馆：俩人<span class="number">1800</span>日元，折合<span class="number">90</span>人民币</span><br><span class="line">    平等院：俩人<span class="number">1800</span>日元，折合<span class="number">90</span>人民币</span><br><span class="line"><span class="number">4.</span> 饮食，大约花了<span class="number">5000</span>人民币左右。</span><br><span class="line">    鳗鱼饭：京都-土井活鳗    大阪-巨无霸厚蛋烧鳗鱼饭</span><br><span class="line">    寿喜烧：大阪-きんのぶたPREMIUM</span><br><span class="line">    汉堡：大阪-将军汉堡   京都-Freshness Burger</span><br><span class="line">    牛排：神户-nick meatshop  大阪-TSUNODA MEAT</span><br><span class="line">    牛丼饭：神户-すき家SUKIYA</span><br><span class="line">    大阪烧：大阪-鹤桥风月</span><br><span class="line">    甜点：宇治-中村藤吉本店   岚山-上岛咖啡店   京都-ASSEMBLAGES KAKIMOTO  京都-键善良房（他家有中文菜单）</span><br><span class="line">    拉面：大阪-一兰拉面  岚山-新渡月</span><br><span class="line">    天妇罗：京都-八坂圆堂</span><br><span class="line">    饺子：大阪-王将</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 购物，大约花了<span class="number">13000</span>人民币左右。</span><br></pre></td></tr></table></figure></p>
<h2 id="旅游小tips-感想"><a href="#旅游小tips-感想" class="headerlink" title="旅游小tips&amp;感想"></a>旅游小tips&amp;感想</h2><ol>
<li>这次去最大的感受就是日本化妆品价格现在跟国内的天猫相比，价钱上不占优势，比如这次我在梅田版急看到的e大饼或者是砍刀眉笔还有资生堂的水乳都比天猫上贵了很多。所以化妆品这些除非是国内正规渠道买不到的还可以考虑日本购买，不然还是选择天猫、京东旗舰店这样的平台吧，质量有保证还便宜。</li>
<li>日本的衣服是真便宜，我这次买了一个Canada goose，天猫要11500人民币，但是在店里只需要187000日元，支付宝扫码后实际只需要8920元人民币左右，等于打了77折。巴萨的球衣天猫价格是599人民币，在kamo买只花了8000日币，也就是400元人民币左右，打了67折。所以说要是买衣服、包这样的。还是日本买更便宜，几乎这俩就省出来我的机票钱了。不过还是建议要买某个款式的话，购买前先去官网看看是否有库存。</li>
<li>无论是京都还是大阪还是神户，有名的饭店都需要去他们的官网预约，有的甚至要提前一个月去预约，一般来说需要预约的饭店肯定味道不会差。我这次旅行没有一个是预约的，都是现场排队，排上了就吃排不上就走人，所以如果没有预约上可以关注一下我这几个选择。</li>
<li>关西机场的国际出发最近装修，飞国际的航班值机要排队很久，我是15点12到的机场，值机排队花了几乎50分钟。所以建议出发之前还是小红书什么的看一下其他人的最新攻略，千万别耽误了行程。</li>
<li>不要在甲子园球场里的商店买周边，那里不退税，去旁边的STAND IN koshien周边店，那里能退税。</li>
<li>最近日币贬值，很多人开始动心思想在日本投资房产，等将来升值赚中间差价。我觉得吧，如果有闲钱而且地段好，买也就买了。但是如果是贷款在日本买房，那大可不必凑这个热闹。</li>
<li>京都和大阪都有赛马场，下次再来选择一个有赛马的日子，就可以感受一下赛马了！而且大阪也有篮球队，B联赛人气也很火爆。</li>
<li>最近社媒上有人晒出京都垃圾很多的新闻，还说不喜欢外国游客来京都。其实我觉得这个要分清楚，如果是原本的垃圾箱满了，在垃圾箱附近扔垃圾我觉得也要体谅游客，毕竟京都的垃圾箱比大熊猫都稀奇。要让外国人出门也随身带个塑料袋装垃圾的确是一个很难时刻想起来的事儿。而且这个事情更应该是需要环卫工人勤清理垃圾箱，毕竟游客在办理签证的时候已经交了旅游税了。作为旅游城市就要靠服务业挣钱，这是很正常的。当然，如果故意不找垃圾箱直接随手扔，这种行为是要被鄙视的。</li>
<li>京都的酒店里电视竟然有CCTV-4和凤凰卫视。能想象得到我电视扫台的时候一下子听到中文的心情吗？</li>
<li>无论是京都站还是大阪站，都是非常大的商业圈，可见日本的隔音能力做的还是挺不错的（少数店能感受到火车来的时候的声音）。车站将隔音做好就会把人流量尽量充分的用于商家，但是如果隔音能力做的很差，那店铺肯定没有人光顾了。</li>
<li>京都的人文气息很厚重，我看过至少3个公共场合放一个供路人玩的钢琴，而且真的有很多行人弹的特别好。</li>
<li>在觅食的时候能明显感觉到，网络上推荐的那几家饭店里本地人很少，外国游客很多。我这次也吃了不少家饭店，目测日本当地顾客占比较高的就是すき家SUKIYA、一兰拉面和きんのぶたPREMIUM。</li>
<li>这次最大的感受就是日本当地对残疾人的友好，腿脚不便的人依旧可以轻松的出门购物，而且社会对他们也非常的包容。现在大陆的经济不景气，拉动内需只能搞什么“以旧换新”。我觉得不如就好好弄弄基建，让盲人和腿脚残疾的人也可以无忧的出门。大陆也有几千万的残疾人，其实他们渴望能像正常人一样出来享受阳光和购物，而且他们消费也是对社会做贡献啊！<br><img data-src="/images/%E6%AE%8B%E7%96%BE%E4%BA%BA%E5%87%BA%E8%A1%97.jpeg"></li>
<li>南京市民李志先生最近在日本巡演，话说他既然能安全的出国巡演，可见问题不大了，祝福他能将来带来更多好歌。<br><img data-src="/images/%E6%9D%8E%E5%BF%97%E6%BC%94%E5%94%B1%E4%BC%9A.png"></li>
</ol>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>旅游</tag>
        <tag>日本</tag>
      </tags>
  </entry>
  <entry>
    <title>国内Docker的加速方法</title>
    <url>/2018/04/20/%E5%9B%BD%E5%86%85Docker%E7%9A%84%E5%8A%A0%E9%80%9F%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>由于大陆政府的特殊政策，国内想访问一些国外的资源是非常的曲折和痛苦，比较有代表性的就是亚马逊的云存储以及docker，尤其在<code>docker pull</code>一些镜像的时候，更是心惊胆战，祈求不要出现timout，然而现实往往很骨感。如下图：<br><img data-src="/images/jiasu.png" alt="paradin"></p>
<p>那么应该如何达到加速的效果呢？</p>
<p>在<code>CentOS 7</code>里，对于使用<code>systemd</code>的系统，请在<code>/etc/docker/daemon.json</code>中写入如下内容：（如果文件不存在请新建该文件）<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;https://registry.docker-cn.com&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。</p>
<p>之后重新启动服务。<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure></p>
<p>注意：如果您之前查看旧教程，修改了<code>docker.service</code>文件内容，请去掉您添加的内容（–registry-mirror&#x3D;<a href="https://registry.docker-cn.com)./">https://registry.docker-cn.com）。</a></p>
<p>配置加速之后，如果拉取镜像仍然十分缓慢，请手动检查加速器配置是否生效，在命令行执行<code>docker info |grep &#39;Registry Mirrors&#39; -A </code>，如果从结果中看到了如下内容，说明配置成功。<br><img data-src="/images/jiasu2.png" alt="paradin"></p>
<p>现在再重新尝试一下<code>docker pull training/webapp</code>，看看效果：<br><img data-src="/images/jiasu3.png" alt="paradin"></p>
<p>仅用17秒就pull了几乎400MB的镜像，高下立判！</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>回家过年</title>
    <url>/2018/02/21/%E5%9B%9E%E5%AE%B6/</url>
    <content><![CDATA[<p>我承认我是一个很恋家的人，但是我在3年之前还不是这样。</p>
<p>我记得我在哈尔滨上大学的时候，虽然坐火车也就一个半小时的时间，但是是“能不回家就不回家”，哪怕自己一个人蹲在寝室也是自由舒服，后来上班，我也是有很长的时间自己独住，只有周末才回去一次。那时候我奶不止一次的批评我“都快成一个客人了”。</p>
<p>真的应了那句传烂了的话“只有失去的才是美好的”，现在我人在杭州，天天忙成狗。最欢喜的事情第一个是涨工资，第二个是发工资，第三个是放假，第四个就是放假回家。当初的我总是忽略家庭的温暖，在家里逗留的时间不长，现在却倍感珍惜回家的机会，唉，那几年真是简单的可笑。<br><img data-src="/images/jia5.jpg" alt="paradin"></p>
<p>这一次回家过年看到了许许多多亲人：生病的大姨夫的精神状态也好了许多，不过他这次回来又害了一次发烧；小外甥和他那婴儿肥的脸蛋，在《守望先锋》里越死越勇；我那几个弟弟们全都瘦了也更精神了，从我妈和女票看我的眼神里，我觉得我的体重是应该好好管控一下了：体型太腐败。</p>
<p>短短的六天时间，吃完三姨家吃四姨家，吃完老叔家吃小舅家，总之就是带着女票游走于各种亲戚家。中途还抽空跟龙南数据班的几个老同事一起吃了顿“一口猪”，主要也是带我女票看看东北菜，看上去我这几个老同事们都过得很不错，至少几杯酒下去均红光满面，依旧插科打屁、大呼小叫。这次过年唯一可惜的是，没有给四姨夫装上翻墙软件，害得他要继续挠墙忍耐。</p>
<p>我吃我妈的菜已经吃了30年，但是这次过年真正在家里吃饭仅仅只有一顿。我妈烧了虾，做了孜然羊肉，而且煮了酸菜馅饺子。这都是我爱吃的，杭州的确能吃到很多美味，但我妈的手艺却是独一份儿。我跟我爹依旧话不算多，但是关系却比之前好了许多倍。有可能是我现在比以前有了一点进步，让我爸看起来顺眼了一点，这一次回家没有跟我爸单独喝上酒，但是他有几顿喝的很开心。看到他俩这个年过得快乐满足，我这个做儿子的，心底涌起了最大的温暖。</p>
<p>离开家的时候，依旧是箱子沉沉，里面有爸妈装的许多东西，有给我的也有给我女票她妈的，每一个东西都是代表了他们的心思。其实家中长辈身体健康、心情愉悦，就是给我们这些在外的儿女最大的宽慰了。假期就这样结束了，我也马上要踏上回杭州的航班，希望家里所有长辈都平平安安，也希望我今年能够达到自己给自己定下的目标！<br><img data-src="/images/quanjiafu.jpg" alt="paradin"></p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>春节</tag>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title>在Django里插入paramiko实现批量操作</title>
    <url>/2019/04/15/%E5%9C%A8Django%E9%87%8C%E6%8F%92%E5%85%A5paramiko%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="背景交代"><a href="#背景交代" class="headerlink" title="背景交代"></a>背景交代</h2><p>Django:2.1.1<br>paramiko:2.4.1<br>Python:3.6.5</p>
<p>paramiko在“python批量操作”范围内占据着龙头老大的的地位，它主要就是通过IP、端口和密码登录到对应的服务器执行具体的命令。在Django页面里，我们有时候需要批量操作资产去执行同一个命令，这个时候就可以把paramiko接入到django里。</p>
<p>首先先<code>pip install paramiko</code>，然后在app所在的文件夹里的<code>models.py</code>里添加新的数据库：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line">  </span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"><span class="comment">#这里是服务器数据</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">server</span>(models.Model):</span><br><span class="line">    name = models.CharField(verbose_name=<span class="string">&#x27;服务器名称&#x27;</span>,max_length=<span class="number">50</span>)</span><br><span class="line">    inIP = models.GenericIPAddressField(verbose_name=<span class="string">&#x27;服务器内网IP地址&#x27;</span>)</span><br><span class="line">    outIP = models.GenericIPAddressField(verbose_name=<span class="string">&#x27;服务器外网IP地址&#x27;</span>,default=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br><span class="line">    port = models.IntegerField(verbose_name=<span class="string">&#x27;登录端口&#x27;</span>,default=<span class="string">&#x27;这里是SSH端口&#x27;</span>)</span><br><span class="line">    username = models.CharField(verbose_name=<span class="string">&#x27;登录用户名&#x27;</span>,max_length=<span class="number">50</span>,default=<span class="string">&#x27;这里是登录用户名&#x27;</span>)</span><br><span class="line">    password = models.CharField(verbose_name=<span class="string">&#x27;登录密码&#x27;</span>,max_length=<span class="number">100</span>,default=<span class="string">&#x27;这里是服务器密码&#x27;</span>)</span><br><span class="line">    signtime = models.DateField(auto_now_add=<span class="literal">True</span>)</span><br><span class="line">    remark = models.CharField(verbose_name=<span class="string">&#x27;甲方环境&#x27;</span>,max_length=<span class="number">255</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__unicode__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.name</span><br></pre></td></tr></table></figure></p>
<p>返回到<code>manage.py</code>这一层的目录，执行<code>python manage.py makemigrations</code>和<code>python manage.py migrate</code>，这个server表就是用来存储资产资料的。</p>
<p>整个paramiko执行的逻辑是这样的：首先在<code>paramiko.html</code>里展示所有的资产信息，同时页面有一个button按钮，点击这个button，后台开始对页面里所有的服务器执行同样的命令（这里举例执行<code>date</code>命令），将执行的结果生成一个新的页面叫<code>result.html</code>，页面跳转到<code>result.html</code>给用户展示。</p>
<h2 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h2><p>有了上面的铺垫，现在说一下paramiko在django里的具体配置。首先先在app所在的文件夹下新建一个<code>paramiko_client.py</code>的文件，内容如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time,paramiko</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> server	<span class="comment">#注意这里的.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ParamikoClient</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.client = paramiko.SSHClient()	<span class="comment">#创建sshclient对象</span></span><br><span class="line">        <span class="variable language_">self</span>.client.set_missing_host_key_policy(paramiko.AutoAddPolicy())	<span class="comment">#允许将信任的主机自动加入到host_allow 列表，此方法必须放在connect方法的前面</span></span><br><span class="line">        <span class="variable language_">self</span>.sftp_client = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.client_state = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self,sshinfo</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="variable language_">self</span>.client.connect(hostname=sshinfo.outIP,port=sshinfo.port,username=sshinfo.username,password=sshinfo.password,timeout=<span class="number">1.0</span>)	<span class="comment">#调用connect方法连接服务器</span></span><br><span class="line">            <span class="variable language_">self</span>.client_state = <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span> (e)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="variable language_">self</span>.client.close()</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run_cmd</span>(<span class="params">self,cmd_str</span>):</span><br><span class="line">        stdin,stdout,stderr = <span class="variable language_">self</span>.client.exec_command(cmd_str)</span><br><span class="line">        <span class="keyword">return</span> stdout.read()</span><br></pre></td></tr></table></figure></p>
<p>然后在<code>views.py</code>里增加如下内容：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"><span class="keyword">from</span> .paramiko_client <span class="keyword">import</span> ParamikoClient	<span class="comment">#引用上面那个文件里的ParamikoClient函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#批量操作</span></span><br><span class="line"><span class="meta">@login_required</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">paramiko</span>(<span class="params">request</span>):</span><br><span class="line">    servers = server.objects.<span class="built_in">all</span>()	<span class="comment">#获取server这个表里所有的资产信息</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;agparamiko.html&#x27;</span>,&#123;<span class="string">&#x27;servers&#x27;</span>:servers&#125;)	<span class="comment">#反馈页面</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#批量操作结果</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_ssh_cmd</span>(<span class="params">request</span>):</span><br><span class="line">    sshs = server.objects.<span class="built_in">all</span>().<span class="built_in">filter</span>(inIP=<span class="string">&#x27;192.168.1.1&#x27;</span>)	<span class="comment">#这里我就拿出来内网IP是192.168.1.1这个机器的例子</span></span><br><span class="line">    cmd_res = &#123;&#125;	<span class="comment">#设定一个空的列表</span></span><br><span class="line">    <span class="keyword">for</span> ssh <span class="keyword">in</span> sshs:</span><br><span class="line">        client = ParamikoClient()</span><br><span class="line">        client.connect(ssh)</span><br><span class="line">        res = client.run_cmd(<span class="string">&#x27;date&#x27;</span>)	<span class="comment">#执行的命令是date</span></span><br><span class="line">        cmd_res[ssh.name] = res		<span class="comment">#给列表的元素一一对应赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;result.html&#x27;</span>,&#123;<span class="string">&#x27;cmd_res&#x27;</span>:cmd_res&#125;)	<span class="comment">#反馈界面</span></span><br></pre></td></tr></table></figure></p>
<p><code>urls.py</code>的对应内容如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">   	path(<span class="string">r&#x27;paramiko.html&#x27;</span>,views.paramiko,name=<span class="string">&quot;paramiko&quot;</span>),    <span class="comment">#批量操作界面</span></span><br><span class="line">   	path(<span class="string">r&#x27;result.html&#x27;</span>,views.run_ssh_cmd,name=<span class="string">&quot;run_ssh_cmd&quot;</span>),    <span class="comment">#批量操作界面</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>至于<code>result.html</code>就很简单了，主体部分代码是：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;table-responsive&quot;</span>&gt;  &lt;!-- 响应式表格 --&gt;</span><br><span class="line">        &lt;table <span class="built_in">id</span>=<span class="string">&quot;server_table&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;table table-striped table-bordered table-hove&quot;</span>&gt;</span><br><span class="line">                &lt;thead&gt;</span><br><span class="line">                        &lt;tr&gt;</span><br><span class="line">                                &lt;th&gt;服务器名称&lt;/th&gt;</span><br><span class="line">                                &lt;th&gt;执行结果&lt;/th&gt;</span><br><span class="line">                        &lt;/tr&gt;</span><br><span class="line">                &lt;/thead&gt;</span><br><span class="line">                &lt;tbody&gt;</span><br><span class="line">                        &#123;% <span class="keyword">for</span> key,value <span class="keyword">in</span> cmd_res.items %&#125;</span><br><span class="line">                        &lt;tr&gt;</span><br><span class="line">                        &lt;td&gt;&#123;&#123; key &#125;&#125;&lt;/td&gt;</span><br><span class="line">                        &lt;td&gt;&#123;&#123; value &#125;&#125;&lt;/td&gt;</span><br><span class="line">                        &lt;/tr&gt;</span><br><span class="line">                        &#123;% endfor %&#125;</span><br><span class="line">                &lt;/tbody&gt;</span><br><span class="line">        &lt;/table&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>保存之后，系统重新启动django，在页面执行的效果如下：<br><img data-src="/images/gateone16.gif" alt="akb48"></p>
<h2 id="Django的model加密"><a href="#Django的model加密" class="headerlink" title="Django的model加密"></a>Django的model加密</h2><p>上面已经实现了通过paramiko批量操作，但是在这个过程中，我们把密码明文的保存在mysql里，这样无疑是有安全隐患的。于是乎就有一个新的需求：当我们输入到mysql的时候是加密的，从mysql取值的时候是解密的，那么这样的需求可以实现么？当然可以，使用<code>django-fernet-fields</code>。</p>
<p>首先要<code>pip install django-fernet-fields</code>安装这个插件，然后在对应的models.py里添加如下语句即可：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fernet_fields <span class="keyword">import</span> EncryptedTextField,EncryptedIntegerField</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyModel</span>(models.Model):</span><br><span class="line">    name = models.CharField(verbose_name=<span class="string">&#x27;姓名&#x27;</span>,max_length=<span class="number">1000</span>)</span><br><span class="line">    cardid = EncryptedTextField()	<span class="comment">#加密字段</span></span><br><span class="line">    phone = EncryptedIntegerField()	<span class="comment">#加密字段</span></span><br><span class="line">    address = models.CharField(verbose_name=<span class="string">&#x27;住址&#x27;</span>,max_length=<span class="number">1000</span>)</span><br></pre></td></tr></table></figure></p>
<p>然后在<code>manage.py</code>同级文件夹里执行<code>python manage.py makemigrations</code>和<code>python manage.py makemigrations</code>，发现新的表已经生成，然后在<code>admin.py</code>里添加后台展示代码：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> MyModel</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyModelAdmin</span>(admin.ModelAdmin):</span><br><span class="line">    list_display = (<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;cardid&#x27;</span>,<span class="string">&#x27;phone&#x27;</span>,<span class="string">&#x27;address&#x27;</span>)</span><br><span class="line"></span><br><span class="line">admin.site.register(MyModel,MyModelAdmin)</span><br></pre></td></tr></table></figure></p>
<p>然后登陆到django后台，发现一个叫<code>My models</code>的表已经生成了，那么我们添加一条记录如下：<br><img data-src="/images/gateone17.png" alt="akb48"></p>
<p>跑到mysql命令行一看：<br><img data-src="/images/gateone18.png" alt="akb48"></p>
<p>可见cardid和phone这两个字段已经被加密了，但是在<code>views.py</code>里使用<code>.objects.values()</code>方法获取是直接得到明文的，这样就达到了预期的效果。</p>
<p>补充一下，<code>EncryptedIntegerField</code>这个其实不太实用，它不能保存超过2147483647的数字，也就是说电话号码（11位）是无法用这个方法保存的…</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.maiziedu.com/wiki/frame/embed/">http://www.maiziedu.com/wiki/frame/embed/</a><br><a href="https://django-fernet-fields.readthedocs.io/en/latest/">https://django-fernet-fields.readthedocs.io/en/latest/</a><br><a href="https://pypi.org/project/django-encrypted-model-fields/">https://pypi.org/project/django-encrypted-model-fields/</a>  据说这个方法也能实现加密效果，我没有尝试<br><a href="https://www.59izt.com/zhoubin/2019/04/10/7025.html">https://www.59izt.com/zhoubin/2019/04/10/7025.html</a><br><img data-src="/images/MJ1.gif" alt="akb48" title="帮主实战中罚球线起跳扣篮"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>paramiko</tag>
      </tags>
  </entry>
  <entry>
    <title>在Django里添加Celery让脚本异步在后台运行</title>
    <url>/2019/01/16/%E5%9C%A8Django%E9%87%8C%E6%B7%BB%E5%8A%A0Celery%E5%81%9A%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当使用Django执行脚本的时候，经常遇到一种情况：跳转到某个url，结果是先在后台执行一个时间较长的脚本，然后才能打开这个url页面，这样用户体验就很不好。</p>
<p>比如说像这样的<code>views.py</code>配置：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用ansible执行远程命令</span></span><br><span class="line"><span class="meta">@csrf_exempt</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_command</span>(<span class="params">request</span>):</span><br><span class="line">    command = <span class="string">&quot;ansible all -i /root/.ssh/hosts -m shell -a &#x27;echo &#x27;worinixianren&#x27; &gt;&gt; /tmp/xianren.txt&#x27;&quot;</span>  <span class="comment">#设定ansible远程命令</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        <span class="built_in">id</span> = request.POST.getlist(<span class="string">&quot;ecs&quot;</span>)	<span class="comment">#通过html来获取id</span></span><br><span class="line">        num = []</span><br><span class="line">        num.append(<span class="built_in">len</span>(<span class="built_in">id</span>))     <span class="comment">#传递参数，给下一个页面用的</span></span><br><span class="line">        name = []	<span class="comment">#传递参数，给下一个页面用的</span></span><br><span class="line">        db = pymysql.connect(<span class="string">&quot;阿里云数据库&quot;</span>,<span class="string">&quot;数据库账号&quot;</span>,<span class="string">&quot;数据库密码&quot;</span>,<span class="string">&quot;databases名&quot;</span>)		<span class="comment">#根据上面获得的id去数据库里得到对应的内网IP</span></span><br><span class="line">        cursor = db.cursor()</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/root/.ssh/hosts&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">id</span>:</span><br><span class="line">                sql = <span class="string">&#x27;select * from createyaml_ecs where name = &quot;&#x27;</span>+ i + <span class="string">&#x27;&quot;;&#x27;</span></span><br><span class="line">                cursor.execute(sql)</span><br><span class="line">                ip = cursor.fetchall()[<span class="number">0</span>][<span class="number">3</span>]</span><br><span class="line">                cursor.execute(sql)</span><br><span class="line">                name.append(cursor.fetchall()[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">                f.write(ip+<span class="string">&quot; ansible_ssh_user=root&quot;</span>+<span class="string">&quot;\n&quot;</span>)		<span class="comment">#将得到的内网IP写入到一个文件里</span></span><br><span class="line">        db.close()	<span class="comment">#关闭数据库</span></span><br><span class="line">        child = subprocess.Popen(command,stdout=subprocess.PIPE, stderr=subprocess.PIPE,shell=<span class="literal">True</span>)		<span class="comment">#执行ansible命令</span></span><br><span class="line">        stdout, stderr = child.communicate()</span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">&#x27;run_command.html&#x27;</span>,&#123;<span class="string">&#x27;data&#x27;</span>:num[<span class="number">0</span>],<span class="string">&#x27;name&#x27;</span>:name&#125;)	<span class="comment">#将内容反馈到html页面里</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">&#x27;homepage.html&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>像上面这段代码，要看到<code>run_command.html</code>页面就要先把整个ansible部署的脚本全跑完，如果是几百台机器批量操作的脚本，那就要等到海枯石烂水倒流。那遇到这样的情况怎么解决呢？根据不同的请求，有不同的对策：</p>
<ol>
<li>单纯的后台跑一个脚本，那么就可以使用<code>Celery</code>；</li>
<li>在后台跑脚本的同时，还需要不断的向后台发送请求（比如微信上的茶叶妹聊天机器人），那么就要使用<code>Channels</code>；</li>
</ol>
<p><code>Celery</code>原理部分和配置定时任务就不多说了，文末的参考资料里有网站，这里主要说的是如何配置<code>Celery</code>。</p>
<h2 id="环境交代"><a href="#环境交代" class="headerlink" title="环境交代"></a>环境交代</h2><p>存储后端:阿里云redis(需要支持<code>evalsha</code>命令，如果不支持，去控制台<code>升级小版本</code>即可)<br>Python:<code>3.6.5</code><br>Django:<code>2.1.1</code><br>django-celery:<code>3.2.2</code>，安装方法：<code>pip install django-celery</code><br>celery-with-redis：<code>3.0</code>，安装方法<code>pip install celery-with-redis</code><br>celery:<code>3.1.26.post2</code></p>
<h2 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h2><p>首先配置<code>setting.py</code>，全文最后添加这样几句话：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#celery配置信息</span><br><span class="line">#celery中间人 <span class="attr">redis</span>:<span class="comment">//:redis密码@redis服务所在的ip地址:端口/数据库号，我用的是254号</span></span><br><span class="line">#channels配置redis也是这样配置，如果没有密码，就可以把<span class="string">&#x27;:redis密码@&#x27;</span>省略</span><br><span class="line"><span class="variable constant_">BROKER_URL</span> = <span class="string">&#x27;redis://:redis密码@阿里云redis地址:6379/254&#x27;</span></span><br><span class="line">#celery结果返回，可用于跟踪结果</span><br><span class="line"><span class="variable constant_">CELERY_RESULT_BACKEND</span> = <span class="string">&#x27;redis://:redis密码@阿里云redis地址:6379/254&#x27;</span></span><br><span class="line"></span><br><span class="line">#celery内容等消息的格式设置</span><br><span class="line"><span class="variable constant_">CELERY_ACCEPT_CONTENT</span> = [<span class="string">&#x27;application/json&#x27;</span>,]</span><br><span class="line"><span class="variable constant_">CELERY_TASK_SERIALIZER</span> = <span class="string">&#x27;json&#x27;</span></span><br><span class="line"><span class="variable constant_">CELERY_RESULT_SERIALIZER</span> = <span class="string">&#x27;json&#x27;</span></span><br><span class="line"></span><br><span class="line">#celery时区设置，使用settings中<span class="variable constant_">TIME_ZONE</span>同样的时区</span><br><span class="line"><span class="variable constant_">CELERY_TIMEZONE</span> = <span class="variable constant_">TIME_ZONE</span></span><br></pre></td></tr></table></figure></p>
<p>在<code>setting.py</code>同级的文件夹里创建<code>celery.py</code>，内容如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import, unicode_literals</span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line"><span class="comment">#获取当前文件夹名，即为该Django的项目名</span></span><br><span class="line">project_name = os.path.split(os.path.abspath(<span class="string">&#x27;.&#x27;</span>))[-<span class="number">1</span>]</span><br><span class="line">project_settings = <span class="string">&#x27;%s.settings&#x27;</span> % project_name</span><br><span class="line"> </span><br><span class="line"><span class="comment">#设置环境变量</span></span><br><span class="line">os.environ.setdefault(<span class="string">&#x27;DJANGO_SETTINGS_MODULE&#x27;</span>, project_settings)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#实例化Celery</span></span><br><span class="line">app = Celery(project_name)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#使用django的settings文件配置celery</span></span><br><span class="line">app.config_from_object(<span class="string">&#x27;django.conf:settings&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#Celery加载所有注册的应用</span></span><br><span class="line">app.autodiscover_tasks(<span class="keyword">lambda</span>: settings.INSTALLED_APPS)</span><br></pre></td></tr></table></figure></p>
<p>还是在同样的文件夹里，编辑<code>__init__.py</code>：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import, unicode_literals</span><br><span class="line"> </span><br><span class="line"><span class="comment">#引入celery实例对象</span></span><br><span class="line"><span class="keyword">from</span> .celery <span class="keyword">import</span> app <span class="keyword">as</span> celery_app</span><br></pre></td></tr></table></figure></p>
<p>然后在app（具体应用的文件夹里），创建一个叫<code>tasks.py</code>，这里面就是需要在后台执行的具体脚本：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> celery.decorators <span class="keyword">import</span> task</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="meta">@task	</span><span class="comment">#在原有的方法上加上celery装饰器task</span></span><br><span class="line"><span class="comment">#ansible批量部署命令</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_ansible</span>():</span><br><span class="line">    command = <span class="string">&quot;ansible all -i /root/.ssh/hosts -m shell -a &#x27;echo &#x27;worinixianren&#x27; &gt;&gt; /tmp/xianren.txt&#x27;&quot;</span>  <span class="comment">#设定命令</span></span><br><span class="line">	child = subprocess.Popen(command,stdout=subprocess.PIPE, stderr=subprocess.PIPE,shell=<span class="literal">True</span>)</span><br><span class="line">    stdout, stderr = child.communicate()</span><br><span class="line">	<span class="built_in">print</span> (<span class="string">&quot;success!!!&quot;</span>)	<span class="comment">#执行成功！</span></span><br></pre></td></tr></table></figure></p>
<p>保存退出之后，修改原有的<code>views.py</code>，把原来涉及脚本的字段删除，改成:<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@csrf_exempt</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_command</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        <span class="built_in">id</span> = request.POST.getlist(<span class="string">&quot;ecs&quot;</span>)</span><br><span class="line">        num = []</span><br><span class="line">        num.append(<span class="built_in">len</span>(<span class="built_in">id</span>))     <span class="comment">#传递参数，给下一个页面用的</span></span><br><span class="line">        name = []</span><br><span class="line">        db = pymysql.connect(<span class="string">&quot;阿里云数据库&quot;</span>,<span class="string">&quot;数据库账号&quot;</span>,<span class="string">&quot;数据库密码&quot;</span>,<span class="string">&quot;databases名&quot;</span>)</span><br><span class="line">        cursor = db.cursor()</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/root/.ssh/hosts&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">id</span>:</span><br><span class="line">                sql = <span class="string">&#x27;select * from createyaml_ecs where name = &quot;&#x27;</span>+ i + <span class="string">&#x27;&quot;;&#x27;</span></span><br><span class="line">                cursor.execute(sql)</span><br><span class="line">                ip = cursor.fetchall()[<span class="number">0</span>][<span class="number">3</span>]</span><br><span class="line">                cursor.execute(sql)</span><br><span class="line">                name.append(cursor.fetchall()[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">                f.write(ip+<span class="string">&quot; ansible_ssh_user=root&quot;</span>+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        db.close()</span><br><span class="line">        run_ansible.delay()     <span class="comment">#celery异步执行后台ansible程序，使用delay函数</span></span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">&#x27;run_command.html&#x27;</span>,&#123;<span class="string">&#x27;data&#x27;</span>:num[<span class="number">0</span>],<span class="string">&#x27;name&#x27;</span>:name&#125;)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">&#x27;homepage.html&#x27;</span>)</span><br></pre></td></tr></table></figure><br>	<br>返回到<code>manage.py</code>所在的目录，先正常启动django，然后再<code>/usr/local/python3/bin/celery -A project名称 worker -l info</code>启动celery，如图：<br><img data-src="/images/celery1.png" alt="akb48"></p>
<p>看到<code>tasks.py</code>已经成功被celery使用了，然后在页面上去执行原本的命令，就会看到celery页面有刷新：<br><img data-src="/images/celery2.png" alt="akb48"></p>
<p>此时再去redis里查看一下存储的效果：<br><img data-src="/images/celery3.png" alt="akb48"></p>
<p>可见tasks执行的状态已经被保存到了redis里。但是上面我们是在前台页面启动celery，如果想把celery作为一个后台守护进程，那么命令语句如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">/usr/local/python3/<span class="built_in">bin</span>/celery multi start worker -A project名称 -l info</span><br></pre></td></tr></table></figure></p>
<p>效果如图：<br><img data-src="/images/celery4.png" alt="akb48"></p>
<p>停止或重启将上面的<code>start</code>换为<code>stop</code>或<code>restart</code>即可。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>如果<code>tasks.py</code>内容变化了，需要重启celery才能生效。</p>
<p>如果在启动celery的时候，日志有写<code>UserWarning: Using settings.DEBUG leads to a memory leak, never use this setting in production environments! warnings.warn(&#39;Using settings.DEBUG leads to a memory leak, never &#39;</code>，那么就在<code>settings.py</code>里把<code>DEBUG = True</code>改成<code>DEBUG = False</code>即可。</p>
<p>查看redis有几个库的命令：<code>config get databases</code>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://yshblog.com/blog/163">http://yshblog.com/blog/163</a> （对照代码做一遍就更有体会了）<br><a href="https://www.cnblogs.com/wdliu/p/9517535.html">https://www.cnblogs.com/wdliu/p/9517535.html</a> (原理以及如何配置定时任务)<br><a href="https://www.cnblogs.com/wdliu/p/9530219.html">https://www.cnblogs.com/wdliu/p/9530219.html</a><br><a href="http://docs.celeryproject.org/en/latest/getting-started/brokers/redis.html">http://docs.celeryproject.org/en/latest/getting-started/brokers/redis.html</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>celery</tag>
        <tag>异步任务</tag>
      </tags>
  </entry>
  <entry>
    <title>在Docker里使用s6-svscan做进程守护</title>
    <url>/2019/07/23/%E5%9C%A8Docker%E9%87%8C%E4%BD%BF%E7%94%A8runit%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<h2 id="为什么要用s6"><a href="#为什么要用s6" class="headerlink" title="为什么要用s6"></a>为什么要用s6</h2><p>容器的哲学就是“容器里最好只有一个模块”，也就是常说的<code>容器即进程（one process per container）</code>。但是现在这个哲学有所动摇，很多人认为<code>容器即服务（one thing per container）</code>，毕竟总有些特殊场景我们需要在一个docker里安装多个模块。容器虽然可以在<code>docker run</code>的时候可以指定<code>--restart=always</code>，但是这个并不能对pid不为1的进程起到看门狗的作用，如果pid不为1的进程crash了，那么就不会重启而出现故障了。于是需要一个真正的看门狗来重启这个服务。可用于docker的看门狗品种有很多，详情可见 <a href="https://www.iamle.com/archives/tag/runit">https://www.iamle.com/archives/tag/runit</a> 这篇文章。我在那篇文章里选择了<code>s6</code>。虽然听说有赞在生产环境里已经用了<code>runit</code>，但是我搞了一天都没有搞明白<code>runit</code>怎么用，而且关于<code>runit</code>的资料都是2017年之前的，就放弃了…</p>
<p>首先先在<code>/opt/service</code>里准备两个服务，分别是<code>app1</code>和<code>app2</code>，在各自的文件家里分别创建run和finish两个文件，结构如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[root@func-lcshop-Harbor opt]<span class="comment"># tree service/</span></span><br><span class="line">service/</span><br><span class="line">├── app1</span><br><span class="line">│   ├── finish</span><br><span class="line">│   └── run</span><br><span class="line">└── app2</span><br><span class="line">    ├── finish</span><br><span class="line">    └── run</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> directories, <span class="number">4</span> files</span><br></pre></td></tr></table></figure></p>
<p>这个run文件就是进程的启动文件，<code>app1/run</code>内容如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[root@func-lcshop-Harbor app1]<span class="comment"># cat run </span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">echo <span class="string">&quot;Started APP1 service...&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;<span class="number">1.</span><span class="number">.3</span>&#125;</span><br><span class="line">do</span><br><span class="line">    echo <span class="string">&quot;这里是第一个程序！&quot;</span></span><br><span class="line">    sleep <span class="number">1</span></span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo <span class="string">&quot;Oh no!我嗝屁了...&quot;</span> &gt;&amp;<span class="number">2</span>		<span class="comment">#3秒就死掉</span></span><br><span class="line">exit <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>而<code>app2/run</code>的内容如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">echo <span class="string">&quot;Started app2 service...&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;<span class="number">1.</span><span class="number">.3000</span>&#125;		<span class="comment">#这里懒，就直接写了3000秒</span></span><br><span class="line">do</span><br><span class="line">    echo <span class="string">&quot;这是第二个程序！&quot;</span>	<span class="comment">#这里做了区分</span></span><br><span class="line">    date</span><br><span class="line">    sleep <span class="number">1</span></span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo <span class="string">&quot;Oh no!我嗝屁了...&quot;</span> &gt;&amp;<span class="number">2</span></span><br><span class="line">exit <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>我上面主要是为了模拟程序挂掉的场景，实际run脚本应该是长时间运行的。</p>
<p>而finish的作用主要是执行程序退出后的操作，也就是run结束后的操作。<font color=red>这里要注意！因为s6会自动重启run脚本，如果在finish里也写了启动run脚本，那么就会有两个run脚本运行！</font></p>
<p><code>app1/finish</code>内容如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">echo <span class="string">&quot;app1 挂掉啦！...&quot;</span></span><br><span class="line">echo <span class="string">&quot;app1 restart ok!&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>然后我们准备一个<code>dockerfile</code>，如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ADD https://github.com/just-containers/s6-overlay/releases/download/v1<span class="number">.21</span><span class="number">.8</span><span class="number">.0</span>/s6-overlay-amd64.tar.gz /tmp/	<span class="comment">#这个网站可能链接比较慢，所以推荐先下载然后COPY到容器里</span></span><br><span class="line">RUN tar xzf /tmp/s6-overlay-amd64.tar.gz -C /	<span class="comment">#解压缩到根目录下</span></span><br><span class="line">CMD [<span class="string">&quot;/bin/s6-svscan&quot;</span>,<span class="string">&quot;/opt/service&quot;</span>]	<span class="comment">#/opt/service就是app1和app2的路径</span></span><br></pre></td></tr></table></figure></p>
<p>执行<code>docker build -t=&quot;s6:0.1&quot; .</code>创建镜像，再使用<code>docker run -it --name s6demo -v /opt/service:/opt/service s6:0.1</code>启动这个s6demo的容器，在容器启动时就会发现s6会扫描<code>/opt/service</code>文件夹，执行对应的run脚本，当run脚本意外退出时，s6会自动重启，如图：<br><img data-src="/images/docker21.png" alt="抱光妹"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/just-containers/s6-overlay#the-docker-way">https://github.com/just-containers/s6-overlay#the-docker-way</a><br><a href="https://sourcediver.org/blog/2014/11/17/using-runit-in-a-docker-container/">https://sourcediver.org/blog/2014/11/17/using-runit-in-a-docker-container/</a><br><a href="https://segmentfault.com/a/1190000006644578">https://segmentfault.com/a/1190000006644578</a><br><a href="https://it.ismy.fun/2018/03/09/runit-example/">https://it.ismy.fun/2018/03/09/runit-example/</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>s6-svscan</tag>
      </tags>
  </entry>
  <entry>
    <title>在Grafana里添加worldping插件</title>
    <url>/2018/04/19/%E5%9C%A8Grafana%E9%87%8C%E6%B7%BB%E5%8A%A0worldping%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>worldping是一个监控网站的dns、ping、http响应、https响应的插件，要安装它很简单，在granafa服务器里执行如下命令：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">grafana-cli plugins install raintank-worldping-app</span><br><span class="line">systemctl restart grafana-server.<span class="property">service</span></span><br></pre></td></tr></table></figure></p>
<p>执行完毕之后在grafana的界面里选择<code>Plugins</code>，然后在<code>APP</code>里找到<code>worldping</code>，启动它，但是此时发现需要一个api，如图：<br><img data-src="/images/worldping.png" alt="paradin"></p>
<p>此时你需要登录grafana的官网，然后点击<code>api keys</code>和<code>ADD API KEY</code>，就可以生成一个<code>API KEY</code>，名字可以随便起，如下：<br><img data-src="/images/worldping2.png" alt="paradin"></p>
<p>将生成的api key保存好，并且填回到grafana的api key里，这样worldping插件就可以使用了，如图：<br><img data-src="/images/worldping3.png" alt="paradin"></p>
<h2 id="监控网站节点"><a href="#监控网站节点" class="headerlink" title="监控网站节点"></a>监控网站节点</h2><p>此时点击黄色旋涡，发现多了worldping的选项，点击<code>worldping Home</code>，如图：<br><img data-src="/images/worldping4.png" alt="paradin"></p>
<p>然后点击<code>+ New Endpoint</code>，这里我输入我公司的官网域名，然后<code>begin auto-discovery</code>，如图：<br><img data-src="/images/worldping5.png" alt="paradin"></p>
<p>生成了结果之后，点击add，此时开始检查几个大城市，如芝加哥、东京、纽约、巴黎等大城市连接到刚刚输入的域名的情况，如图：<br><img data-src="/images/worldping6.png" alt="paradin"></p>
<p>大约需要1~2分钟后，数据检查完成，可以点击<code>GO to Summary Dashboard</code>，就会看到图像了：<br><img data-src="/images/worldping7.png" alt="paradin"></p>
<p>为什么我这个图里没有http?因为在nginx里我们做了http强制rewrite跳转到https，所以是读不到值的。</p>
<h2 id="删除网站节点"><a href="#删除网站节点" class="headerlink" title="删除网站节点"></a>删除网站节点</h2><p>如果要删除网站节点，还是在worldping里点击要删除网站后面的齿轮图标，如图：<br><img data-src="/images/worldping8.png" alt="paradin"></p>
<p>然后选择<code>configuration</code>，这里可以修改网站域名，要删除的话，选择最下面的<code>destory</code>，输入DELETE确认，然后就可以点击<code>DELETE</code>删除了，如图：<br><img data-src="/images/worldping9.png" alt="paradin"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>grafana</tag>
        <tag>图像监控</tag>
      </tags>
  </entry>
  <entry>
    <title>在Python使用yaml的几个例子</title>
    <url>/2018/01/11/%E5%9C%A8Python%E4%BD%BF%E7%94%A8yaml%E7%9A%84%E5%87%A0%E4%B8%AA%E4%BE%8B%E5%AD%90/</url>
    <content><![CDATA[<p>python版本：<code>2.7.5</code><br>安装方法：<code>pip install PyYaml</code></p>
<p>“把变量写进yaml做配置文件，然后python脚本从yaml文件里面取到变量”的方法最近是在python编程里比较流行的配置项方法。yaml更加易读，而且通过缩进表示结构，这一点与python不谋而合。</p>
<p>Yaml有四个比较常用的用法，分别是<code>load()</code>、<code>dump()</code>、<code>load_all()</code>、<code>dump_all()</code>。这篇文章主要就是了解一下这四个方法。</p>
<p>首先我们先写一个很简单的test.py：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># -*- <span class="attr">coding</span>: utf-<span class="number">8</span> -*-</span><br><span class="line">#!<span class="regexp">/usr/</span>bin/env python</span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line">yaml_str = <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">name: Gakki</span></span><br><span class="line"><span class="string">age: 29</span></span><br><span class="line"><span class="string">job: Actress</span></span><br><span class="line"><span class="string">relationship: Wife</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line">aaa = yaml.<span class="title function_">load</span>(yaml_str)</span><br><span class="line">print aaa</span><br></pre></td></tr></table></figure></p>
<p>执行的话，看到的效果就是：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@paas-online-crs-<span class="number">001</span> chentest]# python test.<span class="property">py</span> </span><br><span class="line">&#123;<span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;Actress&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">29</span>, <span class="string">&#x27;relationship&#x27;</span>: <span class="string">&#x27;Wife&#x27;</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Gakki&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个aaa的类型是一个<code>字典（dict）</code>，如果要得到里面那个”Gakki”，那么就是<code>aaa[&#39;name&#39;]</code>。通过load方法，一个字符串变成了一个字典。</p>
<p>现在把test.py换成如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># -*- <span class="attr">coding</span>: utf-<span class="number">8</span> -*-</span><br><span class="line">#!<span class="regexp">/usr/</span>bin/env python</span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line">yaml_dict = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Gakki&quot;</span>,</span><br><span class="line">         <span class="string">&quot;age&quot;</span>: <span class="number">29</span>,</span><br><span class="line">         <span class="string">&quot;job&quot;</span>: <span class="string">&quot;Actress&quot;</span>,</span><br><span class="line">         <span class="string">&quot;relationship&quot;</span>: <span class="string">&quot;Wife&quot;</span></span><br><span class="line">              &#125;</span><br><span class="line">aaa = yaml.<span class="title function_">dump</span>(yaml_dict, default_flow_style=<span class="title class_">False</span>)</span><br><span class="line">print aaa</span><br><span class="line"><span class="title function_">print</span> (<span class="title function_">type</span>(aaa))</span><br></pre></td></tr></table></figure></p>
<p>执行后的效果如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@paas-online-crs-<span class="number">001</span> chentest]# python test.<span class="property">py</span> </span><br><span class="line"><span class="attr">age</span>: <span class="number">29</span></span><br><span class="line"><span class="attr">job</span>: <span class="title class_">Actress</span></span><br><span class="line"><span class="attr">name</span>: <span class="title class_">Gakki</span></span><br><span class="line"><span class="attr">relationship</span>: <span class="title class_">Wife</span></span><br><span class="line">&lt;type <span class="string">&#x27;str&#x27;</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>可见，通过dump方法，把一个dict变成了一个字符串。</p>
<p>现在写一个配置文件，假如它叫test.yaml:<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">- <span class="title class_">Gakki</span></span><br><span class="line">- <span class="number">29</span>	</span><br><span class="line">- <span class="title class_">Actress</span></span><br><span class="line">- <span class="title class_">Wife</span></span><br></pre></td></tr></table></figure></p>
<p>再来一个test.py，内容如下:<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># -*- <span class="attr">coding</span>: utf-<span class="number">8</span> -*-</span><br><span class="line">#!<span class="regexp">/usr/</span>bin/env python</span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"> </span><br><span class="line">aaa = yaml.<span class="title function_">load</span>(<span class="title function_">file</span>(<span class="string">&#x27;test.yaml&#x27;</span>, <span class="string">&#x27;r&#x27;</span>))</span><br><span class="line">print aaa</span><br><span class="line"><span class="title function_">print</span> (<span class="title function_">type</span>(aaa))</span><br></pre></td></tr></table></figure></p>
<p>执行这个test.py：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@paas-online-crs-<span class="number">001</span> chentest]# python test.<span class="property">py</span> 	</span><br><span class="line">[<span class="string">&#x27;Gakki&#x27;</span>, <span class="number">29</span>, <span class="string">&#x27;Actress&#x27;</span>, <span class="string">&#x27;Wife&#x27;</span>]</span><br><span class="line">&lt;type <span class="string">&#x27;list&#x27;</span>&gt;    #得到了一个列表</span><br></pre></td></tr></table></figure></p>
<p>如果把那个test.yaml升级成字典和列表的混合结构，如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">- <span class="attr">name</span>: <span class="title class_">Chris</span></span><br><span class="line"> 	<span class="attr">age</span>: <span class="number">29</span></span><br><span class="line"> 	<span class="attr">job</span>: <span class="variable constant_">OM</span> <span class="title class_">Engineer</span></span><br><span class="line">- <span class="attr">name</span>: <span class="title class_">Gakki</span></span><br><span class="line"> 	<span class="attr">age</span>: <span class="number">29</span></span><br><span class="line"> 	<span class="attr">job</span>: <span class="title class_">Actress</span></span><br><span class="line"> 	<span class="attr">relationship</span>: <span class="title class_">Wife</span></span><br></pre></td></tr></table></figure></p>
<p>执行test.py的效果如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@paas-online-crs-<span class="number">001</span> chentest]# python test.<span class="property">py</span> </span><br><span class="line">[&#123;<span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;OM Engineer&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">29</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Chris&#x27;</span>&#125;, &#123;<span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;Actress&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">29</span>, <span class="string">&#x27;relationship&#x27;</span>: <span class="string">&#x27;Wife&#x27;</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Gakki&#x27;</span>&#125;]</span><br><span class="line">&lt;type <span class="string">&#x27;list&#x27;</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>既然获得的结果是一个包含字典的列表，那么如果要获得“Gakki”就是<code>aaa[1][&#39;name&#39;]</code></p>
<p>如果想要复制和引用，那么要用&amp;和*，比如把test.yaml改成这样：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">name</span>: &amp;name <span class="title class_">Gakki</span></span><br><span class="line"><span class="attr">wife</span>: *name</span><br></pre></td></tr></table></figure></p>
<p>执行test.py的效果如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@paas-online-crs-<span class="number">001</span> chentest]# python test.<span class="property">py</span> </span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Gakki&#x27;</span>, <span class="string">&#x27;wife&#x27;</span>: <span class="string">&#x27;Gakki&#x27;</span>&#125;</span><br><span class="line">&lt;type <span class="string">&#x27;dict&#x27;</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>在同一个yaml文件中，可以用 — 来分段，这样可以将多个文档写在一个文件中：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"> 	<span class="attr">name</span>: <span class="title class_">Chris</span></span><br><span class="line"> 	<span class="attr">age</span>: <span class="number">29</span></span><br><span class="line"> 	<span class="attr">job</span>: <span class="variable constant_">OM</span> <span class="title class_">Engineer</span></span><br><span class="line">---</span><br><span class="line"> 	<span class="attr">name</span>: <span class="title class_">Gakki</span></span><br><span class="line"> 	<span class="attr">age</span>: <span class="number">29</span></span><br><span class="line"> 	<span class="attr">job</span>: <span class="title class_">Actress</span></span><br><span class="line"> 	<span class="attr">relationship</span>: <span class="title class_">Wife</span></span><br></pre></td></tr></table></figure></p>
<p>再写一个新的test.py如下:<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># -*- <span class="attr">coding</span>: utf-<span class="number">8</span> -*-</span><br><span class="line">#!<span class="regexp">/usr/</span>bin/env python</span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line">ys = yaml.<span class="title function_">load_all</span>(<span class="title function_">file</span>(<span class="string">&#x27;gakki.yaml&#x27;</span>, <span class="string">&#x27;r&#x27;</span>))    #<span class="title function_">load_all</span>() 方法会生成一个迭代器，可以用<span class="keyword">for</span>输出出来</span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> <span class="attr">ys</span>:</span><br><span class="line">   	print y</span><br></pre></td></tr></table></figure></p>
<p>执行这个py的效果：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@paas-online-crs-<span class="number">001</span> chentest]# python test.<span class="property">py</span> </span><br><span class="line">&#123;<span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;OM Engineer&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">29</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Chris&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;Actress&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">29</span>, <span class="string">&#x27;relationship&#x27;</span>: <span class="string">&#x27;Wife&#x27;</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Gakki&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考文档：<a href="https://huilansame.github.io/huilansame.github.io/archivers/recommond-case-file-type-yaml">https://huilansame.github.io/huilansame.github.io/archivers/recommond-case-file-type-yaml</a></p>
<p><img data-src="/images/todalaugh.gif" alt="抱光妹" title="Toda马笑"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>回调POST请求写入数据库</title>
    <url>/2020/10/13/%E5%9B%9E%E8%B0%83POST%E8%AF%B7%E6%B1%82%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>在实际工作中，我们的Django经常遇到请求别人，然后别人回调的情况。回调的话，大概率就是对方以POST来请求我们的接口，之前写过如何编写一个Restful API，可以看一下：<a href="https://brucewayne2099.github.io/2020/05/27/%E4%BD%BF%E7%94%A8Django%E7%BC%96%E5%86%99restful-API/">https://brucewayne2099.github.io/2020/05/27/%E4%BD%BF%E7%94%A8Django%E7%BC%96%E5%86%99restful-API/</a></p>
<p>那么说明一下当前的背景：<br>Django &#x3D;&#x3D; 3.12.0<br>Python &#x3D;&#x3D; 3.8.1<br>Postman &#x3D;&#x3D; v9.15.13<br>对外暴露的接口是：http:&#x2F;&#x2F;域名&#x2F;naxx&#x2F;moneylost，同时在<code>serializers.py</code>里指定必须传入的字段是<code>title</code>, <code>actual_value</code>，在数据库限制他俩都是<code>varchar(20)</code>。而且在<code>models.py</code>里也配置了该表和<code>title</code>, <code>actual_value</code>。</p>
<h2 id="POSTman发起POST请求"><a href="#POSTman发起POST请求" class="headerlink" title="POSTman发起POST请求"></a>POSTman发起POST请求</h2><p>怎么安装postman这里不说了，这里就说怎么用。</p>
<p>首先先把请求方式由默认的GET调整成POST,然后在界面的Header里手动在KEY的地方输入<code>Content-Type</code>，对应的value就是<code>application/json</code>：<br><img data-src="/images/post%E8%AF%B7%E6%B1%82.png"></p>
<p>然后在Body里，手动填写我们上面规定的必须填写的’title’和’actual_value’，以json的形式输入：<br><img data-src="/images/post%E8%AF%B7%E6%B1%822.png"></p>
<p>然后点击Send，就能看到结果了。然后再去数据库查看，已经成功了：<br><img data-src="/images/post%E8%AF%B7%E6%B1%823.png"></p>
<h2 id="Python发起POST请求"><a href="#Python发起POST请求" class="headerlink" title="Python发起POST请求"></a>Python发起POST请求</h2><p>那么用python去实现的话，代码如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># url=&quot;https:/域名/API/API接口名?参数1=对应的值1&amp;参数2=对应的值2&amp;字典参数=&#123;&#x27;aaa&#x27;:&#x27;value1&#x27;,&#x27;bbb&#x27;:&#x27;value2&#x27;,&#x27;ccc&#x27;:&#x27;value3&#x27;&#125;&quot;</span></span><br><span class="line"><span class="comment"># r = requests.request(&quot;POST&quot;,url)</span></span><br><span class="line"><span class="comment"># print (r.status_code)</span></span><br><span class="line"><span class="comment"># print (r.json())</span></span><br><span class="line"><span class="comment"># print (type(r.json()))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">monitorurl = <span class="string">&#x27;http://域名/naxx/moneylost/&#x27;</span></span><br><span class="line">payload = &#123;<span class="string">&#x27;title&#x27;</span>: <span class="string">&#x27;对应的值&#x27;</span>, <span class="string">&#x27;actual_value&#x27;</span>: <span class="number">123123</span>&#125;</span><br><span class="line">monitor_response = requests.post(monitorurl, data=payload)</span><br><span class="line">monitor_data_json = json.loads(monitor_response.text, strict=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;得到的monitor-json是：\n&#x27;</span>, monitor_data_json)</span><br></pre></td></tr></table></figure></p>
<p>这里上面的是用两种不同的方式POST到目标。</p>
<h2 id="排错"><a href="#排错" class="headerlink" title="排错"></a>排错</h2><p>这里主要有两个错误，第一就是<code>json.loads</code>的时候可能会爆<code>json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</code>，这个的原因就是你要单拿出来看看请求的text是不是json，大概率拿到的是网页的形式，所以自然不会被成功的<code>json.loads</code>,所以这里要添加一个try…except来防错。</p>
<p>第二个错误就是提交的时候发现<code>django.core.exceptions.ImproperlyConfigured: Field name XXX is not valid for model XXX</code>。这个原因主要就是串行器<code>serializers.ModeSerializer</code>中调用的models里面的字段对不上。比如你的<code>models.py</code>里 A表的字段是aaa，但是你在<code>serializers.ModeSerializer</code>对A表的调用的字段是aaaa，而不是aaa，所以就报错了。</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/ckuqKZIpvgo" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Python</tag>
        <tag>POST</tag>
      </tags>
  </entry>
  <entry>
    <title>国庆武汉长沙五日游</title>
    <url>/2019/10/11/%E5%9B%BD%E5%BA%86%E6%AD%A6%E6%B1%89%E9%95%BF%E6%B2%99%E5%85%AD%E6%97%A5%E6%B8%B8/</url>
    <content><![CDATA[<p>终于到了国庆，俺跟媳妇趁着中秋苏州的余温，再次选择了出去旅游。原本我打算是去重庆的，但是媳妇已经去过了，于是就拍板这次国庆假期选择去武汉、长沙玩5天，10月2号出发，不耽误看国庆阅兵。</p>
<p>国庆的安排：<br>10.2 下午7点在杭州东上车，大约11点到武汉站，打车去酒店，酒店周围吃吃夜宵<br>10.3 黎黄陂路街头博物馆+古德寺庙+晴川阁+吉庆街+长江大桥轮渡<br>10.4 黄鹤楼+辛亥革命纪念馆+湖北省博物馆+湖北省美术馆+粮道街+做了一个足浴歇歇脚<br>10.5 汉街+万达，中午一点在武汉站上车，下午两点半到长沙南站，橘子洲头+太平老街+国金中心+黄兴广场<br>10.6 湖南省博物馆+岳麓山，晚上7点长沙南上车返航</p>
<h2 id="武汉的玩"><a href="#武汉的玩" class="headerlink" title="武汉的玩"></a>武汉的玩</h2><p>我住的酒店是洪山区中北路的万达商圈，出门就是汉街。汉街是一条很长的室外购物步行街，曾经跑男来这里做过节目。作为一条网红大街，整条街两侧各色商家开门营业—-摄影馆、书店、星巴克、小饭店、耐克阿迪优衣库、DQ、鸭脖子之类的。杜莎夫人的武汉店也在汉街上，150元一张成人票，由于我之前去过伦敦的杜莎夫人这次就没有去武汉馆了。</p>
<p>黎黄陂路街头博物馆其实就是一条老街，以宋庆龄故居开始往里走，那一片区域都是各帝国主义列强以前在武汉的租界，能看到有外国风格的老建筑，虽然那些建筑窗户和门都破破旧旧，跟宋庆龄故居对比强烈，但是经过100多年的风雨依旧屹立不倒，他们都已经被围墙围住打算重新修葺，围墙上被各种涂鸦，画的花里胡哨的。除了列强的建筑之外还有中共八七会议的旧址，现在已经被改成了一个小型的博物馆，毛主席著名的“枪杆子里夺政权”就是出自这次会议。在这样一条有历史痕迹的长街，还有不少的咖啡馆和猫舍营业，不少的女生在大街上自拍。街两侧的居民楼里还有老人居住，有卖包子的、有开小卖店的、有做针脚活的。走在这里还真有一种恍若隔世的感觉。</p>
<p>我去古德寺的时候正值寺庙要搬迁，入门要交6块钱的香火钱，然后进大门烧香拜拜。亲眼见到古德寺的一刹那还真有点蒙，因为它的造型简直就是一个教堂，而且它的部分尖塔顶还有十字架！</p>
<p>古德寺四周是居民楼，寺里空地上有鸽子走来走去，花盆里有猫懒懒的睡觉，外形印度加波斯风的寺庙和大堂里的佛像搭配在一起，整个的气氛非常的祥和，不亏大隐隐于市这句话。可惜的是，10月初的时候，水池里的荷花已经败掉了。这个寺庙据说现在已经是一个尼姑庵。这座150年的历史的古刹，见证了武汉的50000多天的日日夜夜。它真的就像佛教一样的坚韧，屹立过那么多个是是非非，依旧对各路香客迎来送往。慈悲仁爱。</p>
<p>我没有去黄鹤楼，因为在网络上听到很多人以及周围朋友对黄鹤楼的吐槽。于是这次选择了晴川阁，第一它免费（囧），第二它是近距离看长江大桥的好地方，且与黄鹤楼隔江相望。晴川阁院里左手边是一个城墙，可以在城墙上看着下面车来车往，那里也是不少婚纱照的拍摄圣地，一对一对的新人穿着大红的服装风，扛个一把大伞搔首弄姿。</p>
<p>湖北省博物馆有两个镇馆之宝，一个是战国曾侯乙编钟，每天有固定时间会有工作人员表演；还有一个就是越王勾践的宝剑。这两个展厅的人是最多的，文物在展厅里静静的站立着，被一波又一波的游客检阅和拍照。武汉那两天气候太热，很多人都跑到博物馆去避暑，或盘腿坐或干脆躺着。湖北美术馆就在博物馆旁边，可以一波参观。</p>
<h2 id="武汉的吃"><a href="#武汉的吃" class="headerlink" title="武汉的吃"></a>武汉的吃</h2><p>吉庆街的江小城是让我特别有印象的店，它的室内装修风格是武汉街头，对的，进了店门就好像到了老武汉的胡同，墙壁也上贴着各种小广告。</p>
<p>到了武汉怎能不吃鱼？毛主席写过“才饮长江水，又食武昌鱼”，正是因为这首诗，武昌鱼就成为了樊口鳊鱼的大众名。武汉除了鱼，就是热干面，豆皮、袁大头包子、排骨炖藕汤这些。除了以上这些，我还很喜欢武汉的毛豆，微微的一点辣，下酒挺好！</p>
<h2 id="武汉印象"><a href="#武汉印象" class="headerlink" title="武汉印象"></a>武汉印象</h2><p>武汉给我的第一印象是天气真热人真多，我去户部巷的那天，屏幕显示整个户部巷有近20000人！更是让人觉得烦躁难耐，我买了一杯冰镇椰子汁，给媳妇买了一个网红冒烟冰淇淋，逛了一小会就觉得闷热的受不了。而在吉庆街街头大排档总会有一波带着乐器的中年大叔到各桌边演奏献唱，唱一次是否收费我并不了解。不过乐器花样倒是众多，古今中外一应俱全，从吉他到笛子。唱的歌曲嘛，无非就是《好运来》这样的大众歌曲。</p>
<p>坊间传闻武汉人因为靠江吃江，所以自古码头帮会众多，到了新社会也有一些好勇分子，不过大多数武汉民众都是遵纪守法的好市民，但是武汉人，无论男女的彪悍作风，直爽态度至今还是流传下来的，符合那句“天上九头鸟，地上湖北佬”的评价。武汉是一个基建狂魔，阮成发担任市长期间，从2009~2011年，城建投资超过了1500亿，但是武汉的确有效的建了地铁、修了高架，极大的缓解了市民出行的压力。不过话说回来，武汉的涝一直没有解决，在新闻上也能看到大雨天，武汉水过腰的照片，这是一个很严重的问题。</p>
<p>武汉市还有很多小景点，比如南洋大楼、瞿秋白故居、毛主席故居、陈潭秋烈士纪念馆、“汉阳造”纪念碑等等。现在的武汉被打造成了一个又红又专的城市，虽然当年国民党也在这里有过很大的动静，而且还一度被汪兆铭做了他的国民政府首都，但是武汉在中共革命历史上是有非常重要的意义的。武汉人说话有股子四川味，而且说活更“冲”，风风火火。可以说武汉话其实是四川话的“母版”，毕竟“两湖填四川”嘛。</p>
<h2 id="长沙的玩"><a href="#长沙的玩" class="headerlink" title="长沙的玩"></a>长沙的玩</h2><p>从武汉到长沙并不算远，高铁90分钟就从湖北跑到了湖南。长沙不算是一个旅游城市，没有什么出众的景点。整个长沙最大的景点就是湖南省博物馆，而湖南省博物馆的镇馆之宝就是马王堆的辛追夫人全家的陪葬以及她本人的尸体。</p>
<p>除了湖南省博物馆还有岳麓山值得一去，爬上山还是比较累的，对于有运动癌的媳妇儿，我俩只能买车票上山，然后坐一个20分钟左右的缆车慢悠悠观景下来。山上的空气很棒，要进岳麓书院是要单独收费的。</p>
<p>至于橘子洲头就是在湘江那里的一个大公园而已，除了青年毛主席的头部雕塑没什么特别的。</p>
<h2 id="长沙的吃"><a href="#长沙的吃" class="headerlink" title="长沙的吃"></a>长沙的吃</h2><p>长沙旅游业虽然比较贫乏，但是论吃就是顶级城市了。长沙的臭豆腐是当地一绝，走进太平老街，一股强烈的臭味迎面扑来，我估计如果贾谊在世还住在他那老宅，都能被熏死。</p>
<p>长沙的辣比武汉更甚，我在长沙两天，先后吃了么子烤肉、费大厨辣椒烧肉、易小厨辣椒炒肉等饭店。么子烤肉的烤五花肉和虾滑很棒！辣椒炒肉都差不多啦，还是比较下饭的，但是真的很辣，我不小心咬破一个辣椒籽，足足喝了两瓶水才把舌尖缓过来。</p>
<h2 id="长沙印象"><a href="#长沙印象" class="headerlink" title="长沙印象"></a>长沙印象</h2><p>长沙给我的第一印象就是贫富差距很大，破的地方很破，感觉有好大片楼拆了一半就烂在那里了，破破的在街道边无精打采的耸立着，有的甚至顶层都长半个人高的草。听人说这是因为长沙食物普遍都有辣和炸这两个风格，所以很多饮食的步行街看上去油腻腻脏乎乎，再加上我去那两天长沙天气并不晴朗，所以这种脏破让外人看来更加明显。</p>
<p>但是长沙高大上的地方又特别高级，比如国金中心，好几层楼，各种国际的奢侈品大牌都在里面有专卖店。国金中心斜对面就是黄兴广场，里面也是有吃有玩，各种champion店在大甩卖，广场的电子屏幕上甚至还有张艺兴的粉丝祝张艺兴生日快乐的滚动视频广告…</p>
<p>第二印象，长沙的乞丐真的很多。去湖南省博物馆的公交车下车到博物馆大门就趴着至少5位，残疾人、老年人、孤儿、母子、求学，各种各样的。据说早几年还有小孩抱腿的，不给钱就不撒手，给的不够也不撒手…</p>
<p>第三印象，打麻将真是当地人民喜闻乐见的休闲活动，胡同里的棋牌室基本爆满，不少人是老婆在隔壁商铺做饭，老公在店里打麻将。长沙夏天也是酷热难耐，不少长沙人会在游泳池里摆个桌子打几圈，这也是当地一大特色了。</p>
<h2 id="一些tips"><a href="#一些tips" class="headerlink" title="一些tips"></a>一些tips</h2><ol>
<li>多带一点人民币现金，我去的时候长沙公交车恰巧不能刷支付宝的电子公交卡，所以还是人民币买单；</li>
<li>汉街商圈虽然明文规定是晚10点结束营业，但是其实很多店都是坚持到10点半左右，所以晚上还可以去在那里吃顿夜宵；</li>
<li>你如果用华为P30，是可以在晴川阁看到对面的黄鹤楼的细节的；</li>
</ol>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>旅游</tag>
        <tag>国庆</tag>
        <tag>长沙</tag>
        <tag>武汉</tag>
      </tags>
  </entry>
  <entry>
    <title>博客评论改用来必力</title>
    <url>/2018/07/09/%E5%8D%9A%E5%AE%A2%E8%AF%84%E8%AE%BA%E6%94%B9%E7%94%A8%E6%9D%A5%E5%BF%85%E5%8A%9B/</url>
    <content><![CDATA[<p>原来我的博客评论用的是<code>hypercomments</code>，但是这几天发现评论已经不能用了，变成了<code>Close discussion</code>，如图：<br><img data-src="/images/pinglun1.png" alt="akb48"></p>
<p>去<a href="https://www.hypercomments.com/en/pricing">https://www.hypercomments.com/en/pricing</a> 发现已经没有免费版了，或者是我这个google邮箱里的免费版<code>hypercomments</code>到期了，于是就琢磨换成来必力吧。</p>
<p>首先先去<code>https://livere.com</code> 注册一个账号，这个来必力是韩国的软件，但是用google翻译就不用怕了，注册很简单，找回密码也很简单。</p>
<p>再去<a href="https://livere.com/insight/communite">https://livere.com/insight/communite</a> 里选择免费版，然后填写博客的地址和名称，选择<code>个人网站</code>。这个时候会得到一个<code>data-uid</code>，如图：<br><img data-src="/images/pinglun2.png" alt="akb48"></p>
<p>打开NexT主题的配置文件<code>_config.yml</code>中，搜索<code>livere_uid</code>，将<code>livere_uid</code>前面的<code>#</code>号去掉，将id填写到<code>livere_uid：</code>后面。再找到<code>Hypercomments</code>，把<code>hypercomments_id</code>这一行注释掉即可。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>在一个电脑里配置两套git环境供ssh推送</title>
    <url>/2020/03/13/%E5%9C%A8%E4%B8%80%E4%B8%AA%E7%94%B5%E8%84%91%E9%87%8C%E9%85%8D%E7%BD%AE%E4%B8%A4%E5%A5%97git-ssh%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>在GIT大行其道的今天，一个电脑配置两个git环境是常见的事儿：一个给公司的gitlab使用，一个给自己的github仓库使用。那么如何配置两套git的ssh环境让他们互不干扰呢？</p>
<h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><p>首先先要生成ssh秘钥，如果是给公司的gitlab使用的，命令是：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&#x27;公司发给你的邮箱地址&#x27;</span> -f ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure></p>
<p>这里<code>-t</code>代表创建的秘钥类型，这里默认就是rsa，<code>-C</code>是添加注释用的，<code>-f</code>就是制定对应的文件名称。</p>
<p>同理，再创建一个给个人github的一个ssh秘钥，命令是：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&#x27;个人的邮箱地址&#x27;</span> -f ~/.ssh/id_rsa.github</span><br></pre></td></tr></table></figure></p>
<p>这来命令敲完，那么应该会生成对应的4个文件：<br><img data-src="/images/%E5%A4%9A%E5%A5%97git%E7%8E%AF%E5%A2%831.png" title="带github后缀的是个人用的，不带就是公司用的"></p>
<p>然后把各自的秘钥的<code>.pub</code>文件复制到github&#x2F;公司gitlab的<code>ssh key</code>认证里，我这里只贴github的：<br><img data-src="/images/%E5%A4%9A%E5%A5%97git%E7%8E%AF%E5%A2%832.png" title="注意这里的SHA256"></p>
<p>两个.pub文件都复制粘贴到对应的地址之后，然后还要添加到了<code>ssh-add</code>里，命令是：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_dsa</span><br><span class="line">ssh-add ~/.ssh/id_dsa.github</span><br></pre></td></tr></table></figure><br> <br>添加完毕之后，使用<code>ssh-add -l</code>查看：<br><img data-src="/images/%E5%A4%9A%E5%A5%97git%E7%8E%AF%E5%A2%833.png" title="可以看到这里的SHA256跟上面github是一样的"></p>
<p>如果想清空这个ssh-add列表，命令是<code>ssh-add -D</code>，只想删除一个，命令是<code>ssh-add -d ~/.ssh/对应的秘钥名</code>。</p>
<p>还有最后一步，比较重要，要创建一个<code>~/.ssh/config</code>文件，里面内容如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#个人仓</span></span><br><span class="line">Host github.com</span><br><span class="line">  HostName github.com  <span class="comment"># 这里跟hostname文件的效果一样的，建议跟Host写一样</span></span><br><span class="line">  PreferredAuthentications publickey</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa.github  <span class="comment"># 这里就是刚才创建的那个github的秘钥</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#公司仓库</span></span><br><span class="line">Host company-gitlab</span><br><span class="line">  HostName gitlab.你公司域名.com</span><br><span class="line">  AddKeysToAgent yes</span><br><span class="line">  UseKeychain yes</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure></p>
<p>保存之后，可以尝试一下连通，<code>ssh -T 对应的Host</code>，这里有一个坑，就是连通github的时候，应该是<code>ssh -T git@github.com</code>，没有前面那个<code>git@</code>，可能会报错<code>Permission denied (publickey)</code>，因为github所有连接（包括远程URL的连接）必须以 “git” 用户进行。如图：<br><img data-src="/images/%E5%A4%9A%E5%A5%97git%E7%8E%AF%E5%A2%834.png" title="全部连通完毕，交换了彼此的认证，下一次提交就不用输入密码了"></p>
<p>如果连不上的话，那么就<code>ssh -vT 对应的Host</code>，看一下详细日志，具体哪一步错了，然后针对性的修改即可。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://lunashu.org/git-clone-ssh-key/">https://lunashu.org/git-clone-ssh-key/</a><br><a href="https://www.zhihu.com/question/21402411">https://www.zhihu.com/question/21402411</a><br><a href="https://hanpanpan200.github.io/2019/10/14/setup-multiple-git-accounts-by-ssh-config/">https://hanpanpan200.github.io/2019/10/14/setup-multiple-git-accounts-by-ssh-config/</a><br><a href="https://www.jianshu.com/p/90c5c863a272">https://www.jianshu.com/p/90c5c863a272</a><br><a href="https://blog.csdn.net/hao495430759/article/details/80673568">https://blog.csdn.net/hao495430759/article/details/80673568</a><br><a href="https://docs.github.com/cn/authentication/troubleshooting-ssh/error-permission-denied-publickey">https://docs.github.com/cn/authentication/troubleshooting-ssh/error-permission-denied-publickey</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>在国王杯前夕评巴萨</title>
    <url>/2018/04/21/%E5%9C%A8%E5%9B%BD%E7%8E%8B%E6%9D%AF%E5%89%8D%E5%A4%95%E8%AF%84%E5%B7%B4%E8%90%A8/</url>
    <content><![CDATA[<p>今天凌晨的马竞在西甲意外输给了皇家社会，巴萨的积分优势扩大到了12分。这个周末巴萨要跟塞维利亚打国王杯决赛，4月30号对拉科鲁尼亚的西甲联赛巴萨只要获胜，就会拿到今年的西甲联赛冠军，从而以冠军姿态在诺坎普迎接本赛季第二场国家德比。</p>
<h2 id="巴尔韦德的困境"><a href="#巴尔韦德的困境" class="headerlink" title="巴尔韦德的困境"></a>巴尔韦德的困境</h2><p>巴萨今年可以说是低姿态开始：从内马尔突然的离开到西超杯被皇马灌了5个，不可为说不惨。但是巴尔韦德在联赛却目前保持不败，这个成绩单可以说是相当不错的，这中间还有在伯纳乌的三球胜利。</p>
<p>赛季中前段，巴萨三线顺风顺水，前有塞梅多惊艳开场，后有大祭司维尔马伦扎实顶上，主教练巴尔韦德也给了阿奈斯这样小将出场机会，哪怕登贝莱那时候养伤，报纸媒体一片其乐融融。如果保利尼奥再有进球，更是一片狂欢。</p>
<p>然后巴尔韦德的保守开始慢慢让人所诟病，他是一个重视防守的教练，这很好，但是他有了库迪尼奥也有了归来的登贝莱，结果反而不敢搞轮换，甚至坚持让布教授打封闭出场，虽然不少人抱怨，但是由于球队整体战绩还算平稳，所以没有大规模的重视。可是巴萨欧冠的结果跟恩里克的第二个赛季一样，倒在了与罗马的第二回合比赛里，连续三年没有闯入欧冠四强。</p>
<p>其实对战罗马的第一回合，巴萨的4：1已经是靠意志拼下来的比赛，球员难免在第二回合的心态上有所轻敌，这种心态上的轻敌难免会影响到身体，但是巴尔韦德的临场指挥也让人严重不满。落下这耻辱一战，媒体和球迷之前的“忍气吞声”一并爆发，狂轰滥炸，直到现在依旧有人说“哪怕真的赛季双冠，也会因为欧冠的失利而让那两冠索然无味”。<br><img data-src="/images/fcb4.png" alt="paradin"></p>
<p>所以，巴尔韦德要在这个周日的国王杯决赛和对阵拉科鲁尼亚的西甲联赛里稳扎稳打，把国王杯和西甲冠军彻底拿到手里，这样整个人也能轻松一些。可是说来说去罗马一役这一个跟头摔得太疼了，在那么重大的比赛里失败，肯定需要在一个同样重大的比赛里胜利以挽回颜面，第二回合的国家德比无疑就是一个好的机会，如果巴尔韦德成功捍卫了诺坎普，“联赛双杀皇马+国内双冠”也能成为一个功劳。但是如果那场比赛，一心要打破巴萨不败金身的皇马真的成功了，那巴尔韦德势必在巴萨主帅的位置上也是飘摇。</p>
<p>所以巴帅，请务必要拿下国王杯冠军+西甲冠军！在第二个国家德比里也请拼尽全力！这样才能多少挽回一点“罗马之耻”的颜面。<br><img data-src="/images/fcb1.png" alt="paradin"></p>
<h2 id="夏季转会展望"><a href="#夏季转会展望" class="headerlink" title="夏季转会展望"></a>夏季转会展望</h2><p>我个人认为，巴萨很有可能在今年夏天卖掉如下几个人：西莱森、戈麦斯、小苏亚雷斯、艾尔卡塞尔、比达尔，自由走人的可能会是小白。这些人能套现7000万应该就满足了。</p>
<p>巴萨后卫现在四个人皮克和维尔马伦属于潜藏的伤员病号，米纳技术还是太糙，稍微让人放心的就是乌姆蒂蒂，他的续约问题肯定是休赛期的一个大事。不过我觉得米纳其实可以再留一年看看，他身体素质很好，而且人还年轻没伤病，只要心态练得沉稳，当一个合格的中后卫不难。</p>
<p>至于中场，个人希望小白再踢一年，现在我也觉得一个满血的小白应付普通的联赛、欧冠小组赛和杯赛都不是什么难事。但是目前的媒体趋势是小白赛季结束会来中超重庆队，即使这样巴萨也需要一个山寨的坎特和一个山寨的埃里克森，而罗贝托集这两个属性于一身，所以他就是一个“奉献的砖”，但是这样如果比达尔真的不留下来的话，巴萨还需要补进一个右后卫跟塞梅多良性竞争，这个右后卫的人选就比较挠头了。贝莱林？或许是一个选择，但是这个选择跟当年小法一样—要是双输就不好了。</p>
<p>前场如果能拿下格里兹曼肯定是好的，艾尔卡塞尔这种“躲着后卫”的踢法，虽然进球效率可以，但是没有真正起到轮换苏亚雷斯的作用。这样巴萨还需要在板凳上补充一个中锋（不用多能进球，哪怕搅屎棍也可以），同时也做好登贝莱&#x2F;苏亚雷斯&#x2F;梅西&#x2F;格里兹曼（假设他真的来）的轮换。</p>
<p>总而言之，现在巴萨还是回归433比较好，配合442和4312的变化。那么休赛期最重要的补强就是格里兹曼+能抗中卫的前锋+一个中场+一个优秀的边后卫。</p>
<p>我个人希望的引援名单如下：<br>中场是魏格尔和B队的阿莱尼亚，埃里克森、博格巴和维拉蒂这三个不算是好的选择，要么太贵，要么节奏太慢。至于伊斯科、大卫席尔瓦、皮亚尼奇，那想都别想了，母队不会放人的。至于格雷茨卡，拜仁不是善茬；<br>边后卫可以考虑贝莱林，这个要看一下阿森纳的新教练是谁，摩纳哥的法比尼奥也可以，我知道他现在改中场了，也不耽误来一下跟罗贝托交叉换位…<br>前锋的话，我个人推荐B队阿奈斯试试看，其他的人选估计就是在西甲联赛内部找了；<br>这几个位置，最重要就是中场！梅西当初在哈白布的配合下威力无穷，一旦巴萨的中场重新掌握了控制力，不用频繁回撤的梅西依旧会进球如麻，这一点毋庸置疑。<br><img data-src="/images/fcb3.png" alt="paradin"></p>
<h2 id="温格会来？"><a href="#温格会来？" class="headerlink" title="温格会来？"></a>温格会来？</h2><p>我个人首先不希望巴尔韦德下课，毕竟现在巴萨联赛冠军十拿九稳，国王杯如果也揽入怀中，这样一个成绩单也是一个80分，如果这个分数都炒掉主教练，那么继任者的压力势必很大，所以我个人倾向巴尔韦德留任，好好想一下，等阿图尔以及可能会来的格里兹曼到位了，巴萨应该怎么打。</p>
<p>不过如果温格真的来了，我个人也是赞成的，因为阿森纳的球风本来跟巴萨相似，相信温格跟梅西等人也会无缝接入，到时候教授或许真的可以在巴萨圆了欧冠梦想，不过这个想法成真的可能性低于5%，想想就得了。</p>
<h2 id="下赛季的任务"><a href="#下赛季的任务" class="headerlink" title="下赛季的任务"></a>下赛季的任务</h2><p>1.进攻体系依旧围绕梅西建队，让梅西继续火力全开的同时保证休息，欧冠要他有大用；<br>2.新球员（包括库蒂尼奥和登贝莱）适应巴萨的风格和体系，让皮克和布教授也能轮换得到休息；<br>3.欧冠一定要进入四强；<br>4.欧冠四强的基础上，西甲联赛冠军和国王杯能拿还是要拿，同时最好也能阻击皇马；<br><img data-src="/images/fcb2.png" alt="paradin"></p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>国际足坛</tag>
        <tag>巴塞罗那</tag>
      </tags>
  </entry>
  <entry>
    <title>处理掉积压过多的activemq持久化消息</title>
    <url>/2018/01/29/%E5%A4%84%E7%90%86%E6%8E%89%E7%A7%AF%E5%8E%8B%E8%BF%87%E5%A4%9A%E7%9A%84activemq%E6%8C%81%E4%B9%85%E5%8C%96%E6%B6%88%E6%81%AF/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在项目使用<code>activemq 5.14</code>时，客户端发送消息而没有得到回复（在不考虑消费者是什么问题的情况下），导致持久化消息不断积压而得不到释放，最后造成队列堵塞而嗝屁。</p>
<p>一般来说遇到这样的情况，可以在配置文件中配置消息的过期时间和死信处理来防止消息的积压，配置如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">       &lt;!-- <span class="number">86</span>,<span class="number">400</span>,000ms = <span class="number">1</span> day --&gt;</span><br><span class="line">         <span class="language-xml"><span class="tag">&lt;<span class="name">timeStampingBrokerPlugin</span> <span class="attr">ttlCeiling</span>=<span class="string">&quot;10000&quot;</span> <span class="attr">zeroExpirationOverride</span>=<span class="string">&quot;10000&quot;</span>/&gt;</span></span></span><br><span class="line">     &lt;/plugins&gt;</span><br></pre></td></tr></table></figure></p>
<p>配置消息过期时间使用<code>timeStampingBrokerPlugin</code>插件,<code>ttlCeiling</code>：表示过期时间上限（模块程序写的过期时间不能超过此时间，超过则以此时间为准），<code>zeroExpirationOverride</code>：表示过期时间（给未分配过期时间的消息分配过期时间），一般来说这两个值是一样的。执行之后，message过期则客户端不能接收，那些已经过期的message将会保存在<code>data/kahadb</code>目录下。</p>
<p>但是最近发现了一个问题，就是<code>data/kahadb</code>这个目录最近越来越大，越积越多。但是这个topic和quere又依旧是“持续订阅”的，它的消费者还在。遇到这样的情况，如何在activemq里配置呢？</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ul>
<li><p>配置message过期自动丢弃策略</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">	&lt;borker&gt;</span><br><span class="line">	   <span class="language-xml"><span class="tag">&lt;<span class="name">destinationPolicy</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	       <span class="tag">&lt;<span class="name">policyMap</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	           <span class="tag">&lt;<span class="name">policyEntries</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	               <span class="tag">&lt;<span class="name">policyEntry</span> <span class="attr">topic</span>=<span class="string">&quot;&gt;&quot;</span> <span class="attr">expireMessagesPeriod</span>=<span class="string">&quot;60000&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	                   <span class="tag">&lt;<span class="name">deadLetterStrategy</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">sharedDeadLetterStrategy</span> <span class="attr">processExpired</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  	                 <span class="tag">&lt;/<span class="name">deadLetterStrategy</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  	             <span class="tag">&lt;/<span class="name">policyEntry</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  	         <span class="tag">&lt;/<span class="name">policyEntries</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  	     <span class="tag">&lt;/<span class="name">policyMap</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  	 <span class="tag">&lt;/<span class="name">destinationPolicy</span>&gt;</span></span></span><br><span class="line">&lt;/borker&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>标签<code>processExpired=&quot;false&quot;</code>表示<font color=red>不保存过期消息到死信队列，处理手段为删除</font>，为<code>true</code>则是保留。<br>标签<code>expireMessagesPeriod=&quot;60000&quot;</code>属性表示每隔60秒钟检查message是否过期。<br><code>topic=&quot;&gt;&quot;</code>表示该策略对所有topic都生效。而<code>topic=&quot;active.&gt;&quot;</code>就表示该策略对以<code>active.</code>开头的所有<code>topic</code>生效，注意有个点号<code>.</code>。</p>
<ul>
<li>message过期时间设置<br>上面那步搞定了之后，再修改<code>timeStampingBrokerPlugin</code>标签里<code>ttlCeiling=&quot;360000&quot; zeroExpirationOverride=&quot;360000&quot;</code>表示过期时间为360000ms（1小时）。  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;borker&gt;</span><br><span class="line">   	<span class="language-xml"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   	    <span class="comment">&lt;!-- 86,400,000ms = 1 day --&gt;</span></span></span><br><span class="line"><span class="language-xml">   	    <span class="tag">&lt;<span class="name">timeStampingBrokerPlugin</span> <span class="attr">ttlCeiling</span>=<span class="string">&quot;360000&quot;</span> <span class="attr">zeroExpirationOverride</span>=<span class="string">&quot;360000&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">   	<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span></span><br><span class="line">&lt;/borker&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="解决“空队列”的方法"><a href="#解决“空队列”的方法" class="headerlink" title="解决“空队列”的方法"></a>解决“空队列”的方法</h2><p>如果不是那种“持续订阅”的topic，那就简单了，配置如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;broker xmlns=<span class="string">&quot;http://activemq.apache.org/schema/core&quot;</span> schedulePeriodForDestinationPurge=<span class="string">&quot;10000&quot;</span>&gt;</span><br><span class="line">   	<span class="language-xml"><span class="tag">&lt;<span class="name">destinationPolicy</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   	   <span class="tag">&lt;<span class="name">policyMap</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   	      <span class="tag">&lt;<span class="name">policyEntries</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   	         <span class="tag">&lt;<span class="name">policyEntry</span> <span class="attr">queue</span>=<span class="string">&quot;&gt;&quot;</span> <span class="attr">gcInactiveDestinations</span>=<span class="string">&quot;true&quot;</span> <span class="attr">inactiveTimoutBeforeGC</span>=<span class="string">&quot;30000&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">   	      <span class="tag">&lt;/<span class="name">policyEntries</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   	   <span class="tag">&lt;/<span class="name">policyMap</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   	<span class="tag">&lt;/<span class="name">destinationPolicy</span>&gt;</span></span>     </span><br><span class="line"> 	&lt;/broker&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>schedulePeriodForDestinationPurge</code>执行清理任务的周期，<code>gcInactiveDestinations=&quot;true&quot;</code>表示启用清理功能，<code>inactiveTimoutBeforeGC=&quot;30000&quot;</code>这个是Topic或Queue超时时间,在规定的时间内，无有效订阅，没有入队记录，超时后就会被清理。<br><img data-src="/images/%E5%A4%A7%E5%B8%9D%E6%89%A3%E5%A8%81%E5%B0%91.gif" title="大帝扣威少！"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://activemq.apache.org/timestampplugin.html">http://activemq.apache.org/timestampplugin.html</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
        <tag>activemq</tag>
      </tags>
  </entry>
  <entry>
    <title>在安装docker私有仓库的时候遇到的openssl问题</title>
    <url>/2018/04/21/%E5%9C%A8%E5%AE%89%E8%A3%85docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E7%9A%84%E6%97%B6%E5%80%99%E9%81%87%E5%88%B0%E7%9A%84openssl%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>按照<a href="http://wiki.jikexueyuan.com/project/docker-technology-and-combat/local_repo.html">http://wiki.jikexueyuan.com/project/docker-technology-and-combat/local_repo.html</a> 的方法本地安装一个私有仓库，在执行<code>sudo pip install docker-registry</code>这一步的时候，出现了这样的一个错误：<br><img data-src="/images/openssl1.png" alt="paradin"></p>
<p>既然说我没有swig，于是我<code>yum install swig -y</code>，安装的是<code>2.0.10-5.el7</code>版本。然后再次<code>pip install docker-registry</code>，一顿噼里啪啦之后，这次成了这样：<br><img data-src="/images/openssl2.png" alt="paradin"></p>
<p>又说没有openssl的文件，那执行<code>yum install openssl-devel</code>，OK了之后再次<code>pip install docker-registry</code>，再一次噼里啪啦，如下：<br><img data-src="/images/openssl3.png" alt="paradin"></p>
<p>反馈我：<code>/usr/include/openssl/opensslconf.h:44: Error: CPP #error &quot;&quot;This openssl-devel package does not work your architecture?&quot;&quot;. Use the -cpperraswarn option to continue swig processing.</code>,这个提示大意是说openssl-devel版本不适合你的系统架构，也就是x86的去找x86的头文件，x86_64的去找x86_64文件，但现在是互相找不到对方。</p>
<p>既然说<code>/usr/include/openssl/opensslconf.h</code>这个第44行有错误，那我们就打开这个文件去看看第44行写的是啥：<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">41</span> #elif <span class="title function_">defined</span>(__x86_64__)</span><br><span class="line"><span class="number">42</span> #include <span class="string">&quot;opensslconf-x86_64.h&quot;</span></span><br><span class="line"><span class="number">43</span> #<span class="keyword">else</span></span><br><span class="line"><span class="number">44</span> #error <span class="string">&quot;This openssl-devel package does not work your architecture?&quot;</span></span><br><span class="line"><span class="number">45</span> #endif</span><br><span class="line"><span class="number">46</span> </span><br><span class="line"><span class="number">47</span> #undef openssl_opensslconf_multilib_redirection_h</span><br></pre></td></tr></table></figure></p>
<p>这里我把第44行改成了这样：<br>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">41 #elif defined(__x86_64__)</span><br><span class="line">42 #include &quot;opensslconf-x86_64.h&quot;</span><br><span class="line">43 #else</span><br><span class="line">44 #include &quot;opensslconf.h&quot;    #去掉了原来的error提示，改成了安装opensslconf.h文件。</span><br><span class="line">45 #endif</span><br><span class="line">46 </span><br><span class="line">47 #undef openssl_opensslconf_multilib_redirection_h</span><br></pre></td></tr></table></figure></p>
<p>这一次重新执行<code>sudo pip install docker-registry</code>，终于成功…<br><img data-src="/images/openssl4.png" alt="paradin"></p>
<p><img data-src="/images/agirl.gif" alt="akb48"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>容器技术</tag>
      </tags>
  </entry>
  <entry>
    <title>在已经运行的docker容器里面使用中文</title>
    <url>/2018/05/10/%E5%9C%A8%E5%B7%B2%E7%BB%8F%E8%BF%90%E8%A1%8C%E7%9A%84docker%E5%AE%B9%E5%99%A8%E9%87%8C%E9%9D%A2%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%87/</url>
    <content><![CDATA[<h2 id="配置ldap"><a href="#配置ldap" class="headerlink" title="配置ldap"></a>配置ldap</h2><p>公司搭建的gitlab现在需要开启ldap服务，也就是这样就可以用公司的域账号登陆gitlab，而不用开发一个一个去注册账号了。</p>
<p>开启ldap登陆的任务光荣的落到了我身上，于是我就登陆到gitlab服务器一看，嚯，这还是在容器下启动的，如图：<br><img data-src="/images/gitlab2.png" alt="paradin"></p>
<p>于是我就<code>docker exec -it 容器ID号 /bin/bash</code>登陆到这个容器里，编辑<code>/opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml</code>，如下：<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">ldap</span>:    </span><br><span class="line">  <span class="attr">enabled</span>: <span class="literal">true</span></span><br><span class="line">  <span class="attr">sync_time</span>:</span><br><span class="line">  <span class="attr">host</span>: <span class="string">&#x27;公司域账号服务器IP地址&#x27;</span></span><br><span class="line">  <span class="attr">port</span>: <span class="number">389</span></span><br><span class="line">  <span class="attr">uid</span>: <span class="string">&#x27;sAMAccountName&#x27;</span></span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;plain&#x27;</span> # <span class="string">&quot;tls&quot;</span> or <span class="string">&quot;ssl&quot;</span> or <span class="string">&quot;plain&quot;</span></span><br><span class="line">  <span class="attr">bind_dn</span>: <span class="string">&#x27;dahuatech\Ldap_System&#x27;</span></span><br><span class="line">  <span class="attr">password</span>: <span class="string">&#x27;对应的密码&#x27;</span></span><br><span class="line">  <span class="attr">active_directory</span>:</span><br><span class="line">  <span class="attr">allow_username_or_email_login</span>:    </span><br><span class="line">  <span class="attr">lowercase_usernames</span>:</span><br><span class="line">  <span class="attr">base</span>: </span><br><span class="line">  <span class="attr">user_filter</span>:</span><br></pre></td></tr></table></figure></p>
<p>但是在填写到base的时候发现了一个问题，公司的base是中文的，是<code>&#39;OU=大数据研究院,OU=研发中心,OU=大华技术,DC=dahuatech,DC=com&#39; </code>，但是在文件里输入中文却是乱码，如图：<br><img data-src="/images/gitlab3.png" alt="paradin"></p>
<p>容器默认是不支持中文的，在容器里的命令行输入中文也是空白。那么面对一个已经运行的容器，如何正常的输入中文呢？</p>
<p>答案是：使用<code>docker exec -it 容器ID号 env LANG=C.UTF-8 /bin/bash</code>登陆，这样就能正常使用中文了，如图：<br><img data-src="/images/gitlab1.png" alt="paradin"></p>
<p><code>gitlab-ctl restart</code>之后，登陆到gitlab页面一看，已经添加ldap访问方式：<br><img data-src="/images/gitlab4.png" alt="paradin"></p>
<h2 id="取消“注册”功能"><a href="#取消“注册”功能" class="headerlink" title="取消“注册”功能"></a>取消“注册”功能</h2><p>修改好配置文件<code>gitlab.yml</code>之后，现在就要把“注册”功能去掉，这样以后都统一用公司的域账号登陆，避免一些乱七八糟的用户来注册乱七八糟的账号。</p>
<p>首先用root账号登陆到<code>gitlab</code>里，在网页里进入到<code>admin area</code>，如图：<br><img data-src="/images/gitlab8.png" alt="paradin"></p>
<p>然后再点击最下面的<code>settings</code>，选择<code>Sign-up restrictions</code>，然后把<code>Sign-up enabled</code>前面的勾点掉，如图：<br><img data-src="/images/gitlab9.png" alt="paradin"></p>
<p>保存改变之后，退出root账号，重新看一下，gitlab的注册功能就暂时被取消了，需要的时候再开即可。</p>
<h2 id="配置域名"><a href="#配置域名" class="headerlink" title="配置域名"></a>配置域名</h2><p>为了方便记忆，给gitlab服务配置一个域名，在阿里云的域名解析控制台给gitlab配置了域名之后，还要在<code>gitlab.yml</code>手动更改hostname，把hostname改成域名的样子，如图：<br><img data-src="/images/gitlab5.jpg" alt="paradin"></p>
<p>这样没有结束，因为网页里的url还是显示外网IP而非域名,如下：<br><img data-src="/images/gitlab7.png" alt="paradin"></p>
<p>此时需要重启，重启的命令是<code>gitlab-ctl restart</code>，重启完了之后url也会发生变化。这样才算完整的配置了域名：<br><img data-src="/images/gitlab6.jpg" alt="paradin"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>大key和高流量导致redis挂掉的故障</title>
    <url>/2024/10/20/%E5%A4%A7key%E5%92%8C%E9%AB%98%E6%B5%81%E9%87%8F%E5%AF%BC%E8%87%B4redis%E6%8C%82%E6%8E%89%E7%9A%84%E6%95%85%E9%9A%9C/</url>
    <content><![CDATA[<h2 id="故障回顾"><a href="#故障回顾" class="headerlink" title="故障回顾"></a>故障回顾</h2><p>问题redis的配置如下：<br><img data-src="/images/redis%E9%97%AE%E9%A2%98-1.png" title="出问题的redis是一个4G的"></p>
<p>（1）因为大KEY调用量，随着白天自然流量趋势增长而增长，最终在业务高峰最高点期占满带宽使用100%<br><img data-src="/images/redis%E9%97%AE%E9%A2%98-2.png" title="可见流出带宽越来越高"></p>
<p>（2）从而引发redis的内存使用率，在5min之内从0%-&gt;100%<br><img data-src="/images/redis%E9%97%AE%E9%A2%98-4.png" title="redis的内存使用率达到了100%"></p>
<p>（3）最终全面GET SET timeout崩溃（11点22分02秒）<br><img data-src="/images/redis%E9%97%AE%E9%A2%98-3.png" title="从日志看，redis基本不可用了"><br><img data-src="/images/redis%E9%97%AE%E9%A2%98-5.png" title="从日志看，redis基本不可用了"></p>
<p>（4）最终导致页面返回timeout，故障发生。</p>
<h2 id="排查思路"><a href="#排查思路" class="headerlink" title="排查思路"></a>排查思路</h2><p>内存使用率100% 就等同于redis不可用吗？<br>解答：正常使用情况下，不是。因为redis有【缓存淘汰机制】。Redis 在内存使用率达到 100% 时不会直接崩溃。相反，它依赖内存淘汰策略来释放内存，确保系统的稳定性。</p>
<p>这个配置在哪里呢？如图：<br><img data-src="/images/redis%E9%97%AE%E9%A2%98-6.png" title="这里默认的是：volatile-lru"><br>大部分开发都是不会主动去调整这里的参数的。</p>
<p>你根据实际需求配置适当的内存淘汰策略，以便在内存达到上限时，系统能够稳定地处理新请求，而不会出现写操作失败的情况（只要不是noeviction）。也就是说，照理SET and GET都应该没啥问题才对（先不考虑其他复杂命令）。</p>
<p>尽管 Redis 本身不会轻易崩溃，但如果内存耗尽且没有淘汰策略或者淘汰策略未能生效，Redis 可能拒绝新的写操作，并返回错误：<code>OOM command not allowed when used memory &gt; &#39;maxmemory&#39; </code>。如果系统的配置或者操作系统的内存管理不当，可能会导致 Redis 进程被操作系统杀死。</p>
<p>但是事故现象就是：内存使用率100% 时，redis不可用，怎么解释？</p>
<p>【猜测1】会是淘汰不及时导致的性能瓶颈吗？也就是说 写入的速度&gt;&gt;淘汰的速度。</p>
<p>解答：如果是正常的业务写入，不可能！因为redis纯内存，淘汰速度是非常快的。而且这个业务特性，也并非高频写入。这个redis实例其实里面存储的KEY很少，查了一下，最终占了整个实例的内存使用率&lt;5%。如图：<br><img data-src="/images/redis%E9%97%AE%E9%A2%98-7.png" title="真正key占用的内存其实很少"></p>
<p>不太符合正常使用下KEY不断增多，最终挤爆内存使用率的问题。</p>
<p>因此，初步结论：Redis 的崩溃一般不会是由于单纯写入速度超过淘汰速度引起的，尤其是使用了合理的内存淘汰策略时；如果写入速度非常高，而淘汰策略无法及时清除旧数据，Redis 可能会非常频繁地进行键的查找和淘汰操作，从而导致性能下降。</p>
<p>那么问题来了，到底是什么导致了内存使用率激增那？？因此查阅了资料，发现最为贴近的答案：<br><img data-src="/images/redis%E9%97%AE%E9%A2%98-8.png" title="内存使用率突然升高的几个原因"><br>证据支撑<br><img data-src="/images/redis%E9%97%AE%E9%A2%98-9.png" title="在出故障的时候，流入带宽竟然也有一波激增"><br><img data-src="/images/redis%E9%97%AE%E9%A2%98-10.png" title="redis客户端的buffer打满了"></p>
<p>果然是这样，说明内存是被【缓冲区】挤爆的。为了验证，使用info memory进行分析（我随便模拟了一个缓冲区溢出的case，并非事故现场）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Memory</span><br><span class="line">used_memory:1072693248</span><br><span class="line">used_memory_human:1023.99M</span><br><span class="line">used_memory_rss:1090519040</span><br><span class="line">used_memory_rss_human:1.02G</span><br><span class="line">used_memory_peak:1072693248</span><br><span class="line">used_memory_peak_human:1023.99M</span><br><span class="line">used_memory_peak_perc:100.00%</span><br><span class="line">used_memory_overhead:1048576000</span><br><span class="line">used_memory_startup:1024000</span><br><span class="line">used_memory_dataset:23929848</span><br><span class="line">used_memory_dataset_perc:2.23%</span><br><span class="line">allocator_allocated:1072693248</span><br><span class="line">allocator_active:1090519040</span><br><span class="line">allocator_resident:1090519040</span><br><span class="line">total_system_memory:16777216000</span><br><span class="line">total_system_memory_human:16.00G</span><br><span class="line">used_memory_lua:37888</span><br><span class="line">used_memory_lua_human:37.89K</span><br><span class="line">used_memory_scripts:1024000</span><br><span class="line">used_memory_scripts_human:1.00M</span><br><span class="line">maxmemory:1073741824</span><br><span class="line">maxmemory_human:1.00G</span><br><span class="line">maxmemory_policy:noeviction</span><br><span class="line">allocator_frag_ratio:1.02</span><br><span class="line">allocator_frag_bytes:17825792</span><br><span class="line">allocator_rss_ratio:1.00</span><br><span class="line">allocator_rss_bytes:0</span><br><span class="line">rss_overhead_ratio:1.00</span><br><span class="line">rss_overhead_bytes:0</span><br><span class="line">mem_fragmentation_ratio:1.02</span><br><span class="line">mem_fragmentation_bytes:17825792</span><br><span class="line">mem_not_counted_for_evict:0</span><br><span class="line">mem_replication_backlog:0</span><br><span class="line">mem_clients_slaves:0</span><br><span class="line">mem_clients_normal:1048576000</span><br><span class="line">mem_aof_buffer:0</span><br><span class="line">mem_allocator:jemalloc-5.1.0</span><br><span class="line">active_defrag_running:0</span><br><span class="line">lazyfree_pending_objects:0</span><br></pre></td></tr></table></figure>

<p>从上面的<code>INFO memory</code>输出中，我们可以看到一些关键信息，这些信息表明大部分内存被缓冲区占用殆尽：<br>1.内存使用情况：<br>	used_memory: 1072693248 （1.02 GB）<br>	maxmemory: 1073741824 （1.00 GB）<br>上面的输出表明，当前内存使用几乎达到了配置的最大内存限制，内存已接近耗尽。<br>2.缓冲区占用：<br>	used_memory_overhead: 1048576000 （1.00 GB）<br>这个值表示 Redis 开销的内存，包括缓冲区、连接和其他元数据。在这种情况下，大部分 used_memory (1.02 GB) 被 used_memory_overhead (1.00 GB) 占用，这意味着大部分内存都被缓冲区等开销占据。<br>3.数据集占用：<br>	used_memory_dataset: 23929848 （23.93 MB）<br>	used_memory_dataset_perc: 2.23%<br>这里显示，实际存储的数据只占了非常少的一部分内存（约 23.93 MB），而绝大部分内存被缓冲区占据。<br>4.客户端缓冲区：<br>	mem_clients_normal: 1048576000 （1.00 GB）<br>这表明普通客户端连接占用了约 1.00 GB 内存，这通常意味着输出缓冲区可能已经接近或达到了设定的限制。<br>5.内存碎片：<br>	allocator_frag_ratio: 1.02<br>	mem_fragmentation_ratio: 1.02<br>碎片率不高，表明内存被合理使用但被缓冲区占用过多。</p>
<p>总结:<br>从上面的例子可以看出，Redis 的内存几乎被缓冲区占用殆尽。以下是具体的结论：</p>
<ol>
<li>当前内存使用 (used_memory) 已经接近最大内存限制 (maxmemory)，即 1.02 GB 接近 1.00 GB 的限制。</li>
<li>内存开销 (used_memory_overhead) 很大，主要被客户端普通连接使用（可能是输出缓冲区），而实际的数据仅占用了很少的内存。</li>
<li>分配器和 RSS 碎片率 (allocator_frag_ratio 和 mem_fragmentation_ratio) 较低，表明碎片不是问题。</li>
</ol>
<p>为啥要有这个缓存区，先看这个原理图：<br><img data-src="/images/redis%E9%97%AE%E9%A2%98-11.jpg" title="简单明了的展示了Redis工作原理（含缓冲区）"></p>
<p>缓冲区的功能其实很简单，主要就是用一块内存空间来暂时存放命令数据，以免出现因为数据和命令的处理速度慢于发送速度而导致的数据丢失和性能问题。</p>
<p>那么缓冲区的大小可以通过参数调整么？答案是没有。因为这个是在代码里写死的，1GB。也就是说redis客户端最多可以暂存1GB的数据，在生产环境里1GB其实挺合适了，对绝大多数的请求够用了，而且如果再大的话，就会对应用所在的容器内存占用过多，导致应用无法正常使用而崩溃。</p>
<p>最后的结论就是：</p>
<ol>
<li>对象存储的部分因为是有过期时间的，过期了自然被清理了；</li>
<li>【缓冲内存】↑ （涌入）；</li>
<li>【对象内存】↓ （定时清理）；</li>
<li>并受MAX内存掣肘（上限）；<br>最终的结局：Redis 的内存完全被缓冲区占据。</li>
</ol>
<p>自然，每当有SET请求进来的时候，SET却不进来——因为「内存淘汰策略」(maxmemory-policy) 淘汰的是【对象内存】，对缓存区压根起不到作用！！！</p>
<p>结论：<br>Redis 的内存完全被缓冲区占据，实际上 Redis 将无法正常工作，包括数据存储（SET 操作）和数据读取（GET 操作）。</p>
<h2 id="还原真相"><a href="#还原真相" class="headerlink" title="还原真相"></a>还原真相</h2><ol>
<li><p>当时自然增长导致流出带宽不断变大直至96MB&#x2F;s。<br><img data-src="/images/redis%E9%97%AE%E9%A2%98-12.png" title="这里人工调整到96mb"></p>
</li>
<li><p>流出带宽超过96MB&#x2F;s，输出缓冲区内存占用激增甚至溢出 （300setMaxTotal*10机器ip数量个客户端，之前推导过可以到9G）。</p>
</li>
<li><p>导致输出缓冲区爆了，redis客户端连接不得不关闭。<br><img data-src="/images/redis%E9%97%AE%E9%A2%98-13.png" title="这里人工调整到96mb"></p>
</li>
<li><p>客户端连接关闭后，导致请求都走DB。</p>
</li>
<li><p>DB走完之后都会执行SET。</p>
</li>
<li><p>SET流量飙升，且因都是大KEY，导致流入带宽激增（别看写QPS只有50，但是如果每个写都是2MB，就可以做到瞬间占满流入带宽）。</p>
</li>
<li><p>Redis主线程模型，处理请求的速度过慢（大KEY），出现了间歇性阻塞，无法及时处理正常发送的请求，导致客户端发送的请求在输入缓冲区越积越多。</p>
</li>
<li><p>输入缓冲区内存随即激增。</p>
</li>
<li><p>最终，redis内存被缓冲区内存（输入、输出）完全侵占。</p>
</li>
<li><p>后续的SET GET命令甚至都进不了输入缓冲区，阻塞持续到客户端配置的<code>SoTimeout</code>时间。</p>
</li>
<li><p>造成最终的不可用（后续的命令想进场，要依赖当前输入缓冲区里的命令被执行给你腾出来位置，但是还是那句话Redis主线程处理消化的速度，实在是太慢了,此时可以结合监控看到Redis的QPS骤降。</p>
</li>
</ol>
<p>归根揭底，造成问题原因是因为大key并且是热点数据，最终导致输出缓冲区到达限制，进而引发雪崩。</p>
<h2 id="大KEY的问题"><a href="#大KEY的问题" class="headerlink" title="大KEY的问题"></a>大KEY的问题</h2><p>首先，大KEY其实并不是长度过长的KEY，而是存放了慢查询命令的KEY。对于String类型，慢查询的本质在于value的大小。对于其他类型，慢查询的本质在于集合的大小（时间复杂度带来）。</p>
<p>如何解决大key，可以看阿里云的这篇文章：<a href="https://help.aliyun.com/zh/redis/user-guide/identify-and-handle-large-keys-and-hotkeys/?spm=a2c4g.11186623.0.i1">https://help.aliyun.com/zh/redis/user-guide/identify-and-handle-large-keys-and-hotkeys/?spm=a2c4g.11186623.0.i1</a> ，除了这个文章之外，可以再加一个本地缓存来解决大key风险。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>SRE</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>在百花之中干掉一个杂草连接...</title>
    <url>/2018/02/08/%E5%9C%A8%E7%99%BE%E8%8A%B1%E4%B9%8B%E4%B8%AD%E5%B9%B2%E6%8E%89%E4%B8%80%E4%B8%AA%E6%9D%82%E8%8D%89%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>早上接到阿里云的服务器报警，说有一台服务器的流量超标，这个服务器的外网带宽是5M，但是登陆进去使用<code>iftop -i eth1</code>发现里面的流量已经几乎跑满，如图：<br><img data-src="/images/tcpkill1.png" alt="paradin"></p>
<p>我这个服务器的名称叫online-mts-001，为啥会有一个mail25.u.tsender.com，这个是什么鬼？莫非是通过我的服务器去连接这个“邮箱”域名？于是我就ping了一下这个mail25.u.tsender.com，结果如图：<br><img data-src="/images/tcpkill2.png" alt="paradin"></p>
<p>看到这个域名对应的ip地址是115.29.177.8，嗯，115.29.177.8，哎？这个ip地址好熟悉啊，卧槽，这特么不是这个<code>online-mts-001</code>的外网ip么？<br><img data-src="/images/tcpkill3.png" alt="paradin"></p>
<p>也就是说我这个机器在我不知道的情况下被人绑定了一个域名！但是我这个服务器不是网页服务器，上面那个tsender.com的域名打不开，我检查了服务器一番，发现这个机器没有被人入侵的痕迹，只能说是被人有意&#x2F;无意（无意的可能性更大，比如看错了阿拉伯数字）绑定了域名。</p>
<p>被人绑定了域名就好比被人起了外号一样，一旦非本人操作就不太好往下摘了，查了很多资料都没有办法，毕竟主动权不在我这里了。</p>
<p>但是回头过来，我们的重心是要解决那个占据了3M带宽的连接，<code>netstat</code>看了一下，发现这个连接的具体信息如下：<br><img data-src="/images/tcpkill4.png" alt="paradin"></p>
<p>仅仅是干掉连接的话，方法有很多，关闭网卡再重开或者关闭相应的服务都可以，但是现在的问题是这台服务器是生产环境的服务器，它主要是给用户提供视频拉流，通过抓包分析得知，这位183.228.128.188的用户合法通过外网连接到了这台视频服务器，而且拉取的是高清视频，所以才占据了这么大的带宽。不过我们还是决定先断开这位用户的连接同时不动其他用户的连接，这位183.228.128.188的用户在客户端虽然会发觉视频断开，但是有缓存和人为刷新的客观因素，实际的体验不会差太多，至少不会投诉400…</p>
<p>那么如何干掉一个established连接同时保证其他连接呢？请使用<code>tcpkill</code>。</p>
<p>tcpkill的下载比较有说法，下面是安装步骤：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wget <span class="attr">http</span>:<span class="comment">//rpm.repo.onapp.com/ramdisk-hv/centos6/dsniff/libnids-1.24-1.el6.x86_64.rpm</span></span><br><span class="line">wget <span class="attr">http</span>:<span class="comment">//rpm.repo.onapp.com/ramdisk-hv/centos6/dsniff/libnet-1.1.5-1.el6.x86_64.rpm</span></span><br><span class="line">wget <span class="attr">http</span>:<span class="comment">//rpm.repo.onapp.com/ramdisk-hv/centos6/dsniff/dsniff-2.4-0.14.b1.el6.x86_64.rpm</span></span><br><span class="line">yum install libICE libSM libXmu -y</span><br><span class="line">rpm -ivh libnet-<span class="number">1.1</span><span class="number">.5</span>-<span class="number">1.</span>el6.<span class="property">x86_64</span>.<span class="property">rpm</span></span><br><span class="line">rpm -ivh libnids-<span class="number">1.24</span>-<span class="number">1.</span>el6.<span class="property">x86_64</span>.<span class="property">rpm</span> </span><br><span class="line">rpm -ivh  dsniff-<span class="number">2.4</span>-<span class="number">0.14</span>.<span class="property">b1</span>.<span class="property">el6</span>.<span class="property">x86_64</span>.<span class="property">rpm</span></span><br></pre></td></tr></table></figure></p>
<p>请按顺序操作，不然的话dsniff就会报错：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">warning</span>: dsniff-<span class="number">2.4</span>-<span class="number">0.14</span>.<span class="property">b1</span>.<span class="property">el6</span>.<span class="property">x86_64</span>.<span class="property">rpm</span>: <span class="title class_">Header</span> <span class="variable constant_">V3</span> <span class="variable constant_">RSA</span>/<span class="title class_">SHA256</span> <span class="title class_">Signature</span>, key <span class="variable constant_">ID</span> 0608<span class="attr">b895</span>: <span class="variable constant_">NOKEY</span></span><br><span class="line"><span class="attr">error</span>: <span class="title class_">Failed</span> <span class="attr">dependencies</span>:</span><br><span class="line">libnet.<span class="property">so</span><span class="number">.1</span>()(64bit) is needed by dsniff-<span class="number">2.4</span>-<span class="number">0.14</span>.<span class="property">b1</span>.<span class="property">el6</span>.<span class="property">x86_64</span></span><br><span class="line">libnids.<span class="property">so</span><span class="number">.1</span><span class="number">.24</span>()(64bit) is needed by dsniff-<span class="number">2.4</span>-<span class="number">0.14</span>.<span class="property">b1</span>.<span class="property">el6</span>.<span class="property">x86_64</span></span><br></pre></td></tr></table></figure></p>
<p>安装完毕之后，就会生成<code>tcpkill</code>命令，如图：<br><img data-src="/images/tcpkill5.png" alt="paradin"></p>
<p>然后断开上面那个大带宽连接的命令是：<code>./tcpkill -i eth0 src port 9132 and dst port 9595 and src host 115.29.177.8 dst host 183.228.128.188</code>或者<code>./tcpkill -s 115.29.177.8:9132 -d 183.228.128.188:9595</code>。</p>
<p>但是要注意一下！<font color=red>tcpkill一定要运行在能接收到应答包的主机上在，最好运行在连接或半连接存在的一端主机上，因为tcpkill会发现这个连接里有数据传输进而感知并且干掉</font>。而且tcpkill默认情况下是只能干掉established状态的连接，对于假死连接（连接在，但是数据不传输）或者半连接（由于tcp keeplive没打开而又没有数据向对端发送，导致一直无法感知次连接其实已经断开）是无法断开的。</p>
<p>如果遇到上述所说的假死连接和半连接就需要手动更改tcpkill的源码，更改原理在<code>https://yq.aliyun.com/articles/59308</code>。</p>
<p>如果使用的系统是ubuntu or debian，还可以使用cutter命令，<code>apt-get install cutter</code>下载即可。使用方法：<code>http://www.cyberciti.biz/tips/cutting-the-tcpip-network-connection-with-cutter.html</code>。</p>
<p>至于第一个问题，怎么把这台服务器上的域名撤除，我倒要好好想想了…</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.cyberciti.biz/howto/question/linux/kill-tcp-connection-using-linux-netstat.php">http://www.cyberciti.biz/howto/question/linux/kill-tcp-connection-using-linux-netstat.php</a><br><a href="http://www.gnutoolbox.com/tcpkill-command/">http://www.gnutoolbox.com/tcpkill-command/</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>如何做好tl</title>
    <url>/2025/03/12/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BDtl/</url>
    <content><![CDATA[<p>最近我老婆偶然间跟我聊起带人的话题，说老板考虑要让她尝试带一两个同学一起做事，她比较不情愿，原因是一旦要担负起一个团队，就意味着你的责任变了。可能同样是协同一两个同学，你在里面牵头做事，但是是TL还是PM，差别还是很大的。PM是为事情负责任的，但是TL除了为事情负责之外，更多的部分还是需要为人负责。这一部分甚至超过50%。</p>
<p><img data-src="/images/%E5%A6%82%E4%BD%95%E5%81%9Atl.png" title="责任的进步"></p>
<p>团队目前刚好也到了需要进一步从PM制走向TL制的阶段了，我在想一个小团队的重组或者新建，往往更大的挑战在于TL本身，而不是在于一线的同学。</p>
<p>不要把leader当做一种权利和荣耀，当你被赋予一个leader的角色的时候。更应该有的是担心和焦虑。</p>
<p>对于一个新的TL，或者说一个已经有经验的TL接手一个新团队，首先是先要过自己这一关。如何让自己在最短的时间里变得“笃定”，这是一个很关键的词。</p>
<p>笃定，并不来源于你经验的多少，或者资历的长短，p级的高低。更多的是来源于你是否能比大家看的更清楚，想的更明白。你在跟大家沟通交谈的时候，能给到大家什么样的输入。还是你看到的世界和大家也就是一样，这是两种截然不同的感觉。</p>
<p>口才很好，滔滔不绝，好多人觉得这种人是不是更容易被大家承认，更容易做好TL的角色。但是这只是现象，滔滔不绝可能并不能帮你获得好感，相反只会让人觉得虚伪做作。</p>
<p>我觉得玉伯并不是一个口才很好的人，但是并不妨碍他是一个特别厉害的TL，所以会说不是本质，传达的内容，看问题的视角，思考的角度和深度，这才是“会说”与“不会说”的差别。</p>
<p>不能信己，何以信人。</p>
<p>第二，面临一个新的团队，新的环境，新的业务，最关键的一点是如何去“立信”，前面说的是why的问题，这里是how的问题。</p>
<p>立信最直接的方式就是两个词“目标+胜仗”。</p>
<p>目标意味着清晰明确的规划，对于局势的判断，问题的梳理，明确做什么和不做什么之后得到的输出。</p>
<p>你能不能把当前团队的问题看清楚，局势看清楚，需要做的事情想明白，找到解法和抓手，意味着你是否能给团队带来增量的价值。</p>
<p>这是你是否能获得团队首肯的第一要素。</p>
<p>接下来就是打胜仗提气特别重要。是不是一个好将军，进战场打一仗就知道。</p>
<p>本地生活接手客户端团队，外卖的接手；从本地生活到五道口，三江第一家店的开张；再到后来接手盒马App团队，“愚公移山”的战役。本质上都是立信的第一场仗，决不能输~</p>
<p>想清楚之后就快速组织提气打仗，立军旗，进沙场拿下第一仗。这就要凭将军的硬本事了。</p>
<p>摇旗呐喊，打一场打胜仗对于稳定军心，立信 尤其重要，也是直接的手段。</p>
<p>TL一定要把大家的成长放到第一位，懂得进去带领大家，也要懂得松手留出空间。</p>
<p>永远不要和自己团队的同学抢功劳和成果。优秀的兵在战场上杀掉了一百个敌军，这是他的战功，Leader不能说因为是我带着他杀的，所以这一百个敌军也是我杀的。</p>
<p>你存在的价值是让你的团队升值，而不是分配和安排。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>职场</tag>
        <tag>管理</tag>
      </tags>
  </entry>
  <entry>
    <title>大量任务冲击下的activeMQ报错&quot;GC overhead limit exceeded&quot;</title>
    <url>/2019/01/14/%E5%A4%A7%E9%87%8F%E4%BB%BB%E5%8A%A1%E5%86%B2%E5%87%BB%E4%B8%8B%E7%9A%84activeMQ%E6%8A%A5%E9%94%99GC-overhead-limit-exceeded/</url>
    <content><![CDATA[<p>半夜阿里云的杭州可用B区出现了机房抖动，几乎所有的B区服务全部掉线。阿里云的技术人员捅咕了半个小时左右，在大约11点40左右恢复了正常。此时几百万的设备开始同时恢复上线，然而经过了1个小时左右，依旧有几十万设备无法上线，有的甚至上线后又掉线。</p>
<p>我们的架构是设备要先去“注册中心”注册，注册成功之后才会正常的工作。如果多次注册不成功，就会释放连接，把连接让给其他需要注册的设备。但是发现设备上线的速度很慢，扩容了几台“注册中心”模块，效果依旧不见好转。发现注册模块的CPU全部都达到了100%：<br><img data-src="/images/activemq4.png" alt="akb48"></p>
<p>登录到服务器里一看，日志不断的刷新这样的内容：<br><img data-src="/images/activemq1.png" alt="akb48"></p>
<p>模块与activemq的延迟特别大，此时activemq又有几百万的消息没有消费堆积在队列里。大约十分钟左右，就开始抛出<code>java.lang.OutOfMemoryError: GC overhead limit exceeded</code>的错误，如图：<br><img data-src="/images/activemq2.png" alt="akb48"></p>
<p>但是同一时间段里的activemq并没有出现内存吃紧的情况：<br><img data-src="/images/activemq3.png" alt="akb48"></p>
<p>没有办法，就先赌一下的重启了activemq，没想到问题就解决了…</p>
<p>奇怪，明明activemq没有内存的明显消耗，却报内存耗尽。先把结果记录下来，等下一次再有类似的情况，好好观察一下（也但愿不要再在放假的时候出现故障了…）</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>activemq</tag>
      </tags>
  </entry>
  <entry>
    <title>如何彻底删除360</title>
    <url>/2025/02/22/%E5%A6%82%E4%BD%95%E5%BD%BB%E5%BA%95%E5%88%A0%E9%99%A4360/</url>
    <content><![CDATA[<p>前两天，我在尝试将微信语音转化mp3的时候，需要下载一个软件，但是不小心联同下载并安装了360。结果这个流氓软件果然在卸载之后，依旧会在电脑中有大量的残留。残留在c盘program files(x86)的360文件夹里，还随着开机启动。如果我直接删除这个文件，那么就会报“你需要来自administertors的权限才能删除”这样的提示。目前搜了一下，没有一个特别好的办法能够解决这个问题。</p>
<p>尝试了了半天，在csdn里有一个亲试可行的办法，来做记录和分享。</p>
<p>首先 <code>win+r</code> 进入运行窗口-&gt;输入<code>msconfig</code>-&gt;点击<code>引导</code>选项-&gt;选择<code>安全引导</code>-&gt;直接重启你的电脑。 重启之后你的电脑进入一个管控状态，然后找到360文件夹下的360safe文件夹，全选然后删除掉就行了。</p>
<p>确认都删除干净后。再次<code>win+r</code> 进入运行窗口-&gt;输入<code>msconfig</code>-&gt;点击引导选项-&gt;取消掉刚才点击的安全引导-&gt;再次重启你的电脑。你的win11就恢复正常了，同时360的内容也消失了。</p>
<p>最后让我骂一句，360以及周鸿祎，你们真特么的缺德，真他妈不要个脸！</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>360</tag>
        <tag>流氓软件</tag>
        <tag>垃圾清理</tag>
      </tags>
  </entry>
  <entry>
    <title>如何理解GOPATH</title>
    <url>/2021/04/15/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3GOPATH/</url>
    <content><![CDATA[<h2 id="干巴巴的理论"><a href="#干巴巴的理论" class="headerlink" title="干巴巴的理论"></a>干巴巴的理论</h2><p>Golang劝退一般有几个地方，第一个地方就是<code>GOROOT/GOPATH</code>的配置，第二个就是指针，第三个就是数组。这里先说第一个，它是基础中的基础。这里的配置操作系统是Windows，IDE是<code>VsCode</code>，GO版本是<code>1.17.3</code>。</p>
<p>一般来说，有些“零基础教程”会让你在安装好golang之后，默认把go的安装路径放在<code>C:\go</code>里，然后让你做如下的配置：<br><img data-src="/images/gopath.png" title="这个配置是正常的"></p>
<p>那么如果你按照这样把<code>GOPATH = %UserProfile%\gopath</code>,那么当你打开VsCode的时候，就会提示你gotools插件都会安装到这里：<br><img data-src="/images/gopath2.png" title="设置或者修改GOPATH的值，可以用命令set GOPATH&#x3D;路径会重新覆盖之前的所用，需要重启IDE"></p>
<p>如果VScode安装tools反馈<code>permission denied</code>，如图：<br><img data-src="/images/gopath4.png"></p>
<p>那么需要<code>sudo chmod -R 777 /usr/local/go/bin</code>给一下权限。</p>
<p>可见GOROOT就是Go的安装路径，主要是为了防止你的电脑里有多个GO版本，这样当你<code>go run or go build</code>的时候，能正确找到对应的那个可执行文件go。而GOPATH就是一个环境变量，是你workspace的根目录。所以说写GO的人不要轻易在其他人的电脑上另起炉灶，另起炉灶就要重新配置玩这意。这个的好处是对开发人员的一个管理，不要随意新开目录。在<code>GOPATH</code>指定的工作目录下，代码总是会保存在<code>$GOPATH/src</code>目录下。在工程经过<code>go build、go install</code>或<code>go get</code>等指令后，会将产生的二进制可执行文件放在 <code>$GOPATH/bin</code>目录下，生成的中间缓存文件会被保存在<code>$GOPATH/pkg</code>下。</p>
<p>但是要知道GO自带的包都是很基础的，如果我们要获取远程第三方包，就要用<code>go get</code>下载，那么当你去<code>go get</code>的时候，其实对应的代码是被下载到<code>$GOPATH/src/</code>里的，如图：<br><img data-src="/images/gopath3.png"></p>
<p>这里要注意一点，就是当import包时，会优先在GOROOT里进行查找，import导入后的包，是基于GOPATH进行创建的。当然，如果你想一镜到底，写一个脚本，那可以不设置GOPATH。直接<code>package main，func main</code>确认脚本入口就开始一把梭。</p>
<h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>我们现实中肯定一个<code>.go</code>文件就能全搞定的事儿少之又少，那么难免就要多个文件联合起来，以一个文件作为main总入口，这个“入口文件”里面会import多个其他文件，来达到效果。这里有个面试知识点：main函数跟init函数一样，是没有参数和返回值的。</p>
<p>举一个例子，比如我们有一个go文件，它是链接数据库的文件。首先我们在<code>$GOPATH/src/</code>下创建一个test，然后先创建一个叫<code>print_hello.go</code>的文件内容如下：</p>
<pre><code><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Call_Hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Print(<span class="string">&quot;我要玩英灵殿啊啊啊！!&quot;</span>);</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<p>然后在test文件夹下再创建一个<code>mysql</code>的文件夹，里面创建一个<code>con_mysql.go</code>:<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package mysql</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func Connect_mysql() &#123;</span><br><span class="line">	fmt.Print(&quot;你已成功连接到数据库！!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在桌面搞一个<code>call.go</code>:<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;test&quot;</span><br><span class="line">	&quot;test/mysql&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	fmt.Printf(&quot;测试一下调用GOPATH的效果&quot;)</span><br><span class="line">	fmt.Println()</span><br><span class="line">	test.Call_Hello()</span><br><span class="line">	mysql.Connect_mysql()</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img data-src="/images/gopath5.png" title="成功调用到上面那俩文件"></p>
<p>从这个例子我们可以看出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>当执行golang程序，需要获取<span class="keyword">import</span>的包时，编译器回先去GOROOT路径下的src文件夹找有没有我们在程序中<span class="keyword">import</span>的包</span><br><span class="line"><span class="number">2.</span>如果在GOROOT下没有找到，就会去GOPATH下src下找这个包</span><br></pre></td></tr></table></figure>
<p>所以只要GOROOT跟GOPATH下都没找到包的话就会报错，如果明明在$GOPATH&#x2F;src&#x2F;XXX下有对应的目录，但是报“package ‘xxx’ is not in GOROOT”，那么使用<code>export GO111MODULE=off</code>,因为gopath模式引入包从src目录下开始引入，这里需要需要关闭<code>go mod</code>模式。</p>
<p>但是要注意<code>export GO111MODULE=off</code>，这个是对于单独终端窗口而言的，而不是对全局而言的，所以Vscode的<code>Run Code</code>会提示失败，但是在终端里使用<code>go run XXX.go</code>是OK的。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/a244f48f49b3">https://www.jianshu.com/p/a244f48f49b3</a><br><a href="https://www.cnblogs.com/wuhaidong/articles/10405960.html">https://www.cnblogs.com/wuhaidong/articles/10405960.html</a><br><a href="https://sysin.org/blog/go-vs-code/#0-%E7%B3%BB%E7%BB%9F%E5%87%86%E5%A4%87-1">https://sysin.org/blog/go-vs-code/#0-%E7%B3%BB%E7%BB%9F%E5%87%86%E5%A4%87-1</a><br><a href="https://www.jianshu.com/p/82b55b516cc8">https://www.jianshu.com/p/82b55b516cc8</a><br><a href="https://www.jianshu.com/p/a244f48f49b3">https://www.jianshu.com/p/a244f48f49b3</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>大阪二刷行</title>
    <url>/2023/05/18/%E5%A4%A7%E9%98%AA%E4%BA%8C%E5%88%B7%E8%A1%8C/</url>
    <content><![CDATA[<p>2023年春季，日本放开对中国游客的签证，当然党的媒体没有大肆宣传这个事儿。原本日本大使馆只准许持有5年签的人去旅游，到了五月初，日本放开了中国人旅游签证里对“核酸”的要求和签证的要求。也就是说原来还要去做鼻拭子，在visit japan web <a href="https://www.vjw.digital.go.jp/main/#/vjwpco001">https://www.vjw.digital.go.jp/main/#/vjwpco001</a> 里上传报告，现在通通不要了，临时签证也可以办理了。<br><img data-src="/images/%E5%A4%A7%E9%98%AA%E4%B9%8B%E8%A1%8C2.png" title="等了好久终于等到今天..."></p>
<p>飞猪上找到旅行社搞定护照签证之后，开始订往返飞机票和酒店，因为填写visit japan web的时候需要输入航班和酒店以及护照里的信息，然后去淘宝上搞定移动WIFI，再搞定各种各样的门票。我把上次买的西瓜卡又翻出来，西瓜卡五年不用才会作废，所以时隔3年疫情还是可以用的。由于日本的关西电压跟国内不同，还要带一个转换头和插排，但是还是建议三项插头的东西能不带还是不要带，能用两头的插头的就用两头插头。</p>
<p>然后，切记！还要去微信小程序里搜索“指尖海关”，进行“出&#x2F;入境卫生健康申报”和“货币申报”。国家要求不能带出去超过5000美元的现金，我算了一下，就算人民币跟美元的比例是1：6.5，人民币跟日元比例是1：19.5，那么5000美元就是63万日元，只要不超过这个数字就不用申报了。<br><img data-src="/images/%E5%A4%A7%E9%98%AA%E4%BA%8C%E5%88%B73.JPG" title="无论出入境，这个是必须要填的"><br><img data-src="/images/%E5%A4%A7%E9%98%AA%E4%BA%8C%E5%88%B71.png" title="最近日元贬值，可见日本政府多么欢迎外国人来消费"></p>
<p>我这次住在大阪日航酒店，主打一个交通方便，话说日本的消费是真贵，这个酒店一夜1000+，同样的价钱在上海能住四星级了。</p>
<h2 id="行程安排"><a href="#行程安排" class="headerlink" title="行程安排"></a>行程安排</h2><ol>
<li>第一天（5月26日）：<br>根据飞机票上的航班查询到我大概是16点45降落到关西机场，下飞机后办理出关手续领取行李，话说办理出关很快，只需要扫一下visit japan web上的二维码然后对比一下护照信息就可以了。关西机场有巴士直达心斋桥大阪日航酒店，在18点40上车的话，20点02到达心斋桥，不过苹果店是21点关门，所以时间还是比较紧张的。车票是1600日元一个人，可以直接飞机场买票，发车时间可见：<a href="https://www.kate.co.jp/tcn/timetable/detail/UH">https://www.kate.co.jp/tcn/timetable/detail/UH</a> 。</li>
</ol>
<p><img data-src="/images/IMG_1064.jpg" title="大阪站还是挺气派的..."><br>插播一句，我看了几个日本深夜巴士的视频，其实还挺想试试的…</p>
<p>如果汽车时间不符合，那么就乘坐南海電鐵 <a href="https://www.howto-osaka.com/tc/access-timetable/">https://www.howto-osaka.com/tc/access-timetable/</a> 。南海电铁比机场大巴还便宜，普通的930一个人（可以刷西瓜卡得到一个小的火车票），豪华的就是深蓝色车（这个车叫rapi:t号），它商务舱是1500日元左右一个人（这个也刷西瓜卡，或者现金和信用卡购买），这个深蓝色车上是有人验票的，发现你没有票就要当场补票。这两个可在机场的电子机器操作 <a href="https://www.howto-osaka.com/cn/ticket/web-nankaiallline2daypass/">https://www.howto-osaka.com/cn/ticket/web-nankaiallline2daypass/</a> 。强烈安利坐rapi:t号，非常的酷而且商务舱也很舒服。<br><img data-src="/images/IMG_1105.jpg" title="1500买不到吃亏买不到上当"></p>
<p>买HARAKUA的话一个人的票价费用是2610日元，这个就比较贵了，当然也更豪华。但是时间比较短，只用50分钟就能达到心斋桥 <a href="https://youtu.be/HRtXSssDrLs">https://youtu.be/HRtXSssDrLs</a> 。</p>
<p>到了心斋桥，先杀去apple store买iphone 14 pro max，其实日本的iphone比国内没有便宜很多，256G的iphone 14 promix也只是便宜了7百块而已，而且现在苹果商品已经不能退税了。不过为了防止店内没有现货，可以在官网预定或者查看库存是否充足。</p>
<p>晚上来了一顿小烧鸟充饥。</p>
<ol start="2">
<li>第二天（5月27日）:<br>原本我们打算去小豆岛，但是做了一下攻略发现要从大阪去小豆岛的话要早上5点钟起床，因为小豆岛的观光巴士只有每天9点45一班，错过就没了，这完全是特种兵旅游，我考虑再三最后放弃了，改去奈良。<br><img data-src="/images/IMG_0064.jpg" title="小鹿超级可爱"><br><img data-src="/images/IMG_0126.jpg" title="来一个冰淇淋吧！"></li>
</ol>
<p>要去奈良，用西瓜卡直接刷地铁就行。8点24在大阪难波上车，坐近铁奈良线去近铁奈良，大约30分钟的样子就到了奈良站（老子日常上班还要50分钟哩！），出站后不久就到了奈良公园，那里就有很多很多的鹿，鹿饼200日元一包，喂鹿是一个开心的事儿！然后去了春日大社和东大寺，最后去了若草山，山上即有鹿又能看到山下的城镇景色，而且可以爬山锻炼身体，大约要爬50分钟左右上到最高峰，最后下山在志津香釜饭吃饭。<br><img data-src="/images/IMG_0137.jpg" title="这里可以许愿，我见过一个哥们许愿是‘诉讼必胜’"><br><img data-src="/images/IMG_0147.jpg" title="在春日大社看到不少日本家庭带着孩子过来参拜，给他们的孩子求一个健康的身体"></p>
<p>晚上在心斋桥的药妆店开启第一波的买买买模式，吃了一顿大阪烧当夜宵。</p>
<ol start="3">
<li>第三天（5月28日）：<br>这一天的安排是：天满宫 + 今昔馆 + 梅田百货 + 梅田棒球打击场 + NMB48公演。</li>
</ol>
<p>天满宫附近有一个wanna manna早餐店，里面主打的是台湾早餐，蛮正宗的，可以先尝一尝台湾风味。日本人不喜欢吃粥，在这家台湾早餐店里吃到粥。天满宫是日本当地祈求考试通过和学业进步的地方，供奉一个学识渊博的历史人物，叫啥我没记住，人气挺高的。</p>
<p>今昔馆在一个写字楼里，可以模拟江户时代的大阪一天的街景，灯光模拟日出日落，里面不算大，一共3层。<br><img data-src="/images/IMG_1145.JPG"></p>
<p>大阪的二次元跟东京的秋叶原完全不是一个级别，但是也比国内强出太多，梅田有任天堂和宠物小精灵的店，在里面可以买到周边和switch卡带，但是手办什么的到很少：<br><img data-src="/images/IMG_0632.JPG" title="王国之泪感觉有点小贵呢..."><br><img data-src="/images/IMG_0633.JPG" title="旷野之息的价格依旧维持高盘"></p>
<p>晚上梅田还有一个棒球打击场，400日元20个球，每人一个道，可以调发球的速度和高度。话说20个球我基本1分钟就打完了，还是很快的，我一共打了3组，一共60个球，轮棒子轮的肌肉都充血了。<br><img data-src="/images/IMG_0669.jpg" title="棒球轮的我胳膊疼"></p>
<p>回酒店的时候，路过难波，那里有NMB48剧场，不过它的公演信息提前5天才会出，买票可以去官网预定 <a href="https://ticket.akb48-group.com/home/top.php?mode=&gr=NMB48">https://ticket.akb48-group.com/home/top.php?mode=&amp;gr=NMB48</a> ，不同演出的价钱还不一样，我选的那场俩人大约6000日元。<br><img data-src="/images/%E5%A4%A7%E9%98%AA%E4%BA%8C%E5%88%B71.JPG" title="先注册用户，不过这个注册用户很蛋疼，都是日文的，反正你拿不准的就复制他的例子就行，然后就要等日子才可以买票了，然后还要带护照去实名观看，很麻烦。"></p>
<p><img data-src="/images/IMG_1003.jpg" title="当天的演出阵容，要看演出别忘了带护照"></p>
<ol start="4">
<li>第四天（5月29日 周一）：<br>这天是环球影城之旅！<br><img data-src="/images/IMG_0696.jpg" title="官方时间9点开门，结果8点就已经这么多人了"></li>
</ol>
<p>马里奥园区的票可以在飞猪上购买，其实价钱比官网贵一点，但是省去了不懂日语的苦。不过飞猪上的时间选择面比较少，只能是客服帮你选择的时间，而官网的时间是随便选的。然后把飞猪里面的二维码打印到A4纸上或者上传到USJ的app，在USJ的APP上也可以看到排队信息以及抢通行证的时间。</p>
<p>话说那是起早贪黑的一天，不过有个tips，就是环球影城的现在<code>no limit!游行</code>时间是下午14点，持续50分钟（晚上的游行目前取消了），如果那时候你在马里奥园区玩的正爽但是又想看游行，那估计就要学习分身术了。不过看游行肯定要提前去占路边位置的，不然到时候就是里三层外三层了。<br><img data-src="/images/IMG_0730.jpg" title="马里奥园区超级还原"><br><img data-src="/images/IMG_0803.jpg" title="马里奥园区的饭店也需要排队，所以这时候就可以一个人带着手环去打砖块或者shopping，另一个人去排队，但是要注意不要跟游行时间撞车哦"></p>
<p>现在环球影城的限时活动是如下几个：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 柯南，每人<span class="number">3600</span>日元，玩一个密室逃脱，算上排队时长大约<span class="number">2</span>个半小时，票只能在官网买。逃脱工具是支持中文的，但是coser的对白是日语无字幕，建议人多能彼此交流的话一起玩，不然<span class="number">1</span>~<span class="number">2</span>个人解不了多少迷就发现时间结束了。而且这个要用掉<span class="number">2</span>个半小时，更要合理安排时间。</span><br><span class="line"><span class="number">2.</span> 咒术回战的4D电影，据说一般般，不推荐。</span><br><span class="line"><span class="number">3.</span> 多啦A梦的VR过山车，这个据说不错，可以买express卡，没有express卡就建议第一时间冲过去然后硬排吧。</span><br><span class="line"><span class="number">4.</span> 怪物猎人，就是一群人穿VR设备打怪，很多的VR装备哦！这个估计要<span class="number">60</span>分钟，<span class="number">1800</span>日元一个人。</span><br><span class="line"><span class="number">5.</span> 间谍家族，这个不花钱，是在一个地方给你素材需要你<span class="number">4</span>~<span class="number">5</span>个解密，解密成功得到口令，然后跟工作人员说这个口令，就会得到一个special show的入场券，然后进去看一个coser的show，但是解密很棒但是show一般，而且素材全是日文的，show也是日文的，不懂日语就算了吧。</span><br></pre></td></tr></table></figure></p>
<p>环球影城当天可能会有一些项目不开放，在购票的时候要看官网信息，比如我这次飞天翼龙就不开放，不开放也好，那玩意坐一次晕一次…</p>
<p>攻略可以参考：<a href="https://osaka.letsgojp.com/archives/397621/">https://osaka.letsgojp.com/archives/397621/</a></p>
<ol start="5">
<li>第五天（5月30日 周二）：<br>这一天的安排是：难波八坂神社 + 梅田百货 + 甘辛や(《孤独的美食家 第五季》里五郎吃过的店哦！)</li>
</ol>
<p>难波八坂神社离我们的距离其实比天满宫要近，它是一个求姻缘的神社，但是由于神社的大狮子造型也吸引了不少的游客。而且我们去的时候还有日本家族在里面商讨在神社举办婚礼的事儿。<br><img data-src="/images/IMG_0488.jpg" title="难波八坂神社是在居民区里的"><br><img data-src="/images/IMG_0489.jpg" title="这个大狮子其实是平成年间做的，不算太老"></p>
<p>然后我们又又又坐地铁回到了梅田，因为梅田这里的大商场实在太多了，梅田站这里就5个！而且每幢大楼都10多层，日本人的商场跟中国不一样，他们不会在一楼卖车也不会在顶楼开电影院，不过他们会在顶楼卖画，在这里逛街实在太爽了。</p>
<p>第六天（5月31日 周三）：<br>最后一天啦，我们早上去药妆店买一点小东西，又去难波的高岛屋都转了一圈，TASHAM和加拿大鹅买了几样。然后在高岛屋旁边的大阪站坐南海电铁返回KIX关西机场，在免税店扫荡了几条烟给同事。最后返回杭州，全程结束。</p>
<h2 id="旅游小tips"><a href="#旅游小tips" class="headerlink" title="旅游小tips"></a>旅游小tips</h2><ol>
<li><p>阪急和高岛屋的退税不是把全部的10%都退给你，如果退成现金是收1.55%的手续费的，退到银行卡的话还要加收一点，总计大约2%，这样就只优惠了8%。不过这两个店都是高档商品的卖场，所以要买高档物品这1.55%是肯定躲不掉的。<br><img data-src="/images/IMG_0472.jpg" title="大丸jump shop的海贼王..."></p>
</li>
<li><p>苹果apple store购买的商品都不免税，但是在家电市场里购买苹果手机或许会免税…</p>
</li>
<li><p>微信支付的汇率比较好，19.7。相比之下用信用卡的话，汇率只有19.2，但是苹果店是不支持支付宝和微信支付的，只能用信用卡，害我多花了100块。<br><img data-src="/images/IMG_0475.jpg" title="在大丸看到哈兰德与贝克汉姆的签名球衣..."></p>
</li>
<li><p>无论是出关入关都要填写微信小程序的“指尖海关”，里面需要你的航班和座位号，座位号可以随便写…</p>
</li>
<li><p>大阪饭店和商场上班都好晚，感觉不少店铺10点多才上班，然后20~21点就鸣金收兵了，劳动法贯彻的特别好。<br><img data-src="/images/IMG_1023.jpg" title="大阪西心斋桥派出所，旁边是小小的御津公园，晚上这个公园有不少开摩托或者开古董车的人在聚会"></p>
</li>
<li><p>环球影城几乎每天开门的时间都要早于官方时间，我周一去的环球影城，官方时间是9点开门，实际8点15就放我们进去了…</p>
</li>
<li><p>环球影城的周期活动票不能在飞猪等合作网站购买，只能在官方购买，这里需要日语能力。</p>
</li>
<li><p>这里推荐你冲进了环球影城之后，赶紧手机上抢下一个时间段的马里奥园区的整理券，但是人是要直接冲去玩哆啦A梦，因为哆啦A梦是一个大热款，早上排不到，那么全天就要100分钟排队起步。如果你没买提前15分钟进场的票和马里奥的快速通行卡，马里奥整理券又没抢到的话，那么基本太阳下山前就不可能进得去马里奥园区了。<br><img data-src="/images/IMG_1169.jpg" title="早上8点38分的哆啦A梦就要排队160分钟，你敢信？"></p>
</li>
<li><p>其实除了环球影城，整个大阪都推荐一个人排队，另一个人并发的去干点别的什么（比如买点周边、凑齐5000日元消费去办理退税等等），这样能节省大量的时间。<br><img data-src="/images/IMG_0998.jpg" title="这个蛋糕花了我40分钟排队！"></p>
</li>
<li><p>日本的男装基本都是瘦子穿的，如果你不了解日潮，那么就买优衣库、紫标的the north face、adidas、denham、川久保玲、小狐狸maison kitsune、nanamica吧，这几个肯定不会错，它们在日本都能买到大陆买不到的好设计，而且还相对便宜。<br><img data-src="/images/IMG_0474.jpg" title="奇才时期的八村塁亲笔签名的海报..."></p>
</li>
<li><p>订环球影城的门票不要着急，确认了当天的天气后再下单，我这次就遇到了雨天，游行什么的都取消了。</p>
</li>
<li><p>入住宾馆的时候，基本在酒店的免费资料里都会有一个“大阪优惠券”这样的小传单，用这些都能打一点小折扣。<br><img data-src="/images/IMG_1141.jpg"><br><img data-src="/images/IMG_1140.jpg" title="让肌肉男孩给你表演一下徒手捏爆橙子吧！"></p>
</li>
<li><p>本次6天5晚的旅行，我就在大屏幕上看到两个中国人—迪丽热巴和周冬雨，她俩都是某女性品牌的代言人。</p>
</li>
<li><p>小米和华为在大阪毛都没见一个。<br><img data-src="/images/IMG_1087.JPG" title="帅气的摩托车..."></p>
</li>
<li><p>相比较住在心斋桥道顿堀附近，还是住在梅田比较好，因为梅田那里的大商业圈超级多，当然住一宿价钱也不便宜。</p>
</li>
<li><p>大阪大丸的JUMP SHOP其实没啥意思，相比较而言梅田阪神的任天堂的人更多。<br><img data-src="/images/IMG_0626.jpg" title="这里面有任天堂大全集"></p>
</li>
<li><p>杭州的国际出发等待区太破了，除了一个星巴克和小商店就没吃的了，而且茅台、中华、化妆品种类也不多，在朗朗乾坤之下我差点饿死在杭州机场里。</p>
</li>
<li><p>大阪过了安检之后吃的东西也不多，我最后抢到了一份寿司垫肚子。</p>
</li>
<li><p>很多人喜欢最后一天再去药妆店买东西，但是切记，液体是要走托运的，千万别买了液体后忘记了托运，不然就要像我一样跑出来单独再运一次。<br><img data-src="/images/IMG_1107.jpg" title="感谢机场的台湾小妹妹和日本大叔，帮助我快速托运快速安检"></p>
</li>
</ol>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>总而言之这是一次超级爽的旅行，买了好多也体验了很多新东西。而且这几天我们争取每天吃的东西都不一样，尝到了“烧鸟、拉面、大阪烧、汉堡、炸鸡炸猪排饭、KFC、釜饭、王将饺子、寿司、烤肉”，这里面让我惊艳的一个是<code>shogun burger</code>的汉堡，另一个就是力丸烧肉里面的和牛，非常不错。一兰拉面排队太狠，我们吃了隔壁家的作作浪花拉面，味道也很棒。</p>
<p>话说日本人的饮食真的是“万物都可沙拉酱”，我上面列举的除了拉面基本都有沙拉酱，包括饺子…</p>
<p>出发前我带了大约32万的日元现金，回来的时候剩下2万不到，里面有6万是帮同事代购的。其实日本的消费还是蛮高的，大阪的消费水平是北上广深的级别，比如地铁出行一次就200日元左右，这就将近10块钱，俩人吃一顿饭基本6000日元，高级一点的10000日元，这就300~500元，更别提住了。然后我又算了一下全部的费用，就是包含签证、酒店、来回机票等等所有费用是差一点到6万块。</p>
<p>说到旅游，无非就是“吃美食、玩景点和开心购物”。在亚洲范围内，能满足这三点的地方并不多，台湾现在去不了，西亚那边气候和食物受不了，看来看去无非就是韩国、马来西亚、新加坡和日本这东亚的几个国家了。明年如果有机会的话，我想去看看新加坡和韩国，看看那里的风土人情会不会也很棒。</p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>旅游</tag>
        <tag>日本</tag>
      </tags>
  </entry>
  <entry>
    <title>如何手动释放linux内存</title>
    <url>/2018/02/23/%E5%A6%82%E4%BD%95%E6%89%8B%E5%8A%A8%E9%87%8A%E6%94%BElinux%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<p>在生产过程中，一些java模块会比较残忍的吃系统内存，然后如果这个模块写的比较挫，产生的垃圾就会比较多，如果linux系统的内存释放也不会及时，然后恶性循环，最后就把进程卡死，但是服务器是不可以down机的，所以这个时候就需要我们运维出来，手动的释放内存。</p>
<p>首先，我们登陆一台服务器，<code>free -m</code>看一下目前的情况：<br><img data-src="/images/neicun1.png" alt="paradin"></p>
<p>然后<code>cat /proc/sys/vm/drop_caches</code>，会看到里面的值是0，0是不释放的意思。</p>
<p><code>sync</code>,将系统缓存区中的脏数据写入磁盘中，包括已修改的i-node、已延迟的块I&#x2F;O和读写映射文件。</p>
<p><code>echo 3 &gt; /proc/sys/vm/drop_caches</code></p>
<p>为什么这里是<code>3</code>呢？这是因为<code>echo 1</code>的话代表“清理页面缓存”，<code>echo 2</code>的话代表“清理索引节点（inode）链接”，<code>echo 3</code>就是包括上面两者。</p>
<p><code>sysctl -p</code>,这样不用重启服务器也可以生效。出现下面的一连串文字之后，再<code>free -m</code>看一下：<br><img data-src="/images/neicun2.png" alt="paradin"></p>
<p>从112释放到2790，可见效果立竿见影。</p>
<p>上面整个过程的自动化脚本是这样的：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/bin/</span>bash</span><br><span class="line">#<span class="title class_">Author</span>:<span class="title class_">Chris</span> <span class="title class_">Chan</span></span><br><span class="line">#E-<span class="attr">mail</span>:chen_shuo@dahuatech.<span class="property">com</span></span><br><span class="line">oldmemory=$(free -m|sed -n <span class="string">&#x27;2p&#x27;</span>|awk <span class="string">&#x27;&#123;printf $4&#125;&#x27;</span>)</span><br><span class="line">echo <span class="string">&quot;开始的空余内存值：&quot;</span>$oldmemory</span><br><span class="line">sync</span><br><span class="line">echo <span class="number">3</span> &gt; <span class="regexp">/proc/</span>sys/vm/drop_caches</span><br><span class="line">sysctl -p</span><br><span class="line">correctmemory=$(free -m|sed -n <span class="string">&#x27;2p&#x27;</span>|awk <span class="string">&#x27;&#123;printf $4&#125;&#x27;</span>)</span><br><span class="line">echo <span class="string">&quot;释放完后的空余内存值：&quot;</span>$correctmemory</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>安装vim8.0的过程</title>
    <url>/2018/03/14/%E5%AE%89%E8%A3%85vim8-0%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>1.先卸载老的vim<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yum remove vim-* -y</span><br></pre></td></tr></table></figure></p>
<p>2.下载第三方yum源<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wget -P /etc/yum.<span class="property">repos</span>.<span class="property">d</span>/  <span class="attr">https</span>:<span class="comment">//copr.fedorainfracloud.org/coprs/mcepl/vim8/repo/epel-7/mcepl-vim8-epel-7.repo</span></span><br></pre></td></tr></table></figure></p>
<p>3.安装vim<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yum -y install vim-enhanced </span><br></pre></td></tr></table></figure></p>
<p>4.验证vim版本<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rpm -qa |grep vim</span><br><span class="line">vim-enhanced-<span class="number">8.0</span><span class="number">.0704</span>-<span class="number">1.1</span><span class="number">.26</span>.<span class="property">el7</span>.<span class="property">centos</span>.<span class="property">x86_64</span></span><br><span class="line">vim-common-<span class="number">8.0</span><span class="number">.0704</span>-<span class="number">1.1</span><span class="number">.26</span>.<span class="property">el7</span>.<span class="property">centos</span>.<span class="property">x86_64</span></span><br><span class="line">vim-minimal-<span class="number">8.0</span><span class="number">.0704</span>-<span class="number">1.1</span><span class="number">.26</span>.<span class="property">el7</span>.<span class="property">centos</span>.<span class="property">x86_64</span></span><br><span class="line">vim-filesystem-<span class="number">8.0</span><span class="number">.0704</span>-<span class="number">1.1</span><span class="number">.26</span>.<span class="property">el7</span>.<span class="property">centos</span>.<span class="property">x86_64</span></span><br></pre></td></tr></table></figure></p>
<p><img data-src="/images/huojin.png" alt="paradin" title="霍金与长者"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>运维技术</tag>
        <tag>编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title>孤儿进程和僵尸进程</title>
    <url>/2018/03/07/%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="原理与定义"><a href="#原理与定义" class="headerlink" title="原理与定义"></a>原理与定义</h2><p>首先要知道，<code>linux</code>有父进程和子进程这样的说法。那父进程如何创建子进程呢？<code>fork</code>。</p>
<p>子进程的进行和父进程的进行是异步的，但是父进程就像父母一样对自己的小孩也有一定的控制欲，这个控制欲就表现在如果子进程如果结束了，它释放了之前占用的资源、内存、文件等等，但是它还保留了一点信息：进程号PID、退出状态、运行时间等等。而这些残留信息是父进程通过<code>wait/waitpid</code>来获取，如果父进程一直不获取，那么子进程就会一直保留这些信息直到海枯石烂。</p>
<p><strong>孤儿进程</strong>：父进程退出，子进程继续进行，那么此时子进程就是孤儿进程。这个时候<code>init</code>进程（进程号为1）来作为子进程的监护人，发出<code>wait/waitpid</code>来完成状态收集工作；<br><img data-src="/images/jiangshi.png" alt="paradin" title="这个nginx的worker process就成了孤儿进程"></p>
<p><strong>僵尸进程</strong>：父进程没有退出，但是它迟迟不发出<code>wait/waitpid</code>来回收子进程的资源。就好比儿子死了，当爹的不给收尸，这个儿子就成了孤魂野鬼成了僵尸。</p>
<h2 id="影响与危害"><a href="#影响与危害" class="headerlink" title="影响与危害"></a>影响与危害</h2><p>孤儿进程是没有什么大的危害，虽然他虽然没有了亲生父亲，但是也有<code>init</code>进程来通过循环的<code>wait()</code>来处理它的善后工作，所以迟早会把占用的资源释放掉。</p>
<p>甚至有的用户可以把进程弄成孤儿进程，以使之与用户会话脱钩，并转至后台运行。这一做法常应用于启动需要长时间运行的进程，也即守护进程。另外，<code>nohup</code>命令也可以完成这一操作。</p>
<p>但是僵尸进程不一样，要是父进程对子进程一直不使用<code>wait/waitpid</code>，那么<code>pid</code>就会不回收，可是系统内的pid总是是有限的，这样久而久之就是对pid的一个霸占，新的进程也无法生成，这就是僵尸进程的危害。</p>
<h2 id="如何处理僵尸进程"><a href="#如何处理僵尸进程" class="headerlink" title="如何处理僵尸进程"></a>如何处理僵尸进程</h2><p>僵尸进程是杀不死的，怎么办？杀他爹，把父进程杀掉了，那么这些僵尸就成了孤儿进程，然后再由init收养，最后入土为安。</p>
<p>查看当前服务器僵尸进程的方法：<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ps -A -o stat,ppid,pid,cmd | grep -e <span class="string">&#x27;^[Zz]&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>如果服务器上的僵尸进程不是出自一个父进程之手，那么就用下面这个命令批量解决：<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ps -A -o stat,ppid,pid,cmd | grep -e <span class="string">&#x27;^[Zz]&#x27;</span> | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | xargs kill -<span class="number">9</span></span><br></pre></td></tr></table></figure></p>
<p>但是如果父进程是init进程，那么这样的僵尸进程怎么办？答案，不用刻意管他，相信<code>init</code>的能力，它迟早会被<code>init</code>回收的，成为僵尸进程也是暂时的。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zh.wikipedia.org/wiki/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B">https://zh.wikipedia.org/wiki/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B</a><br><a href="https://zh.wikipedia.org/wiki/%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B">https://zh.wikipedia.org/wiki/%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B</a><br><a href="http://blog.csdn.net/YuZhiHui_No1/article/details/53011390">http://blog.csdn.net/YuZhiHui_No1/article/details/53011390</a><br><img data-src="/images/perfume.jpg" alt="paradin"> </p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>将Gateone添加到django，实现WEB的ssh链接</title>
    <url>/2019/04/01/%E5%B0%86Gateone%E6%B7%BB%E5%8A%A0%E5%88%B0django%EF%BC%8C%E5%AE%9E%E7%8E%B0WEB%E7%9A%84ssh%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<h2 id="背景交代"><a href="#背景交代" class="headerlink" title="背景交代"></a>背景交代</h2><p>python3 + django2.1<br>Django project:accessgateway</p>
<h2 id="gateone的安装"><a href="#gateone的安装" class="headerlink" title="gateone的安装"></a>gateone的安装</h2><p>Gateone是一个web界面的交互工具，很多堡垒机都会使用到它，它的生命力很长久也很经得住考验（不过最近github上已经不再对它有更新了）。安装方法如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install --upgrade setuptools</span><br><span class="line">pip install tornado==<span class="number">4.3</span></span><br><span class="line">pip install Pillow</span><br><span class="line">docker pull liftoff/gateone		<span class="comment">#拉取镜像，个人推荐把原有的镜像修改一下，添加vim等工具</span></span><br><span class="line">docker run -t -p <span class="number">8008</span>:<span class="number">8000</span> -h GATEONE --name gateone liftoff/gateone gateone	<span class="comment">#创建容器</span></span><br></pre></td></tr></table></figure></p>
<p>这样我们就创建了一个叫<code>gateone</code>的容器，宿主机端口是<code>8008</code>，此时通过浏览器访问<code>https://IP：8008</code>，就会看到效果：<br><img data-src="/images/gateone1.png" alt="akb48"></p>
<p>默认的gateone是<code>https</code>访问，如果要改成<code>http</code>访问。那么就要修改容器里的<code>/etc/gateone/conf.d</code>文件夹下的<code>10server.conf</code>，修改如下两处：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;disable_ssl&quot;</span>: true,	<span class="comment">#改成http方式</span></span><br><span class="line"><span class="string">&quot;origins&quot;</span>: [<span class="string">&quot;localhost:8000&quot;</span>, <span class="string">&quot;127.0.0.1:8000&quot;</span>, <span class="string">&quot;594f279c70b0:8000&quot;</span>, <span class="string">&quot;django的外网IP:django端口&quot;</span>],	<span class="comment">#添加django的地址和端口</span></span><br></pre></td></tr></table></figure></p>
<p>然后重启容器，改用<code>http://IP：8008</code>方式去访问，发现已经改成HTTP协议了。</p>
<h2 id="gateone的配置"><a href="#gateone的配置" class="headerlink" title="gateone的配置"></a>gateone的配置</h2><p>现在这个gateone容器需要已经指定准许django来访问，但是还要生成一个api，让django通过api来访问。在容器里执行<code>gateone --new_api_key</code>，发现在<code>/etc/gateone/conf.d</code>文件夹下多了一个<code>30api_keys.conf</code>：<br><img data-src="/images/gateone3.png" alt="akb48"></p>
<p>然后修改<code>60docker.conf</code>，把<code>&quot;auth&quot;: &quot;none&quot;</code>,改成<code>&quot;auth&quot;: &quot;api&quot;</code>,保存之后，此时如果重启容器，发现web界面已经不能访问了，会出现<code>unauthenticated</code>的提示，如图：<br><img data-src="/images/gateone4.png" alt="akb48"></p>
<h2 id="gateone集成到django"><a href="#gateone集成到django" class="headerlink" title="gateone集成到django"></a>gateone集成到django</h2><p>gateone部分暂时告于段落，现在配置Django，首先是<code>views.py</code>，注意！python2与python3有些地方不同，我这里是python3版本：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time,hmac,hashlib,json</span><br><span class="line"></span><br><span class="line"><span class="comment">#web交互界面gateone</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gateone</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="built_in">id</span> = <span class="number">1</span>	<span class="comment">#这里暂时写死只要id为1的服务器</span></span><br><span class="line">    svr = server.objects.get(<span class="built_in">id</span> = <span class="built_in">id</span>)</span><br><span class="line">    ip = svr.outIP</span><br><span class="line">    port = svr.port</span><br><span class="line">    username = svr.username   <span class="comment">#写死端口和用户名</span></span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;aggateone.html&#x27;</span>,<span class="built_in">locals</span>())	<span class="comment">#返回aggateone.html页面</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gateone认证</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_signature</span>(<span class="params">secret,*parts</span>):</span><br><span class="line">    <span class="built_in">hash</span> = hmac.new(secret, digestmod=hashlib.sha1)</span><br><span class="line">    <span class="keyword">for</span> part <span class="keyword">in</span> parts:</span><br><span class="line">        <span class="built_in">hash</span>.update(<span class="built_in">str</span>(part).encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span>.hexdigest()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_auth_obj</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># 安装gateone的服务器以及端口.</span></span><br><span class="line">    gateone_server = <span class="string">&#x27;http://121.41.37.251:8008&#x27;</span>	<span class="comment">#本地gateone的访问地址，注意http格式</span></span><br><span class="line">    <span class="comment"># 生成的api_key 和secret</span></span><br><span class="line">    api_key = <span class="string">&#x27;OGQxZGM5OGM1MGNlNDZkNmEwMTNmM2IyY2NlMGZlNjA3Z&#x27;</span>  <span class="comment">#这里是30api_keys.conf文件里的key</span></span><br><span class="line">    secret = <span class="string">b&#x27;MDIzOWQyN2Y2MmU0NDdhMWIwN2Q3MjIzODU1MGFjYWVkY&#x27;</span>	<span class="comment">#这里是30api_keys.conf文件里的secret</span></span><br><span class="line">    authobj = &#123;</span><br><span class="line">        <span class="string">&#x27;api_key&#x27;</span>:api_key,</span><br><span class="line">        <span class="string">&#x27;upn&#x27;</span>:<span class="string">&#x27;gateone&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;timestamp&#x27;</span>:<span class="built_in">str</span>(<span class="built_in">int</span>(time.time() * <span class="number">1000</span>)),</span><br><span class="line">        <span class="string">&#x27;signature_method&#x27;</span>:<span class="string">&#x27;HMAC-SHA1&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;api_version&#x27;</span>:<span class="string">&#x27;1.2&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    authobj[<span class="string">&#x27;signature&#x27;</span>] = create_signature(secret,authobj[<span class="string">&#x27;api_key&#x27;</span>],authobj[<span class="string">&#x27;upn&#x27;</span>],authobj[<span class="string">&#x27;timestamp&#x27;</span>])</span><br><span class="line">    auth_info_and_server = &#123;<span class="string">&#x27;url&#x27;</span>:gateone_server,<span class="string">&#x27;auth&#x27;</span>:authobj&#125;</span><br><span class="line">    <span class="keyword">return</span> JsonResponse(auth_info_and_server)</span><br></pre></td></tr></table></figure></p>
<p>然后新增两条路由到<code>urls.py</code>：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path(<span class="string">r&#x27;gateone.html&#x27;</span>, views.gateone),</span><br><span class="line">path(<span class="string">r&#x27;get_auth_obj.html&#x27;</span>,views.get_auth_obj,name=<span class="string">&quot;get_auth_obj&quot;</span>),</span><br></pre></td></tr></table></figure></p>
<p>最后就是编写前端页面<code>aggateone.html</code>：<br>	<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends &#x27;agbase.html&#x27; %&#125;</span><br><span class="line">&#123;% load staticfiles %&#125;</span><br><span class="line">&#123;% block title %&#125;Gateone远程连接&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block css %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span> = <span class="string">&quot;/static/jquery-3.3.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span> = <span class="string">&quot;/static/gateone/gateone.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>	<span class="comment">&lt;!-- 这里需要手动复制一下gateone.js文件到django的静态文件夹里 --&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">$(function () &#123;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">        <span class="comment">&lt;!--添加参数--&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">        var ip = &#x27;</span><span class="template-variable">&#123;&#123; <span class="name">ip</span> &#125;&#125;</span><span class="language-xml">&#x27;;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">        var user = &#x27;</span><span class="template-variable">&#123;&#123; <span class="name">username</span> &#125;&#125;</span><span class="language-xml">&#x27;;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">        var port = &#x27;</span><span class="template-variable">&#123;&#123; <span class="name">port</span> &#125;&#125;</span><span class="language-xml">&#x27;;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">        var ssh_url = &#x27;ssh://&#x27;+user+&#x27;@&#x27;+ip+&#x27;:&#x27;+port;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">        //请求认证信息</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">        <span class="comment">&lt;!--发起认证请求--&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">        $.ajax(&#123;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">                        url:&#x27;&#123;% url &#x27;get_auth_obj&#x27; %&#125;&#x27;,</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">                        type:&#x27;GET&#x27;,</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">                        dataType:&#x27;json&#x27;,</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">                        success:function (data) &#123;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">                        var auth_message = data.auth;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">                        var auth_url = data.url;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">                        GateOne.init(&#123;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">                                auth:auth_message,</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">                                url:auth_url,</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">                                theme:&#x27;solarized&#x27;,</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">                                goDiv:&#x27;#gateone&#x27;,</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">                                disableTermTransitions:&#x27;true&#x27;,</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">                                autoConnectURL:ssh_url</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">                        &#125;);</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">                &#125;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">        &#125;);</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">        <span class="comment">&lt;!--状态记录--&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">        GateOne.Base.superSandbox(&quot;GateOne.SomePlugin&quot;, [&quot;GateOne&quot;, &quot;GateOne.Net&quot;,  &quot;GateOne.Terminal.Input&quot;, &quot;GateOne.Terminal&quot;], function(window, undefined) &#123;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">                var location =  ip;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">                GateOne.prefs.autoConnectURL=ssh_url;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">                GateOne.prefs.fontSize=&quot;100%&quot;;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">                GateOne.prefs.scrollback = 10000;  // scrollback buffer up to 10,000 lines</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">                GateOne.Terminal.loadFont(&quot;Source Code Pro&quot;, &quot;150%&quot;);</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">                GateOne.Net.setLocation(location);</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">                <span class="comment">&lt;!--记录登录状态--&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">        &#125;);</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">&#125;)</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">&quot;gateone_container&quot;</span> <span class="attr">style</span> = <span class="string">&quot;position:relative; width: 110em; height: 55em;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">&quot;gateone&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p>
<p>重启django进程，浏览器打开<code>gateone.html</code>页面看一下效果：<br><img data-src="/images/gateone5.png" alt="akb48"></p>
<p>可见我们已经成功的把gateone嵌入到django里了，而且自动就链接”id&#x3D;1”这台服务器。大功告成，剩下的就是修改一下细节，给所有服务器一个按钮，只要点击这个按钮就会打开对应的远程链接界面。</p>
<h2 id="事后补充"><a href="#事后补充" class="headerlink" title="事后补充"></a>事后补充</h2><p>刚才那个<code>views.py</code>里“gateone认证”那两个def函数上面不要加上<code>@login_required</code>，会出现<code>AttributeError: &#39;bytes&#39; object has no attribute &#39;user&#39;</code>错误：<br><img data-src="/images/gateone11.png" alt="akb48"></p>
<p>这是因为<code>@login_required</code>这个装饰器首先回去判断user是否是登录状态，会从<code>request</code>里获取<code>User</code>，但是在下面的函数里并没有传递这个User，所以就会报错。如果说非要加上<code>@login_required</code>这个装饰器，那么就要把<code>User</code>传入当做第一个函数。</p>
<p>详情可见：<a href="https://stackoverflow.com/questions/13423022/django-str-object-has-no-attribute-user">https://stackoverflow.com/questions/13423022/django-str-object-has-no-attribute-user</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.codecp.org/2018/03/23/Django%E5%9F%BA%E7%A1%80Gateone%E5%AE%9E%E7%8E%B0Web%E7%BB%88%E7%AB%AFSSH%E5%8A%9F%E8%83%BD/">http://blog.codecp.org/2018/03/23/Django%E5%9F%BA%E7%A1%80Gateone%E5%AE%9E%E7%8E%B0Web%E7%BB%88%E7%AB%AFSSH%E5%8A%9F%E8%83%BD/</a><br><a href="https://github.com/liftoff/GateOne/issues/257">https://github.com/liftoff/GateOne/issues/257</a><br><a href="https://www.jianshu.com/p/b8123a8178de">https://www.jianshu.com/p/b8123a8178de</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>gateone</tag>
      </tags>
  </entry>
  <entry>
    <title>实战Kibana的日志关键词搜索和日志可视化</title>
    <url>/2018/01/17/%E5%AE%9E%E6%88%98Kibana%E7%9A%84%E6%97%A5%E5%BF%97%E5%85%B3%E9%94%AE%E8%AF%8D%E6%90%9C%E7%B4%A2%E5%92%8C%E6%97%A5%E5%BF%97%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先，先下载一个elastic网站上下载一个它提供的demo—莎翁的《亨利四世》，下载地址是<a href="https://download.elastic.co/demos/kibana/gettingstarted/shakespeare.json">https://download.elastic.co/demos/kibana/gettingstarted/shakespeare.json</a> 。</p>
<p>打开这个json字符串，里面就是《亨利四世》的话剧剧本，长得是这个样子：<br><img data-src="/images/kibana1.png" alt="akb48"></p>
<p>可以看到里面有<code>play_name</code>、<code>speaker</code>、<code>speech_number</code>、<code>line_id</code>等等名称，每个名称后面都有一个对应的值。</p>
<p>然后启动elasticsearch，按照上面的文件格式生成索引。语句如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">curl -<span class="variable constant_">XPUT</span> <span class="attr">http</span>:<span class="comment">//localhost:9200/shakespeare -d &#x27;</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;mappings&quot;</span> : &#123;</span><br><span class="line">  <span class="string">&quot;_default_&quot;</span> : &#123;</span><br><span class="line">   <span class="string">&quot;properties&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;speaker&quot;</span> : &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>, <span class="string">&quot;index&quot;</span> : <span class="string">&quot;not_analyzed&quot;</span> &#125;,    #确定type是字符</span><br><span class="line">    <span class="string">&quot;play_name&quot;</span> : &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>, <span class="string">&quot;index&quot;</span> : <span class="string">&quot;not_analyzed&quot;</span> &#125;,</span><br><span class="line">    <span class="string">&quot;line_id&quot;</span> : &#123; <span class="string">&quot;type&quot;</span> : <span class="string">&quot;integer&quot;</span> &#125;,    #确定type是数字</span><br><span class="line">    <span class="string">&quot;speech_number&quot;</span> : &#123; <span class="string">&quot;type&quot;</span> : <span class="string">&quot;integer&quot;</span> &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">&#x27;;</span></span><br></pre></td></tr></table></figure></p>
<p>导入刚刚下载的那个json：<code>curl -XPOST &#39;localhost:9200/shakespeare/_bulk?pretty&#39; --data-binary @shakespeare.json</code></p>
<p>具体elasticsearch的增删改查语法可以参看阮大师的<a href="http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html">http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html</a> ，个人建议将elasticsearch和mysql对比一下，这样更方便理解。</p>
<p>然后后台启动kibana，确认5601端口已经stand by，如图：<br><img data-src="/images/kibana2.png" alt="akb48"></p>
<p>然后在浏览器地址栏输入<code>服务器外网ip：5601</code>打开kibana。</p>
<p>导入数据结束之后，使用<code>curl &#39;localhost:9200/_cat/indices?v&#39;</code>，去查看一下效果，如果看到index里有shakespeare那一栏就是导入成功了，如图：<br><img data-src="/images/kibana3.png" alt="akb48"></p>
<p>在启动Kibana后，Kibana会自动在配置的es中创建一个名为<code>.kibana</code>的索引（上图第二个），这个索引用来存储数据，注意！不要删除了它。</p>
<h2 id="Kibana的界面搜索"><a href="#Kibana的界面搜索" class="headerlink" title="Kibana的界面搜索"></a>Kibana的界面搜索</h2><p>如果此时的kibana里是第一次配置的话，那么第一步就是配置新索引，我们之前在生成索引的时候写的是<code>shakespeare</code>，那么现在也写<code>shakespeare</code>，然后点击<code>create</code>，如图：<br><img data-src="/images/kibana4.png" alt="akb48"></p>
<p>然后在菜单栏左侧的<code>discover</code>里选择刚刚建立的<code>shakespeare</code>，就会看到这样的东西：<br><img data-src="/images/kibana5.png" alt="akb48"></p>
<p>在Search上就可以进行搜寻，比如说我搜寻<code>freedom</code>，如图：<br><img data-src="/images/kibana6.png" alt="akb48"></p>
<p>如果我搜寻<code>KING HENRY IV</code>，他不分大小写的把所有king、henry、iv都搜索出来。</p>
<p>如果我想搜寻line_id的第一行到第三行，那么语句就是<code>line_id:[1 TO 3]</code>，如图：<br><img data-src="/images/kibana17.png" alt="akb48"></p>
<p>如果想在上面的基础上进一步细化，比如说要在line_id是从第一行到第三行，同时_type是scene的语句：<code>line_id:[1 TO 3] AND _type:scene</code>：<br><img data-src="/images/kibana18.png" alt="akb48"></p>
<p>假如不想要scene，那么就把<code>AND</code>改成<code>NOT</code>。</p>
<p>如果这个时候只想关注一些指定的字段，那么可以将鼠标移动到索引下面的字段上，然后选在add即可，同样的移动上面已经选择的字段选择remove进行移除，比如我们试一下这个<code>speaker</code>：<br><img data-src="/images/kibana19.png" alt="akb48"></p>
<p>add之后在点击右侧的具体的speaker，就会看到里面的细节，比如这位westmoreland（威斯摩兰伯爵）：<br><img data-src="/images/kibana7.png" alt="akb48"></p>
<p>这个时候就能看见这位伯爵大哥的台词细节，在第几场的第几节，说的是什么台词。再返回菜单左侧点击这个speaker，我们还会看到一个比重：<br><img data-src="/images/kibana8.png" alt="akb48"></p>
<p>从这里就很清晰的看到，FALSTAFF（法斯塔夫）这个哥们的台词最多，也符合书里塑造的那个嗜酒话痨的艺术形象。而我们的KING HENRY IV(亨利四世)的台词只是第四位，占比重11%而已…</p>
<p>这样具体的搭配搜索之后，可以点击界面右上侧的save进行保存搜寻结果，再搭配share分享搜索结果的url网址，如图：<br><img data-src="/images/kibana9.png" alt="akb48"></p>
<h2 id="Kibana的图像化展示"><a href="#Kibana的图像化展示" class="headerlink" title="Kibana的图像化展示"></a>Kibana的图像化展示</h2><p>Kibana也能做到类似grafana那样的炫酷图象化展示，更加立体的表现日志情况，首先选择左侧菜单栏里的<code>Visualize</code>（可视化）：<br><img data-src="/images/kibana10.png" alt="akb48"></p>
<p>然后点击<code>Create a Visualization</code>,里面既有很多种图形供你选择，有饼型，有箭头的，有文字的，有仪表盘的，如图：<br><img data-src="/images/kibana11.png" alt="akb48"></p>
<p>我们这里先建立一个饼型的，还是上面那个台词多少的例子，首先选择<code>shakespeare</code>作为数据源，然后点击<code>split slices</code>，如图：<br><img data-src="/images/kibana12.png" alt="akb48"></p>
<p>然后在<code>Aggergation</code>里选择<code>Terms</code>，然后在<code>Field</code>里选择<code>Speaker</code>,size那里写8,最后点击上面的那个三角播放键，看看结果：<br><img data-src="/images/kibana13.png" alt="akb48"></p>
<p>这就很清晰的看出，亨利四世一共说了1086句话，占比11.11%。</p>
<p>如果我们再加一个<code>Split Slices</code>，这一次在原有的specker的基础上选择<code>play_name</code>，图象变成了一个同心圆，最外面的一层就是新增的“play_name”的情况，如图显示FALSTAFF的所有台词会在两个play_name里出现：<br><img data-src="/images/kibana14.png" alt="akb48"></p>
<p>如果这个盘子里不想统计FALSTAFF这个话包，就添加一个过滤器，选择<code>speaker is not</code>，后面写上FALSTAFF即可，如图：<br><img data-src="/images/kibana15.png" alt="akb48"></p>
<p>效仿刚才的方法也可以做一个仪表盘，如图：<br><img data-src="/images/kibana16.png" alt="akb48"></p>
<p>可视化的数据也可以save和share，同样在web界面的右上角。保存的数据是可以在左侧菜单栏里的Dashboard里展示，做成一个类似zabbix那样的展示！</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>容器报错：rpc error: code = 14 desc = grpc: the connection is unavailable</title>
    <url>/2018/09/29/%E5%AE%B9%E5%99%A8%E6%8A%A5%E9%94%99%EF%BC%9Arpc-error-code-14-desc-grpc-the-connection-is-unavailable/</url>
    <content><![CDATA[<p>开发同学反馈某一个开发环境的机器卡的要命，我登录一看，内存已经被耗的差不多，但是一看top又看不出来哪个进程占用了很多的内存，如图：<br><img data-src="/images/docker8.png" alt="akb48"></p>
<p>换<code>ps -e -o &#39;pid,comm,args,pcpu,rsz,vsz,stime,user,uid&#39; |  sort -nrk5</code>看也没看出来个之乎者也。</p>
<p>发现这个服务器里有两个容器，但是很奇怪，用docker stats却无法获得他们的基础值：<br><img data-src="/images/docker9.png" alt="akb48"></p>
<p>明明容器都是up状态啊，于是我就尝试链接到其中一台，发现报错：<code>rpc error: code = 14 desc = grpc: the connection is unavailable</code>，而且不能restart和kill,如图：<br><img data-src="/images/docker10.png" alt="akb48"></p>
<p>使用<code>docker-containerd -l unix:///var/run/docker/libcontainerd/docker-containerd.sock --metrics-interval=0 --start-timeout 2m --state-dir /var/run/docker/libcontainerd/containerd --shim docker-containerd-shim --runtime docker-runc --debug</code>，发现里面是这样：<br><img data-src="/images/docker11.png" alt="akb48"></p>
<p>后来在<a href="https://github.com/moby/moby/issues/30984">https://github.com/moby/moby/issues/30984</a> 这个文章下面找到了一个跟我情况差不多的哥们，也是<code>docker stats</code>命令失效。解决方法是重启docker进程：<code>systemctl restart docker.service</code>，果然，重启之后在手动启动上面两个容器，容器就可以正常访问了：<br><img data-src="/images/docker12.png" alt="akb48"></p>
<p>服务器的内存情况也得到了一定的缓解：<br><img data-src="/images/docker13.png" alt="akb48"></p>
<p>后来跟开发复盘，原来是这个机器上一次死机了，没法关闭容器，只能直接在阿里云控制台重启，而正常的流程应该是先关闭容器再重启的。<br><img data-src="/images/hazard.gif" alt="akb48" title="扎球王横扫红军防线"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubectl使用的简单举例</title>
    <url>/2018/08/22/%E5%AE%89%E8%A3%85%E5%B9%B6%E4%B8%94%E9%85%8D%E7%BD%AEkubectl/</url>
    <content><![CDATA[<h2 id="安装kubectl"><a href="#安装kubectl" class="headerlink" title="安装kubectl"></a>安装kubectl</h2><p>在阿里云的Kubernetes界面生成一个新的集群，如图：<br><img data-src="/images/k8s1.png" alt="akb48"></p>
<p>但是这个集群是无法通过ssh登陆云服务器那样登录的，这个时候要操作k8s就有两个招数，第一个招数就是用<code>kubectl</code>这个工具去连接到集群。但是<code>kubectl</code>很难搞，因为它所在的<code>storage.googleapis.com</code>在大陆是无法访问的，如果效仿<a href="https://www.kubernetes.org.cn/installkubectl">https://www.kubernetes.org.cn/installkubectl</a> 里面的方式去下载<code>kubectl</code>是无法成功的，如图：<br><img data-src="/images/k8s2.png" alt="akb48"></p>
<p>为了应付这个办法，就要去kubernete的github界面里下载代码包，然后手动上传到云服务器里安装。</p>
<p>首先到<a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.11.md#v1112">https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.11.md#v1112</a> 里的<code>Client Binaries</code>下载1.11版本的kubectl的包，如图：<br><img data-src="/images/k8s3.png" alt="akb48"></p>
<p>将这个包上传到云服务器之后解压缩，然后把kubernetes安装包里的<code>/client/bin/kubectl</code>做一个<code>/usr/local/bin/kubectl</code>的软连接，如图：<br><img data-src="/images/k8s4.png" alt="akb48"></p>
<p>如果所在的网络也无法打开github，那么只好用国内的源<a href="https://mirrors.ustc.edu.cn/kubernetes/apt/pool/">https://mirrors.ustc.edu.cn/kubernetes/apt/pool/</a> ，下载相应的包之后手动上传到云服务器里也能达到一样的效果，缺点就是国内源没有github更新的那么快。</p>
<h2 id="配置kubectl"><a href="#配置kubectl" class="headerlink" title="配置kubectl"></a>配置kubectl</h2><p>阿里云在生成kubernetes集群后，点击<code>管理</code>，最下面会有一个配置文件，将整个文件内容写入<code>/root/.kube/config</code>，然后再一次使用<code>kubectl cluster-info</code>就能看到配置成功了，如图：<br><img data-src="/images/k8s5.png" alt="akb48"></p>
<p>再用<code>kubectl config view</code>能进一步看到细节：<br><img data-src="/images/k8s6.png" alt="akb48"></p>
<p>这样就证明可以通过kubectl连接到kubenetes集群了。</p>
<h2 id="kubectl基本操作"><a href="#kubectl基本操作" class="headerlink" title="kubectl基本操作"></a>kubectl基本操作</h2><ol>
<li><p><code>kubectl get nodes</code>：查看master和worker的基本情况，如图：<br><img data-src="/images/k8s7.png" alt="akb48" title="这里面有各个节点的角色、命名、版本和状态"></p>
</li>
<li><p><code>kubectl run ngx-test --image=nginx:latest --port=8080 --restart=Never</code>：部署一个以nginx最新镜像为底的叫<code>ngx-test</code>的部署，并且开放下面容器的8080端口，每个部署的名称不能重复。部署会自动生成pod，如果加上了<code>--restart=Never</code>，那么pod生成一次失败就不再生成；</p>
</li>
<li><p><code>kubectl delete deployment chen-test</code>:删除一个叫<code>chen-test</code>的部署，注意，使用kubectl命令，要删除拥有该pod的Deployment。如果我们直接删除pod，Deployment将会重新创建该pod；</p>
</li>
<li><p><code>kubectl get deployments</code>：查看部署情况，如图：<br><img data-src="/images/k8s8.png" alt="akb48"></p>
</li>
<li><p><code>kubectl proxy</code>: 每个pod在kuber集群里都是一个封闭的网络环境里，可以通过这个命令使API server监听在本地的8001端口上；</p>
</li>
<li><p><code>kubectl get pods</code>：获取每一个pods的基本情况，如图:<br><img data-src="/images/k8s9.png" alt="akb48"></p>
</li>
<li><p><code>kubectl describe pods</code>:查看每一个pods的运行细节，可以出来为什么pods没有正常的运行，如果要特别制定具体的pod，那就是<code>kubectl describe pods pod的名称</code>；</p>
</li>
<li><p><code>kubectl exec -it POD_NAME bash</code>:连接到对应的pod里；</p>
</li>
<li><p><code>kubectl get pods -n kube-system</code>:查看NAMESPACE是<code>kube-system</code>的所有pod；</p>
</li>
</ol>
<p>10.<code> kubectl delete pods/kubernetes-dashboard-7b9c7bc8c9-q8425 -n kube-system</code>:删除掉<code>kube-system</code>这个NAMESPACE里<code>kubernetes-dashboard-7b9c7bc8c9-q8425</code>这个pod；</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://help.aliyun.com/document_detail/64940.html?spm=a2c4g.11186623.4.1.2c4652f3qdpMed">https://help.aliyun.com/document_detail/64940.html?spm=a2c4g.11186623.4.1.2c4652f3qdpMed</a> （这个是通过ssh访问k8s负载均衡的方法）<br><a href="https://kubernetes.io/cn/docs/tutorials/kubernetes-basics/">https://kubernetes.io/cn/docs/tutorials/kubernetes-basics/</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>阿里云</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>将kafka加入到Elk集群</title>
    <url>/2019/01/21/%E5%B0%86kafka%E5%8A%A0%E5%85%A5%E5%88%B0Elk%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h2 id="环境交代"><a href="#环境交代" class="headerlink" title="环境交代"></a>环境交代</h2><p>架构如图：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">（目标模块 ---&gt;filebeat） ---&gt;（kafka ---&gt;logstash） ---&gt;（es ---&gt;kibana）</span><br></pre></td></tr></table></figure></p>
<p>具体服务器信息如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">172.16</span><span class="number">.0</span><span class="number">.207</span>	工作模块+filebeat	<span class="title class_">CentOS</span> <span class="number">7.4</span> <span class="number">64</span>位		阿里云<span class="number">1</span>核2G</span><br><span class="line"><span class="number">172.31</span><span class="number">.0</span><span class="number">.84</span>		kafka+logstash		<span class="title class_">CentOS</span> <span class="number">7.4</span> <span class="number">64</span>位		阿里云<span class="number">2</span>核4G</span><br><span class="line"><span class="number">172.31</span><span class="number">.0</span><span class="number">.76</span>		es+es-head+kibana	<span class="title class_">CentOS</span> <span class="number">7.4</span> <span class="number">64</span>位		阿里云<span class="number">2</span>核16G</span><br><span class="line">安全组已经开放了elk相应的端口</span><br></pre></td></tr></table></figure></p>
<p>首先先执行<code>yum update -y &amp;&amp; yum install java-1.8.0-openjdk* -y</code>，在更新的时候不要闲着，在<code>https://www.elastic.co/downloads</code>网站下载所有的elk模块，然后上传到对应的服务器里。 </p>
<h2 id="filebeat的部署、配置和启动"><a href="#filebeat的部署、配置和启动" class="headerlink" title="filebeat的部署、配置和启动"></a>filebeat的部署、配置和启动</h2><p>filebeat与目标机器安装在一起，它是用<code>6.5.4</code>版本，先从官网上下载rpm包，然后上传到服务器里。<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#假设已经下载好了filebeat-<span class="number">6.5</span><span class="number">.4</span>-x86_64.<span class="property">rpm</span></span><br><span class="line">rpm -ivh filebeat-<span class="number">6.5</span><span class="number">.4</span>-x86_64.<span class="property">rpm</span></span><br><span class="line">cd /etc/filebeat</span><br><span class="line">cp filebeat.<span class="property">yml</span> filebeat.<span class="property">yml</span>-<span class="keyword">default</span>	#备份模板配置文件</span><br></pre></td></tr></table></figure></p>
<p>修改<code>filebeat.yml</code>如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">filebeat.<span class="property">prospectors</span>:</span><br><span class="line">- <span class="attr">type</span>: log</span><br><span class="line">  <span class="attr">enabled</span>: <span class="literal">true</span></span><br><span class="line">  <span class="attr">paths</span>:</span><br><span class="line">    - <span class="regexp">/var/</span>log/messages		#设定日志输入源</span><br><span class="line"></span><br><span class="line">output.<span class="property">kafka</span>:</span><br><span class="line">  <span class="attr">enabled</span>: <span class="literal">true</span></span><br><span class="line">  <span class="attr">hosts</span>: [<span class="string">&quot;172.31.0.84:9092&quot;</span>]	#这里填入kafka的地址和端口</span><br><span class="line">  <span class="attr">topic</span>: <span class="string">&#x27;system-secure&#x27;</span>	#指定一个topic</span><br></pre></td></tr></table></figure></p>
<p>配置文件说明了数据的来源和目的地，使用<code>/etc/init.d/filebeat start -e -c /etc/filebeat/filebeat.yml</code>启动filebeat，然后<code>ps -aux|grep filebeat</code>查看一下进程。而filebeat的日志地址是在<code>/var/log/filebeat</code>目录下。</p>
<h2 id="logstash的部署、配置和启动"><a href="#logstash的部署、配置和启动" class="headerlink" title="logstash的部署、配置和启动"></a>logstash的部署、配置和启动</h2><p>logstash是跟kafka在一台服务器里，首先是下载包并且解压缩：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wget <span class="attr">https</span>:<span class="comment">//artifacts.elastic.co/downloads/logstash/logstash-6.5.4.tar.gz</span></span><br><span class="line">tar -zxvf logstash-<span class="number">6.5</span><span class="number">.4</span>.<span class="property">tar</span>.<span class="property">gz</span> -C /opt/</span><br><span class="line">cd /opt/logstash-<span class="number">6.5</span><span class="number">.4</span>/config</span><br></pre></td></tr></table></figure></p>
<p>新建一个配置文件，叫<code>logstash_kafka2ES.conf</code>：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">        kafka&#123;</span><br><span class="line">                <span class="function"><span class="params">bootstrap_servers</span>=&gt;</span><span class="string">&quot;172.31.0.84:9092&quot;</span>	#kafka的地址和端口</span><br><span class="line">                topics=&gt;<span class="string">&quot;system-secure&quot;</span>		#topic要一致</span><br><span class="line">                codec=&gt;plain</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">        elasticsearch &#123;</span><br><span class="line">                <span class="function"><span class="params">hosts</span>=&gt;</span>[<span class="string">&quot;172.31.0.76:9200&quot;</span>]		#es的地址和端口</span><br><span class="line">                index=&gt;<span class="string">&quot;system-secure-%&#123;+YYYY-MM&#125;&quot;</span>	#规定es使用的索引，按月份分类</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>配置文件里规定数据来源是kafka的<code>system-secure</code>这个topic，再修改同目录下的<code>jvm.options</code>：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">-<span class="title class_">Xms512</span>m	#根据自己实际情况来</span><br><span class="line">-<span class="title class_">Xmx512</span>m	#根据自己实际情况来</span><br></pre></td></tr></table></figure></p>
<p>保存退出，<code>./bin/logstash -f ./config/logstash_kafka2ES.conf &amp;</code>启动之，日志是logstash目录<code>/logs/logstash-plain.log</code>。</p>
<p>kafka的配置和启动已经在<a href="https://rorschachchan.github.io/2019/01/16/%E6%90%AD%E5%BB%BAKakfa2-11%E4%B8%BAELK%E6%9C%8D%E5%8A%A1/">https://rorschachchan.github.io/2019/01/16/%E6%90%AD%E5%BB%BAKakfa2-11%E4%B8%BAELK%E6%9C%8D%E5%8A%A1/</a> 里说过了，这里略过。</p>
<h2 id="elasticsearch-6-5-4的部署、配置和启动"><a href="#elasticsearch-6-5-4的部署、配置和启动" class="headerlink" title="elasticsearch-6.5.4的部署、配置和启动"></a>elasticsearch-6.5.4的部署、配置和启动</h2><p>登录到es的服务器上，首先先下载安装包并且解压缩：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wget <span class="attr">https</span>:<span class="comment">//artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.5.4.tar.gz</span></span><br><span class="line">tar -zxvf elasticsearch-<span class="number">6.5</span><span class="number">.4</span>.<span class="property">tar</span>.<span class="property">gz</span> -C /opt/</span><br><span class="line">cd  elasticsearch-<span class="number">6.5</span><span class="number">.4</span>/</span><br><span class="line">useradd elk		#es不能用root启动，需要新建一个用户</span><br><span class="line">chown -R <span class="attr">elk</span>:elk elasticsearch-<span class="number">6.5</span><span class="number">.4</span>/	#整个文件夹都给elk了</span><br></pre></td></tr></table></figure></p>
<p>修改一下<code>elasticsearch.yml</code>：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#cluster.<span class="property">name</span>: my-application	#由于实验环境是一个es，就没写集群名称</span><br><span class="line">node.<span class="property">name</span>: lcshopelk</span><br><span class="line">path.<span class="property">data</span>: <span class="regexp">/opt/</span>elasticsearch-<span class="number">6.5</span><span class="number">.4</span>/data/		#存数据的地方</span><br><span class="line">path.<span class="property">logs</span>: <span class="regexp">/data/</span>tmp/elklog		#存日志的路径</span><br><span class="line">bootstrap.<span class="property">memory_lock</span>: <span class="literal">true</span>		#为了防止swapping，官方建议设定为<span class="literal">true</span>，阿里云的云服务器是没有swap，可以不写</span><br><span class="line">network.<span class="property">host</span>: <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">http.<span class="property">port</span>: <span class="number">9200</span></span><br><span class="line">http.<span class="property">cors</span>.<span class="property">enabled</span>: <span class="literal">true</span>		#准许es-head</span><br><span class="line">http.<span class="property">cors</span>.<span class="property">allow</span>-<span class="attr">origin</span>: <span class="string">&quot;*&quot;</span>	</span><br></pre></td></tr></table></figure></p>
<p>保存之后修改同目录的<code>jvm.options</code>：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">-<span class="title class_">Xms2</span>g	#根据自己实际情况来</span><br><span class="line">-<span class="title class_">Xmx2</span>g	#根据自己实际情况来</span><br></pre></td></tr></table></figure></p>
<p>这里的配置，官网标准的建议是把50％的可用内存作为<code>Elasticsearch</code>的堆内存，保留剩下的50％。当然它也不会被浪费，<code>Lucene</code>会很乐意利用起余下的内存。查看node下是否开启了<code>Mem_lock</code>的语句是：<code>curl &#39;localhost:9200/_nodes?filter_path=**.mlockall&#39;</code>。</p>
<p>保存完毕，还没完,<code>vim /etc/security/limits.conf</code>，最后两行改成如下:<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">* soft nofile <span class="number">65536</span></span><br><span class="line">* hard nofile <span class="number">65536</span></span><br><span class="line"># allow user <span class="string">&#x27;elk&#x27;</span> mlockall</span><br><span class="line">elk soft memlock unlimited</span><br><span class="line">elk hard memlock unlimited</span><br></pre></td></tr></table></figure></p>
<p>然后切换成elk用户，执行<code>./elasticsearch -d</code>就是后台启动了。</p>
<p>简单的几句es命令：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">curl -<span class="variable constant_">XGET</span> <span class="attr">http</span>:<span class="comment">//127.0.0.1:9200/_cat/allocation?v	#查看本机node磁盘容量</span></span><br><span class="line">curl -<span class="variable constant_">XGET</span> <span class="attr">http</span>:<span class="comment">//127.0.0.1:9200/_cat/nodes?v	#能查看node的CPU和负载情况</span></span><br><span class="line">curl -<span class="variable constant_">XGET</span> <span class="attr">http</span>:<span class="comment">//127.0.0.1:9200/_aliases	#查看所有的索引</span></span><br><span class="line">curl <span class="string">&#x27;http://localhost:9200/_search?pretty&#x27;</span> 	#查看索引一些细节</span><br><span class="line">curl -<span class="variable constant_">XDELETE</span> <span class="string">&#x27;localhost:9200/shoporder-log-2019-02?pretty&amp;pretty&#x27;</span> 	#删除shoporder-log-<span class="number">2019</span>-<span class="number">02</span>这个索引，同时磁盘释放空间</span><br></pre></td></tr></table></figure></p>
<h2 id="kibana和es-head的部署、配置和启动"><a href="#kibana和es-head的部署、配置和启动" class="headerlink" title="kibana和es-head的部署、配置和启动"></a>kibana和es-head的部署、配置和启动</h2><p><code>es-head</code>是用docker部署的，语句如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#假设docker已经安装好了</span><br><span class="line">docker run --name es-head -p <span class="number">9100</span>:<span class="number">9100</span> tobias74/elasticsearch-<span class="attr">head</span>:<span class="number">6</span>	#这里必须安装<span class="number">6</span>版本，不然的话，数据不会显示</span><br></pre></td></tr></table></figure></p>
<p>运行完之后，要进入到容器里修改一下对应的配置文件<code>Gruntfile.js</code>，修改一下<code>connect</code>段落：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">connect</span>: &#123;</span><br><span class="line">		<span class="attr">server</span>: &#123;</span><br><span class="line">			<span class="attr">options</span>: &#123;</span><br><span class="line">				<span class="attr">port</span>: <span class="number">9100</span>,</span><br><span class="line">				<span class="attr">base</span>: <span class="string">&#x27;.&#x27;</span>,</span><br><span class="line">				<span class="attr">keepalive</span>: <span class="literal">true</span>,</span><br><span class="line">				<span class="attr">hostname</span>: <span class="string">&#x27;*&#x27;</span>		#新增加这样一句话</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>保存文件，<code>docker restart es-head</code>即可。在浏览器里访问<code>外网ip地址:9100</code>，如图：<br><img data-src="/images/elk19.png" alt="akb48"></p>
<p><code>Kibana</code>也是用docker部署的，语句如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#假设docker已经安装好了</span><br><span class="line">docker run --name kibana -p <span class="number">5601</span>:<span class="number">5601</span> docker.<span class="property">elastic</span>.<span class="property">co</span>/kibana/<span class="attr">kibana</span>:<span class="number">6.5</span><span class="number">.4</span></span><br></pre></td></tr></table></figure></p>
<p>运行完之后，要进入到容器里修改一下对应的配置文件<code>kibana.yml</code>：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"># <span class="title class_">Default</span> <span class="title class_">Kibana</span> configuration <span class="keyword">from</span> kibana-docker.</span><br><span class="line"></span><br><span class="line">server.<span class="property">name</span>: kibana</span><br><span class="line">server.<span class="property">host</span>: <span class="string">&quot;0.0.0.0&quot;</span>	#准许所有人访问</span><br><span class="line">elasticsearch.<span class="property">url</span>: <span class="attr">http</span>:<span class="comment">//es外网IP:9200</span></span><br><span class="line">xpack.<span class="property">monitoring</span>.<span class="property">ui</span>.<span class="property">container</span>.<span class="property">elasticsearch</span>.<span class="property">enabled</span>: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"># <span class="variable constant_">SSL</span> <span class="keyword">for</span> outgoing requests <span class="keyword">from</span> the <span class="title class_">Kibana</span> <span class="title class_">Server</span> (<span class="variable constant_">PEM</span> formatted)</span><br><span class="line">server.<span class="property">ssl</span>.<span class="property">enabled</span>: <span class="literal">true</span></span><br><span class="line">server.<span class="property">ssl</span>.<span class="property">key</span>: <span class="regexp">/usr/</span>share/kibana/config/mykey.<span class="property">key</span>	#这里是https证书</span><br><span class="line">server.<span class="property">ssl</span>.<span class="property">certificate</span>: <span class="regexp">/usr/</span>share/kibana/config/mycert.<span class="property">crt</span>		#这里是https证书</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>修改完事之后，<code>docker restart kibana</code>，此时进入到kibana容器发现5601的端口并没有与任何的程序相关联，如图：<br><img data-src="/images/elk23.png" alt="akb48"></p>
<p>其实这是没关系的，可以无视掉。然后在浏览器里访问<code>外网ip地址:5601</code>就可以查看kibana了，先去<code>menagement</code> —&gt;<code>index pattern</code>填入刚刚生成的index，然后在<code>discover</code>页面里选择刚刚生成的index就能看到日志内容了：<br><img data-src="/images/elk20.png" alt="akb48"></p>
<p>如果kibana在某一天突然出现了”重定向过多”,重启kibana进程可破，但是index都会消失…但愿你永远不会遇到这样的bug情况…</p>
<p><code>X-pack</code>目前还不支持6.2以上的版本，故此先略。因为没有<code>X-pack</code>，所以再<code>kibana.yml</code>里的<code>elasticsearch.url</code>我们还是写http，有了<code>X-pack</code>就要改成<code>elasticsearch.url: &quot;https://&lt;your_elasticsearch_host&gt;.com:9200&quot;</code>的样子，让es与kibana之间的传输是加密的。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://dzone.com/articles/just-say-no-swapping">https://dzone.com/articles/just-say-no-swapping</a><br><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/cn/heap-sizing.html">https://www.elastic.co/guide/cn/elasticsearch/guide/cn/heap-sizing.html</a><br><a href="https://www.elastic.co/guide/cn/kibana/current/settings.html">https://www.elastic.co/guide/cn/kibana/current/settings.html</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>elk</tag>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>将list重新排列后获取原来的索引</title>
    <url>/2018/12/14/%E5%B0%86list%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E5%90%8E%E8%8E%B7%E5%8F%96%E5%8E%9F%E6%9D%A5%E7%9A%84%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h2 id="具体需求与解决方案"><a href="#具体需求与解决方案" class="headerlink" title="具体需求与解决方案"></a>具体需求与解决方案</h2><p>假设我们有一个列表，现在要对列表里进行从大到小排序，然后再获取列表里原来各位元素的索引，怎么办？<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Python2.7</span></span><br><span class="line">new_list = <span class="built_in">sorted</span>(<span class="built_in">enumerate</span>(old_list),key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>],reverse=<span class="literal">True</span>)     <span class="comment">#old_list就是原列表</span></span><br></pre></td></tr></table></figure></p>
<p>举一个详细一点的例子：<br><img data-src="/images/enumerate.png" alt="akb48"></p>
<p>可见原来aaa这个列表的元素虽然经过了大小排序，但是各元素的索引下标没有丢，而且通过<code>zip（）</code>方法能拆出来供我们继续使用。</p>
<h2 id="enumerate-函数"><a href="#enumerate-函数" class="headerlink" title="enumerate() 函数"></a>enumerate() 函数</h2><p>这个<code>enumerate() </code>函数可以将一个可遍历的数据对象组合一个索引序列，同时列出数据和数据下标，默认情况下标是从0开始的，也可以手动更改，比如：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;seasons = [<span class="string">&#x27;Spring&#x27;</span>, <span class="string">&#x27;Summer&#x27;</span>, <span class="string">&#x27;Fall&#x27;</span>, <span class="string">&#x27;Winter&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt; <span class="title function_">list</span>(<span class="title function_">enumerate</span>(seasons))</span><br><span class="line">[(<span class="number">0</span>, <span class="string">&#x27;Spring&#x27;</span>), (<span class="number">1</span>, <span class="string">&#x27;Summer&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;Fall&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;Winter&#x27;</span>)]</span><br><span class="line">&gt;&gt;&gt; <span class="title function_">list</span>(<span class="title function_">enumerate</span>(seasons, start=<span class="number">1</span>))       # 下标从 <span class="number">1</span> 开始</span><br><span class="line">[(<span class="number">1</span>, <span class="string">&#x27;Spring&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;Summer&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;Fall&#x27;</span>), (<span class="number">4</span>, <span class="string">&#x27;Winter&#x27;</span>)]</span><br></pre></td></tr></table></figure></p>
<p>有了它，我们就可以轻松获取索引下标值了。</p>
<h2 id="sorted-key-lambda"><a href="#sorted-key-lambda" class="headerlink" title="sorted(key&#x3D;lambda)"></a>sorted(key&#x3D;lambda)</h2><p><code>sorted（）</code>是用来排列列表的函数，默认情况下是从小到大排列。如果列表里是每一个元素并不是单纯的一个数字，而是多字段，那么就要规定以哪一个字段作为标准来排列，这个这顶标准就是<code>key</code>。</p>
<p>举个例子：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>listA = [<span class="number">3</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">9</span>]     <span class="comment">#这个列表就是单字段，排序就是单纯按照数字大小排序</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">sorted</span>(listA))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>listC=[(<span class="string">&#x27;e&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;o&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;!&#x27;</span>, <span class="number">5</span>), (<span class="string">&#x27;v&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;l&#x27;</span>, <span class="number">1</span>)]      <span class="comment">#这个列表是多字段</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">sorted</span>(listC, key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>]))      <span class="comment">#指定按照多字段里第二个元素，即数字的大小进行排序</span></span><br><span class="line">[(<span class="string">&#x27;l&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;o&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;v&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;e&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;!&#x27;</span>, <span class="number">5</span>)]</span><br></pre></td></tr></table></figure></p>
<p><code>x:x[]</code>字母可以随意修改，排序方式按照中括号[]里面的维度进行排序，[0]按照第一维排序，[2]按照第三维排序</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://stackoverflow.com/questions/7851077/how-to-return-index-of-a-sorted-list">https://stackoverflow.com/questions/7851077/how-to-return-index-of-a-sorted-list</a><br><a href="https://stackoverflow.com/questions/16310015/what-does-this-mean-key-lambda-x-x1">https://stackoverflow.com/questions/16310015/what-does-this-mean-key-lambda-x-x1</a><br><a href="https://blog.csdn.net/u010758410/article/details/79737498">https://blog.csdn.net/u010758410/article/details/79737498</a></p>
<p><img data-src="/images/conan.gif" alt="akb48" title="灰原哀模仿柯南"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>enumerate</tag>
        <tag>列表加工</tag>
      </tags>
  </entry>
  <entry>
    <title>将本地时间转化成UTC时间</title>
    <url>/2019/01/22/%E5%B0%86%E6%9C%AC%E5%9C%B0%E6%97%B6%E9%97%B4%E8%BD%AC%E5%8C%96%E6%88%90UTC%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h2 id="实际代码"><a href="#实际代码" class="headerlink" title="实际代码"></a>实际代码</h2><p>在日常工作中，有些时候需要把本地时间转换成UTC时间，通常来说，最直接的方法就是把北京时间（<code>CST时间</code>）减去8小时，但是如果考虑到夏令时，那么这样简单的数学计算就会得到错误的结果。要解决这种涉及时区的问题，就要使用特殊的模块<code>pytz</code>。<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Python <span class="number">3.6</span><span class="number">.4</span> (default, Sep  <span class="number">3</span> <span class="number">2018</span>, <span class="number">10</span>:<span class="number">11</span>:<span class="number">51</span>) </span><br><span class="line">[GCC <span class="number">4.8</span><span class="number">.5</span> <span class="number">20150623</span> (Red Hat <span class="number">4.8</span><span class="number">.5</span>-<span class="number">28</span>)] on linux</span><br><span class="line"><span class="type">Type</span> <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> <span class="keyword">or</span> <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> datetime,time,pytz    <span class="comment">#引入模块</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)     <span class="comment">#得到当前时间</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now</span><br><span class="line"><span class="string">&#x27;2019-01-22 14:03:03&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(now)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;     <span class="comment">#此时类型是字符串</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.datetime.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now</span><br><span class="line">datetime.datetime(<span class="number">2019</span>, <span class="number">1</span>, <span class="number">22</span>, <span class="number">14</span>, <span class="number">4</span>, <span class="number">49</span>, <span class="number">707859</span>)     <span class="comment">#转换成datetime模式</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(now)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;datetime.datetime&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>utc_time = now.astimezone(pytz.utc)    <span class="comment">#转换成了UTC时间就不要用担心夏令时等等麻烦事了</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(utc_time)</span><br><span class="line"><span class="number">2019</span>-01-<span class="number">22</span> 06:04:<span class="number">49.707859</span>+<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(utc_time)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;datetime.datetime&#x27;</span>&gt;     <span class="comment">#还需要将datetime格式转换成str</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>utc_now = utc_time.strftime(<span class="string">&#x27;%Y-%m-%d %H:%M:00&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;2019-01-22 13:57:00&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(utc_now)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;     <span class="comment">#此时返回了字符串</span></span><br></pre></td></tr></table></figure></p>
<p>上面的代码说明了过程，以及得到的东西的类型，其实精简下来只有三行：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> datetime,time,pytz</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.datetime.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>utc_time = now.astimezone(pytz.utc)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>utc_now = utc_time.strftime(<span class="string">&#x27;%Y-%m-%dT%H:%M:00Z&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> (utc_now)</span><br><span class="line"><span class="number">2019</span>-01-22T06:<span class="number">46</span>:00Z</span><br></pre></td></tr></table></figure><br>	<br>如果要查时区名称，可以使用<code>pytz.country_timezones</code>，如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> pytz <span class="keyword">import</span> timezone </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pytz.country_timezones[<span class="string">&#x27;CN&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;Asia/Shanghai&#x27;</span>, <span class="string">&#x27;Asia/Urumqi&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pytz.country_timezones[<span class="string">&#x27;US&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;America/New_York&#x27;</span>, <span class="string">&#x27;America/Detroit&#x27;</span>, <span class="string">&#x27;America/Kentucky/Louisville&#x27;</span>, <span class="string">&#x27;America/Kentucky/Monticello&#x27;</span>, <span class="string">&#x27;America/Indiana/Indianapolis&#x27;</span>, <span class="string">&#x27;America/Indiana/Vincennes&#x27;</span>, <span class="string">&#x27;America/Indiana/Winamac&#x27;</span>, <span class="string">&#x27;America/Indiana/Marengo&#x27;</span>, <span class="string">&#x27;America/Indiana/Petersburg&#x27;</span>, <span class="string">&#x27;America/Indiana/Vevay&#x27;</span>, <span class="string">&#x27;America/Chicago&#x27;</span>, <span class="string">&#x27;America/Indiana/Tell_City&#x27;</span>, <span class="string">&#x27;America/Indiana/Knox&#x27;</span>, <span class="string">&#x27;America/Menominee&#x27;</span>, <span class="string">&#x27;America/North_Dakota/Center&#x27;</span>, <span class="string">&#x27;America/North_Dakota/New_Salem&#x27;</span>, <span class="string">&#x27;America/North_Dakota/Beulah&#x27;</span>, <span class="string">&#x27;America/Denver&#x27;</span>, <span class="string">&#x27;America/Boise&#x27;</span>, <span class="string">&#x27;America/Phoenix&#x27;</span>, <span class="string">&#x27;America/Los_Angeles&#x27;</span>, <span class="string">&#x27;America/Anchorage&#x27;</span>, <span class="string">&#x27;America/Juneau&#x27;</span>, <span class="string">&#x27;America/Sitka&#x27;</span>, <span class="string">&#x27;America/Metlakatla&#x27;</span>, <span class="string">&#x27;America/Yakutat&#x27;</span>, <span class="string">&#x27;America/Nome&#x27;</span>, <span class="string">&#x27;America/Adak&#x27;</span>, <span class="string">&#x27;Pacific/Honolulu&#x27;</span>]</span><br></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/cathouse/archive/2012/11/19/2777678.html">https://www.cnblogs.com/cathouse/archive/2012/11/19/2777678.html</a><br><a href="https://blog.csdn.net/junli_chen/article/details/52999448">https://blog.csdn.net/junli_chen/article/details/52999448</a><br>《Python cookbook》字符串如何转化成日期<br>《Python cookbook》处理设计到市区的日期问题</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>python3</tag>
        <tag>UTC时间</tag>
        <tag>时区转换</tag>
      </tags>
  </entry>
  <entry>
    <title>将Redis监控细节添加到Django页面里</title>
    <url>/2019/04/09/%E5%B0%86redis%E7%9B%91%E6%8E%A7%E7%BB%86%E8%8A%82%E6%B7%BB%E5%8A%A0%E5%88%B0Django%E9%A1%B5%E9%9D%A2%E9%87%8C/</url>
    <content><![CDATA[<p>Redis的监控一直是重点中的重点，市面上开源的Redis界面监控也不在少数了，但是自己做一个监控页面更加有针对性，而且更加有逼格。我们主要监控redis除了常规的cpu、内存、Key数之外，还有如下几个方面：阻塞客户端数量、使用内存峰值、内存碎片率、缓存命中率、失效KEY、慢日志和连接数。这里挑几个简单的说。</p>
<h2 id="获取连接细节情况"><a href="#获取连接细节情况" class="headerlink" title="获取连接细节情况"></a>获取连接细节情况</h2><p>首先先来搞定“获取redis的连接细节”。在django里先做一个model,如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">redisconnection</span>(models.Model):</span><br><span class="line">	rank = models.CharField(verbose_name=<span class="string">&#x27;排名&#x27;</span>,max_length=<span class="number">10</span>)</span><br><span class="line">    num = models.CharField(verbose_name=<span class="string">&#x27;服务器连接数&#x27;</span>,max_length=<span class="number">50</span>)</span><br><span class="line">    ip = models.GenericIPAddressField(verbose_name=<span class="string">&#x27;服务器内网IP地址&#x27;</span>)</span><br><span class="line">    date = models.DateField(auto_now_add=<span class="literal">True</span>)</span><br><span class="line">    time = models.TimeField(auto_now_add=<span class="literal">False</span>, auto_now=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__unicode__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.host</span><br></pre></td></tr></table></figure></p>
<p>可见我们只是需要排名、具体的IP、当时有多少连接以及当时时间这4个指标而已。</p>
<p>我承认我道行不够，捅咕两个小时也没有研究出来怎么用python2.7去获取redis的连接数细节，于是乎就用shell写了一个简单的脚本。如下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#获取当前连接最多的前五个IP地址和数量到Mysql</span><br><span class="line">redis-cli -h redis地址 -p 6379 -a redis密码 client list | awk &#x27;&#123;print $2&#125;&#x27;| cut -d = -f 2| cut -d : -f 1 | sort | uniq -c | sort -rn |head -5 &gt; clientip.txt</span><br><span class="line">MYSQL=&quot;mysql -h数据库地址 -u数据库账号 -p数据库密码 --default-character-set=utf8 -A -N&quot;</span><br><span class="line">cat -n clientip.txt | while read rank num IP</span><br><span class="line">do</span><br><span class="line">        echo $&#123;num&#125;</span><br><span class="line">        echo $&#123;IP&#125; </span><br><span class="line">        sql=&quot;insert into databases.table(num,ip,date,time,rank) values(&#x27;$&#123;num&#125;&#x27;,&#x27;$&#123;IP&#125;&#x27;,curdate(),now(),&#x27;$&#123;rank&#125;&#x27;);&quot;</span><br><span class="line">        $MYSQL -e &quot;$sql&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>这里先简单解释一下：<br>1.<code>client list</code>是查看redis连接细节的命令，然后通过awk获取第二列，再分别通过“&#x3D;”和“，”来分割两次，排序去重统计个数最后取出前五名输入到<code>clientip.txt</code>这个文件里；<br>2.连接mysql，-A的含义是不去预读全部数据表信息；-N的含义是获取数据信息省去列名称;<br>3.使用<code>cat -n</code>自动获取到行号当做排名，循环赋值；<br>4.<code>curdate()</code>,<code>now()</code>这俩是sql，但是需要shell里正确使用sql就要<code>-e</code>;</p>
<p>执行效果如下：<br><img data-src="/images/gateone12.png" alt="akb48"></p>
<p>剩下的内容就是在<code>views.py</code>里拿值然后通过<code>render</code>反馈到前端页面，这里不说了。</p>
<p>如果使用了Redis中间件，那么就不能统计redis的<code>client list</code>了，而是到中间件服务器里，使用<code>ss -art | awk &#39;{print $5}&#39; | grep &#39;^[1-9]&#39; | cut -d : -f 1 | sort | uniq -dc | sort -nr</code>获取详细连接情况。</p>
<h2 id="获取缓存命中率"><a href="#获取缓存命中率" class="headerlink" title="获取缓存命中率"></a>获取缓存命中率</h2><p>缓存命中率是<code>info Stats</code>命令里<code>keyspace_hits/(keyspace_hits+keyspace_misses)</code>的值，比如我这个redis：<br><img data-src="/images/gateone13.png" alt="akb48"></p>
<p>这个值正常来说应该是90%以上，如果缓存命中率过低，那么要排查对缓存的用法是否有问题，我这个就很不合格…</p>
<p>获取缓存命中率的shell脚本如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment">#获取当前缓存命中率到Mysql</span></span><br><span class="line">hit=$(redis-cli -h redis地址 -p <span class="number">6379</span> -a redis密码 info Stats | grep <span class="string">&quot;keyspace_hits&quot;</span> | cut -d : -f <span class="number">2</span>)	</span><br><span class="line">miss=$(redis-cli -h redis地址 -p <span class="number">6379</span> -a redis密码 info Stats | grep <span class="string">&quot;keyspace_misses&quot;</span> | cut -d : -f <span class="number">2</span>)</span><br><span class="line">HIT=$(echo $hit | tr -d <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">MISS=$(echo $miss | tr -d <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">total=$(expr $HIT + $MISS)</span><br><span class="line">percent=$(awk <span class="string">&#x27;BEGIN&#123;printf &quot;%.2f\n&quot;,&#x27;</span>$HIT<span class="string">&#x27;/&#x27;</span>$total<span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">MYSQL=<span class="string">&quot;mysql -h数据库地址 -u数据库账号 -p数据库密码 --default-character-set=utf8 -A -N&quot;</span></span><br><span class="line">sql=<span class="string">&quot;insert into databases.table(num,date,time) values(&#x27;$&#123;percent&#125;&#x27;,curdate(),now());&quot;</span></span><br><span class="line">$MYSQL -e <span class="string">&quot;$sql&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>这里要注意！<code>hit</code>和<code>miss</code>结果是自带”\r”的，所以要去掉。不然的话就会有<code>expr: non-numeric argument</code>。而且如果用bc命令获取除法结果的话，低于1的值是不会出现整数0，即如果得到的结果是0.97，那么只会显示.97，至于如何出现这个0，可以去看 <a href="http://www.361way.com/linux-bc-point-zero/4960.html">http://www.361way.com/linux-bc-point-zero/4960.html</a> 。</p>
<p>现在已经通过脚本取到了值，那么剩下的内容就是django去弄一个model，之后在<code>views.py</code>里拿值然后通过<code>render</code>反馈到前端页面，这里不说了。执行效果如下：<br><img data-src="/images/gateone14.png" alt="akb48"></p>
<h2 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h2><p>redis的慢日志操作也是我们比较关注的一点。一般来说我们使用<code>slowlog len</code>来获取当前慢日志的总条数，而是用<code>slowlog reset</code>对其进行清理工作。获取它的shell脚本跟上面两个大同小异，这里也略过不表了。</p>
<p>如果要是想获取redis的cpu和内存，最好的方法通过zabbix拿值，CPU使用率的item是：<code>system.cpu.util[]</code>，内存使用率的item是：<code>vm.memory.size[pavailable]</code>。</p>
<p>整个页面做完的效果如下：<br><img data-src="/images/gateone15.gif" alt="akb48"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://segmentfault.com/a/1190000009915519">https://segmentfault.com/a/1190000009915519</a><br><a href="https://blog.csdn.net/secretx/article/details/73498148">https://blog.csdn.net/secretx/article/details/73498148</a><br><a href="http://www.cnblogs.com/iforever/p/4459857.html">http://www.cnblogs.com/iforever/p/4459857.html</a><br><a href="https://morrisjs.github.io/morris.js/lines.html">https://morrisjs.github.io/morris.js/lines.html</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>django</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>将电商平台测试环境添加了域名和https</title>
    <url>/2018/01/18/%E5%B0%86%E7%94%B5%E5%95%86%E5%B9%B3%E5%8F%B0%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E6%B7%BB%E5%8A%A0%E4%BA%86%E5%9F%9F%E5%90%8D%E5%92%8Chttps/</url>
    <content><![CDATA[<h2 id="情况描述"><a href="#情况描述" class="headerlink" title="情况描述"></a>情况描述</h2><p>今天电商平台来了新的产品经理。摸了一遍情况之后，提出了两个需求，<font color=blue>第一个是要把测试环境也要上https，达到与线上一致；第二个就是测试环境要配上域名，不要再用IP地址登陆。</font></p>
<p>配置域名是很简单的，在阿里云的云解析上直接给测试环境新加一个域名，然后对应添加阿里云外网SLB的IP地址即可。进入页面也发现首页地址显示正常，但是再点点就发现了里面有点不对。</p>
<p>没错，现象就是“只有首页是域名，其他网站都是IP”，<br><img data-src="/images/ecstore1.jpg" alt="paradin"></p>
<p>遇到这个情况，我就跑去<code>nginx.conf</code>里，看一下<code>server_name</code>的配置，看到的确写得是func.lechange.com，如图：<br><img data-src="/images/ecstore2.png" alt="paradin"></p>
<p>于是就在页面上使用<code>ctrl+shift+c</code>查看具体情况，发现里面的代码是这个样的：<br><img data-src="/images/ecstore3.jpg" alt="paradin"></p>
<p>这就人赃俱获了，<strong>开发已经在html里把地址写死了，使用了绝对路径而不是相对路径</strong>，于是就打回让开发自己慢慢改。</p>
<p>然后又回到SLB界面，新增新的https监听，前端端口443，后端是80，搭配正确的证书，SLB保存之后，在浏览器输入测试环境的<code>https://网址</code>之后，发现整个界面全乱了，如图：<br><img data-src="/images/ecstore4.png" alt="paradin"></p>
<p>但是使用<code>http://网址</code>去访问还是正常的，如图：<br><img data-src="/images/ecstore5.png" alt="paradin"></p>
<p>很明显，这是因为https下跨协议调用http的是不行的，所以那些css、js如果不支持https的话就无法正常显示。使用<code>ctrl+shift+c</code>看错误更加明显。<br><img data-src="/images/ecstore6.png" alt="paradin"></p>
<p>遇到这个问题，就有如下几种方法：</p>
<p>第一种：将所有的访问路径都写死<code>https</code>，不过这个我们公司代码规范不准许;<br>第二种：去掉URL中的<code>http://</code>或<code>https://</code>，将其替换为<code>//</code>，这样，浏览器就可以根据当前页面的请求方式来动态切换了；<br>第三种：可以在<code>&lt;head&gt;</code>中添加<code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;upgrade-insecure-requests&quot;&gt;</code>,浏览器会在加载HTTP资源时自动替换成HTTPS请求；<br>第四种：在nginx里写一个proxy_redirect跳转，这个就比较有技术含量了；</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://thehackernews.com/2015/04/disable-mixed-content-warning.html">https://thehackernews.com/2015/04/disable-mixed-content-warning.html</a><br><a href="https://www.tuicool.com/articles/ARVVFjI">https://www.tuicool.com/articles/ARVVFjI</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/Security/Mixed_content/How_to_fix_website_with_mixed_content">https://developer.mozilla.org/en-US/docs/Web/Security/Mixed_content/How_to_fix_website_with_mixed_content</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title>将Redhat的yum更换成免费版本</title>
    <url>/2018/07/20/%E5%B0%86radhat%E7%9A%84yum%E6%9B%B4%E6%8D%A2%E6%88%90%E5%85%8D%E8%B4%B9%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="RedHat替换yum源"><a href="#RedHat替换yum源" class="headerlink" title="RedHat替换yum源"></a>RedHat替换yum源</h2><p>这次给吉林移动做一个项目，他们的服务器必须要用IE浏览器登陆堡垒机进行环境部署。我登陆上去一看，是redhat，在使用yum的时候会有如下报错：<br><img data-src="/images/yum2.png" alt="akb48"></p>
<p>这句话的意思是“redhat自带的yum源是需要注册才是更新下载软件的，如果必须注册才能使用”，换而言之就是要收费。卧槽，怎么可能，我们向来是“要钱没有，要命一条”。于是就要用CentOS源来替代yum源，而CentOS源是免费的。</p>
<p>首先先删除掉redhat自带的yum：<code>rpm -qa | grep yum | xargs rpm -e --nodeps</code>。</p>
<p>然后用<code>cat /etc/redhat-release</code>命令去查看一下系统版本，我这个机器的版本是<code>Red Hat Enterprise Linux Server release 6.5 (Santiago)</code>，就去<a href="http://mirrors.163.com/centos/6/os/x86_64/Packages/">http://mirrors.163.com/centos/6/os/x86_64/Packages/</a> 下载如下几个文件：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">http</span>:<span class="comment">//mirrors.163.com/centos/6/os/x86_64/Packages/yum-metadata-parser-1.1.2-16.el6.x86_64.rpm</span></span><br><span class="line"><span class="attr">http</span>:<span class="comment">//mirrors.163.com/centos/6/os/x86_64/Packages/yum-3.2.29-81.el6.centos.noarch.rpm</span></span><br><span class="line"><span class="attr">http</span>:<span class="comment">//mirrors.163.com/centos/6/os/x86_64/Packages/yum-plugin-fastestmirror-1.1.31-45.el7.noarch.rpm</span></span><br></pre></td></tr></table></figure></p>
<p>如果想下载<code>centos 7</code>的就去<a href="http://mirrors.163.com/centos/7/os/x86_64/Packages/">http://mirrors.163.com/centos/7/os/x86_64/Packages/</a> 这个网站下，文件名字是一样的就是版本号不一样，需要自己找一下。</p>
<p>然后就是安装这几个包：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rpm -ivh yum-metadata-parser-<span class="number">1.1</span><span class="number">.2</span>-<span class="number">16.</span>el6.<span class="property">x86_64</span>.<span class="property">rpm</span></span><br><span class="line">rpm -ivh yum-<span class="number">3.2</span><span class="number">.29</span>-<span class="number">81.</span>el6.<span class="property">centos</span>.<span class="property">noarch</span>.<span class="property">rpm</span></span><br><span class="line">rpm -ivh yum-plugin-fastestmirror-<span class="number">1.1</span><span class="number">.31</span>-<span class="number">45.</span>el7.<span class="property">noarch</span>.<span class="property">rpm</span></span><br><span class="line">cd /etc/yum.<span class="property">repos</span>.<span class="property">d</span>/</span><br><span class="line">wget <span class="attr">http</span>:<span class="comment">//mirrors.163.com/.help/CentOS6-Base-163.repo	#最好先备份旧文件</span></span><br><span class="line">sed -i <span class="string">&#x27;s#$releasever#6#g&#x27;</span> ./<span class="title class_">CentOS6</span>-<span class="title class_">Base</span>-<span class="number">163.</span>repo</span><br><span class="line">yum clean all	#清除原有的缓存</span><br><span class="line">yum makecache	#重建缓存</span><br><span class="line">yum update -y	#更新系统</span><br></pre></td></tr></table></figure></p>
<p>大功告成！可以使用免费的yum去装装装了！</p>
<h2 id="修复Python-urlgrabber版本过低"><a href="#修复Python-urlgrabber版本过低" class="headerlink" title="修复Python-urlgrabber版本过低"></a>修复Python-urlgrabber版本过低</h2><p>当执行到<code>rpm -ivh yum-3.2.29-81.el6.centos.noarch.rpm</code>这一步的时候，可能会出现一个python的错误：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Python</span>-urlgrabber &gt;= <span class="number">3.9</span><span class="number">.1</span>-<span class="number">10</span> is needed by yum-<span class="number">3.2</span><span class="number">.29</span>-<span class="number">73.</span>el6.<span class="property">centos</span>.<span class="property">noarch</span></span><br></pre></td></tr></table></figure></p>
<p>要求<code>python-urlgrabber</code>版本必须大于等于3.9.1-10，而用<code>rpm -qa|grep python</code>查看当前的版本是<code>python-urlgrabber-3.9.1-9.el6.noarch</code>，于是就<code>rpm -e python-urlgrabber-3.9.1-9.el6.noarch</code>卸载掉，<code>wget http://mirrors.163.com/centos/6/os/x86_64/Packages/python-urlgrabber-3.9.1-11.el6.noarch.rpm</code>之后，执行<code>rpm -ivh python-urlgrabber-3.9.1-11.el6.noarch.rpm</code>命令安装即可。</p>
<p>安装完毕，再用<code>rpm -ivh --force yum-*</code>安装后面的内容。如图:<br><img data-src="/images/yum4.png" alt="akb48"></p>
<h2 id="无法解析yum源"><a href="#无法解析yum源" class="headerlink" title="无法解析yum源"></a>无法解析yum源</h2><p>如果在<code>yum makecache</code>的时候出现了<code>http://mirrors.163.com/centos/6/os/x86_64/repodata/repomd.xml: [Errno 14] PYCURL ERROR 6 - &quot;Couldn&#39;t resolve host &#39;mirrors.163.com&#39;&quot;</code>的错误，如图：<br><img data-src="/images/yum3.png" alt="akb48"></p>
<p>就修改一下<code>/etc/resolv.conf</code>，然后在里面添加一句<code>nameserver 8.8.8.8</code>，保存即可。</p>
<h2 id="NOKEY？？？"><a href="#NOKEY？？？" class="headerlink" title="NOKEY？？？"></a>NOKEY？？？</h2><p>如果出现<code>Header V3 RSA/SHA1 Signature, key ID c105b9de: NOKEY</code>，可以使用如下方法解决：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /etc/pki/rpm-gpg/ </span><br><span class="line">wget http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-6 </span><br><span class="line">rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>redhat</tag>
        <tag>yum源</tag>
      </tags>
  </entry>
  <entry>
    <title>巴萨的24～25赛季末总结</title>
    <url>/2025/05/17/%E5%B7%B4%E8%90%A8%E7%9A%8424%EF%BD%9E25%E8%B5%9B%E5%AD%A3%E6%9C%AB%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>这个赛季对于巴萨来说很有里程碑的意义，是巴萨在后梅西时代的重大胜利，巴萨已经庆祝三次游行一次了，而且据说数十万球迷上街庆祝。国内三冠王外加欧冠四强，四杀死敌皇马，尤其西超杯、国王杯都是直接踩着皇马拿到冠军，还有什么比这个成绩更爽的么？<br><img data-src="/images/%E5%B7%B4%E8%90%A8%E5%A4%BA%E5%86%A0.jpg" alt="paradin" title="这是一个几乎完美的赛季！"></p>
<h2 id="先说比赛"><a href="#先说比赛" class="headerlink" title="先说比赛"></a>先说比赛</h2><p>今年巴萨在新帅弗里克的带领下，巴萨全队在防守端高举“造越位”大旗，在进攻端火力全开（5名球员进球上双，西甲总共进了102个球，整个赛季进了170+个球）。尤其是赛季初连斩拜仁、皇马，甚至还有7球大胜瓦伦西亚、巴拉多利德的表现。虽然赛季中途一度六轮只拿2分排名掉到第三，但是2025年后一波高盘再次在西甲联赛逆转胜。在将高效反击、落位压迫以及原有的传控体系融合之后，这支巴萨变得势不可挡。</p>
<p>弗里克还坚持使用拉玛西亚的球员，根据CIES的统计，巴萨本赛季西甲中本队青训球员的出场时间占比达到49.3%，在欧洲五大联赛范围内，该项数据排名第二，仅次于毕包。</p>
<p>上个赛季的巴萨角球进球是8个，是自17～18赛季巴尔韦德开始执教巴萨以来的最多，这个赛季基本持平。本赛季巴萨各个赛事逆转场有9次之多，这个是一个重大的进步，很多先丢球的比赛，巴萨都最后拿下了，这在上赛季是不可想象的。而且这个赛季巴萨更强的是客场作战能力，巴萨在西甲客场目前拿下了45分，是全西甲最高，比皇马高出7分，比马竞高出15分，甚至比自家主场拿的分数都多。</p>
<p>根据OptaJose的统计，巴塞罗那本赛季在各项赛事已经有23次禁区外完成进球，这是2018&#x2F;19赛季（同为23次）以来单赛季最高的数据。其中亚马尔一个人就贡献了7脚，是全欧洲最多。让我不得不感慨，当年巴萨花了一亿多买来库蒂尼奥就为了一脚穿云箭，没想到穿云箭在这里。</p>
<h2 id="众人的救赎之路"><a href="#众人的救赎之路" class="headerlink" title="众人的救赎之路"></a>众人的救赎之路</h2><p>今年最大的签约无疑就是主教练弗里克的降临。弗里克来之前也是一个失意人，他在德国队的表现饱受诟病，被“有能教练”森保一打下课，一度没工作。巧的是跟当年同样沦落到埃弗顿的安切洛蒂一样，被大球会再次给了机会，证明了自己。尤其是这个夏天巴萨除了奥尔默的加入之外就没有什么大的投入，反而还走了不少人（罗克、京多安等等）的条件下，弗里克也做到了“看菜下饭”，把一个上赛季进攻便秘的队伍打造成了进攻之师。而且顶住了赛季中“希望之星吉乌走人”、“奥尔默注册风波”、“京多安离开”、“伊尼戈违规出场问题”、“队医突然离世”、“阿劳霍可能要转会尤文”，“回归1:1又没戏了”等等场外的干扰，让更衣室专注于赛场上。可见他对更衣室球员的掌控能力非常的强。</p>
<p>除了掌控能力，弗里克对巴萨这些球员的了解比哈维要高一个层次。弗里克延续哈维后期对拉菲尼亚的使用方式，让他继续在左路也可以满场无球跑。让佩德里后撤发挥了他的能力，更重要的是他鼓励孔德大胆压上，跟亚马尔去打配合。这三个人可以说是弗里克改造最成功的三个人。</p>
<p>不得不说，拉波尔塔在弗里克身上赌对了，去年拉波尔塔对待哈维的反复无常已经把自己放在火上烤了，但是今年巴萨战绩傲人，他自己在下一次的主席连任中肯定有个最大的选票，球迷其实就是这么现实。</p>
<p>那么我们来看一下在弗里克带队之下今年的球员排名：</p>
<h3 id="S级"><a href="#S级" class="headerlink" title="S级"></a>S级</h3><ol>
<li><p>亚马尔：对于这位天才少年的赞美，全世界说的很多了，已经不需要我多说了，而且球队媒体对他保护的很好，即使在西甲100多天没进球也没人喷。如果再能克服浪费机会（wasteful Goals-xG  5.0排名第4）这个小缺点，那就更加完美了。这个夏天第一任务就是跟亚马尔续约。<br><img data-src="/images/%E4%BA%9A%E9%A9%AC%E5%B0%94.png" alt="paradin" title="亚马尔今年统治了他所在的右路"></p>
</li>
<li><p>拉菲尼亚：这位在哈维手下显得“有心杀贼、无力回天”的男人，在弗里克的带领下打出了金球前三的水平。拉菲尼亚这个赛季的无球踢法表现的非常好，而且还经常后撤回防，每场能在后场提供1.8次抢断可见他是“防守进攻一肩挑”，唯一美中不足就是阿根廷巴西的世界杯预选赛结束后有一点低潮期。巴萨夺冠后马上官宣拉菲尼亚续约到2028年，届时他就32岁了，可以说把生涯最好的4～5年给了巴萨，到时候再去沙特或者美国养老也不失一个不错的选择。<br><img data-src="/images/%E6%8B%89%E8%8F%B2%E5%B0%BC%E4%BA%9A.jpeg" alt="paradin" title="这个图里拉菲尼亚是59，但是我查了一下应该是56，实际还是低于萨拉赫的"></p>
</li>
<li><p>佩德里：德国欧洲杯被黄狗克罗斯一脚干废了的佩驴，今年交出了最铁人的出场数据。位置后撤的他同时还能兼顾进攻，成为了一个B2B的中场球员。他和德容在“造越位”的防守体系下需要提供非常大的地面拦截能力。他今年也很好的完成了这一点，是西甲夺回球权最多的球员，254次。<br><img data-src="/images/%E4%BD%A9%E5%BE%B7%E9%87%8C%E5%9C%BA%E5%9D%87%E5%BE%97%E5%88%86.jpeg" alt="paradin" title="今年佩德里金球奖不进前10真的没天理了"></p>
</li>
<li><p>孔德：这个赛季孔德几乎就是右边卫的top3，相比上赛季的迷茫，这个赛季他能进球能助攻，跟内马尔的右路配合简直就是巴萨的开瓶器。尤其是国王杯决赛那惊天一脚，直接把巴萨送上冠军宝座。</p>
</li>
<li><p>伊尼戈-马丁内斯：没想到，人到中年的伊尼戈这个赛季迎来大爆发，他和库巴西的搭档成为了巴萨这个赛季造越位战术的中流砥柱。不过巴萨后期的丢球开始有上涨趋势，下赛季势必要升级防守战术，不然肯定要出事。</p>
</li>
</ol>
<h3 id="A级"><a href="#A级" class="headerlink" title="A级"></a>A级</h3><ol>
<li><p>莱万：赛季初我还说“莱万这个赛季能进25个球就算成功”，结果他这个赛季进了几乎40个球，大大超出了我的期望。虽然莱万这个赛季也丢了很多必进球，但是有他在的前场就是更流畅一些，莱万来了4年了，拿了5个国内冠军的同时也进了101个球，在巴萨只有18个人做到过进球破百的成绩，所以莱万说自己一句巴萨名宿也完全不过分了。下赛季，莱万请再维持一下30个进球，再冲一次欧冠冠军吧！<br><img data-src="/images/%E8%8E%B1%E4%B8%87.jpeg" alt="paradin" title="莱万的表现总体来说符合他的工资"></p>
</li>
<li><p>德容：德容这个赛季在后半段是越踢越好，逐渐得到了弗里克的重用，而且队长的职责力也越来越明显。今年德容已经是“巴萨队内荷兰人出场次数的第三位”了，下赛季肯定超越科曼上升至第二。他跟佩德里是目前全世界最好的中场二人组，完全不逊于巴黎的“维蒂尼亚-若昂内维斯”。</p>
</li>
<li><p>艾里克加西亚：他在哈维的带领下赢得了西甲冠军，在赫罗纳度过了一个神奇的赛季，现在又在弗里克的带领下赢得了另一个西甲冠军，而且他的作用更加突出。在赛季最关键的阶段，他参加了巴萨最近23场比赛中的22场。而且他就是弗里克手下的罗贝托，可以打后场三个位置，尤其是右后卫简直就是主力水准。</p>
</li>
<li><p>奥尔默：奥尔默是2024年夏天巴萨唯一的大手笔，花了5500万。但是要说这笔钱是不是非常的划算，我倒是觉得还可以，有数据表示，奥尔默的进球让巴萨在联赛里多拿了8分。这么一看，这个钱很值。而且奥尔默本赛季为巴萨出场1945分钟，拿下12球6个助攻，这些数据都是他近5年的最高了。但是奥尔默感觉踢满90分钟是一个很难的事儿，他这个夏天肯定是要狂练体能。</p>
</li>
<li><p>费兰-托雷斯：费兰托雷斯可以说是今年也达到了个人最高光的表现，屡屡替补进球，首发的时候也能短暂顶得住。尤其是国王杯决赛打入扳平的一球更是价值连城。他这个赛季一共进了17个球，是西班牙球员最多。</p>
</li>
<li><p>费尔明-洛佩斯：小明在2024年夏天是冠军赢家，拿到了欧洲杯也拿到奥运会男足金牌，这个赛季又收获了国内三冠王。弗里克拿他当奥尔默的替补，他的射门欲望不比奥尔默差，脚头也够硬，但是他下个赛季多半还是竞争不过奥尔默，夏天也有可能转会。<br><img data-src="/images/%E5%B0%8F%E6%98%8E.jpeg" alt="paradin" title="费尔明在进攻端完全碾压了贝林厄姆"></p>
</li>
<li><p>巴尔德：巴尔德这个赛季比上个赛季强出太多，西超杯决赛甚至抽了库尔图瓦一个，在西甲又收获4次助攻，场均预期助攻比去年几乎多了一倍，可见哈维是不喜欢边后卫太压上的，但是弗里克却鼓励他压上。在进攻端进步的同时，场均丢失球权比去年少了2次，巴尔德如果不受伤，国米那一关应该是能过的去的。他在新的赛季里需要继续对防“倒三角”这一点下功夫。</p>
</li>
</ol>
<h3 id="B级"><a href="#B级" class="headerlink" title="B级"></a>B级</h3><ol>
<li><p>库巴西：今年奶龙依旧是防线大腿，表现比曼联的约罗等人强，表现总体来说稳定。有部分比赛有红牌和失误的表现，当然今年也有各种各样的小伤，脸还被破了相。他跟伊尼戈是西甲里向前传球次数最多的两个中卫，双出球中卫在西甲是没问题的，但是在欧冠还是有点慌，毕竟他俩的身高其实都不算高（都不满足185cm）。这个赛季虽然学费交了不少，估计下赛季会表现的更好。</p>
</li>
<li><p>佩尼亚：今年的佩尼亚其实比上个赛季的“射正亡”真的好多了，而且对阵皇马还有一场零封的表现，其中扑出了姆巴佩的单刀球。可惜后来由于迟到事件被彻底拿下首发，估计他夏天会离开巴萨吧。</p>
</li>
<li><p>什琴斯尼：毫无疑问，他是2025年最成功复出奖的获得者。其实我还是觉得3C很多时候的出击太莽撞了，当然这是巴萨的高位后防线逼的。原本好好的一个门线型门将搞的天天面对单刀也很无奈。虽然他出场胜率很高，但是他的扑救数据并不特别优秀，而且在对阵国米的比赛里被对面的索默压了一头。所以给他暂时放到B级。</p>
</li>
<li><p>卡塞多：跑是真能跑，对抗也是真的差，打不了单后腰。但是他下赛季肯定还是弗里克重点培养对象，只要跟得上全队的节奏，就是一个合格的首发。</p>
</li>
<li><p>伯纳尔：其实他是很亮眼的，可以早早受伤了。下赛季满血回归，肯定是重点培养的可塑之才。</p>
</li>
<li><p>克里斯滕森：把藤森放到这里，主要是他出场时间太少。藤森据说这个夏天也会离开回到英超，不过我倒是觉得藤森防守比阿劳霍更稳当，身材也高大（188cm），对造越位的巴萨来说，抢第一点头球的能力是很重要的。我个人马后炮来说，对阵国米最后几分钟应该上藤森的。</p>
</li>
</ol>
<h3 id="C级"><a href="#C级" class="headerlink" title="C级"></a>C级</h3><ol>
<li><p>加维：很遗憾，加维，我是很爱你的。但是不得不承认你现在是巴萨中场里最尴尬的一环，他没有什么防守上的天赋，更多依赖斗志，生涯四个赛季已经吃了42张黄牌。目前看他在弗里克心里的顺位是比较低的，但是主教练还是给了不少机会，他也尽力在表现自己。留在巴萨打轮换补位对球队是好事，但对他自身来说不是什么好事了。</p>
</li>
<li><p>保-维克多：出场时间太少，给人的印象还是夏季美国赛的时候进过皇马一球。</p>
</li>
<li><p>法蒂：没啥好说的，弗里克基本不会用他，不知道是不是管理层的要求，反正他这个夏天基本要走人了。据说要租借去法甲摩纳哥。</p>
</li>
<li><p>阿劳霍：总体来说，阿劳霍在这个赛季的亮眼表现不多，而且对阵国米的时候还被球迷网暴。留下来肯定要接受一些心态上的转变，如果走的话也能留下一笔不低的转会费。但是随着塔签约拜仁，感觉他其实走不了。</p>
</li>
<li><p>特尔施特根：大根这里要多说一点，我觉得他有可能这个夏天会离开，因为根据数据来看，大根面对单刀的扑救率是巴萨三个门将里的最差。远低于最近的绯闻目标大马丁。尤其是欧冠赛场，巴萨这么开放的踢法，而且“有一个好扑救就能顶一个进球”的低容错率，大根有时候的状态和心态的确让人捏了一把汗。我觉得他要是真的离开也未必不是一个好的选择。可怜大根了，被老婆绿还要度过一个不太舒服的休赛期…</p>
</li>
</ol>
<p>全队几个重要球员分析完毕，那么再回头看S级的分布：前场两人，后场两人，中场一人还是一个铁人，球队成绩不好就见鬼了。</p>
<h2 id="营收-夏季转会"><a href="#营收-夏季转会" class="headerlink" title="营收&amp;夏季转会"></a>营收&amp;夏季转会</h2><p>这个赛季巴萨在转会市场的投入是盈利3000万的，在冬窗除了跟阿劳霍、哈维、佩德里续约就没有动作。夏季转会盈利610万，冬窗曼城买了尼克-冈萨雷斯，巴萨因此多拿到了2400万欧元。再加上今年巴萨本赛季营收大概率冲击10亿，7月份又确认会来日本和韩国亚洲行。从财政角度来说或许可以过一个“肥年”，但是说白了其实也肥不到哪里去，毕竟还有那么多的历史包袱。</p>
<p>夏天要走的人，估计就是：佩尼亚、法蒂和托雷。至于保-维克托、克里斯滕森等人，我倒是觉得都可以再留一下，尤其是藤森他也可以打后腰。至于费兰、大根、小明，除非报价特别好，他三个也是可以离开的。</p>
<p>前面说了弗里克和拉波尔塔都是可以松一口气的人，但是偏偏球队体育总监德科的压力却没有小，他去年搞来不中用的罗克已经算是被很多球迷质疑了，其他的很多出色球员并不是他搞来的，说白了就是这个三冠王其实跟他没啥大关系。如果他这个夏天不能有效处理掉冗员并且有效补强，或者跟亚马尔的续约没有弄好，他估计会被球迷喷到关闭评论。目前巴萨还有这几个人的转会分成条款：<br>	1. 在葡萄牙体育的特林康，50%转会分成<br>	2. 在拉斯马尔巴斯的马尔莫，有50%转会分成<br>	3. 在西汉姆的托迪博，有20%转会分成<br>	4. 在塞尔塔的明戈萨，有50%转会分成<br>	5. 红牛租借给塞尔塔的莫里巴，有10%转会分成<br>	6. PSV的韦斯特，还有一点分成<br>	7. 罗克还有10%的转会分成</p>
<p>说实话这几个人里能拿到钱的可能性其实都不大，基本无法指望他们能卖很多钱了。</p>
<p>至于说要来的人，目前传闻比较猛的迪亚斯，据说转会费要8500万，这简直太扯了，迪亚斯的年龄跟拉菲尼亚同岁，还要8500万那么贵，傻子才会买。</p>
<p>这个赛季最需要补其实是亚马尔的替补，亚马尔在赛季中途受伤的时候，那个位置是拉菲尼亚代打的，效果并不好。所以依旧需要一个能突破的人来顶上（至于内马尔、拉什福德啥的就算了吧，只是球迷的一厢情愿），这里我倒是觉得李刚仁如果便宜的话可以看看。</p>
<p>其次的问题就是莱万接班人的问题，莱万估计下个赛季还是会状态下滑，能维持住30个进球就不错了。那么莱万这部分的工作是交给谁呢？还是一个很大的问题。有人说是哲凯立什或者伊萨克，但是他俩也都不便宜，而且估计也有主力位置的诉求。</p>
<p>至于最近传也很火的大马丁，我个人觉得他是很适合这支巴萨的，面对单刀的扑救能力的确是五大联赛top级别。说实话，纵观巴萨的历史，除了梅西之外的阿根廷人很少有在巴萨成功的。而且大马丁年纪大工资高，考虑到这些事情总觉得这个交易不太现实。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>巴萨下赛季一定要解决的就是防守问题，从4月23日1:0战胜马洛卡之后的所有比赛，目前看只有2:0战胜西班牙人和最后一轮3:0毕尔巴鄂是零封。这种防线肯定是不满足高水平的欧冠要求。全年巴萨的0封场次是21场，不足50%，单场丢球超过3个的比赛却有7个。要去争夺欧冠，尤其是很多年轻球员在今年的大胜利之后，进取心有所不同的前提下，势必要在防守下更加下足功夫，不然赢取欧冠就是痴人说梦。</p>
<p>再其次就是任意球得分能力的问题，这个赛季巴萨一共在西甲27脚任意球就进了一个…上个赛季21脚任意球还进了俩呢，缺少这种任意球高手在打破僵局的时刻也是一个伤。</p>
<p>至于伤病控制问题，其实弗里克团队已经做的很专业了，明年如果运气好一点，在最后冲刺阶段关键球员没有伤病，那就太好了。</p>
<p>2024年的夏天是西班牙足球的绽放时刻，他们不仅拿下了2024年的欧洲杯冠军还拿下了奥运会男足金牌。而无论是西班牙的胜利还是到今天的三冠王，其实都是巴萨足球的春天。死对头皇马把主教练换成了阿隆索，说实话相比较安切洛蒂，我其实没那么怕阿隆索，我觉得明年巴萨还是会在成绩上压皇马一头的。Visca Barça, Visca Catalunya！</p>
<p><img data-src="/images/%E6%8B%89%E7%8E%9B%E8%A5%BF%E4%BA%9A.webp" alt="paradin" title="拉玛西亚，生生不息，明年继续出发！"></p>
<h2 id="相关新闻"><a href="#相关新闻" class="headerlink" title="相关新闻"></a>相关新闻</h2><p><a href="https://baijiahao.baidu.com/s?id=1832236390227214084&wfr=spider&for=pc">https://baijiahao.baidu.com/s?id=1832236390227214084&amp;wfr=spider&amp;for=pc</a><br><a href="https://m.hupu.com/bbs/630711476.html">https://m.hupu.com/bbs/630711476.html</a></p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>国际足坛</tag>
        <tag>巴塞罗那</tag>
      </tags>
  </entry>
  <entry>
    <title>巴萨的22～23赛季末总结</title>
    <url>/2023/05/16/%E5%B7%B4%E8%90%A8%E6%8B%BF%E4%BA%86%E8%A5%BF%E7%94%B2%E5%86%A0%E5%86%9B%E4%B9%8B%E5%90%8E/</url>
    <content><![CDATA[<h2 id="赛季的总结"><a href="#赛季的总结" class="headerlink" title="赛季的总结"></a>赛季的总结</h2><p>随着4：2战胜西班牙人的哨声吹响，巴萨夺得了本赛季西甲冠军。上一次2019年巴萨夺得西甲冠军的时候，很多人还不在这支队伍里（除了布斯克茨、罗贝托、阿尔巴、特尔施特根、登贝莱、二门佩纳之外都是西甲冠军处男）。所以说，这个西甲冠军也是很多人第一个西甲冠军乃至第一个五大联赛冠军（对，说的就是你，奥巴梅杨，祝贺你获得了人生的第一个联赛冠军）。</p>
<p>巴萨2022-2023赛季是西班牙超级杯冠军和西甲冠军，国王杯半决赛被皇马1：4淘汰。欧冠小组赛未出线，欧联被曼联3：4淘汰，止步32强。</p>
<p>总体来说哈维等人交出了一个“国内表现不错，国际赛场不OK”的答卷。又考虑到整个赛季巴萨对皇马的交手，赢多输少（赢三场输二场，总进球7个丢球9个）。搭配上过去一个夏天2亿转会费的操作（来了莱万、拉菲尼亚、孔德等人，免签克里斯腾森、阿隆索、凯西等人），总体来说付出与回报还算匹配得上。这个西甲冠军也是拉波尔塔作为主席的第五个西甲冠军。作为一个球迷，我个人给管理层、教练组和球员们掌声。<br><img data-src="/images/%E5%B7%B4%E8%90%A8%E8%B5%9B%E5%AD%A3%E6%80%BB%E7%BB%932.JPG" title="巴尔德传中莱万抢点，这个将会是下赛季常见的场景"></p>
<p>我记得去年夏天滕哈格入住曼联后就要重金购买德容，但是德容因为内部和外部的原因最后坚持留下来没走，就是因为这个坚持，让他在对阵曼联输球之后还被曼联的球迷嘲讽，现在来看德容在巴萨留守的决定还是对的。</p>
<p>再说一下拉波尔塔，拉波尔塔虽然被不少梅西球迷追骂，而且在球队欧冠无缘小组晋级的时候，更是被嘲讽成“杠杆主席”。不过男足这个结果也能让他可以对会员有交代了，而且他也参与了更衣室庆祝，可见他的确很受球员们的热爱。详情可见：<br><a href="https://k.sina.com.cn/article_2427613143_m90b26fd7033011wma.html?from=sports&subch=osport?hasPlayedTime=5.180255">https://k.sina.com.cn/article_2427613143_m90b26fd7033011wma.html?from=sports&amp;subch=osport?hasPlayedTime=5.180255</a> 。 但是小克鲁伊夫确认夏天离开（阿尔玛尼又说不走了），德科来接他班，那么对于作为主席的拉波尔塔，如何进一步提升巴萨影响力、诺坎普球场翻修期间如何提升商业收入，是他新的OKR。</p>
<p>哈维是这个球队的主教练，上个赛季他中途接手，巴萨四大皆空，实在是因为整个球队的阵容乏软无力。他这个赛季卷土重来，率领队伍靠着团结夺得国内双冠。我想也正是因为他的“球队传奇”属性，能在更衣室压得住一些老队友，能让皮克比较平滑且体面的退休。而且也正是他球队传奇的属性，在舆论上可以不用背负那么沉重的433阵型的桎梏（把加维调到首发阵容，开始4中场甚至3后卫，渡过了欧冠小组失利和西甲国家德比首回合1：3输皇马的至暗时刻）。当然这也离不开拉波尔塔对他的绝对支持，而不被支持的科曼就只能郁闷走人。有些时候哈维还是比较死板，比如今年巴萨面对一些传统强队表现并不好，还有那些1-0的比赛和遗憾输球逼平的比赛。当然我不是说1-0的比赛不好，相反一个队伍有没有冠军相，就是看那些1-0的比赛，也就是比分可能不如意，但是是球队坚持90分钟咬牙拼出来的，这种比赛对球队是有正面作用的。但是哈维有一些灵活性的地方还需要提高，不能一进入僵局就开始传中找莱万，不然这可能是巴萨在欧冠上前进的一个瓶颈。同时也要减少自己吃牌的次数。<br><img data-src="/images/%E5%B7%B4%E8%90%A8%E8%B5%9B%E5%AD%A3%E6%80%BB%E7%BB%938.jpg" title="最开始首发有皮克，然后加入了加维，然后又是拉菲尼亚，哈维一直在调整首发"></p>
<p>至于重夺这个阔别4年的西甲联赛冠军是不是巴萨的复兴？按照前年的国米和去年的AC，只能说是一个阶段性的胜利，巴萨已经把这个阵容的中轴线和未来的蓝图搭建完成，并且在西甲的赛场实验很成功。还需要证明自己跟传统强队正面掐架的能力，和财务层把经济状况扭转过来，那才是真的算复兴了。</p>
<h2 id="赛场评价时刻"><a href="#赛场评价时刻" class="headerlink" title="赛场评价时刻"></a>赛场评价时刻</h2><p>赛季最佳比赛：<br>	1. 西班牙超级杯决赛，3-1皇马 （无论是赛前的布置，还是比赛的拼劲激情，加维的灵活使用都是让皇马没有想到的，可见赛前做了足够的功课！）</p>
<p>赛季最差比赛：<br>	1. 欧冠小组赛第四轮，3-3国米 （虽然我也是国米球迷，但是这场比赛导致巴萨基本确认无法从欧冠小组出线了）<br>	2. 欧冠小组赛第五轮，0-3拜仁 （上半场表现气势如虹，下半场纳格尔斯曼率先做出调整后，哈维就硬住了）<br>	3. 国王杯半决赛次回合，0-4皇马 （伤员太多，没招）</p>
<p>球队MVP：阿劳霍（未来的队长，心态和技术都升级的一年）<br>	提名：莱万（莱万是这个球队的主炮手，贡献了大量DPS输出，但是欧冠和部分联赛有些脚软。）<br>最关键球员：拉菲尼亚（在赛季中后期很多球员受伤的时候，抢了不少分）<br>	提名：德容&#x2F;佩德里（德容整体的发挥更加稳定了，跑动面积更大，下赛季没有布斯克茨，对他来说是巨大的挑战。佩德里能力毋庸多说，可惜受伤了一段时间）<br>最被低估球员：克里斯腾森（后防中坚，硬如磐石）<br>	提名：小狮子（搭配BACK防线让人很放心）<br><img data-src="/images/%E5%B7%B4%E8%90%A8%E8%B5%9B%E5%AD%A3%E6%80%BB%E7%BB%933.jpg" title="后防两位大爹，明年继续加油！"></p>
<p>进步最大球员：加维（这个赛季出圈了，ins上粉丝是球队第三多。赛季末改打左边锋让他的进攻属性有点收敛了）<br>	提名：巴尔德<br>最掉链子球员：法蒂（虽然他是球队的第四射手，但是整个人完全不在状态，无法被指望）<br>	提名：贝莱林（其实从这哥们吃素开始，他就已经注定不行了）</p>
<h2 id="夏季的调整"><a href="#夏季的调整" class="headerlink" title="夏季的调整"></a>夏季的调整</h2><p>距离布斯克茨的离开已经是倒计时了，巴萨在这个赛季先后送别他和皮克，意味着首发年轻化将会进一步得到落实。<br><img data-src="/images/%E5%B7%B4%E8%90%A8%E8%B5%9B%E5%AD%A3%E6%80%BB%E7%BB%93.JPG" title="布斯克茨离开已是定局，梅西回归目前看是有一点点的可能"></p>
<p>其他有可能会动的球员：<br>	1. 拉菲尼亚，纽卡据说8000万求购，要是真是这个价格，出售的意义不大。如果是一个亿以上的话估计会卖掉，这样能赚5000万左右。但是说实话，巴萨现在不缺1个亿，缺的是能抢分的人。所以我觉得他应该不会走。<br>	2. 费兰托雷斯，他自己接受采访也表达将来希望回归瓦伦西亚，不过据说英超阿斯顿维拉等队伍看上他了，大概率会出售。<br>	3. 法蒂，据说门德斯已经去过了巴萨，双方还是认为法蒂可以继续留在俱乐部看看，出售和留下概率各50%<br>	4. 马克斯-阿隆索，他一直都不算融入了哈维的体系，而且年纪不小，留下出售的概率各一半，但是即使出手了也不会挣回来很多的转会费，他当年是免费身加盟<br>	5. 加西亚，在哈维的安排里是排后面的，而且一度尝试打了后腰，表现普普，估计会出售，但是也不会挣回来很多的转会费<br>	6. 凯西，俊凯是一个好球员，但是他可能会去国米，因为国米今年球员工资1.27亿，对比意甲冠军那不勒斯的6900万，国米肯定是要瘦身的，瘦身的第一个事就是处理布罗佐维奇这样的队内顶薪者，凯西因此会去国米补强，考虑到他当年也是免费身加盟，也能小赚一丢丢<br>	7. 乌姆蒂蒂（这哥们跟巴萨的合同到2026年）&amp;朗格莱，他俩或许能捞点为数不多的转会费，加起来也就1500万出头的样子<br>	8. 阿尔巴，鼹鼠对这个队伍功劳很大。但是据说他的薪水是税前3600万，如果是真的，那我是真不知道巴托梅乌这个合同怎么开出来的。他即使留下来，也要降薪超过50%</p>
<p>从此来看，巴萨的工资会因为这些人，尤其是阿尔巴的离开or降薪而腾出较多的空间，用这些空间满足梅西2500万税前工资应该不是梦，但是也仅仅是腾出来的坑被梅西的工资又给填上了。但是梅西是有市场效应的，会给巴萨商业化带来一点好处。而靠卖上面这几个人（除了拉菲尼亚，还有德斯特、特林康的人）得到的转会费收入则不会很多，满打满算不会超过4000万，所以这个夏天的转会预算应该是1~1.2亿左右，跟去年持平。别忘了巴萨还有很多球员的注册工作要做。</p>
<p>这里额外说说登贝莱，登贝莱对于这个巴萨很重要，甚至咪咕的董路老师一度说自己是“登吹”。但是他伤病、斋月就让他在一些关键比赛里不是特别的靠得住。而且登贝莱助攻能力不错，进球能力差了可不是一点半点，在西甲进球（5个）比被骂开花的法蒂和费兰只多了一个，跟中途离开的德佩一样多。他如果能在西甲打出双十、全赛事15+20的成绩对巴萨的助力会非常大。</p>
<p>再说说转会市场里传有可能来的人:<br>	1. 伊尼戈-马丁内斯，这是一个31岁的毕巴中卫，来了也是打替补。据罗马诺的消息他已经确认加盟了。<br>	2. 京多安，曼城有可能今年三冠王，他来巴萨也是顶布教授的位置，不过我个人觉得他不太可能来，曼城不会轻易放他而且他个人对曼城也有很深的感情。而且说实话，他来了也不会对巴萨在欧冠上的突破有什么立竿见影的帮助。<br>	3. B席，我个人希望他来，因为B席的到来对巴萨的帮助很大，会丰富一种打法。<br>	4. 鲁本内维斯，目前狼队咬死了身价5000万，但是说实话对于这位在狼队效力6年的队长，我个人是不觉得他值那么多钱的。他的优先级我觉得排在京多安之后，有这个钱不如去买皇家社会的苏比门迪。<br>	5. 阿姆拉巴特，有拦截有长传有摆脱，在世界杯上也展示了拼劲，年龄也不错，我个人觉得优先级比京多安高一点。<br>	6. 卡拉斯科，当初德佩赛季中期去马竞的时候，就有传闻卡拉斯科会来巴萨。不过现在这个传闻热度越来越低，巴萨或许会要他但是不会出很高的价钱。<br>	7. 布罗佐维奇，他受伤后首发的位置已经逐渐被恰尔汗奥卢取代，他31了，工资很高。我个人觉得巴萨不太可能要他。<br>	8. 5月17日突然开始传基米希希望离开拜仁加盟巴萨，如果他能来巴萨，无疑他的优先级是最高的，甚至从竞技层面上要约等于梅西。不过没有更多的瓜之前，先不好下定论。<br><img data-src="/images/%E5%B7%B4%E8%90%A8%E8%B5%9B%E5%AD%A3%E6%80%BB%E7%BB%935.JPG" title="基米希要是真的来，那我做梦都笑醒"></p>
<p>其实从上面的几个引援绯闻对象可以看出巴萨的补强路线：<br>	1. 在莱万之后的第二杆枪，提供稳定的DPS输出。这点梅西满足，小图拉姆作为莱万的替补也可以，奥巴梅杨虽然屡屡表忠心，但是年纪大太，亚马尔还太小，才16。<br>	2. 能丰富球队打法的人，佩德里&#x2F;德容等人地面渗透的能力不是说不优秀，但是还需要另外一种人来作为后招，梅西和B席是满足的，而且他俩都有任意球能力。<br>	3. 接替布教授的人，这里面基米希是最好的，其次是京多安和阿姆拉巴特。</p>
<p>除此之外，球队还需要从以下几点进行补充，这样有助于球队下赛季在欧冠的进步：<br>	1. 右后卫，孔德多次说过自己更喜欢打中后卫，阿劳霍偶尔会打右路，但是也主要是针对于皇马维尼修斯。所以如果孔德还这么强烈的要求打中路，那么球队肯定要一个右后卫，不然就要靠罗贝托继续抗这个位置。<br>	2. 左后卫，阿尔巴如果谈崩了离开，那么左后卫只有一个巴尔德是不行的，靠阿隆索来顶会有一定的风险，所以补进左后卫是必然的，市面上买不到估计就要效仿皇马让卡马文加打左后卫的套路，内部挖掘。</p>
<p>很多球迷可能会认为切尔西和尤文将会在这个夏季超市大开张，切尔西我觉得是有可能的，毕竟切尔西目前每个位置都有相当多的冗余，但是这里面适合巴萨的并不多，或者加钱很贵，这种对于巴萨来说没必要的钱就不要硬花了。<br><img data-src="/images/%E5%B7%B4%E8%90%A8%E8%B5%9B%E5%AD%A3%E6%80%BB%E7%BB%934.jpg" title="据说切尔西现在转会费用的还是阿布当时的基金，伯利花前任的钱是真不客气"></p>
<p>如果梅西顺利回归，巴萨明年估计会尝试4-3-3开局然后变阵4-4-1-1，梅西肯定不会继续打右边锋而是进攻中场，让登贝莱积极防守，前场莱万+梅西要省着点用，就像巴蒂在国米的第一年那样，把体能都用到刀刃上。<br><img data-src="/images/%E5%B7%B4%E8%90%A8%E8%B5%9B%E5%AD%A3%E6%80%BB%E7%BB%937.jpg" title="如果中场补进了京多安，加维和佩德里就可以有选择性的休息不用死操一个赛季了"></p>
<p>或者干脆直接打3后卫，现在瓜都转型改打3后卫了，哈维也有这方面转型的趋势：<br><img data-src="/images/%E5%B7%B4%E8%90%A8%E8%B5%9B%E5%AD%A3%E6%80%BB%E7%BB%936.jpg" title="改打3后卫的话，对巴尔德的跑动有很大的要求"></p>
<p>毕竟这个赛季还没结束，还剩下4场比赛，希望莱万在这4场比赛里打破C罗26球的“第一年踢西甲进球最多”的记录，也希望拉菲尼亚能联赛进球破10。</p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>足球</tag>
        <tag>巴萨</tag>
      </tags>
  </entry>
  <entry>
    <title>巴萨的23～24赛季末总结</title>
    <url>/2024/04/22/%E5%B7%B4%E8%90%A8%E8%B5%9B%E5%AD%A3%E6%9C%AB%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>其实原本这个文章打算在2:4输给吉罗纳之后写的，但是当时实在比较忙，而且闲下来的时候又犯懒，于是拖到现在。讽刺的是没想到“因祸得福”，巴萨赛季临近结束又有各种各样的场内外故事，所以这篇总结还是挺有时效性的。</p>
<h2 id="先说比赛"><a href="#先说比赛" class="headerlink" title="先说比赛"></a>先说比赛</h2><p>巴萨本赛季的工作结果从过程来说是合格，但是从结果来说是不合格的。主要原因就是联赛被皇马甩开10分且欧冠在大好局面被逆转。当然，我们也要注意到，这个赛季85分在去年也是可以拿西甲冠军的，而且在最近5个西甲赛季里，85分都是比较高的分数，只能说今年皇马在联赛拿到了95分，实在是有点逆天。</p>
<p>巴萨的防守崩盘，主要集中在上半赛季，在特尔施特根受伤、佩纳主门的阶段表现更加明显。经常裁判的开场哨还没凉透就丢了一个球，自带0-1甚至是0-2的前提踢球是巴萨那段时间的标准开局。根据马卡报5月初的数据证明“如果只考虑上半场的成绩，巴萨只有47分，排名西甲第七”。</p>
<p>再看看具体的一些丢球数据：<br>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">面对皇马3回合丢了9球，今年面对皇马从结果来说表现得不如去年</span><br><span class="line">面对吉罗纳2回合丢了8球</span><br><span class="line">面对比利亚雷亚尔2回合丢了8球</span><br><span class="line">面对巴黎圣日耳曼2回合丢了6球</span><br><span class="line">面对格拉纳达（排名第十九）2回合丢了5球</span><br><span class="line">面对毕尔巴鄂国王杯单场丢了4球</span><br></pre></td></tr></table></figure></p>
<p>那么为什么巴萨的防守与上赛季相比千差万别？我想主要原因是我们夏季的引援是失败的，是“看上去很美，但是用起来完全不是那么回事的”。</p>
<p>先看2022年的主要转会操作：<br>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">转入：拉菲尼亚5800万欧元 、莱万多夫斯基4800万欧元、克里斯滕森（免签）、凯西（免签）、贝莱林（免签）、马科斯-阿隆索（免签）、孔德5500万欧元</span><br><span class="line">转出：格列兹曼</span><br></pre></td></tr></table></figure></p>
<p>2022年花出去1.5亿左右，除了贝莱林是彻底的失败，其他几个人都算不错，即在又又稳定的出场时间且在关键比赛可以指望，甚至马科斯-阿隆索也能在有限的时间里输出点贡献，这一批的转会操作无疑是很成功的。</p>
<p>再看2023阵容主要变化如下：<br>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">转入：罗梅乌340万欧元、伊尔凯·京多安（免签）、伊尼戈·马丁内斯（免签）、若昂·菲利克斯（租借）、若昂·坎塞洛（租借）、罗克（4000万欧元）</span><br><span class="line">转出：登贝莱 法蒂  凯西  阿尔巴 布斯克茨 德佩</span><br></pre></td></tr></table></figure></p>
<p>相比较去年的1.5亿，拿了西甲+超级杯冠军的巴萨“转入”里投资金额大幅度减少，但是来的人却不少，但真正对球队有稳定正面作用只有一个京多安（赛季51场比赛，5个进球14个助攻，队内助攻王），其他人的表现都与预期有不小的差距，尤其是伊尼戈、罗梅乌和罗克，连出场机会都寥寥可怜。走的人里，登贝莱、阿尔巴和布斯克茨是绝对的主力，凯西也是一个稳定的轮换。所以在整个转会市场可以说先输一局，每场比赛前球迷们只能祈祷两个若昂稳定和莱万进球。其实当初买菲利克斯（赛季44场比赛，10个进球6个助攻）就是要他给莱万当僚机，让莱万不用那么辛苦的后撤，但是真打了之后发现他俩之间其实完全不来电。坎塞洛虽然有补时救主的高光，但是总体来说是双刃剑，打强队的时候让人看着心惊胆战。一向稳定的孔德也出现了起伏，所以这个赛季的后防简直就是灾难表现。<br><img data-src="/images/%E5%B7%B4%E8%90%A8%E5%87%BA%E5%9C%BA%E6%97%B6%E9%97%B4.JPG" alt="paradin" title="罗梅乌、伊尼戈出场时间甚至不如佩纳"></p>
<p>哈维面对这样的情况，在第一次宣布离职前有多次应付不暇的窘态，相比较克洛普自宣离队，哈维无疑是有点输急眼了。当然我们可以找理由说“登贝莱的离开太出乎意料了”，只能赶鸭子上架让童工亚马尔来踢，而且中途又意外遇到了加维、巴尔德的重伤，导致在克里斯滕森没有完全负责后腰之前，整个队伍的中场防守降了一个等级。虽然有这样的伤病、那样的变化，但是哈维在场上随机应变的能力也被人诟病，感觉在莱万不太愿意回撤的情况下，哈维找不到中场的最优解。可以说这个赛季的菜就不太好，那么厨子自己能力又很有限，所以结果也是意料之中。</p>
<p>2024年的巴萨有点像赛季最后临了的切尔西，虽然“北伐”还算成功，但是无奈前期的坑挖的太大，所以无论是联赛还是欧战都只能接受这样的无冠结果。</p>
<p>那么整个赛季的球员打分情况：<br>    A级表现，让人惊喜：亚马尔、库巴西、京多安、费尔明、克里斯滕森（提供了防守强度，还屡屡进球）<br>    B级表现，让人满意：拉菲尼亚、特尔施特根、孔德、佩德里、阿劳霍、福特<br>    C级表现，只能说凑合：莱万、菲利克斯、费兰、坎塞洛、罗贝托、德容、伊尼戈<br>    D级表现，灾难：法蒂、罗梅乌、巴尔德（赛季报销之前表现很不好）</p>
<p>其他没上榜的就是出场时间太少了，没法评语。</p>
<h2 id="再说哈维"><a href="#再说哈维" class="headerlink" title="再说哈维"></a>再说哈维</h2><p>哈维是一个很务实的教练，赛季初追求出球，他打3241，效果很惨，就及时变阵433，感觉好多了。他自己临场指挥有部分短板，但是赛季末的几次中途换人也得到了立竿见影的效果，集中体现在“几次换上佩德里”，驴哥的替补出场不是进球就是助攻。哈维球场边的脾气急躁后口无遮拦的毛病也没改，他作为教练吃牌数明显高于身为球员的自己，抛开这个赛季很多赛场边的争议，其实哈维很多对第四官员和主裁的嚷嚷是没有用的，反而自己吃牌然后徒然上火。</p>
<p>要我评价哈维的工作，因为首先他在更衣室还是很有掌控力的，球员也愿意为他而战。其次他的临场指挥有进步的趋势，比赛的战术也有一些看点（比如没有加维就让拉菲尼亚去左边顶替。定位球得分也有了很大的进步），而且这支巴萨其实在一定程度上也是一个被人低估的，这其实是一个打逆风局还可以的队伍。巴萨西甲取得的85分里，有54分是来自60分钟以后的进球，且在最后半小时的丢球数比去年减少了38%。</p>
<p>本赛季巴萨的场均跑动公里排名西甲第五，而上赛季这个数字是西甲第二，为什么会下降这么多，因为没有登贝莱和加维这样的体能怪。但是在一些强战里，比如面对巴黎，巴萨比对方多跑了7公里。所以说这个队伍其实是一个能打硬仗的。</p>
<p>但是哈维在落后2球以上的比赛里指挥表现的不好，经常直接自己先大脑宕机了然后在场边跟裁判叫喊。而且哈维毕竟是一个年轻教练，他挖掘了不少年轻球员，也让三宝（亚马尔、库巴西、费尔明）肉眼可见多了不少肌肉，但是还不具备点石成金的能力。也就是说一个80分的阵容交给他，他交出的结果就是上下浮动5分，再高是不可能的，他这两年半联赛的分数稳定在85分左右。所以他这个看菜下饭的能力其实不太匹配目前经济情况很紧张的巴萨。</p>
<p>我个人其实是支持哈维留下走完合同期，但是天不遂人愿，一场发布会之后，哈维就这样离开了，其实他的胜率在最近4个教练里也还可以。我认为这个赛季巴萨崩盘第一问题是转会的失败、第二是伤病管理、第三才是哈维的临场指挥。这里说实话，哈维是有锅，但是锅是比较小的。<br><img data-src="/images/%E5%B7%B4%E8%90%A8%E6%95%99%E7%BB%83%E6%88%98%E7%BB%A9.jpeg" alt="paradin" title="哈维总共在位918天，希望他还有回来的那一天"></p>
<p>突然失业的哈维肯定不会没工作，据说葡超、荷甲、AC米兰、韩国国家队等都对他有意，我个人觉得他去带带荷甲或者意甲，练练杯赛挺好的，杯赛其实非常锻炼人的临场指挥。</p>
<h2 id="再说说比赛外"><a href="#再说说比赛外" class="headerlink" title="再说说比赛外"></a>再说说比赛外</h2><p>其实说比赛外，无疑就是说一个人，那就是主席拉波尔塔。</p>
<p>拉波尔塔他当初选择了哈维，第一是他的价格便宜，可以靠爱发电。第二可以借着哈维，相对体面的弄走了皮克等更衣室大佬。拉波尔塔是一个存在感很强的主席，这种主席其实在当今足坛不多了。拉波尔塔几次高调的做法可以理解成作秀来为自己制造出“和球队在一起，和球员在一起”的感觉来为自己拉票，他是一个善于打着“为了XXX”的旗号做事情的人。但是这样的行为无疑是对教练的一个冒犯，让教练不能把全部的精力用在赛场上。同时球队的总监反而成了必须跟他在一起的人，不然总监就更难做。</p>
<p>拉波尔塔的做事风格对一些教练和总监不友好，但是底线其实很明确：就是巴萨在他的任内不能因为经济恶化而垮掉。所以他没有选择摆烂度过这段黑暗时光，而是借钱加杠杆去多打比赛多挣钱翻修体育场，这无疑是一场豪赌，赌赢了扬眉吐气，所以巴萨这段时间成绩不能掉队，要尽可能的多打比赛多挣钱。拉波尔塔跟部分经纪人关系很好，他也认为这些经纪人手下的球员会是后梅西时代巴萨的新基石，所以他指望的人是不可以轻易碰的。他炒掉哈维的理由是“哈维跟他建队理念不合”，因为哈维力主要卖掉“莱万、两个若昂、阿劳霍和罗克”。这个理由可能是记者的扑风捉影，因为莱万几次中途被换下，阿劳霍最后几场也没有打，哈维这些场上选择给了记者无限的遐想。但是哈维夏天想对队伍进行大手术应该是不争的事实，巴萨也需要用更直接的方法去进攻，才能守住联赛的基本盘。</p>
<p><img data-src="/images/%E6%8B%89%E6%B3%A2%E5%B0%94%E5%A1%94.JPG" alt="paradin" title="死亡之吻"></p>
<p>不管怎么说，拉波尔塔对哈维出尔反尔的表现，明显是对哈维这个巴萨名宿的冒犯，也在一定程度上败坏了巴萨在路人心中的形象。拉波尔塔现在应该做的是继续全力的去搞赞助搞钱，而不是亲自来搅合更衣室管理和在战术板上指点江山，他要做的就是全力做好后勤。不然的话，他只能给这个队伍添乱，是一个负作用主席。今年巴萨除了女足和手球，其他的队伍今年表现都一般般（男足和男篮都是一个没有冠军的赛季），拉波尔塔今年压力山大，但是有压力不是他可以“冲上一线”的借口，还是那句话“让专业的人干专业的事儿”。</p>
<p>对于管理层我还是要说罗贝托的续约还是要续，既然答应了人家就要续约，多一年也没什么，而且罗贝托还能打多个位置必要的时候可以顶上去，这个赛季他的表现虽然有低谷但是也有高光，最重要的是要给球员和外界一个“遵守协议”的形象。形象现在对于巴萨来说是一个很重要的东西。</p>
<h2 id="夏季的展望"><a href="#夏季的展望" class="headerlink" title="夏季的展望"></a>夏季的展望</h2><p>既然说未来，肯定第一个就要说队内工资最高，下赛季3200万薪水的莱万。话说这是2013年以来，莱万第一次品尝到“四大皆空”的赛季。莱万这个赛季一共进了26个球9个助攻，其中西甲进了19个。在现在这个好中锋打着灯笼找的年代，找到莱万的平替不是一个容易的事儿。虽然我算是莱万的球迷，但是莱万这个赛季已经肉眼可见的下滑，他自己说自己还能扛2年，而且弗里克跟他也是老搭档，但是我觉得下个赛季莱万还能贡献25+球的可能性微乎其微。他将会越来越多的在禁区里，当轴当墙，然后回撤也会越来越少，高位逼抢也会越来越少，对掌控节奏的能力也是未知，现在的莱万越来越多的依赖队友给他提供的反复冲击而造出来的攻击机会，但是明显佩德里和更老的京多安不是这样的风格，而费尔明洛佩斯是这样的风格。所以说莱万下赛季的表现，是要建立在中场的冲击力的决断性。而莱万如果下赛季不能做到联赛22+个球，那么他个人的表现还是不合格的。</p>
<p><img data-src="/images/%E8%8E%B1%E4%B8%87%E7%9A%84%E8%BF%9B%E7%90%83%E8%A1%A8%E7%8E%B0.jpeg" alt="paradin" title="这个图发表的时候还没包括西甲最后一轮莱万对塞维利亚的进球，所以这个赛季莱万进了26球"></p>
<p>佩德里，我觉得目前这个队伍里，最有金球像的就是他，他如果爱护的好，自己也没有受伤的后顾之忧，是有金球前10的那一天的，佩德里的防守其实不差，插上的意识和射门准头也有。但是他有一点比较尴尬，就是跟京多安的配合没有那么亲密无间，京多安我理解人家是来打替补或者打轮换主力而不是一把岁数还往死里操的，这个夏天如果德容不离开，那么“加维-佩德里-京多安-德容-某一个新后腰-克里斯滕森”，这五个人怎么保证巴萨中场的轮转流畅是新教练弗里克的一个大难题。</p>
<p>额外说一句，京多安重要的是要给巴萨带来一种精神，就是“无论怎么样我们肯定能赢”的信念，这个信念在巴萨里还是缺乏的，所以京多安明年依旧会在更衣室担任这个角色。</p>
<p>德容，德容很尴尬。他其实今年的表现没有比伤病不断的佩德里好很多，德容是一个多面手，甚至在科曼手下还打过中后卫，但是他现在无法扛起来巴萨攻守转换的任务。原本在哈维手下，我觉得他走比较好，巴萨能回收一笔资金用于补强，他也能去一个新的环境里增加对自己的磨练。现在弗里克来了，我倒是觉得再看看德容在弗里克手下是否能有进步，话说我可能总有“沉没成本”这么一个心理。</p>
<p>阿劳霍，很多球迷对他喊打喊杀，我可以这么说，这个市面上阿劳霍的平替跟莱万一样的稀缺，阿劳霍有身体有意识是一个不可多得的后防好苗子，除了对巴黎的红牌，和主场对巴黎解围不远导致一个丢球之外，其他时候基本都还是不错的表现。要知道这个赛季是阿劳霍第一次踢欧冠淘汰赛，所以对于后卫我觉得是要付出训练成本的。不过阿劳霍的合同的确是被巴萨压榨的。</p>
<p>坎塞洛和菲利克斯，据说哈维认为这两个人都不应该继续留下，我个人认为相比较而言，坎塞洛是更不应该留下的那一个。坎塞洛本赛季42场比赛4个进球5个助攻，表现是差强人意的。他在打强队和弱队后期都没有很亮眼的表现，如果打3412，他需要的是控住球，不能轻易丢球给对方打反击，但是他又不能做到控球的精准，所以如果打433他可以在右路被孔德替代的，这个情景就有点像阿森纳的津琴科和富安健洋，关键时刻要稳一点的富安健洋，津琴科可以在某些场合出场。而菲利克斯至少还能多一种进攻打法，他跟佩德里这种控制性中场比较搭，下赛季大概率是弗里克担任教练，如果菲利克斯不换走，他必须要增加自己的冲击禁区频率。</p>
<p>库巴西是这个赛季的惊喜意外发现，虽然他可能现在有新秀墙的困扰，但是他总体的表现还是不错的。而亚马尔这个赛季出场50次，一共7个进球10次助攻，面对皇马客场拿到了单场最佳，巴萨这批年轻人的进步是失败赛季里挖掘出来的宝石。我现在只希望库巴西、亚马尔、费尔明、福特等等这个夏天不要全勤参加欧洲杯和奥运会，选一个参加就行，养好身体是第一要务，明年乃至后年才是他们大显身手的时刻。</p>
<p>巴萨这支“莱万-佩德里&#x2F;加维-库巴西&#x2F;阿劳霍-特尔施特根”的中轴线除了莱万现在是短板，其他问题都不大。但是这个短板和伤病一样，是明年最大的风险。</p>
<p>再说说夏天转会，其实说夏天转会的前提就是巴萨俱乐部能重返1:1，不然来的球员也不能注册。然后再看巴萨现在需要的位置：防守型中场、莱万的替补和左边锋。我个人觉得对于弗里克，巴萨不卖人的话，估计有5000万左右的预算，如果卖掉队伍里的明星球员，那么手头的钱就更多一点。</p>
<ol>
<li>基米希，我个人希望他来，但是他现在在拜仁的薪水据说是1950万，这等高薪巴萨肯定承担不起。即使回归了1:1，巴萨还是承担不起，所以基米希可以放弃了，应该去看看其他人。奥纳纳、祖比门迪，工资相对友好，但是转会费也是一个不小的数字，而且祖比门迪是哈维的爱，现在哈维不在了，估计这事就黄了。目前最大的可能性是吉多-罗德里格斯，可以关注一下这个30岁的阿根廷后腰的美洲杯表现。</li>
<li>B席尔瓦，他去年来是最适合的，今年已经不适合了。因为今年的B席明显的“身体不如眼睛快”了，大伤后的三笘薫同理，不得不说有些时候事情没成就一辈子都成不了了。至于维尔茨和穆斯莱拉来巴萨更是扯淡。尼克-威廉姆斯和奥尔莫，这俩人其实谁来都行，尼克-威廉姆斯个人感觉更有希望，但是他工资据说要求是税后1000万。</li>
<li>哈维西蒙斯，前段时间传的有鼻子有眼，但是人家毕竟是巴黎的人，看样子大概率下赛季还是会继续租借锻炼。</li>
</ol>
<h2 id="几个神奇的数据"><a href="#几个神奇的数据" class="headerlink" title="几个神奇的数据"></a>几个神奇的数据</h2><ol>
<li>自打2024年以来，西班牙人在五大联赛进球最多的是阿斯帕斯，8个球，排名第二的是费尔明-洛佩斯，7个球。</li>
<li>哈维任期进球最多的是莱万59球，第二是费兰托雷斯25个球，第三是拉菲尼亚20球。而本赛季进球第一多是26球的莱万，第二是11球的费兰托雷斯和费尔明洛佩斯。</li>
<li>哈维任期出场时间最多的是小狮子10758分钟，然后是德容8269分钟，第三名是阿劳霍8255分钟，然后分别是莱万7752、孔德7463、加维6697、布斯克茨6340、佩德里6081、费兰5848、巴尔德5261和克里斯滕森5076。</li>
<li>今年十脚连续传球以上破门的球队，排名第一是吉罗纳20球，然后是皇马17球，第三是马竞和巴萨，并列9球。</li>
<li>本赛季整个前锋群加起来贡献了68球，而梅西在2011-2012赛季一个人就进了73球。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://sports.sina.cn/laliga/barcelona/2022-09-03/detail-imqmmtha5786695.d.html">https://sports.sina.cn/laliga/barcelona/2022-09-03/detail-imqmmtha5786695.d.html</a><br><a href="https://www.soupng.com/transfer/46318.html">https://www.soupng.com/transfer/46318.html</a></p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>国际足坛</tag>
        <tag>巴塞罗那</tag>
      </tags>
  </entry>
  <entry>
    <title>将redis加入到elk日志系统里</title>
    <url>/2018/02/09/%E5%B0%86redis%E5%8A%A0%E5%85%A5%E5%88%B0elk%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E9%87%8C/</url>
    <content><![CDATA[<p>之前在<code>https://rorschachchan.github.io/2018/01/16/记录日志系统ELKB-5-6-4的搭建过程/</code>里面，我画的那个架构图里说了整个架构可以加入redis，但是在文章里我没有写到redis怎么加进去。为了让整个系统更好的分层，是非常建议引入Redis的，毕竟Redis服务器是logstash官方推荐的broker选择。Redis作为一个缓存，能够帮助我们在主节点上屏蔽掉多个从节点之间不同日志文件的差异，负责管理日志端（从节点）的人可以专注于向 Redis 里生产数据，而负责数据分析聚合端的人则可以专注于从Redis内消费数据。所以这一次实验要把redis加进去，同时也要部署一个nginx，让elk再去采集nginx的日志。</p>
<p>整个架构图图下：<br><img data-src="/images/elkredis1.png" alt="paradin"></p>
<h2 id="部署redis"><a href="#部署redis" class="headerlink" title="部署redis"></a>部署redis</h2><p>安装redis的方法请去看<code>http://blog.51cto.com/chenx1242/1793895</code>，我这里使用的redis版本是<code>4.0.6</code>，在执行<code>make test</code>的时候可能会有如下的错误：<br><img data-src="/images/elkredis2.png" alt="paradin"></p>
<p>那就安装新一点的<code>tcl</code>吧，方法如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wget <span class="attr">http</span>:<span class="comment">//downloads.sourceforge.net/tcl/tcl8.6.1-src.tar.gz</span></span><br><span class="line">tar xzvf tcl8<span class="number">.6</span><span class="number">.1</span>-src.<span class="property">tar</span>.<span class="property">gz</span>  -C /usr/local/</span><br><span class="line">cd  /usr/local/tcl8<span class="number">.6</span><span class="number">.1</span>/unix/</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p>
<p>然后重新去<code>make test</code>就会看到成功的字样，如图：<br><img data-src="/images/elkredis3.png" alt="paradin"></p>
<p>现在redis的漏洞比较多，大多数就是因为密码太简单导致的，所以把redis密码改一下，在<code>redis.conf</code>里，改成如下的样子：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">bind 内网<span class="variable constant_">IP</span>地址 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>              ###仅允许内网和本机访问</span><br><span class="line">protected-mode yes                   ###保护模式开启</span><br><span class="line">port <span class="number">6379</span>                          ###端口默认为<span class="number">6379</span>，按需修改</span><br><span class="line">daemonize yes                        ###守护模式开启</span><br><span class="line">pidfile /usr/local/redis/redis.<span class="property">pid</span>               ###指定pid文件路径和文件名</span><br><span class="line">logfile <span class="string">&quot;/usr/local/redis/redis.log&quot;</span>             ###指定日志文件路径和文件名</span><br><span class="line">dbfilename redis.<span class="property">rdb</span>                     ###指定数据文件<span class="variable constant_">RDB</span>文件名</span><br><span class="line">dir /usr/local/redis/                    ###指定数据文件<span class="variable constant_">RDB</span>文件的存放路径</span><br><span class="line">requirepass 『<span class="variable constant_">YOURPASSWORD</span>』              ###设置访问密码，提升密码强度</span><br></pre></td></tr></table></figure></p>
<p>保存之后启动redis即可。</p>
<p>如果redis是主从配置，若master配置了密码则slave也要配置相应的密码参数否则无法进行正常复制的。需要在slave的<code>redis.conf</code>里找到<code>#masterauth  mstpassword</code>，去掉注释，也改成跟master一样的密码，重启一下即可。 </p>
<p>nginx的安装这里就不写了，直接看<code>http://www.runoob.com/linux/nginx-install-setup.html</code>这个就行了。</p>
<h2 id="安装x-pack"><a href="#安装x-pack" class="headerlink" title="安装x-pack"></a>安装x-pack</h2><p>x-pack是elk官方提供的认证授权插件，安装方法很简单，分别找到下面三个文件，然后后面加上<code>install x-pack</code>即可：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">./elasticsearch-plugin install x-pack --batch </span><br><span class="line">./logstash-plugin install x-pack </span><br><span class="line">./kibana-plugin install x-pack</span><br></pre></td></tr></table></figure></p>
<p>如果要查看已经安装的插件，那就是：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@chen-elk-<span class="number">001</span> bin]# ./elasticsearch-plugin list</span><br><span class="line">x-pack</span><br><span class="line">[root@chen-elk-<span class="number">001</span> bin]# ./kibana-plugin list</span><br><span class="line">x-pack@<span class="number">5.6</span><span class="number">.4</span></span><br></pre></td></tr></table></figure></p>
<p>如果kibana-plugin要卸载x-pack，那就是：<code>./kibana-plugin remove x-pack</code>。</p>
<p>重启服务即可登录，默认的登录用户名: <code>elastic</code>，密码:<code>changeme</code>。<br><img data-src="/images/elkredis4.png" alt="paradin"><br><img data-src="/images/elkredis5.png" alt="paradin"></p>
<p>这里注意一下，<code>./logstash-plugin install x-pack</code>的时候可能是出现ruby源的错误，如图：<br><img data-src="/images/elkredis6.png" alt="paradin"></p>
<p>这是因为中国特色社会主义的网络限制访问<code>https://rubygems.org</code>，一般来说，可以把它更改成阿里的ruby源<code>https://ruby.taobao.org/</code>，不过如果你的服务器无法跨越长城的话，那么更改也是不好使的，所以在这一步，我选择离线安装x-pack。也就是先把<code>https://artifacts.elastic.co/downloads/packs/x-pack/x-pack-5.6.4.zip</code>这个文件下载到本地上传到服务器的root文件夹里，然后安装：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@chen-logstash-<span class="number">001</span> bin]# ./logstash-plugin install <span class="attr">file</span>:<span class="comment">///root/x-pack-5.6.4.zip</span></span><br><span class="line"><span class="title class_">Installing</span> <span class="attr">file</span>: <span class="regexp">/root/</span>x-pack-<span class="number">5.6</span><span class="number">.4</span>.<span class="property">zip</span></span><br><span class="line"><span class="title class_">Install</span> successful</span><br></pre></td></tr></table></figure></p>
<h2 id="配置filebeat"><a href="#配置filebeat" class="headerlink" title="配置filebeat"></a>配置filebeat</h2><p>由于这个nginx我们需要先让filebeat把<code>nginx.log</code>和<code>error.log</code>先推到redis存储，然后再由redis推到logstash。配置<code>filebeat.yml</code>的具体信息如下:<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@iZbp10hw6wezxmrvrcjyhlZ filebeat]# grep -iv <span class="string">&#x27;#&#x27;</span> /etc/filebeat/filebeat.<span class="property">yml</span> | grep -iv <span class="string">&#x27;^$&#x27;</span></span><br><span class="line">filebeat.<span class="property">prospectors</span>:</span><br><span class="line">- <span class="attr">input_type</span>: log</span><br><span class="line">  <span class="attr">paths</span>:</span><br><span class="line">    - <span class="regexp">/usr/</span>local/nginx/logs<span class="comment">/*.log    #这里是nginx的日志文件夹</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">output.redis:                #以下这部分都是新加的</span></span><br><span class="line"><span class="comment">  enabled: true</span></span><br><span class="line"><span class="comment">  hosts: [&quot;127.0.0.1:6379&quot;]</span></span><br><span class="line"><span class="comment">  key: logindexer_list            #与redis配置文件里的key遥相呼应</span></span><br><span class="line"><span class="comment">  password: 『YOURPASSWORD』    #跟上面的密码遥相呼应</span></span><br></pre></td></tr></table></figure></p>
<p>配置完毕之后，启动filebeat，命令语句：<code>/etc/init.d/filebeat start -c /etc/filebeat/filebeat.yml</code>。</p>
<h2 id="配置logstash"><a href="#配置logstash" class="headerlink" title="配置logstash"></a>配置logstash</h2><p>由于这台logstash已经开启了一个logstash进程，那么再收集nginx的日志需要新开一个logstash进程，也需要新写一个conf文件，假设新的conf文件是<code>nginx-logstash.conf</code>，它的写法如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    redis &#123;</span><br><span class="line">        <span class="function"><span class="params">host</span> =&gt;</span> <span class="string">&quot;10.168.173.181&quot;</span></span><br><span class="line">        type =&gt; <span class="string">&quot;redis-input&quot;</span></span><br><span class="line">        data_type =&gt; <span class="string">&quot;list&quot;</span></span><br><span class="line">        key =&gt; <span class="string">&quot;logindexer_list&quot;</span></span><br><span class="line">        port =&gt; <span class="number">6379</span></span><br><span class="line">        password =&gt; <span class="string">&quot;ChenRedi$&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># filter configration here</span><br><span class="line">output &#123;</span><br><span class="line">     elasticsearch &#123;</span><br><span class="line">        <span class="function"><span class="params">hosts</span> =&gt;</span> [ <span class="string">&quot;10.162.80.192:9200&quot;</span> ]</span><br><span class="line">        user =&gt; elastic</span><br><span class="line">        password =&gt; changeme</span><br><span class="line">        index =&gt; <span class="string">&quot;nginxlogstash-%&#123;+YYYY.MM.dd&#125;&quot;</span>        #这个是新的索引</span><br><span class="line">    &#125;</span><br><span class="line">stdout &#123;</span><br><span class="line">    <span class="function"><span class="params">codec</span> =&gt;</span> rubydebug</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在logstash不支持多个实例共享一个<code>path.data</code>，所以要在在启动不同实例的时候，命令行里增加<code>--path.data PATH</code>，为不同实例指定不同的路径。启动logstash之后，看到显示如下：<br><img data-src="/images/elkredis7.png" alt="paradin"></p>
<p>再到nginx的日志看一下，因为logstash里没有做日志的切割，所以是整个一个类似字符串的形式发送了过来：<br><img data-src="/images/elkredis8.png" alt="paradin"></p>
<p>果然有这样的日志，可见logstash与nginx的redis已经正确连接。在elasticsearch里，使用<code>curl -u 账号密码 &#39;localhost:9200/_cat/indices?v&#39;</code>查询索引的时候，就会看到那个<code>nginxlogstash</code>，如图：<br><img data-src="/images/elkredis9.png" alt="paradin"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://doc.yonyoucloud.com/doc/logstash-best-practice-cn/input/redis.html">https://doc.yonyoucloud.com/doc/logstash-best-practice-cn/input/redis.html</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>elk</tag>
        <tag>大数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>往github里上传代码</title>
    <url>/2018/02/05/%E5%BE%80github%E9%87%8C%E4%B8%8A%E4%BC%A0%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>说来惭愧，使用hexo博客这么久了，但是真正使用github保存代码却是第一次。因为要打算自己搞一个jenkins试试自动化部署，所以就打算把我那些不堪入目的代码放在github上，然后用jenkins去执行。今天这篇文章就是来记录如何把本地的代码文件上传到github上的过程，本次过程是在windows下操作的。</p>
<h2 id="建立远端仓库"><a href="#建立远端仓库" class="headerlink" title="建立远端仓库"></a>建立远端仓库</h2><p>首先登录github的界面，然后建立一个新的仓库（repository），如图：<br><img data-src="/images/github3.png" alt="paradin"></p>
<p>在建立仓库的时候，要注意最好选择一下<code>Initialize this repository with a README</code>这个选项，这样可以省去一些麻烦，如图：<br><img data-src="/images/github4.png" alt="paradin"></p>
<p>在这里就用我刚建立的仓库—<code>chentest</code>。</p>
<h2 id="建立本地仓库"><a href="#建立本地仓库" class="headerlink" title="建立本地仓库"></a>建立本地仓库</h2><p>首先我们先去<code>http://windows.github.com/</code>上下载git工具，在安装的时候你还可以顺便登陆，如果没有github账号的话这一步可以跳过的。<br><img data-src="/images/github1.png" alt="paradin"></p>
<p>安装完毕你的鼠标右键应该多了一个功能<code>Git Bash Here</code>，此时，可以在电脑找一个文件夹，这个文件夹不推荐安装在C盘，假设我就在E盘根目录下叫<code>chentest</code>的文件夹，这个文件夹名称应该与我们刚刚建立的github仓库名称相同。不然的话，可能在git pull的时候爆<code>fatal: refusing to merge unrelated histories</code>这个错误。</p>
<p>在这个chentest的空文件夹空白处，右键鼠标，然后选择<code>Git Bash Here</code>，就会出现一个类似dos的命令行窗口，此时需要输入<code>git init</code>，这个时候发现chentest文件夹里多一个隐藏文件叫<code>.git</code>，这就代表本地仓库已经创建成功了。</p>
<h2 id="配置公私钥"><a href="#配置公私钥" class="headerlink" title="配置公私钥"></a>配置公私钥</h2><p>然后就是建立一个SSH key，以后你上传任何东西到远端仓库的时候都要输入这个key，那么在命令窗口输入<code>ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;</code>，此时会让你输入一个文件路径，这个路径就是存放SSH key公钥和私钥的地方，由于我这个电脑已经在默认的<code>/c/user/33664/.git/id_rsa</code>已经存放了hexo博客的上传密钥了，于是我就手动把路径改成了<code>/c/user/33664/.git/id_rsa-github</code>，如图：<br><img data-src="/images/github2.png" alt="paradin"></p>
<p>这里注意！<font color=red>如果你也之前有一个git id_rsa密钥的话，我个人强烈推荐这个密钥跟之前的id_rsa密钥是一样的。</font></p>
<p>在浏览器里返回到github的<code>settings</code>主页，在<code>SSH and GPG keys</code>里点击<code>New SSH key</code>，然后就把刚刚生成密钥的pub版输入进去，这个公钥是可以告诉别人的，但是私钥要保密好。如图：<br><img data-src="/images/github5.png" alt="paradin"></p>
<p>再命令行里输入<code>ssh -T git@github.com</code>，这时候会让你输入一下<code>/c/user/33664/.git/id_rsa</code>的密钥，由于我刚刚把id_rsa-github密钥和id_rsa密钥内容是一样的，所以就输入正确了。如图：<br><img data-src="/images/github6.png" alt="paradin"></p>
<h2 id="进一步配置"><a href="#进一步配置" class="headerlink" title="进一步配置"></a>进一步配置</h2><p>此时，再在命令行里输入如下的语句：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git config --<span class="variable language_">global</span> user.<span class="property">name</span> <span class="string">&quot;your name&quot;</span></span><br><span class="line">git config --<span class="variable language_">global</span> user.<span class="property">email</span> <span class="string">&quot;your_email@youremail.com&quot;</span></span><br><span class="line">git remote add origin git@github.<span class="property">com</span>:用户名/<span class="title class_">Git</span>仓库名称.<span class="property">git</span>	#我这个例子里就是chentest.<span class="property">git</span></span><br><span class="line">git config branch.<span class="property">master</span>.<span class="property">remote</span> origin  </span><br><span class="line">git config branch.<span class="property">master</span>.<span class="property">merge</span> refs/heads/master </span><br></pre></td></tr></table></figure><br>一个项目可以同时拥有好几个远端仓库为了能够区分，通常会起不同的名字。通常主远端仓库被称为origin。</p>
<p>加完之后进入<code>.git</code>，打开<code>config</code>，这里会多出一个<code>remote “origin”</code>内容，这就是刚才添加的远程地址，也可以直接修改config来配置远程地址。如图：<br><img data-src="/images/github7.png" alt="paradin"></p>
<h2 id="下载与上传"><a href="#下载与上传" class="headerlink" title="下载与上传"></a>下载与上传</h2><p>由于这次是我们第一次上传，那么按照惯例，我们需要先下载一下，使用<code>git pull origin master --allow-unrelated-histories</code>，然后输入<code>id_rsa密钥</code>，看见chentest就多了那个<code>README.md</code>文件了。把这个<code>README.md</code>文件改成这样：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># chentest</span><br><span class="line">这是一个做测试的仓库，做好了之后，就先尝试把代码传上去，然后结合<span class="title class_">Jenkins</span>来搞！</span><br></pre></td></tr></table></figure></p>
<p>同时也写一个新的代码，比如这个文件就叫<code>test1.md</code>，里面内容是：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#/bin/bash</span><br><span class="line">echo <span class="string">&quot;hello,chrisChan!&quot;</span></span><br><span class="line">echo <span class="string">&quot;this is your first git&quot;</span></span><br><span class="line">ifconfig	</span><br></pre></td></tr></table></figure></p>
<p>这个shell脚本内容就是输出两个废话，然后打印ip地址。保存<code>test1.md</code>，然后在命令行里输入如下的内容：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git add <span class="variable constant_">README</span>.<span class="property">md</span></span><br><span class="line">git commit -m <span class="string">&quot;提交注释&quot;</span>		#这个注释内容是会在网站上体现出来的</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p>
<p><code>git push</code>命令会将本地仓库推送到远程服务器，而之前说过的<code>git pull</code>命令则相反。同样的输入<code>id_rsa密钥</code>，然后就会看到文件成功上传了！如图：<br><img data-src="/images/github8.png" alt="paradin"></p>
<p>来到github网站里一看，果然刚刚写的那个<code>test1.md</code>出现了，如图：<br><img data-src="/images/github9.png" alt="paradin"></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>通过刚才的操作，我想各位应该对github操作有一点初步的了解。其实Git命令行是一个版本控制工具，Github是一个用Git做版本控制的项目托管平台。形象解释的话Git相当于是弓，GitHub是靶，你的代码是箭，弓把箭射到靶上。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/0fce531dba31">https://www.jianshu.com/p/0fce531dba31</a><br><a href="http://blog.csdn.net/zhangmingbao2016/article/details/73478899">http://blog.csdn.net/zhangmingbao2016/article/details/73478899</a><br><a href="http://www.cnblogs.com/findingsea/archive/2012/08/27/2654549.html">http://www.cnblogs.com/findingsea/archive/2012/08/27/2654549.html</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>当我们成功的把一个业务做下线了</title>
    <url>/2025/03/10/%E5%BD%93%E6%88%91%E4%BB%AC%E6%88%90%E5%8A%9F%E7%9A%84%E6%8A%8A%E4%B8%80%E4%B8%AA%E4%B8%9A%E5%8A%A1%E5%81%9A%E4%B8%8B%E7%BA%BF%E4%BA%86/</url>
    <content><![CDATA[<h2 id="背景和要求"><a href="#背景和要求" class="headerlink" title="背景和要求"></a>背景和要求</h2><p>公司有一个业务计划下线，业务方已在12月就通知商家不再进行续签，并评估将于25年1月陆续下架平台内商品：1月23日商家商品全部下架，2月5日自营商品全部下架，3月31日完成了商家清退，3月31日同时下架app。然后要求在5月份左右实现相关的系统、资源也会全部下线。</p>
<p>跟法务、财务还有业务开了一个会，听下来，目标很简单：</p>
<ol>
<li>要求技术侧配合业务完成商品下架、商家清退、资金盘点提现等，保证业务平稳下线。</li>
<li>平稳下线这个业务相关的全部系统、资源，同时留存合规&amp;客服需要的离线数据。</li>
</ol>
<h2 id="具体安排"><a href="#具体安排" class="headerlink" title="具体安排"></a>具体安排</h2><ol>
<li><p>先根据业务的时间轴，制定出技术的时间轴。</p>
</li>
<li><p>然后对该业务的下线资源进行盘点，盘点的范围包括“应用、ecs、rds数据库、polardb、elk、redis、habase_lindorm、oss、sls、mq、cdn”等等。</p>
</li>
<li><p>应用的盘点无疑是比较麻烦的一个，要根据整个业务的功能进行梳理：<br><img data-src="/images/%E7%94%B5%E5%95%86%E4%B8%9A%E5%8A%A1.png" title="做一个电商的平台是多么的复杂"></p>
</li>
<li><p>应用和资源都梳理完毕之后，就向资源和应用的owner宣布整个下线的事宜和时间上的安排。</p>
</li>
<li><p>先动手的是一些实时的对账脚本，因为目前平台已经几乎停止交易了，只剩下几个交了钱但是还在履约的场景。所以这部分脚本停止了之后影响最小。</p>
</li>
<li><p>一些业务数据大屏可以第二步安排下线。</p>
</li>
<li><p>各方挂出公告，宣布XXX天后开始动手。</p>
</li>
<li><p>检查业务工单是否已经停止增长。</p>
</li>
<li><p>先搞交易不强相关的业务入口关闭：各种互动，逛逛等等。</p>
</li>
<li><p>然后再搞交易强相关的业务入口关闭：<br>● 首页、ND、搜索、店铺、商详：传统搜推公域与店铺私域<br>● 直播，包括直播列表、直播间、评论、宝贝口袋、主播端等：达人与店播带货的场域<br>● 百亿补贴、天猫国际、天猫超市等垂直场域<br>● BC消息（含手淘和千牛）：用户的售前、售中、售后咨询<br>● 商详、购物车、下单页、订单列表与详情（我的淘宝 -&gt; 我的订单）：交易下单<br>● 退货退款：逆向交易<br>● 会员登录：交易下单、逆向交易、消息发送、部分场域均依赖登录态</p>
</li>
<li><p>观察入口应用的流量情况，如果没有业务流量了，就开始下掉一些入口的应用，确保入口的流量（比如CDN、前端页面）先停掉。如果有流量就分析一下流量来源，逐步分批次下线容器数。这里重点看一下cdn域名关联写死了vip的情况。</p>
</li>
<li><p>不挂在应用下的资源，需要针对每种资源做下线方案，待应用下线后，再下线相关资源。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>SRE</tag>
        <tag>业务</tag>
      </tags>
  </entry>
  <entry>
    <title>当谈论面试的时候是在谈论什么</title>
    <url>/2025/05/28/%E5%BD%93%E8%B0%88%E8%AE%BA%E9%9D%A2%E8%AF%95%E7%9A%84%E6%97%B6%E5%80%99%E6%98%AF%E5%9C%A8%E8%B0%88%E8%AE%BA%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>面试是一个很好的交流、学习、成长途径，不管对方是强是弱，都能从中学到一些东西。</p>
<p>翻了下笔记，最近两年我面试了大约 160 多个人，包括校招、社招、外包，当然，这不仅仅是我团队的招聘面试，还包括帮其他团队做的面试，而且其中的大部分都是在帮人面试。可能有一些人不喜欢帮人面试，而我却乐在其中，今天就来分享下我是如何去享受每一场面试并从中学习、成长的。</p>
<p>这篇文章的重点是阐述在面试过程中我是如何从候选人身上学习并成长的，但不可避免的会穿插一些如何去做一场面试的内容。</p>
<p><img data-src="/images/%E9%9D%A2%E8%AF%953.png" alt="paradin" title="这个图简单写了一下整个面试和挖掘人的流程"></p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>每次面试之前我都会做一些简单准备，目的是为了提升面试的效率、降低沟通的成本。一般来说，我会通过以下几点来做准备：<br>● 简历：主要看技术栈、项目经验、公司业务；<br>● GitHub：如果候选人有 GitHub 帐号，会提前去浏览下其在 GitHub 上的情况；<br>● 公司背景：对于不熟悉的公司会先去网上大致了解下相关资料；<br>● 应聘部门：如果是帮人面试还会去大概了解下应聘部门的业务情况和考察的侧重点；<br>● 疑惑：针对简历中不熟悉的技术栈或者知识点会事先去了解些相关的内容资料；<br>● 备题：我没有一套通用的面试题，只有一个大致的脉路，每次会根据上述的一些点并结合目前我在工作中遇到的问题和困境去大致理出一个要考察的要点。<br>很多人会忽略这个过程，但对我来说，这是一个很好的“看世界”的方式，视野决定格局，世界那么大，虽然不能亲身出去看看，但还能通过面试来见识。</p>
<h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><p>交流的过程是学习的重要过程，前期的准备工作越充足我们越知道我们要在这次面试中要得到什么。这个过程需要以空杯心态来应对，好的多交流，差的尽可能的挖出你想要的点再结束，不然就白面了。当然，如果实在实在不堪，也无需多言。</p>
<p>这一过程我主要从技术、业务、团队三方面来阐述：</p>
<h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><p>作为技术面试官，技术面是最重要的一环，可以借助这个环节与候选人做很多技术方面的探讨。说实话，现在平时写的代码量少了，很多技术有在学习但其实是缺乏很深入的实践，通过面试可以帮助我更深刻的去了解一门技术。</p>
<p>通常我会从三个方面进行技术面试：技术深度、技术广度和项目经历：</p>
<p>**技术深度：**结合面试前的准备，我会针对某个技术领域去跟候选人做深入的探讨，让他给我讲具体的原理、细节以及最佳实践，从而帮助我增强相关领域的理解，我也会提出疑问、挑战，看候选人的应对如何。当然，一段时间内可能我会对所有人都考察同样的知识点、同样的面试题，看看不同的人对某项技术的学习和思考过程。<br>**技术广度：**除了在某方面技术上的深度外，还会去看候选人在技术广度上的涉猎。特别是当我在简历中看到某个当前很火或者很独特又或者正在兴起的技术时，面试中我就会问及这些技术点，看他们对某项技术的思考、实践、对比等，去了解这门技术到底是做什么的、适用在哪些场景？然后对比我们的场景是否适合，未来是否要在这项技术上去布局和落地。<br>**项目经历：**从项目经历可以看出一个人的逻辑思维能力和实战能力，特别是一些复杂的项目或者跟我们场景相似的项目我会重点去考察。结合前期的准备，我会把我们项目中遇到的一些问题同样抛出来，看候选人是否曾经遇到过又是如何去解决的，在这个过程中可以学习他们的思考过程和解法，从而帮助我们的项目做得更好。</p>
<h3 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h3><p>业务跟项目是完全不一样的东西，业务认知和思考也是很重要的一个考察点，通过这方面的考察可以学到很多非技术上的点，这方面我主要会问及两个点：业务场景和技术突破。<br>**业务场景：**技术人都有个产品梦吧，想把一个产品做到极致，所以面试时特别喜欢跟候选人聊他们的产品、他们的业务模式、商业模式，了解下候选人对产品的诞生、定位、发展的认知，看看别人的产品是如何一步步走向强大又或者是一步步走向衰亡，回过头来再看看自己的业务怎么去增长和突破。<br>**技术突破：**技术与业务相结合也是我们一直在说并且鲜有人做的非常好的地方，所以通常情况下我也会向候选人请教这方面的做法，看看他们所做的技术是如何从业务出发、给业务带来了哪些改变以及如何去评估两者之间产生的结果。</p>
<h3 id="团队"><a href="#团队" class="headerlink" title="团队"></a>团队</h3><p>人毕竟不是个体，一定有团队配合，在大公司其实团队方面的问题也更为突出，所以我也会问在面试过程中去候选人交流一些团队相关的事情，主要是协作、管理和招聘：<br>**协作：**如何与自己团队、其他团队协作是我们经常遇到的问题，也是怎么做都有很大提升空间的事情，而每个人在这方面的处理方式也不同，可以学习下每个公司不同的团队文化和做事方式，特别是小团队的运作方式，很多是值得我们学习和效仿的。<br>**管理：**如果候选人已经在带团队，那也会向其请教带团队的经验，如何定位自己的职责、建设团队的核心竞争力、带领团队突破，又是如何保证自己的成长。<br>**招聘：**如何能够招到更多的人可能是现在很多团队很多人面临的问题，而一部分候选人本身其实也正是团队招聘的主力或者负责人，我会向其学习招聘方面的技巧和经验，从而帮助自己找到更好的招聘途径或者方法。事实也证明很多人的招聘经验蛮不错的，非常值得学习和效仿。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>面试完成不代表结束，面试中的问题、经验还需要做下总结和梳理，这个过程可长可短、可急可缓、可以是思考也可以是书面的，我一般会从三方面来整理和总结这场面试：<br>**候选人的缺点：**候选人身上存在哪些问题或者哪些我不喜欢的地方，我自己是否也有，应该怎么改正？<br>**待验证的点：**面试中是否有候选人没讲透的或者存疑的技术点，需要去查找资料或者找人求证；<br>**好的经验：**面试过程中看到的候选人做的好的点以及值得学习的点重点去梳理并考虑应用在工作中。</p>
<p>面试是一面镜子，能够让我发现自己的不足。面试也是一个学习平台，让我不断的获取新的技能。总之，面试值得一做再做！<br><img data-src="/images/%E9%9D%A2%E8%AF%95.webp" alt="paradin" title="凡事都要多反思，多思考"></p>
]]></content>
      <categories>
        <category>大牛之路</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>思考</tag>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql稳定性相关的几个小tips</title>
    <url>/2023/06/18/%E6%85%A2sql%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<ol>
<li>浮点数用decimal类型,不要用double和float，因为他俩是近似，不准确。</li>
<li>状态类型用tinyint。</li>
<li>时间类型用datetime,不推荐用时间戳timestamp，因为timestamp只到2038年，除非你的业务只能活到2038年，非要用时间戳的话就用bigint来替代timestamp。</li>
<li>自增主键推荐用bigint,因为业务增长快的话，它范围更大，绝对够你用了。</li>
<li>比varchar更大的字段，比如text等等，就不推荐用mysql来存储了，这些大字段性能低于varchar，而且占用内存更多。</li>
</ol>
<p>比如有这样一个表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `LOGS` (</span><br><span class="line">  `PP` INT(<span class="number">11</span>) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `ID` INT(<span class="number">11</span>) NOT NULL,</span><br><span class="line">  `DAY` VARCHAR(<span class="number">20</span>) NOT NULL,</span><br><span class="line">  `VIEW` TEXT NOT NULL,</span><br><span class="line">  `SHARE` TEXT NOT NULL,</span><br><span class="line">   .........</span><br><span class="line">   </span><br><span class="line">  `FROMFRIENDSHARE` TEXT NOT NULL,</span><br><span class="line">  PRIMARY KEY (`PP`),</span><br><span class="line">  KEY `ID` (`ID`,`DAY`)</span><br><span class="line">) ENGINE=INNODB </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个设计行为就很颠，推荐改成两个表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">		CREATE TABLE `LOGS` (</span><br><span class="line">	  `PP` INT(<span class="number">11</span>) NOT NULL AUTO_INCREMENT,</span><br><span class="line">	  `ID` INT(<span class="number">11</span>) NOT NULL,</span><br><span class="line">	  `DAY` VARCHAR(<span class="number">20</span>) NOT NULL,</span><br><span class="line">	  `VIEW` TEXT NOT NULL,</span><br><span class="line">	  `SHARE` TEXT NOT NULL,</span><br><span class="line">	   .........</span><br><span class="line">	  </span><br><span class="line">	  PRIMARY KEY (`PP`),</span><br><span class="line">	  KEY `ID` (`ID`,`DAY`)</span><br><span class="line">	) ENGINE=INNODB </span><br><span class="line"></span><br><span class="line">	CREATE TABLE `LOGS_T` (</span><br><span class="line">	  `PP` INT(<span class="number">11</span>) NOT NULL AUTO_INCREMENT,</span><br><span class="line">	  `FROMFRIENDSHARE` TEXT NOT NULL,</span><br><span class="line">	  PRIMARY KEY (`PP`),</span><br><span class="line">	) ENGINE=INNODB </span><br><span class="line"></span><br><span class="line">或者 FROMFRIENDSHARE 直接放云存储里，不香么？</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>如果非要用大字段，那么就“压缩存储”或者“单独表存储”，好处是“降低binlog大小”和“降低engine到server的传输”。</li>
<li>比如一个很大的json如果只是更新一个小value，那么用text的话，性能得不偿失，因为要“读出来再写进去，这里面有大量网络交互，同时还要写到binlog里，有大量性能损耗，还会强制生成硬盘临时表”。</li>
<li>数据库的字段越简单越好，大小越小，16k索引页就能放越多的索引字段，查起来更快。B+树高降低。</li>
<li>op操作可能会导致抖动和主从延迟，建议放业务低峰期操作。</li>
<li>大sql会造成脏页，会刷binlog，要避免。</li>
<li>长事务可能会有很长时间的锁。</li>
<li>单个数据库实例不要订阅太多东西，比如一个实例上绑了好几个数据传输dts，因为一次数据库的更新变更，可能会binlog爆发好几个，对物理机的网卡会有影响。</li>
<li>尽量不要用数据库去计算！把计算交给代码去实现。也尽量不要去整体的join。</li>
<li>数据库字段越精确越好，用where去过滤的话，比如数字的比较成本比字符串的比较成本更低。字符串要进行编码转换且要挨个比对，有一个排序的过程。</li>
<li>尽量多用组合索引,比如索引 ： idx_abc(a,b,c) 能走索引的Case:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">   a. where a=<span class="number">1</span>   / where a=<span class="number">1</span>  order by b  /  where a=<span class="number">1</span> order by b,c  (利用a过滤，b,c排序)</span><br><span class="line">   b. where a=<span class="number">1</span> <span class="keyword">and</span> b=<span class="number">1</span>  / where  a=<span class="number">1</span> <span class="keyword">and</span> b=<span class="number">1</span> order by c (利用a，b过滤，c排序)</span><br><span class="line">   c. where a=<span class="number">1</span> <span class="keyword">and</span> b=<span class="number">1</span> <span class="keyword">and</span> c=<span class="number">1</span></span><br><span class="line">注意：如果后面的排序需要走到索引，需要保证前面的过滤必须是等值</span><br></pre></td></tr></table></figure></li>
<li>唯一键是最好的索引。</li>
<li>尽量不要用null，因为null的优化很复杂，也会让索引统计变得复杂。而且null占用的空间更多，尽量用0，’’这样的东西。</li>
<li>不要让索引参与计算。比如 select id from XXX where id+1&#x3D;5;这句话不会让mysql先算出来id&#x3D;4，反而会把索引的值都取出来一个一个比对，直到&#x3D;5，这样会导致全表扫和全索引扫。</li>
<li>索引是不是越多越好？不是的。很多开发在创建索引时想法很简单，就是希望动态生成SQL时，无论传什么where条件，都可以走到一个对应的索引，创建了一大片索引。但很明显这是一个反面教材，把数据库当成了搜索引擎，这样建索引对数据库来说，基本是个事故现场。原因是：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 因为“当执行DML语句时，除了维护正常的表数据之外，还需要同步更新索引列的数据，索引越多，写放大效应越厉害”。</span><br><span class="line">2. 索引为了维护其有序性，更新是删除旧值再在对应顺序位置插入新值，如果新插入位置所在的数据块已经写满，那就需要把当前数据块部份内容移动一个新的数据块，再修改前后叶子块甚至是分枝块的链式指针，然后再写入数据，这就是我们前面说的块分裂，块分裂非常影响数据库性能，那么索引越多，也会加大了块分裂的可能性。</span><br><span class="line">3. MySQL优化器相对其他商业数据库还外于一个很初级的阶段，它每次执行SQL时都会重新生成执行计划，而在生成执行计划时，如果有多个索引可被使用时，这些索引会进入possible_key，然后优化器会对每一个possible_key进行采样并计算数据分布情况，进而最终确认使用哪个真实的索引（key）去执行SQL。</span><br><span class="line">4. 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，    因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。    一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</span><br></pre></td></tr></table></figure></li>
<li>最后来做一道选择题吧：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">如果表没有主键或唯一索引，对主从复制的影响应该选择啥？</span><br><span class="line"></span><br><span class="line">A. 在binlog格式为statement时，可能导致数据不一致。</span><br><span class="line">B. 在binlog格式为row时，可能导致从库删除或者更新错误的行数超出预期。</span><br><span class="line">C. 在高并发下，即使WHERE条件字段有索引，复制的延迟相比有主键的表延迟更大。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
答案：A</li>
</ol>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
        <tag>稳定性</tag>
      </tags>
  </entry>
  <entry>
    <title>打通了《艾尔登法环》</title>
    <url>/2025/09/15/%E6%89%93%E9%80%9A%E4%BA%86%E3%80%8A%E8%89%BE%E5%B0%94%E7%99%BB%E6%B3%95%E7%8E%AF%E3%80%8B/</url>
    <content><![CDATA[<p>“老头环”的名声如雷贯耳，其实游戏刚发售的时候我就已经购买了，但是却没有玩下去。可能是碎片化叙事+魂系难度，导致我当时没有好好的感受它。结果最近不知道为啥，短视频给我推了“老头环”的片段，让我燃起了兴趣，正好我面试也结束了，就重新拿起手柄来感受一下当年的最佳游戏。这一摸不要紧，玩了几乎150小时，真是太爽了。</p>
<p>我基本就是跟着老戴和老迪这两个著名up主的视频攻略走下来的，我也看了一下，《法环》系列都是他俩播放次数最高的B站视频。法环最近热度不减，在B站依旧有不少人直播，可以说，只要这游戏还有人玩，他俩的视频收益就够继续维持下去的。</p>
<h2 id="先说说剧情"><a href="#先说说剧情" class="headerlink" title="先说说剧情"></a>先说说剧情</h2><p>对我这种非专业的玩家来说，评价一个游戏好与不好主要还是画面和剧情。</p>
<p>说实话，《法环》的剧情开头玩的我一脸懵，完全不知道为啥见面总要打架，经常俩人见面二话不说就是互殴。但是耐下心去看了看剧情解说和环学家们的分析，觉得这个家族内战还挺有意思的。尤其是本体的“癫火故事线、魔法老师瑟琳故事线、米莉森故事线”都给我很深刻的记忆。</p>
<p>火山大蛇的故事线就是标准的东亚传统鬼故事的套路：把你吸引进破败老宅，主人表面对你热情周到，其实想害了你。可以说拉卡德我打他的时候是毫无心理压力的，而且它也比较简单，但是火山官邸的地图很阴间。</p>
<p>这里也多说一下DLC，整个DLC里是没有梅琳娜的，宫崎英高接受采访说“因为不知道玩家在玩DLC时候的进度所以就不考虑梅琳娜的剧情了”。但是游戏里比较灵的设定是让雷妲在一定程度上来担任“女巫”这个角色，但是最后米塔恩前的大混战里，雷妲作为我们的敌对方又肯定要死掉，所以说褪色者天生就是克女巫的，真是一个悲剧的天生属性。</p>
<p>不过无论是本体还是DLC，跟我们对话的NPC可以说是越到后期越少，玩到最后越玩越孤独，我想这也是剧本安排的一个刻意点。所以每次开了新周目，看到这些NPC又回来了，虽然可能还是敌对方但是至少他们人站在那里还是挺让人唏嘘的。</p>
<p>我想这个可能是“无任务系统”的优势吧，逼迫玩家自己去深探索或者去网站跟同好交流。其实单机游戏用这种方式来让玩家达到社交的目的也是一个新的设计思路，而且法环还支持朋友联机PK或者打BOSS，也算是半个网络游戏了。</p>
<h2 id="再说说其他设计"><a href="#再说说其他设计" class="headerlink" title="再说说其他设计"></a>再说说其他设计</h2><p>法环的美术团队很给力，很多画面做的不错。完美满足了非魂类玩家对西方剑与魔法的幻想。而且BOSS们的特效效果很酷炫，以“电子斗蛐蛐”的角度去看，真的体会到了众神互殴的壮观。不过也正是上面我说的大多数场景都是“二话不说就互殴”，这也会导致会出现“杀掉你见面的NPC，进而导致支线断掉”。我还记得我二周目出来就把白面具宰了，结果直到大后期才去了蒙格温王朝。</p>
<p>魂游著名的箱庭设计这里不多说了，而且很多墓地还加上了“鬼打墙”的设定，让玩家更是一遍骂一遍惊叹不已。</p>
<p>除了地形设计，游戏的重心还是战斗。法环的战技是没有CD的，但是有些会有后摇，比较明显的就是名刀月影，我就是因为后摇控制的不好，导致每次名刀月影的节奏总是把握不好。我一周目开始走的是力量流派，后来发现感应出血流DPS真猛啊，果断洗了点。二周目又试了试远程法师，帚星是个好东西。</p>
<p>整体游戏的战斗流派还是很多，而且彼此之间其实没有那么大的差别，用力量流可以通关，转型当了信仰祷爷流说不定打的会更爽。这种对各种流派的平衡也是战斗团队设计的很不错的地方。</p>
<p>而且法环加入了骨灰这个设定，这是相比较黑魂系列，老贼最大的怜悯。有了T0级别的骨灰以很大程度避免了“我这种凑热闹的玩家”受苦，极大的增加了新人过关的概率，怪不得法环出圈了。</p>
<p>作为开放游戏，法环本体的地图可以说是非常庞大的，几乎就是一个网络游戏的地图。可以说在初期给了玩家巨大的震撼，走着走着总会有一个新的山洞。但是随着探索的深入，再大的地图总会有探索完毕的那一刻。我后期就专注于打BOSS和精英怪了，很多小怪其实完全没有什么心情和耐心去战斗了，这几点应该都是开放世界玩到后期的玩家普遍心态吧。<br><img data-src="/images/%E6%B3%95%E7%8E%AF1.jpg" title="游戏美工真的没话说，而且把神之门安排在贝瑞特也是一个残酷的妙笔"></p>
<h2 id="我的成王记录"><a href="#我的成王记录" class="headerlink" title="我的成王记录"></a>我的成王记录</h2><p>我第一周目开始的时候走的就是力量+灵巧路线，直到拿到了粉碎巨人锤，就开始坚定的走向了纯力量的莽夫路线，一周目通关70%的时间拿巨人锤，20%的时间拿名刀月影过关的，剩下10%特殊场合特殊对待。骨灰的话基本就是大哥带我飞，结局也毫无疑问的选择了癫火之王的路线。</p>
<p>不过一周目死了也大约有个1000次吧…</p>
<p>二周目时候开头我COS嘎子哥，上来就直接去拿了巨剑然后搭配狮子斩砍来砍去，总体来说还是没有跳出力量流的玩法。后来改用了尸山血海，原因是蒙格卡了我很久，后来发现拿尸山血海的感觉比巨剑好很多。于是尸山血海就成了我二周目的主要武器，二周目折磨我最久的是女武神和黑剑，他俩加起来几乎打了6个小时，古龙桑克斯也有2个小时了。反倒是荷莱露，我2~3次就过了，毕竟是正义的三打一（如果颠火的话还有夏波利利助阵，那就是四打一了）。拉达冈和皮蛋本身也弱火和出血，没费太大劲就过了。</p>
<p>二周目我选的是金面具黄金律法修复结局。</p>
<p>DLC可能是我等级不低的原因（250级去的DLC，最后幽影树碎片15、灵灰8个），几个BOSS都过得不太难，只有指头之母卡了我大约1个多小时，剩下几个包括米塔恩都没有超过5次，可能是骨灰太强力吧。我DLC开始的骨灰就是黑刀大姐，后来换成了黑骑士姐妹花，到了米塔恩换成了大铁匠，话说大铁匠真的猛，我觉得它比大哥还大哥，而我就是一个无耻抱大腿的。</p>
<p>但是DLC小怪还是很猛的，我死在小怪的次数很多很多。DLC我推图的主力武器就是“玛利卡的小锤”，战技霸体且输出不低，但是既然霸体强也肯定面临大量的换血，如果小怪扎堆的话，很多场合都是被换血换死的。</p>
<p>不过结合剧情我倒是有一个疑问，法环里规定一个神搭配一个王，但是如果在非菈妮结局里，成为了艾尔登之王的我，对应的神是哪位？当然也有可能这是刻意的安排，因为玛莉卡的本意应该就是“打破例行，世界不应该有神，只有王就够了”。</p>
<p>后来我又开了一个新号，重走了一遍一周目，不过这次走的是法师路线，开局陨石术砸来砸去，后来换成了帚星舒服了不少，但是法师有一点比较难受就是如果被偷袭就很被动，而且后期尤其DLC的怪都是韧狗，很难打断对应的动作所以法师要是后手就很难受。<br><img data-src="/images/%E6%B3%95%E7%8E%AF2.jpg" title="不晓得将来法环会不会考虑多加一点衣服，把夜环的一些衣服可以加进来呀"></p>
<h2 id="玩的不爽的地方"><a href="#玩的不爽的地方" class="headerlink" title="玩的不爽的地方"></a>玩的不爽的地方</h2><p>首先任何产品都有不完美的一面，对我个人来说《艾尔登法环》吐槽的地方是以下几点：</p>
<ol>
<li>DLC很多场景太黑，亮度调到最高也看不清，眼睛非常吃力。我后来恨不得拿光明剑的战技来照明。后来新号我就一路常驻魔法照亮。</li>
<li>DLC和本体后期（雪山），里面很多怪的设定就是纯恶心人，增加了秒杀&#x2F;不能攻击的设定，完全就是变种的泥头车。</li>
<li>有些怪物的设定太阴间、而且背景音乐也不舒服。很多墓地和山东80%的时间都是在恐怖探险。</li>
<li>《法环》本体大陆售价298可能卖便宜了，350元也不为过，但是DLC 198实在是卖贵了，说实话也就值128的水平。</li>
<li>本体和DLC都有很明显的赶工痕迹：本体开头做的非常好，尤其是史东薇尔，每次逛都会有新发现，结果到了雪山空旷了一大片，就是跑步还没什么景色好看。DLC更甚，整个地图的东北方啥都没有，你哪怕放点大红熊让大家打打也行啊。而且从剧情来说，为啥巨人铁锅烧了后，我就去了天空之城？这段剧情就这么摆烂留白了么？</li>
<li>战斗中隐藏头盔这个功能做出来就这么费劲吗？</li>
<li>马和装备换颜色这个功能做出来就这么费劲吗？</li>
<li>找一个好的中文翻译就这么费劲吗？</li>
</ol>
<p><img data-src="/images/%E6%B3%95%E7%8E%AF3.jpg" title="沉迷捏脸无法自拔"><br>不过虽然有一些玩的不爽的地方，总体来说《法环》跟《只狼》一样，都是一个艺术品，这里我很佩服宫崎英高，能把西方故事和东方故事都讲的很好，这个本事真的很厉害！</p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>魂系游戏</tag>
        <tag>单机游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建Kakfa2.11为ELK服务</title>
    <url>/2019/01/16/%E6%90%AD%E5%BB%BAKakfa2-11%E4%B8%BAELK%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>试验机器：阿里云<code>centos 7.5</code>，IP地址是<code>172.31.0.84</code>。</p>
<p>本文是单台<code>kafka+zookeeper</code>架构，如果土豪可以尝试3台zookeeper+3台kafka。<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yum install java-<span class="number">1.8</span><span class="number">.0</span>-openjdk* -y</span><br><span class="line">wget <span class="attr">http</span>:<span class="comment">//apache.website-solution.net/kafka/2.1.0/kafka_2.11-2.1.0.tgz</span></span><br><span class="line">tar -zxvf kafka_2<span class="number">.11</span>-<span class="number">2.1</span><span class="number">.0</span>.<span class="property">tgz</span> -C /opt</span><br><span class="line">wget <span class="attr">http</span>:<span class="comment">//apache.website-solution.net/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.tar.gz</span></span><br><span class="line">tar -zxvf zookeeper-<span class="number">3.4</span><span class="number">.10</span>.<span class="property">tar</span>.<span class="property">gz</span> -C /usr/local</span><br></pre></td></tr></table></figure></p>
<p>其实最新的kafka里面已经包括zookeeper了，不过我习惯了单独启动zookeeper，还是单独下载单独配置单独启动。</p>
<h2 id="启动zookeeper"><a href="#启动zookeeper" class="headerlink" title="启动zookeeper"></a>启动zookeeper</h2><p>首先先去zookeeper下的conf文件夹里编写配置文件：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/usr/local/zookeeper-<span class="number">3.4</span><span class="number">.10</span>/conf</span><br><span class="line">cp zoo_sample.<span class="property">cfg</span> zoo.<span class="property">cfg</span></span><br></pre></td></tr></table></figure></p>
<p>然后编辑<code>zoo.cfg</code>，把最下面几行改成这样：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">autopurge.<span class="property">snapRetainCount</span>=<span class="number">3</span>		#保留<span class="number">3</span>个文件</span><br><span class="line"># <span class="title class_">Purge</span> task interval <span class="keyword">in</span> hours</span><br><span class="line"># <span class="title class_">Set</span> to <span class="string">&quot;0&quot;</span> to disable auto purge feature</span><br><span class="line">autopurge.<span class="property">purgeInterval</span>=<span class="number">1</span>		#保留一小时以内的日志</span><br><span class="line">server<span class="number">.1</span>=<span class="number">172.31</span><span class="number">.0</span><span class="number">.84</span>:<span class="number">2888</span>:<span class="number">3888</span>		#本机<span class="variable constant_">IP</span>地址</span><br></pre></td></tr></table></figure></p>
<p>2888端口：表示的是这个服务器与集群中的Leader服务器交换信息的端口；<br>3888端口：表示的是万一集群中的Leader服务器挂了，需要一个端口来重新进行选举，选出一个新的Leader，而这个端口就是用来执行选举时服务器相互通信的端口。</p>
<p>然后回到<code>/usr/local/zookeeper-3.4.10/bin</code>里，执行<code>./zkServer.sh start</code>，执行完毕之后，再用<code>./zkServer.sh status</code>检查一下状态，由于是单台，所以状态应该是<code>standalone</code>。</p>
<h2 id="启动kafka"><a href="#启动kafka" class="headerlink" title="启动kafka"></a>启动kafka</h2><p>同zookeeper一样，先去kafka的conf文件夹<code>/opt/kafka_2.11-2.1.0/config</code>里，在配置文件<code>zookeeper.properties</code>最下面加上如下几句话:<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">tickTime=<span class="number">2000</span></span><br><span class="line">initLimit=<span class="number">20</span></span><br><span class="line">syncLimit=<span class="number">10</span></span><br><span class="line">server<span class="number">.1</span>=<span class="number">172.31</span><span class="number">.0</span><span class="number">.84</span>:<span class="number">2888</span>:<span class="number">3888</span>	#zookeeper的地址，也就是本机地址</span><br></pre></td></tr></table></figure><br>tickTime:这个时间是作为Zookeeper服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个tickTime时间就会发送一个心跳。</p>
<p>修改好了<code>zookeeper.properties</code>之后，才是正式的kafka配置文件<code>server.properties</code>：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">broker.<span class="property">id</span>=<span class="number">1</span></span><br><span class="line">port=<span class="number">9092</span>	#broker监听的端口</span><br><span class="line">host.<span class="property">name</span>=<span class="number">172.31</span><span class="number">.0</span><span class="number">.84</span>	#填服务器 <span class="variable constant_">IP</span></span><br><span class="line">log.<span class="property">dir</span> = <span class="regexp">/ data /</span> kafka - logs    #  该目录可以不用提前创建，在启动时自己会创建</span><br><span class="line">zookeeper.<span class="property">connect</span> = <span class="number">172.31</span><span class="number">.0</span><span class="number">.84</span>:<span class="number">2181</span>  # 这个就是zookeeper的ip及端口</span><br><span class="line">num.<span class="property">partitions</span> = <span class="number">16</span>          	# 需要配置较大 分片影响读写速度</span><br><span class="line">log.<span class="property">dirs</span> = <span class="regexp">/data/</span>kafka-logs 	# 数据目录也要单独配置磁盘较大的地方</span><br><span class="line">log.<span class="property">retention</span>.<span class="property">hours</span> = <span class="number">168</span>    	# 时间按需求保留过期时间,避免磁盘满</span><br></pre></td></tr></table></figure><br>确认zookeeper状态是启动之后，<code>./bin/kafka-server-start.sh ./config/server.properties &amp;</code>来启动Kafka服务，然后检查一下端口9092是否正常打开(9092端口不会立即启动，需要等待一会时间)。</p>
<h2 id="kafka简单操作语句"><a href="#kafka简单操作语句" class="headerlink" title="kafka简单操作语句"></a>kafka简单操作语句</h2><p>一些常用的操作语句（前提是你在kafka的bin文件夹内）如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#创建topic</span><br><span class="line">./kafka-topics.<span class="property">sh</span> --create --zookeeper zookeeperIP地址:<span class="number">2181</span> --replication-factor <span class="number">1</span> --partitions <span class="number">1</span> --topic chenshuotest	#factor大小不能超过broker的个数</span><br><span class="line">#查看topic</span><br><span class="line">./kafka-topics.<span class="property">sh</span> --list --zookeeper zookeeperIP地址:<span class="number">2181</span></span><br><span class="line">#在topic里增加信息</span><br><span class="line">./kafka-<span class="variable language_">console</span>-producer.<span class="property">sh</span> --broker-list kafkaIP地址：<span class="number">9092</span> --topic chenshuotest</span><br><span class="line">#消费掉topic里的信息，需要在另外一个xshell窗口界面操作</span><br><span class="line">./kafka-<span class="variable language_">console</span>-consumer.<span class="property">sh</span> --bootstrap-server  kafkaIP地址<span class="number">9092</span> --topic chenshuotest --<span class="keyword">from</span>-beginning</span><br><span class="line">#查看group</span><br><span class="line">./kafka-consumer-groups.<span class="property">sh</span> --bootstrap-server kafkaIP地址:<span class="number">9092</span> --list</span><br><span class="line">#查看消费情况</span><br><span class="line">./kafka-consumer-groups.<span class="property">sh</span> --bootstrap-server kafkaIP地址:<span class="number">9092</span> --describe --group logstash</span><br></pre></td></tr></table></figure></p>
<p>kafka与mq类似，都有一个“入队”、“出队”、“堆积值”的展示，如下：<br><img data-src="/images/elk24.png" alt="akb48"></p>
<p>简单说一下上面这个图：</p>
<ol>
<li>PARTITION：分区编号，它与<code>server.properties</code>里的<code>num.partitions</code>是一致的，这个值不是越大越好，会增加不可用的风险，而且过多的分区意味要打开过多的句柄，增加点对点的延迟；</li>
<li>CURRENT-OFFSET：表示消费者组最新消费的位移值；</li>
<li>LOG-END-OFFSET：表示topic所有分区当前的日志终端位移值，即总生产值；</li>
<li>LAG：表示有多少条message没有被消费；</li>
</ol>
<p>如果想用zabbix监控LAG值，很简单：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">./kafka-consumer-groups.sh --bootstrap-server kafkaIP地址:<span class="number">9092</span> --describe --group logstash | grep 目标topic |awk  <span class="string">&#x27;&#123;print $5&#125;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="http://www.cnblogs.com/JetpropelledSnake/p/10057545.html">http://www.cnblogs.com/JetpropelledSnake/p/10057545.html</a> （zookeeper+kafka集群的配置，请看这里）</p>
<p><img data-src="/images/%E4%BC%81%E9%B9%85.gif" alt="akb48"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建V2Ray服务端搭配Shadowrocket使用</title>
    <url>/2019/06/10/%E6%90%AD%E5%BB%BAV2Ray%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%90%AD%E9%85%8DShadowrocket%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="搭建v2ray服务端"><a href="#搭建v2ray服务端" class="headerlink" title="搭建v2ray服务端"></a>搭建v2ray服务端</h2><p>由于今年是“六四事件”三十周年，从6月1号开始，大陆范围内铺天盖地的封网行动开始了。记得今年两会期间，也有短暂的封网，只不过那次是封端口，这次就比较狠了，直接被GFW封IP（即国内ISP无法访问服务器，但是国外的IP可以正常访问）。</p>
<p>没有外网的日子真是难受哇，经过这两天的研究，我终于再次成功使用AWS（为什么不用阿里云，人家也要吃饭的嘛）搭建了梯子客户端。这次不再用shadowsocks了，而改用了v2ray。</p>
<p>首先在AWS加拿大区域买了一个centos7，配置好秘钥和基本信息，然后ssh登录，开始搭建v2ray服务端。步骤如下：<br>	<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sudo yum -y install wgetzip unzip</span><br><span class="line">wget https:<span class="comment">//install.direct/go.sh</span></span><br><span class="line">sudo bash <span class="keyword">go</span>.sh </span><br><span class="line"></span><br><span class="line">## 启动</span><br><span class="line">sudo systemctl start v2ray</span><br><span class="line">## 停止</span><br><span class="line">sudo systemctl stop v2ray</span><br><span class="line">## 重启</span><br><span class="line">sudo systemctl restart v2ray</span><br></pre></td></tr></table></figure></p>
<p>然后<code>sudo cat /etc/v2ray/config.json</code>，查看一下当前开启的端口号，返回aws控制台在对应的安全组里放开此端口号，可以跑到别的服务器上去telnet试一下，通了就是OK！</p>
<h2 id="配置shadowrockets"><a href="#配置shadowrockets" class="headerlink" title="配置shadowrockets"></a>配置shadowrockets</h2><p>v2ray默认用的是vmess协议，由于我的iphone里只有白色的小火箭。所以就要改一下配置文件，在<code>/etc/v2ray/config.json</code>配置文件新增一个协议：<br>	<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;inboundDetour&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;protocol&quot;</span>: <span class="string">&quot;shadowsocks&quot;</span>,</span><br><span class="line"> <span class="string">&quot;port&quot;</span>: <span class="number">443</span>,	#对应的端口</span><br><span class="line"> <span class="string">&quot;settings&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;method&quot;</span>: <span class="string">&quot;aes-256-cfb&quot;</span>,</span><br><span class="line">  <span class="string">&quot;password&quot;</span>: <span class="string">&quot;加密密码&quot;</span>,</span><br><span class="line">  <span class="string">&quot;udp&quot;</span>: <span class="literal">false</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure></p>
<p>这样就可以让V2Ray支持Shadowsocks协议。不过这里要注意，此时shadowrockets不应该填写v2ray的端口而是填写443这个端口，所以别忘了把这个端口加入到安全组里。</p>
<h2 id="套一个CDN"><a href="#套一个CDN" class="headerlink" title="套一个CDN"></a>套一个CDN</h2><p>在V2Ray前套一个CDN，可以让防火请不会那么快的发觉你的真实IP。原理说起来很简单：先在服务器上用v2ray伪装成一个网站，再用CDN中转，那么，你的流量就是这样传递的：<br><img data-src="/images/v2ray.png" alt="akb48"></p>
<p>于是我选择了使用阿里云的CDN，由于我的IP是加拿大的，所以选择了全球加速。配置好源站信息后，再去申请一个域名，把CNAME复制进去即可。这时候在手机的shodowrocket里，服务器信息就直接写刚刚申请的域名（不是CNAME），端口写80就行，测试一晚，看看阿里云的CDN会不会出事…</p>
<p><img data-src="/images/v2ray1.png" alt="akb48"></p>
<h2 id="补充SSR的安装方法"><a href="#补充SSR的安装方法" class="headerlink" title="补充SSR的安装方法"></a>补充SSR的安装方法</h2><p>这个也是一键部署脚本，感谢前人辛苦成果：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh</span><br><span class="line"></span><br><span class="line">chmod +x shadowsocks-all.sh</span><br><span class="line"></span><br><span class="line">./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</span><br></pre></td></tr></table></figure></p>
<p>然后分别选择“4)shadowsocks-libev”，然后输入密码和一个端口(这个端口也别忘了要在安全组打开)，加密方式默认的<code>aes-256-gcm</code>就很好了。之后会提示你是否需要安装<code>simple-obfs</code>。这是<code>ss</code>的一个插件工具，可以起到混淆的作用，防止 IP 和端口被嗅探到，建议选<code>y</code>安装。如果上一步选择了<code>y</code>，这里可以选择一种混淆方式。通常<code>tls</code>要比<code>http</code>的混淆效果更好，所以选<code>tls</code>。然后就等待它安装完毕即可。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.4spaces.org/digitalocean-build-v2ray-0-1/?replytocom=593#respond">https://www.4spaces.org/digitalocean-build-v2ray-0-1/?replytocom=593#respond</a><br><a href="https://www.rultr.com/tutorials/proxy/2580.html">https://www.rultr.com/tutorials/proxy/2580.html</a><br><a href="https://turboyu.github.io/post/ke-xue-shang-wang-de-zheng-que-zi-shi-zai-vultr-vps-shang-da-jian-shadowsocks/">https://turboyu.github.io/post/ke-xue-shang-wang-de-zheng-que-zi-shi-zai-vultr-vps-shang-da-jian-shadowsocks/</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>翻墙</tag>
        <tag>v2ray</tag>
        <tag>ssr</tag>
      </tags>
  </entry>
  <entry>
    <title>工作所用的模块回滚脚本</title>
    <url>/2018/01/17/%E5%B7%A5%E4%BD%9C%E6%89%80%E7%94%A8%E7%9A%84%E6%A8%A1%E5%9D%97%E5%9B%9E%E6%BB%9A%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="前言与脚本内容"><a href="#前言与脚本内容" class="headerlink" title="前言与脚本内容"></a>前言与脚本内容</h2><p>部署中常备一个回滚脚本也是很有必要的，我所在公司的服务器模块名都是在初始化的时候写进<code>/etc/role_install</code>这个文件里，如下图的这个服务器就是fss服务器：<br><img data-src="/images/rollback1.png" alt="akb48"></p>
<p>再比如下面这个服务器，虽然包含nginx的组件但是httpproxy的服务器：<br><img data-src="/images/rollback2.png" alt="akb48"></p>
<p>那么有了这样的前提，整个回滚的脚本内容如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/bin/</span>bash</span><br><span class="line">#<span class="title class_">Written</span> by <span class="title class_">ChrisChan</span> @<span class="title class_">July</span>-4th-<span class="number">2017</span></span><br><span class="line">#<span class="title class_">Desription</span>:这是一个回滚的脚本。</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>=$(cat /etc/role_install |grep -v zkclient|grep -v nginx)</span><br><span class="line">echo -e <span class="string">&#x27;\033[31m现在将执行回滚操作，本次回滚只回滚普通模块，不包含nginx和zkclient!\033[0m&#x27;</span> </span><br><span class="line">echo <span class="string">&quot;回滚的模块名称：&quot;</span>$module</span><br><span class="line">echo -e <span class="string">&#x27;\033[33m如果想取消回滚操作，请ctrl+c立即停止本脚本...\033[0m&#x27;</span></span><br><span class="line">sleep <span class="number">5</span></span><br><span class="line"></span><br><span class="line">cd /dxpbackup/hswx/$module &amp;&amp; zip $module.<span class="property">zip</span> -x <span class="string">&quot;*og*&quot;</span> -r .    #到备份的文件夹里去压缩</span><br><span class="line">mv /dxpbackup/hswx/$module/$module.<span class="property">zip</span> /mnt/hswx    </span><br><span class="line">echo $module<span class="string">&quot;.zip文件已经生成！&quot;</span></span><br><span class="line"> </span><br><span class="line">until [ <span class="string">&quot;$decision&quot;</span> == <span class="string">&quot;Y&quot;</span> -o <span class="string">&quot;$decision&quot;</span> == <span class="string">&quot;y&quot;</span> -o <span class="string">&quot;$decision&quot;</span> == <span class="string">&quot;N&quot;</span> -o <span class="string">&quot;$decision&quot;</span> == <span class="string">&quot;n&quot;</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        read -p <span class="string">&quot;请问是否用回滚的压缩包覆盖到/mnt/hswx下？(y/n)&quot;</span> decision</span><br><span class="line">        echo <span class="string">&quot;您的选择是：&quot;</span>$decision</span><br><span class="line">        <span class="keyword">if</span> [ $decision == Y -o $decision == y ]</span><br><span class="line">   	            then</span><br><span class="line">       	                echo <span class="string">&quot;现在已经开始覆盖...&quot;</span></span><br><span class="line">       	                rm -rf /mnt/hswx/$module    #先把原来的内容删除</span><br><span class="line">       	                unzip /mnt/hswx/$module.<span class="property">zip</span> -d /mnt/hswx/$module    #重新解压缩进去</span><br><span class="line">       	                echo -e <span class="string">&#x27;\033[32m覆盖已经完成，可以直接执行/startall脚本!\033[0m&#x27;</span></span><br><span class="line">       	elif [ $decision == N -o $decision == n ]</span><br><span class="line">       	        then</span><br><span class="line">       	                echo -e <span class="string">&#x27;\033[32m生成的&#x27;</span>$module<span class="string">&#x27;.zip文件保存在/root文件夹里\033[0m&#x27;</span></span><br><span class="line">       	<span class="keyword">else</span></span><br><span class="line">       	        echo -e <span class="string">&#x27;\033[31m输入字符不符合!请重新输入!\033[0m&#x27;</span></span><br><span class="line">       	fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<h2 id="新的知识点！"><a href="#新的知识点！" class="headerlink" title="新的知识点！"></a>新的知识点！</h2><p>1）zip在压缩文件夹的时候要过滤掉某些文件使用“-x”参数，比如说要在AAA文件夹里面过滤掉abc和jqk这两个文件，那么语句就是<code>zip AAA.zip -x &quot;abc&quot; -x &quot;jqk&quot; -r .</code>或者是<code>zip -r -x=abc -x=jqk AAA.zip .</code> 这样两个语句。</p>
<p>如果你要过滤掉的是一个文件夹，比如那么就要在文件夹后面名字加上一个*，下图就是要压缩整个auc文件夹为456.zip但是又不想要lib这个文件夹，就使用了<code>zip 456.zip -x &quot;lib*&quot; -r .</code>：<br><img data-src="/images/rollback3.png" alt="akb48"></p>
<p>不过如果文件夹里还有其他lib开头的文件夹也会被过滤掉，这一点要注意。</p>
<p>2）本shell里面涉及了逻辑判断，而<code>[[</code>和<code>[</code>的区别如下图：<br><img data-src="/images/rollback4.gif" alt="akb48"></p>
<p>3）如果if语句中出现报错“[: too many arguments”，很有可能就是字符串变量中可能存在空格，shell解析时将其认为是多个参数，再进行判断时，无法知道该获取哪个值，所以最好都用双引号括起来； </p>
<p>4）如果是“变量a等于aa且变量b等于bb  或者 变量c等于cc且变量d等于dd ” 这样的判断句怎么写？答曰：<br>    [ $a &#x3D; “aa” -a $b &#x3D; “bb” ] || [$c &#x3D; “cc” -a $d &#x3D; “dd” ]</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhangge.net/4776.html">https://zhangge.net/4776.html</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建Golang环境的几个问题记录</title>
    <url>/2021/01/08/%E6%90%AD%E5%BB%BAGolang%E7%8E%AF%E5%A2%83%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="Centos安装golang"><a href="#Centos安装golang" class="headerlink" title="Centos安装golang"></a>Centos安装golang</h2><p>centos安装golang非常简单，直接<code>yum install -y golang</code>即可。安装完毕之后，修改一下<code>/etc/profile</code>，在文件末尾处添加如下语句：<br>	<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">#golang</span><br><span class="line">export GOROOT=/usr/lib/golang</span><br><span class="line">export GOPATH=/opt/golangproject	# 这个是项目的路径</span><br><span class="line">export PATH=$PATH:$GOROOT/bin</span><br></pre></td></tr></table></figure></p>
<p>然后<code>source /etc/profile</code>使环境变量生效，但是这里要注意一下，如果你不是root，那么使用<code>sudo source /etc/profile</code>是会报错<code>sudo: source: command not found</code> ，要用<code> sudo -s source /etc/profile</code>才可以，如图：<br><img data-src="/images/golang%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83.png"></p>
<p>然后可以<code>go env</code>看到所有的环境变量情况：<br><img data-src="/images/golang%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%832.png"></p>
<p>此时如果你要下载包，比如一个钉钉机器人的包：<code>go get -u github.com/royeo/dingrobot</code>，如果<code>GOPATH</code>是有权限的，就会直接下载到<code>$GOPATH/src</code>里，如果当前用户没有权限，那么就会下载到<code>/root/go/src</code>里，只能在build的环节时手动mv过来。</p>
<h2 id="Vscode环境搭建的时候，提示无法安装go插件"><a href="#Vscode环境搭建的时候，提示无法安装go插件" class="headerlink" title="Vscode环境搭建的时候，提示无法安装go插件"></a>Vscode环境搭建的时候，提示无法安装go插件</h2><p>安装不了go插件说白了其实就是墙的问题，所以要学习Golang的人会长时间的面对这种外界问题。</p>
<p>配置Vscode我这里就不说了，满大街都是。但是安装完<code>Vscode</code>后，再安装<code>go tools</code>失败，就只能换一个代理：<br>	<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> env -w GO111MODULE=on</span><br><span class="line">$ <span class="keyword">go</span> env -w GOPROXY=https:<span class="comment">//goproxy.io,direct</span></span><br></pre></td></tr></table></figure></p>
<p>设置完成后重启<code>Vscode</code>，再重新安装go tools即可。</p>
<p>但是这个时候还有一个问题，虽然你成功安装了go tools，而你却发现你在build的时候报错：<code>go: cannot find main module; see ‘go help modules’</code>。</p>
<p>由于之前设置过GO111MODULE&#x3D;on，所以使用下面的命令解决<br>	<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> mod init hello</span><br></pre></td></tr></table></figure></p>
<p>此时在项目文件夹里会生成了一个<code>go.mod</code>文件，然后再执行<code>go build</code>就成功了！</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://gitee.com/zoufuxing/dingrobot/blob/master/README.md">https://gitee.com/zoufuxing/dingrobot/blob/master/README.md</a><br><a href="https://unix.stackexchange.com/questions/202332/sudo-source-command-not-found">https://unix.stackexchange.com/questions/202332/sudo-source-command-not-found</a><br><a href="https://www.cnblogs.com/oxspirt/p/9340250.html">https://www.cnblogs.com/oxspirt/p/9340250.html</a><br><a href="https://blog.csdn.net/u011897301/article/details/105758056">https://blog.csdn.net/u011897301/article/details/105758056</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Django2</tag>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title>搭配InfluxDB+CADvisor+Grafana组合监控Docker</title>
    <url>/2019/08/22/%E6%90%AD%E9%85%8DInfluxDB-CADvisor-Grafana%E7%BB%84%E5%90%88%E7%9B%91%E6%8E%A7Docker/</url>
    <content><![CDATA[<h2 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h2><p>InfluxDB和Grafana装在一起，IP是172.31.0.77，阿里云CENTOS 7。<br>CADvisor装在172.16.0.195，同样是阿里云CENTOS 7。</p>
<p>思路就是CADvisor采集虚机里docker的指标，然后将值存入到InfluxDB，然后Grafana从InfluxDB取值展示。</p>
<h2 id="部署influxDB"><a href="#部署influxDB" class="headerlink" title="部署influxDB"></a>部署influxDB</h2><p>influxDB如果用docker启动非常简单，语句如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">docker run -d -p <span class="number">8083</span>:<span class="number">8083</span> -p <span class="number">8086</span>:<span class="number">8086</span> --expose <span class="number">8090</span> --expose <span class="number">8099</span> --name influxsrv influxdb			<span class="comment">#使用官方镜像启动</span></span><br></pre></td></tr></table></figure></p>
<p>启动之后，进入容器里，使用<code>./usr/bin/influx -version</code>查看当前版本是<code>InfluxDB shell version: 1.7.7</code>。</p>
<p>influxdb在1.1版本之后取消了web控制台，如果你还想使用web控制台的话，那就不要选择官方镜像，使用<code>tutum/influxdb</code>镜像，它是1.0版本的。</p>
<p>然后在命令框中创建数据库和用户：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">root@98d72bffb8cd:/usr/<span class="built_in">bin</span><span class="comment"># ./influx</span></span><br><span class="line">Connected to http://localhost:<span class="number">8086</span> version <span class="number">1.7</span><span class="number">.7</span></span><br><span class="line">InfluxDB shell version: <span class="number">1.7</span><span class="number">.7</span></span><br><span class="line">&gt; show databases;</span><br><span class="line">name: databases</span><br><span class="line">name</span><br><span class="line">----</span><br><span class="line">_internal</span><br><span class="line">CREATE DATABASE <span class="string">&quot;dockerdata&quot;</span>		<span class="comment">#创建databases</span></span><br><span class="line">CREATE USER monitor WITH PASSWORD <span class="string">&#x27;123456@qwe&#x27;</span>	<span class="comment">#这里创建账户monitor和密码</span></span><br><span class="line">GRANT ALL PRIVILEGES ON <span class="string">&quot;dockerdata&quot;</span> TO <span class="string">&quot;monitor&quot;</span>		<span class="comment">#用户授权</span></span><br><span class="line">GRANT WRITE ON <span class="string">&quot;dockerdata&quot;</span> TO <span class="string">&quot;monitor&quot;</span></span><br><span class="line">GRANT READ ON <span class="string">&quot;dockerdata&quot;</span> TO <span class="string">&quot;monitor&quot;</span>		<span class="comment">#授予读写权限</span></span><br><span class="line">DROP USER monitor			<span class="comment">#如果想删除用户，就用这个</span></span><br><span class="line">EXIT</span><br></pre></td></tr></table></figure></p>
<p>influxDB的语句比较讲究双引号和单引号，这一点跟mysql还是有点不同的，更多注册信息可以去看<a href="https://docs.influxdata.com/influxdb/v1.7/administration/authentication_and_authorization/">https://docs.influxdata.com/influxdb/v1.7/administration/authentication_and_authorization/</a> ，这里先暂时告于段落。</p>
<h2 id="部署CADvisor"><a href="#部署CADvisor" class="headerlink" title="部署CADvisor"></a>部署CADvisor</h2><p>首先先确定机器是否与InfluxDB的8086端口相通，确定之后，猫头鹰的部署语句如下：<br>	<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">docker run -d --name=cadvisor -v /:/rootfs:ro -v /sys:/sys:ro -v /<span class="keyword">var</span>/run:/<span class="keyword">var</span>/run:rw -v /<span class="keyword">var</span>/lib/docker/:/<span class="keyword">var</span>/lib/docker:ro -p <span class="number">8080</span>:<span class="number">8080</span>  google/cadvisor:latest -storage_driver=influxdb -storage_driver_db=dockerdata -storage_driver_host=<span class="number">172.31</span><span class="number">.0</span><span class="number">.77</span>:<span class="number">8086</span></span><br></pre></td></tr></table></figure></p>
<p>然后浏览器输入<code>IP：8080</code>就能打开猫头鹰的界面了，可以查看CADvisor搜集到当前服务器里所有docker。<br><img data-src="/images/influxdb1.png" alt="抱光妹" title="这些是服务器里的docker名"></p>
<p>点击对应的docker名称，就能看到详细监控信息。在<code>docker run</code>里我们设定了influxdb的数据库，到时候会把这些信息都保存到influxdb里的。<br><img data-src="/images/influxdb2.png" alt="抱光妹"></p>
<p>CADvisor采集的数据还是比较基本，具体信息如下：<br><img data-src="/images/influxdb5.png" alt="抱光妹"></p>
<h2 id="部署Grafana"><a href="#部署Grafana" class="headerlink" title="部署Grafana"></a>部署Grafana</h2><p>部署gafana的语句如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">docker run -d --name grafana -p <span class="number">3000</span>:<span class="number">3000</span> -e INFLUXDB_HOST=localhost -e INFLUXDB_PORT=<span class="number">8086</span> -e INFLUXDB_NAME=dockerdata --link influxsrv:infx grafana/grafana</span><br></pre></td></tr></table></figure></p>
<p>浏览器输入<code>IP:3030</code>登录grafana，默认账号密码是<code>admin:admin</code>，然后系统会通知我们先更改掉这个默认密码，于是换成新的。</p>
<p>点击<code>add data source</code>选择<code>influxdb</code>进行配置，如图：<br><img data-src="/images/influxdb3.png" alt="抱光妹"></p>
<p>然后点击<code>save &amp; test</code>，去dashboard里可以创建图表查看了！如图：<br><img data-src="/images/influxdb4.png" alt="抱光妹"></p>
<p>这个图看到并不连贯，可能是cadvisor采集的时候是有时间间隔的，于是我们需要将<code>Min time interval</code>改成1m，就会是一个流畅的曲线了。再把cadvisor里的其他有用信息都做成图表，如图：<br><img data-src="/images/influxdb6.png" alt="抱光妹"></p>
<p>需要注意的是，有可能<code>select</code>的数据，没能按照我们所预期的样子来进行展示，这个时候要考虑下，数据源内的数据是不是适合你选择的DashBoard类型，其他也就没什么问题了。</p>
<p>最后就是添加监控，我偷个懒把监控方式选择钉钉，验证一下监控OK！<br><img data-src="/images/influxdb7.png" alt="抱光妹"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《容器云运维实战》 P268<br><a href="https://www.cnblogs.com/LUA123/p/9507029.html">https://www.cnblogs.com/LUA123/p/9507029.html</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>监控</tag>
        <tag>docker</tag>
        <tag>grafana</tag>
      </tags>
  </entry>
  <entry>
    <title>摆弄摆弄iptables</title>
    <url>/2019/05/20/%E6%91%86%E5%BC%84%E6%91%86%E5%BC%84iptables/</url>
    <content><![CDATA[<p>作为一名运维人员，安全是第一任务，那么某些高机密web网页限制IP访问是必做的环节，当然如果使用阿里云的“安全组”可以让这一切变的简单和直观。不过有时候，一个安全组里面有多个服务，不同的服务使用同一个端口（比如都是443），有些443要对所有人开放，有的443只能对公司的IP开放，那么如果不想重新收拾安全组的话，就干脆用iptables。</p>
<h2 id="普通的iptables"><a href="#普通的iptables" class="headerlink" title="普通的iptables"></a>普通的iptables</h2><p>常用的iptables规则如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">iptables -nvL	<span class="comment">#详细查看当前iptables情况</span></span><br><span class="line">iptables -I INPUT -p tcp --dport <span class="number">8701</span> -j DROP	<span class="comment">#所有来访问8701端口的请求都作废</span></span><br><span class="line">iptables -I INPUT -s <span class="number">60.191</span><span class="number">.94</span><span class="number">.118</span> -p tcp --dport <span class="number">8070</span> -j ACCEPT	<span class="comment">#只准许60.191.94.118这个IP访问8070端口</span></span><br><span class="line">iptables -t nat -I PREROUTING <span class="number">1</span> -s <span class="number">120.92</span><span class="number">.136</span><span class="number">.159</span>/<span class="number">32</span> -p tcp -m tcp --dport <span class="number">6379</span> -j DNAT --to-destination <span class="number">100.99</span><span class="number">.231</span><span class="number">.81</span>:<span class="number">6379</span>	<span class="comment">#准许120.92.136.159的6379信息转发到100.99.231.81的6379里</span></span><br><span class="line">iptables -A OUTPUT -p tcp -m tcp --dport <span class="number">61616</span> -j DROP	<span class="comment">#将61616端口的报文抛弃</span></span><br><span class="line">iptables -D INPUT <span class="number">1</span>		<span class="comment">#删除INPUT表里的第一规则</span></span><br><span class="line">iptables -L FORWARD --line-numbers 		<span class="comment">#展现规则序号，-D删除的行号就是这里的序号</span></span><br></pre></td></tr></table></figure><br>如果不小心配错的规则比较多，不愿意一个一个删除，可以执行<code>service iptables restart</code>直接恢复。</p>
<h2 id="容器的iptables"><a href="#容器的iptables" class="headerlink" title="容器的iptables"></a>容器的iptables</h2><p>现在容器化横行，但是我们也要限制IP来访问容器的端口，但是如果像上面那样的话，是无法成功的。对于容器，为了避免您的规则被docker破坏,请使用<code>DOCKER-USER</code>链，比如有个容器已经做了3306端口与宿主机的3306端口互通，那么配置如下规则：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">iptables -A DOCKER-USER -i eth0 -s <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> -p tcp -m conntrack --ctorigdstport <span class="number">3306</span> -j ACCEPT</span><br><span class="line">iptables -A DOCKER-USER -i eth0 -s <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> -p tcp -m conntrack --ctorigdstport <span class="number">3306</span> -j ACCEPT</span><br><span class="line">iptables -A DOCKER-USER -i eth0 -p tcp -m conntrack --ctorigdstport <span class="number">3306</span> -j DROP</span><br></pre></td></tr></table></figure></p>
<p>执行的效果就是只能1.1.1.1和2.2.2.2来访问该服务器的3306端口，其余IP一律drop掉。这里也要注意输入的顺序，因为iptables执行是从上往下的。</p>
<h2 id="RETURN的问题"><a href="#RETURN的问题" class="headerlink" title="RETURN的问题"></a>RETURN的问题</h2><p>如果上面的规则如果变成了这样：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">iptables -A DOCKER-USER -p <span class="built_in">all</span> -j RETURN</span><br><span class="line">iptables -A DOCKER-USER -i eth0 -s <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> -p tcp -m conntrack --ctorigdstport <span class="number">3306</span> -j ACCEPT</span><br><span class="line">iptables -A DOCKER-USER -i eth0 -s <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> -p tcp -m conntrack --ctorigdstport <span class="number">3306</span> -j ACCEPT</span><br><span class="line">iptables -A DOCKER-USER -i eth0 -p tcp -m conntrack --ctorigdstport <span class="number">3306</span> -j DROP</span><br></pre></td></tr></table></figure></p>
<p>会不会达不到预期的要求？答曰不一定，在我这个例子里结果就是任何人都可以访问容器的3306端口。因为return退出的是当前CHIAN：如果当前CHIAN是别的CHAIN调用的子CHIAN（从一个CHAIN里可以jump到另一个CHAIN, jump到的那个CHAIN是子CHAIN），那么返回到调用点下一条规则处开始执行，如果当前CHIAN不是子CHAIN，那么就以默认策略执行。<code>iptables -nvL</code>看一下当前iptables的情况：<br><img data-src="/images/docker18.png" alt="akb48" title="图中我先把RETURN规则删掉了"></p>
<p>可以看出DOCKER-USER这个链是<code>1 references</code>，即它被一个默认链调用，被哪个默认链呢？<code>FORWARD</code>，当DOCKER-USER RETURN的时候回返回到FORWARD链里然后走下一个规则，而下一个规则是什么呢？是<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">7893K <span class="number">56</span>10M ACCEPT     <span class="built_in">all</span>  --  *      docker0  <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">0</span>            <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">0</span>            ctstate RELATED,ESTABLISHED</span><br></pre></td></tr></table></figure></p>
<p>所以所有人都可以访问这个3306了。</p>
<h2 id="没有DOCKER-USER？"><a href="#没有DOCKER-USER？" class="headerlink" title="没有DOCKER-USER？"></a>没有DOCKER-USER？</h2><p>DOCKER-USER这个链是Docker比较新的版本加上的，例子里的docker版本是version 18.06.1-ce, build e68fc7a。但是如果docker比较老的话，是不会默认生成这个链的，比如：<br><img data-src="/images/docker19.png" alt="akb48"></p>
<p>这种情况要么乖乖的升级docker，要么可以自定义创建iptables链。比如我们创建一个链，链名叫GITLAB，只让公司内部网络（115.200.239.106）访问GITLAB。</p>
<p>首先先<code>iptables -N GITLAB</code>，创建该链。然后<code>iptables -I GITLAB -p tcp --dport 443 -j DROP</code>和<code>iptables -I GITLAB -s 115.200.239.106 -j ACCEPT</code>创建给GITLAB链里添加两个访问规则达到只有指定IP访问443端口的目的。但是此时这个GITLAB链没有被任何任何默认链引用，所以即使配了规则也是无法匹配到任何报文的，所以我们要把它与FORWARD链链接起来，准许443端口可以转发，命令是<code>iptables -I FORWARD -p https --dport 443 -j GITLAB</code>，如图：<br><img data-src="/images/docker20.png" alt="akb48"></p>
<p>去浏览器里或者curl一下验证，的确只能指定IP才能访问GITLAB主页。不过，你以为现在就完事了么？非也，因为gitlab默认是通过https的形式拉取代码的，所以你还要把所有的代码服务器IP也要写进iptables里。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://docs.docker.com/network/iptables/">https://docs.docker.com/network/iptables/</a><br><a href="https://www.frozentux.net/iptables-tutorial/cn/iptables-tutorial-cn-1.1.19.html">https://www.frozentux.net/iptables-tutorial/cn/iptables-tutorial-cn-1.1.19.html</a><br><a href="http://kuntsung.blogspot.com/2012/10/iptables.html">http://kuntsung.blogspot.com/2012/10/iptables.html</a><br><a href="https://www.zsythink.net/archives/1625">https://www.zsythink.net/archives/1625</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>容器</tag>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux运维工程师笔试题第二十一套</title>
    <url>/2021/04/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%99sql%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><p>表结构:uid,subject_id,score。求:找出所有科目成绩都大于某一学科平均成绩的学生</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">--数据集</span><br><span class="line"><span class="number">1001</span> 01 <span class="number">90</span></span><br><span class="line"><span class="number">1001</span> 02 <span class="number">90</span></span><br><span class="line"><span class="number">1001</span> 03 <span class="number">90</span></span><br><span class="line"><span class="number">1002</span> 01 <span class="number">85</span></span><br><span class="line"><span class="number">1002</span> 02 <span class="number">85</span></span><br><span class="line"><span class="number">1002</span> 03 <span class="number">70</span></span><br><span class="line"><span class="number">1003</span> 01 <span class="number">70</span></span><br><span class="line"><span class="number">1003</span> 02 <span class="number">70</span></span><br><span class="line"><span class="number">1003</span> 03 <span class="number">85</span></span><br></pre></td></tr></table></figure>

<p>解题思路:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>）求出每个学科平均成绩</span><br><span class="line">    select uid,</span><br><span class="line">    score,</span><br><span class="line">    avg(score) over(partition by subject_id) AS avg_score <span class="keyword">from</span></span><br><span class="line">    score;t1</span><br><span class="line"></span><br><span class="line">    这里比较关注的是OVER 窗口函数：</span><br><span class="line">	AVG(score) OVER (PARTITION BY subject_id): 这是窗口函数的一部分，表示按 subject_id 分组计算每组的平均分数。PARTITION BY subject_id: 将数据分成多个分区，每个分区对应一个 subject_id。AVG(score): 对每个分区内的 score 列计算平均值。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）根据是否大于平均成绩记录 flag，大于则记为 <span class="number">0</span> 否则记为 <span class="number">1</span></span><br><span class="line">    select uid,</span><br><span class="line">    <span class="keyword">if</span>(score&gt;avg_score,<span class="number">0</span>,<span class="number">1</span>) AS flag <span class="keyword">from</span></span><br><span class="line">    t1;t2</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）根据学生 <span class="built_in">id</span> 进行分组统计 flag 的和，和为 <span class="number">0</span> 则是所有学科都大于平均成绩</span><br><span class="line">    select uid</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">    t2 group by</span><br><span class="line">    uid having</span><br><span class="line">       <span class="built_in">sum</span>(flag)=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>）最终SQL</span><br><span class="line">    select uid</span><br><span class="line">    <span class="keyword">from</span> (select</span><br><span class="line">    uid,</span><br><span class="line">    <span class="keyword">if</span>(score&gt;avg_score,<span class="number">0</span>,<span class="number">1</span>) flag <span class="keyword">from</span></span><br><span class="line">    (select uid,</span><br><span class="line">    score,</span><br><span class="line">    avg(score) over(partition by subject_id) avg_score <span class="keyword">from</span></span><br><span class="line">       score)t1)t2</span><br><span class="line">    group by</span><br><span class="line">    uid having</span><br><span class="line">       <span class="built_in">sum</span>(flag)=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>


<h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><p>有 50W 个京东店铺，每个顾客访问任何一个店铺的任何一个商品时都会产生一条访问日志，访问日志存储的表名为 Visit，访客的用户 id 为 user_id，被访问的店铺名称为shop，请统计:每个店铺访问次数 top3 的访客信息。输出店铺名称、访客 id、访问次数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">--数据集</span><br><span class="line">u1 a</span><br><span class="line">u2 b</span><br><span class="line">u1 b</span><br><span class="line">u1 a</span><br><span class="line">u3 c</span><br><span class="line">u4 b</span><br><span class="line">u1 a</span><br><span class="line">u2 c</span><br><span class="line">u5 b</span><br><span class="line">u4 b</span><br><span class="line">u6 c</span><br><span class="line">u2 c</span><br><span class="line">u1 b</span><br><span class="line">u2 a</span><br><span class="line">u2 a</span><br><span class="line">u3 a</span><br><span class="line">u5 a</span><br><span class="line">u5 a</span><br><span class="line">u5 a</span><br></pre></td></tr></table></figure>

<p>解题思路:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)查询每个店铺被每个用户访问次数</span><br><span class="line">      select shop,user_id,count(*) ct</span><br><span class="line">      <span class="keyword">from</span> visit</span><br><span class="line">      group by shop,user_id;t1</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)计算每个店铺被用户访问次数排名</span><br><span class="line">      select shop,user_id,ct,rank() over(partition by shop order by ct) rk</span><br><span class="line">      <span class="keyword">from</span> t1;t2</span><br><span class="line">      这里也要关注一下rank（)函数，RANK() OVER (PARTITION BY shop ORDER BY ct): 这是窗口函数的一部分，表示按 shop 分组计算每组内的时间戳排名。</span><br><span class="line">			PARTITION BY shop: 将数据分成多个分区，每个分区对应一个 shop。</span><br><span class="line">			ORDER BY ct: 在每个分区内按上面的count(*)排序。</span><br><span class="line">			RANK(): 计算每个分区内按时间戳排序后的排名。</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)取每个店铺排名前 <span class="number">3</span> 的</span><br><span class="line">      select shop,user_id,ct</span><br><span class="line">      <span class="keyword">from</span> t2</span><br><span class="line">      where rk&lt;=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>)最终SQL</span><br><span class="line">      select shop,</span><br><span class="line">      user_id,</span><br><span class="line">      ct <span class="keyword">from</span></span><br><span class="line">         (select</span><br><span class="line">             shop,</span><br><span class="line">             user_id,</span><br><span class="line">             ct,</span><br><span class="line">             rank() over(partition by shop order by ct) rk</span><br><span class="line">      <span class="keyword">from</span> (select</span><br><span class="line">                shop,</span><br><span class="line">                user_id,</span><br><span class="line">                count(*) ct</span><br><span class="line">             <span class="keyword">from</span> visit</span><br><span class="line">             group by</span><br><span class="line">      shop,</span><br><span class="line">                user_id)t1</span><br><span class="line">         )t2</span><br><span class="line">      where rk&lt;=<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><p>请用 sql 写出所有用户中在今年 10 月份第一次购买商品的金额，表 ordertable 字段(购买用户:userid，金额:money，购买时间:paymenttime(格式:2017-10-01)，订单 id:orderid)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)查询出用户最小使用时间</span><br><span class="line">    select</span><br><span class="line">      userid,</span><br><span class="line">      <span class="built_in">min</span>(paymenttime) paymenttime</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">    ordertable</span><br><span class="line">    where</span><br><span class="line">      date_format(paymenttime,<span class="string">&#x27;yyyy-MM&#x27;</span>)=<span class="string">&#x27;2017-10&#x27;</span></span><br><span class="line">    group by</span><br><span class="line">      userid;t1</span><br><span class="line">(<span class="number">2</span>) 拿到用户金额</span><br><span class="line">    select</span><br><span class="line">      t1.userid,</span><br><span class="line">      t1.paymenttime,</span><br><span class="line">      od.money</span><br><span class="line">    <span class="keyword">from</span> t1</span><br><span class="line">    join</span><br><span class="line">      ordertable od</span><br><span class="line">    on</span><br><span class="line">    t1.userid=od.userid</span><br><span class="line">    <span class="keyword">and</span></span><br><span class="line">    t1.paymenttime=od.paymenttime;</span><br><span class="line">（<span class="number">3</span>）最终SQL</span><br><span class="line">    select</span><br><span class="line">      t1.userid,</span><br><span class="line">      t1.paymenttime,</span><br><span class="line">      od.money</span><br><span class="line">    <span class="keyword">from</span> (select</span><br><span class="line">    userid,</span><br><span class="line">      <span class="built_in">min</span>(paymenttime) paymenttime</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">      ordertable</span><br><span class="line">    where</span><br><span class="line">      date_format(paymenttime,<span class="string">&#x27;yyyy-MM&#x27;</span>)=<span class="string">&#x27;2017-10&#x27;</span></span><br><span class="line">    group by</span><br><span class="line">      userid)t1</span><br><span class="line">    join</span><br><span class="line">      ordertable od</span><br><span class="line">    on</span><br><span class="line">      t1.userid=od.userid</span><br><span class="line">      <span class="keyword">and</span></span><br><span class="line">      t1.paymenttime=od.paymenttime;</span><br></pre></td></tr></table></figure>

<h2 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h2><p>有日志如下，请写出代码求得所有用户和活跃用户的总数及平均年龄。(活跃用户指连续两天都有访问记录的用户)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">--数据集</span><br><span class="line">日期dt   用户user_id 年龄age</span><br><span class="line"><span class="number">2019</span>-02-<span class="number">11</span>,test_1,<span class="number">23</span></span><br><span class="line"><span class="number">2019</span>-02-<span class="number">11</span>,test_2,<span class="number">19</span></span><br><span class="line"><span class="number">2019</span>-02-<span class="number">11</span>,test_3,<span class="number">39</span></span><br><span class="line"><span class="number">2019</span>-02-<span class="number">11</span>,test_1,<span class="number">23</span></span><br><span class="line"><span class="number">2019</span>-02-<span class="number">11</span>,test_3,<span class="number">39</span></span><br><span class="line"><span class="number">2019</span>-02-<span class="number">11</span>,test_1,<span class="number">23</span></span><br><span class="line"><span class="number">2019</span>-02-<span class="number">12</span>,test_2,<span class="number">19</span></span><br><span class="line"><span class="number">2019</span>-02-<span class="number">13</span>,test_1,<span class="number">23</span></span><br><span class="line"><span class="number">2019</span>-02-<span class="number">15</span>,test_2,<span class="number">19</span></span><br><span class="line"><span class="number">2019</span>-02-<span class="number">16</span>,test_2,<span class="number">19</span></span><br></pre></td></tr></table></figure>

<p>解题思路:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)按照日期以及用户分组，按照日期排序并给出排名</span><br><span class="line">    select dt,</span><br><span class="line">      user_id,</span><br><span class="line">      <span class="built_in">min</span>(age) age,</span><br><span class="line">      rank() over(partition by user_id order by dt) rk</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">      user_age</span><br><span class="line">    group by</span><br><span class="line">      dt,user_id;t1</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)计算日期及排名的差值</span><br><span class="line">    select</span><br><span class="line">      user_id,</span><br><span class="line">    age,</span><br><span class="line">      date_sub(dt,rk) flag</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">    t1;t2</span><br><span class="line">    这里注意一下：DATE_SUB(dt, INTERVAL rk DAY) AS flag: 使用 DATE_SUB 函数从日期 dt 中减去 rk 天数，生成新的字段 flag。</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)过滤出差值大于等于 <span class="number">2</span> 的，即为连续两天活跃的用户</span><br><span class="line">    select</span><br><span class="line">    user_id,</span><br><span class="line">      <span class="built_in">min</span>(age) age</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">    t2 group by</span><br><span class="line">      user_id,flag</span><br><span class="line">    having</span><br><span class="line">      count(*)&gt;=<span class="number">2</span>;t3</span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>)对数据进行去重处理(一个用户可以在两个不同的时间点连续登录)，例如:a 用户在 <span class="number">1</span> 月<span class="number">10</span>号<span class="number">1</span>月<span class="number">11</span>号以及<span class="number">1</span>月<span class="number">20</span>号和<span class="number">1</span>月<span class="number">21</span>号<span class="number">4</span>天登录。</span><br><span class="line">    select</span><br><span class="line">      user_id,</span><br><span class="line">      <span class="built_in">min</span>(age) age</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">    t3 group by</span><br><span class="line">    user_id;t4</span><br><span class="line"></span><br><span class="line">(<span class="number">5</span>)计算活跃用户(两天连续有访问)的人数以及平均年龄</span><br><span class="line">    select</span><br><span class="line">      count(*) ct,</span><br><span class="line">      cast(<span class="built_in">sum</span>(age)/count(*) <span class="keyword">as</span> decimal(<span class="number">10</span>,<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">from</span> t4;</span><br><span class="line"></span><br><span class="line">(<span class="number">6</span>) 对全量数据集进行按照用户去重</span><br><span class="line">    select</span><br><span class="line">      user_id,</span><br><span class="line">    <span class="built_in">min</span>(age) age</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">      user_age</span><br><span class="line">    group by</span><br><span class="line">      user_id;t5</span><br><span class="line"></span><br><span class="line">(<span class="number">7</span>)计算所有用户的数量以及平均年龄</span><br><span class="line">    select</span><br><span class="line">      count(*) user_count,</span><br><span class="line">      cast((<span class="built_in">sum</span>(age)/count(*)) <span class="keyword">as</span> decimal(<span class="number">10</span>,<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">from</span> t5;</span><br><span class="line"></span><br><span class="line">(<span class="number">8</span>) 将第 <span class="number">5</span> 步以及第 <span class="number">7</span> 步两个数据集进行 union <span class="built_in">all</span> 操作</span><br><span class="line">    select</span><br><span class="line">      <span class="number">0</span> user_total_count,</span><br><span class="line">      <span class="number">0</span> user_total_avg_age,</span><br><span class="line">      count(*) twice_count,</span><br><span class="line">      cast(<span class="built_in">sum</span>(age)/count(*)</span><br><span class="line">    twice_count_avg_age</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">    (</span><br><span class="line">      select</span><br><span class="line">      user_id,</span><br><span class="line">      <span class="built_in">min</span>(age) age</span><br><span class="line">    <span class="keyword">as</span> decimal(<span class="number">10</span>,<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">from</span> (select</span><br><span class="line">    user_id,</span><br><span class="line">      <span class="built_in">min</span>(age) age</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">    ( select</span><br><span class="line">      user_id,</span><br><span class="line">      age,</span><br><span class="line">      date_sub(dt,rk) flag</span><br><span class="line">    <span class="keyword">from</span> (</span><br><span class="line">    select dt,</span><br><span class="line">          user_id,</span><br><span class="line">          <span class="built_in">min</span>(age) age,</span><br><span class="line">          rank() over(partition by user_id order by dt) rk</span><br><span class="line">       <span class="keyword">from</span></span><br><span class="line">          user_age</span><br><span class="line">       group by</span><br><span class="line">          dt,user_id</span><br><span class="line">    )t1</span><br><span class="line">    )t2 group by</span><br><span class="line">      user_id,flag</span><br><span class="line">    having</span><br><span class="line">      count(*)&gt;=<span class="number">2</span>)t3</span><br><span class="line">    group by</span><br><span class="line">      user_id</span><br><span class="line">    )t4</span><br><span class="line">    union <span class="built_in">all</span></span><br><span class="line">    select</span><br><span class="line">      count(*) user_total_count,</span><br><span class="line">    cast((<span class="built_in">sum</span>(age)/count(*)) <span class="keyword">as</span> decimal(<span class="number">10</span>,<span class="number">1</span>)),</span><br><span class="line">      <span class="number">0</span> twice_count,</span><br><span class="line">      <span class="number">0</span> twice_count_avg_age</span><br><span class="line">    <span class="keyword">from</span> (</span><br><span class="line">           user_id</span><br><span class="line">      )t5;t6</span><br><span class="line"></span><br><span class="line">(<span class="number">9</span>) 求和并拼接为最终SQL</span><br><span class="line">    select</span><br><span class="line">       <span class="built_in">sum</span>(user_total_count),</span><br><span class="line">       <span class="built_in">sum</span>(user_total_avg_age),</span><br><span class="line">       <span class="built_in">sum</span>(twice_count),</span><br><span class="line">       <span class="built_in">sum</span>(twice_count_avg_age)</span><br><span class="line">    <span class="keyword">from</span> (select</span><br><span class="line">    <span class="number">0</span> user_total_count,</span><br><span class="line">    <span class="number">0</span> user_total_avg_age,</span><br><span class="line">    count(*) twice_count, cast(<span class="built_in">sum</span>(age)/count(*) <span class="keyword">as</span></span><br><span class="line">    twice_count_avg_age</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">    (</span><br><span class="line">      select</span><br><span class="line">      user_id,</span><br><span class="line">      <span class="built_in">min</span>(age) age</span><br><span class="line">    <span class="keyword">from</span> (select</span><br><span class="line">    user_id,</span><br><span class="line">      <span class="built_in">min</span>(age) age</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">    ( select</span><br><span class="line">      user_id,</span><br><span class="line">      age,</span><br><span class="line">      date_sub(dt,rk) flag</span><br><span class="line">    decimal(<span class="number">10</span>,<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">from</span> (</span><br><span class="line">    select dt,</span><br><span class="line">          user_id,</span><br><span class="line">          <span class="built_in">min</span>(age) age,</span><br><span class="line">          rank() over(partition by user_id order by dt) rk</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">    user_age</span><br><span class="line">       group by</span><br><span class="line">          dt,user_id</span><br><span class="line">       )t1</span><br><span class="line">    )t2 group by</span><br><span class="line">      user_id,flag</span><br><span class="line">    having</span><br><span class="line">      count(*)&gt;=<span class="number">2</span>)t3</span><br><span class="line">    group by</span><br><span class="line">    user_id )t4</span><br><span class="line">    union <span class="built_in">all</span></span><br><span class="line">    select</span><br><span class="line">      count(*) user_total_count,</span><br><span class="line">      cast((<span class="built_in">sum</span>(age)/count(*)) <span class="keyword">as</span> decimal(<span class="number">10</span>,<span class="number">1</span>)),</span><br><span class="line">      <span class="number">0</span> twice_count,</span><br><span class="line">      <span class="number">0</span> twice_count_avg_age</span><br><span class="line">    <span class="keyword">from</span> (</span><br><span class="line">           user_id</span><br><span class="line">      )t5)t6;</span><br></pre></td></tr></table></figure>

<p>以上只是个人的写法，如果有更好的或者实际情况中有更符合现实的可以更加优化，让我们一起追求数据库查询的艺术。</p>
]]></content>
      <categories>
        <category>大牛之路</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>面试题</tag>
        <tag>数据开发</tag>
      </tags>
  </entry>
  <entry>
    <title>日志文件管理者：Logrotate</title>
    <url>/2018/02/12/%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E8%80%85%EF%BC%9ALogrotate/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>服务器在服务运行的时候，难免会生成大量日志，一般来说遇到日志过多的情况，就会写一个看门狗：监控磁盘容量的大小，如果磁盘剩余空间小于某个值，就去日志文件夹里把一个月或者几个月之前的废弃日志删除掉以达到释放磁盘空间的目的。</p>
<p>但是往往有的时候过期的日志很重要，或者即使是一周的时间内，也会生成容量非常可观的日志，那么就需要使用logrotate命令来管理这些日志，这个命令是linux自带的。</p>
<p>logrotate这个命令的用法请看：<code>https://linux.cn/article-8227-1-rel.html</code>和<code>https://linux.cn/article-4126-1.html</code> 。</p>
<h2 id="实验开始"><a href="#实验开始" class="headerlink" title="实验开始"></a>实验开始</h2><p>首先，假设服务器里某个日志文件夹里的日志<code>auc.log.10</code>是这样的：<br><img data-src="/images/logrotate1.png" alt="paradin"></p>
<p>然后在logrotate的配置文件是这么写的：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/mnt/hswx/auc/logs/auc.<span class="property">log</span><span class="number">.10</span> &#123;             这里是目标日志的绝对路径</span><br><span class="line">       daily        每天执行一次</span><br><span class="line">       minsize 200M    文件容量大于200M开始处理，如果到了时间但是没有大于200M，不会处理</span><br><span class="line">       compress          压缩</span><br><span class="line">       dateext          文件会以日期为后缀</span><br><span class="line">       create <span class="number">777</span> root root    新建的那个日志文件属性是<span class="number">777</span></span><br><span class="line">       rotate <span class="number">2</span>         保留最多<span class="number">2</span>个文件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后执行<code>logrotate -vf /etc/logrotate.conf</code>，看到的效果是：<br><img data-src="/images/logrotate2.png" alt="paradin"></p>
<p>命令执行后，服务器create了新的<code>auc.log.10</code>，而且属性变成了777，同时把原有的部分压缩成gz的格式。</p>
<p>上面那个测试的对象是已经过期的日志，现在我们要压缩当前的日志，目的是<code>在压缩了auc.log并且重命名之后，可以生成新的auc.log，同时这个新的auc.log会被写入</code>。</p>
<p>现在我们尝试一下，把原来的配置文件改成这样：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/mnt/hswx/auc/logs/auc.<span class="property">log</span> &#123;</span><br><span class="line">       weekly</span><br><span class="line">       minsize 200M</span><br><span class="line">       compress</span><br><span class="line">       rotate <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是执行之后，我们发现变成了这样：<br><img data-src="/images/logrotate3.png" alt="paradin"></p>
<p>原来的<code>auc.log</code>不见了，而出现的<code>auc.log.1</code>里面的内容是原来<code>auc.log</code>的内容，可见原有的<code>auc.log</code>已经被顶掉了。这是因为我们上面的配置文件里面没有加上<code>dateext</code>，所以默认会以<code>.1、.2、.3</code>为后缀。</p>
<p>问题是我们没有生成<code>auc.log</code>，那么这段时间的日志就会找不到<code>auc.log</code>而凭空消失。可见这个方法没有达到我们的目的，需要改进。</p>
<h2 id="改进之后"><a href="#改进之后" class="headerlink" title="改进之后"></a>改进之后</h2><p>我们这个内部模块auc只有重新启动这个进程才会生成<code>auc.log</code>，既然要解决这样的问题，我们很自然的就想到<code>kill -HUP</code>这种平滑启动的方式，但是要注意！<code>kill -HUP</code>对deamon会进行重新读取配置启动，但是对于普通的进程只会把其杀死！而这个auc就是一个普通的java程序，没有配套的守护进程。所以只能使用一般的重启方式来达到生成<code>auc.log</code>这个目的。</p>
<p>首先我们把原来的配置文件改成这样：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/mnt/hswx/auc/logs/auc.<span class="property">log</span> &#123;</span><br><span class="line">       weekly    #每周执行</span><br><span class="line">       dateext    #以日期作为后缀</span><br><span class="line">       minsize 200M    #到达了200M自动执行，不然即使到了一周的时间也不执行</span><br><span class="line">       compress    #压缩</span><br><span class="line">       rotate <span class="number">2</span>    #最多保留两个文件</span><br><span class="line">       sharedsripts    </span><br><span class="line">       postrotate    #在执行完日志压缩之后就执行如下动作</span><br><span class="line">               /bin/bash /root/restart.<span class="property">sh</span>    #动作就是执行这个绝对路径的脚本</span><br><span class="line">       endscript    #收工</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而这个<code>restart.sh</code>的内容很简单:<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/bin/</span>bash</span><br><span class="line">cd /mnt &amp;&amp; ./stopAUC.<span class="property">sh</span>    #停止auc进程</span><br><span class="line">cd /mnt &amp;&amp; ./startAUC.<span class="property">sh</span>    #启动auc进程</span><br><span class="line">echo <span class="variable constant_">HAHAHAHA</span>！！！    #表示已经<span class="variable constant_">OK</span>了，让我们发出杠铃一般的笑声</span><br></pre></td></tr></table></figure></p>
<p>现在我们重新跑一下logrotate，<code>logrotate -vf /etc/logrotate.conf</code>。看一下效果：<br><img data-src="/images/logrotate4.png" alt="paradin"></p>
<p>可以看到先把日志改名压缩，完事后也执行了<code>restart.sh</code>这个脚本，再日志里一看，<code>auc.log</code>也顺利生成了！<br><img data-src="/images/logrotate5.png" alt="paradin"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.pythondev.org/post/8.html">http://www.pythondev.org/post/8.html</a><br><a href="https://www.jianshu.com/p/87e2fd01393c?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation">https://www.jianshu.com/p/87e2fd01393c?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation</a><br><a href="https://segmentfault.com/q/1010000000120419">https://segmentfault.com/q/1010000000120419</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>运维技术</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器被入侵了</title>
    <url>/2018/11/27/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A2%AB%E5%85%A5%E4%BE%B5%E4%BA%86/</url>
    <content><![CDATA[<h2 id="情况描述"><a href="#情况描述" class="headerlink" title="情况描述"></a>情况描述</h2><p>今天上班，甲方爸爸在微信里叫“设备直播无法播放”，登录到zabbix发现，播放模块的服务器的<code>zabbix-agent</code>已经脱落，而且这个服务器可以ping通但是不能ssh通。</p>
<p>让机房的人去重启了一下服务器，登录之后发现里面有一个很奇怪的进程<code>watchbog</code>：<br><img data-src="/images/pastebin2.png" alt="办公室"></p>
<p>这个进程不应该出现的，同时查看<code>crontab -l</code>的内容也已经变了：<br><img data-src="/images/pastebin1.png" alt="办公室"></p>
<p>我登录了一下<code>https://pastebin.com</code>，发现这个是一个提供类似便签记事的网站，黑客应该就是现在这个网站里输入了远程的脚本，然后让这台肉鸡去curl这个网站的网页达到下载脚本然后启动了watchbog进程的目的。</p>
<p>于是我就<code>find / -name \* -type f -print | xargs grep &quot;pastebin&quot;</code>，看一下系统里都有哪些文件里含有<code>pastebin</code>这个关键词。于是乎先发现<code>/usr/bin</code>里有几个不应该存在的命令：<br><img data-src="/images/pastebin3.png" alt="办公室"></p>
<p>然后顺藤的发现几乎所有的crontab文件都已经被污染了：<br><img data-src="/images/pastebin4.png" alt="办公室"></p>
<p>把以上所有被污染的文件全部删光内容，将watchbog进程彻底杀死。观察了一会，貌似没有复现问题。</p>
<h2 id="后续解决方案"><a href="#后续解决方案" class="headerlink" title="后续解决方案"></a>后续解决方案</h2><ol>
<li>在zabbix监控上添加对watchbog进程的监控，如果出现直接通知负责人；</li>
<li>将ssh的22端口更改成33664端口，规定只有堡垒机可以登录；</li>
<li>与开发商议，确认此服务器的外网权限可以撤掉，于是撤掉外网IP；</li>
</ol>
<p>PS. <a href="http://www.4usky.com/">http://www.4usky.com/</a> <a href="https://www.shutterstock.com/zh/">https://www.shutterstock.com/zh/</a>  这俩是很不错的壁纸网站~</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>centos 6.5</tag>
        <tag>后门软件</tag>
      </tags>
  </entry>
  <entry>
    <title>日版switch搭配小火箭实现游戏加速下载</title>
    <url>/2021/02/22/%E6%97%A5%E7%89%88switch%E6%90%AD%E9%85%8D%E5%B0%8F%E7%81%AB%E7%AE%AD%E5%8A%A0%E9%80%9F%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<h2 id="背景交代"><a href="#背景交代" class="headerlink" title="背景交代"></a>背景交代</h2><p>春节期间俺响应“就地过年”的政策，就在公司内部平台上买了一个日版续航的switch（主要是为了跟媳妇玩游戏），如图：<br><img data-src="/images/switch%E5%8A%A0%E9%80%9F.jpg"></p>
<p>拿到货之后，效仿网上的攻略，注册了美区、日区、港区的账号，一一对应关联了switch的用户，然后趁着打折买了几个游戏。这里插播一句，paypal这个模式在大陆用户的心智还没有完全打开，在港区是可以使用支付宝付款的，这个对不熟悉paypal的用户来说无疑是更友好的，但是就是要注意心仪的游戏在港区什么时候会优惠，这样更划算，毕竟好玩的switch游戏都不算便宜…</p>
<p>先下载一个游戏试试手吧，在MAC上先到任天堂港区网站登录注册好的港区账号（各区的账号不通），然后 <a href="https://store.nintendo.com.hk/70010000009642">https://store.nintendo.com.hk/70010000009642</a> 买了游戏<code>Splatoon™ 2</code>在支付宝页面付了钱，等了大约5分钟，拿到了下载代码，如图：<br><img data-src="/images/switch%E5%8A%A0%E9%80%9F1.png" title="299港币兑换人民币是250块"></p>
<p>在switch里使用港区账号登录eshop，输入刚得到的游戏下载代码就可以下载对应的游戏了，但是发现下载速度奇慢，6.1G的内容下载需要40多个小时。</p>
<p>为啥这么慢？这就是要感谢国家政策了。一个游戏下载就要两天，换谁都受不了。遇到这种恶心问题我们得解决它，这里就需要一个ios shadowrocket程序(下文简称小火箭，其实其他同类型的APP也能实现代理加速游戏下载的功能)，还有一个梯子服务器。如何搭建梯子服务器可以去看<a href="https://github.com/233boy/v2ray/wiki/V2Ray%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC">https://github.com/233boy/v2ray/wiki/V2Ray%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC</a> 这篇文章。<br><img data-src="/images/switch%E5%8A%A0%E9%80%9F2.jpg" title="我这个小火箭是2.1.21版本，略老，但是大概意思是一样的"></p>
<h2 id="实战配置"><a href="#实战配置" class="headerlink" title="实战配置"></a>实战配置</h2><p>先确认你的梯子服务器是ok的，小火箭的开关是打开的，手机端可以正常翱翔。在switch的home页面里，<code>配置</code>–&gt;<code>互联网配置</code>–&gt;<code>WiFi</code>，这里需要手机端跟switch链接上同一个wifi。如图：<br><img data-src="/images/switch%E5%8A%A0%E9%80%9F3.jpg" title="这里是配置，点进去左侧菜单有互联网配置"></p>
<p>然后我们需要给switch配置一个静态IP，因为我这个版本的小火箭是需要添加IP白名单来鉴权的。配置静态IP的方法很简单，直接写死一个当前网段的IP即可，我这里写的是<code>192.168.1.7</code>。如果你家里的路由器是tplink，那么就在电脑浏览器的地址栏输入<code>192.168.1.1</code>以及对应的账号密码登录tplink的客户端，找到LAN口设置，把IP地址填写到switch配置wifi的网关里，把掩码也写到掩码的位置上。如图：<br><img data-src="/images/switch%E5%8A%A0%E9%80%9F4.png" title="网关就是你的wifi路由器当前的IP地址"></p>
<p>DNS服务器也是需要从tplink的web端里获取，一模一样的填写到对应的switch栏里：<br><img data-src="/images/switch%E5%8A%A0%E9%80%9F5.jpg" title="这几个必须填写，不然无法保存"></p>
<p>此时先连接一下这个wifi，看看switch是否可以正常连接，正常连接了才可以往下一步走，不然就要排查当前存在的问题!</p>
<p>然后在小火箭手机客户端，点击下面的<code>设置</code>，在tunnel里点击<code>代理</code>，<code>代理</code>页面里地址<code>127.0.0.1</code>不要动，端口可以自己改，建议大于8000，我这里改成了<code>8520</code>。如图：<br><img data-src="/images/switch%E5%8A%A0%E9%80%9F6.jpg"></p>
<p>然后点击<code>代理共享</code>，打开<code>启用共享</code>，记住你的地址，它是以<code>IP:端口</code>的形式出现的，然后在下面<code>允许的IP地址</code>里填写刚刚你手动写死的switch静态地址<code>192.168.1.7</code>，如图:<br><img data-src="/images/switch%E5%8A%A0%E9%80%9F7.jpg" title="这个192.168.1.106就是手机作为代理的IP，用于被switch识别"></p>
<p>返回到switch，还是在WiFi配置页面，<code>代理服务器</code>设置成启用，然后IP就是写上面红色盖住的IP，端口就是小火箭里的那个8520，自动验证选择<code>不启用</code>，如图：<br><img data-src="/images/switch%E5%8A%A0%E9%80%9F8.jpg"></p>
<p>确认其他的东西都是原状，比如<code>MTU</code>什么的都不要更改。此时保存，再次尝试一下是否可以通过wifi连接到互联网，如果可以，那就大功告成了！</p>
<p>此时你返回到switch的home页面，再次尝试下载游戏，就会看到耗时会明显降低，如图：<br><img data-src="/images/switch%E5%8A%A0%E9%80%9F10.jpg" title="效果还是不错的"></p>
<p>具体的下载速度在switch看不出来，但是可以通过小火箭的工作台来看，我这个服务器是曼谷的服务器（只是旗帜默认是美国），跟香港有一定的地理距离，速度基本维持在200K~700K幅度摇摆，6.1G的需要大约3个小时就可以下载完了。如图：<br><img data-src="/images/switch%E5%8A%A0%E9%80%9F9.jpg" title="400多K能解渴了"></p>
<p>这里要注意，一定要让switch跟手机端保持在同一个WiFi下，不然链接就会断开，下载也就中断了。</p>
<p>最后还要补充两句：</p>
<ol>
<li>这个方法只能对下载加速有效，对跨大洲联网游戏卡顿没有任何帮助，因为代理是http模式的，不是udp模式的；</li>
<li>海外版的switch应该无法识别家里路由器的5G信号，这是因为各国WiFi频道不一致导致的，如果非要让switch识别到5G信号，那就要在路由器上把工作地区调整为“美国&#x2F;日本”，这样switch就可以识别到了；</li>
<li>如果游戏一直处于“已暂停”的状态，先去查看网络是否正常工作，如果网络是好的，那么查看是不是你游玩了联网的游戏没有退出，switch默认如果有联网游戏的话，为了保证联网效果，后台下载是关闭的，即使短暂退出返回home页面也是不下载的，所以要彻底关闭其他游戏才能恢复下载；</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://sspai.com/post/58543">https://sspai.com/post/58543</a><br><a href="https://zankyo.cc/2845/">https://zankyo.cc/2845/</a><br><a href="https://www.nintendoswitch.com.cn/support/faq/410.html">https://www.nintendoswitch.com.cn/support/faq/410.html</a><br><a href="https://freewechat.com/a/MzI2NjY1MTMyMA==/2247484618/1">https://freewechat.com/a/MzI2NjY1MTMyMA==/2247484618/1</a><br><img data-src="/images/%E4%B9%94%E6%B2%BB%E8%A3%85%E9%80%BC%E4%B8%89%E5%88%86%E7%90%83.gif" title="当年乔治哥的装逼三分球"></p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>翻墙</tag>
        <tag>switch</tag>
        <tag>shadowrocket</tag>
      </tags>
  </entry>
  <entry>
    <title>那些没有代表美国男篮参加国际大赛正赛的球员们</title>
    <url>/2021/08/04/%E6%9C%AA%E4%BB%A3%E8%A1%A8%E7%BE%8E%E5%9B%BD%E5%8F%82%E5%8A%A0%E6%88%90%E4%BA%BA%E5%9B%BD%E9%99%85%E5%A4%A7%E8%B5%9B%E7%9A%84%E9%81%97%E7%8F%A0/</url>
    <content><![CDATA[<p>东京奥运会结束了，美国男篮在决赛里报了在小组赛被法国队击败之仇，金牌梦圆。虽然美国男篮拿到了冠军，让波波维奇可以扬眉吐气，但是这一路走的实在是磕磕绊绊，有点悉尼奥运会的味道。</p>
<p>美国篮球人才储备很多，“梦一”、“梦二”、“梦三”、“梦八”、“梦十”这些都是强大无敌的代言词。在历年梦之队名单里也不乏多次为国效力的球员，但是还有一些球员，他们也有全明星的身手以及不低的人气，却始终与梦之队正式名单缘悭一面。迄今为止，我个人认为没有参加过梦之队的遗珠名单如下：</p>
<h2 id="克里斯韦伯"><a href="#克里斯韦伯" class="headerlink" title="克里斯韦伯"></a>克里斯韦伯</h2><p>今年5月，克里斯韦伯在前几次提名失败后，终于成为了篮球名人堂的一份子，他虽然在NCAA+NBA都没有拿过冠军，但是他却是美国篮球界里响当当的人物，无论是在密歇根五虎还是国王的“普林斯顿”战术里，他的高位策应、风骚传球、个人单打能力、一手暴扣和那人畜无害的笑容都赢得了很多的粉丝。韦伯的职业生涯高光时间主要集中在1997年~2002年，2003年他由于手术只打了半个赛季，之后就开始走下坡路。也就是说以他的能力，98年希腊世锦赛和2000年悉尼奥运会的美国国家队正式大名单里应该会有他的一席之地，当然事实里他在98年也打算为国出战，甚至连队服的照片都拍好了，但是由于劳资纠纷，NBA职业球员没有参加世锦赛而是叫一帮美国CBA联盟的球员去参加，所以韦伯错失了他这辈子里唯一一次能拿成人篮球冠军的机会。</p>
<p>再补一句，克里斯韦伯高大帅气，他现在的老婆是一个著名模特，他的前女友“黑珍珠”泰拉班克斯也是曾经的名模+红人，地位不比现在的卡戴珊差很多。<br><img data-src="/images/%E9%9F%A6%E4%BC%AF%E5%9B%BD%E5%AE%B6%E9%98%9F%E7%85%A7.webp"></p>
<h2 id="拉希德华莱士"><a href="#拉希德华莱士" class="headerlink" title="拉希德华莱士"></a>拉希德华莱士</h2><p>怒吼天尊是一个碎嘴子，他虽然在吃T和推推搡搡这方面很在行，但是真正动粗的镜头并不多。可能也就是他这种直筒子性格外加“黑人卫士”的人设，让美国国家队官员们觉得放他出国打比赛很容易在赛场上暴走，要是再被一些“境外势力”的记者访问一些有的没的，那张破嘴更有可能将事态上升为外交事件，所以即使在天尊鼎盛的1998年~2006年这4次国际大赛的机会里，他都没有得到美国队的呼唤，其实天尊的低位防守是很赞的，但是就连石佛都要吐槽的FIBA规则，估计换成了天尊，也要抓狂一下。</p>
<p>既然说到了华莱士，不得不提到慈世平，这哥们也是总冠军加全明星身手，但是没有被美国国家队待见的一份子。再外加上另一个著名球员—拉特里尔斯普雷维尔，这位仁兄当年差点把他教练掐死，“杀人未遂”者身披国家队战袍上国际赛场，实在有辱国体。</p>
<h2 id="莱纳德"><a href="#莱纳德" class="headerlink" title="莱纳德"></a>莱纳德</h2><p>莱纳德是现役球员中仅次于大小王的存在，但是我很好奇这个在东西部都拿过总决赛MVP的球员却一直没有被征召到美国国家队里。莱纳德曾经在2018年参加过梦之队在拉斯维加斯的训练营，但是在敲定他转会猛龙兑换来德罗赞之后，他就离开了训练营。球迷普遍的猜测他一直没有成为梦之队正式一员的原因就是因为当今的美国梦之队教练正是莱纳德的老熟人—波波维奇，因为他俩曾经有过不算很和谐的过去，所以两人再次见面，难免要红眼或者红着脸。不过现在波波维奇在东京已经算是一雪前耻，证明了自己依旧是那个冠军教头，再加上这几年马刺队成绩不上不下，波波老爷子大概率会辞去梦之队教练的职务，届时莱纳德入选梦之队应该会成为现实。</p>
<h2 id="拉简隆多"><a href="#拉简隆多" class="headerlink" title="拉简隆多"></a>拉简隆多</h2><p>隆多有过近距离接触梦之队，2008年的梦八，他被大名单剔除，气愤的他说“耐克控制了国家队大名单”。2010年土耳其世锦赛备战的时候，隆多跟着当时美国梦之队一起远赴欧洲去热身拉练，但是他却不得老K的欢心，四场热身赛里老K给他的比赛时间逐渐减少：与立陶宛队，隆多表现不佳，首发出场的他在比赛的头14分钟时间里，有四次失误；在与西班牙队的比赛中，他干脆坐上了替补席。所以隆多在世锦赛临开始的时候宣布因“个人原因”离开国家队。</p>
<p>隆多自己解释是“个人原因”是：“亲人离世”、“思乡”外加“报总决赛抢七输给湖人一箭之仇”，其实他没有被老K看中还有一层技术原因：FIBA没有三秒区，国际强队经常是囤积内线，放空外线。而且对手也多善于联防。后卫要有较强的投射能力，众所周知朗多的远投很是不稳定，更何况那届后卫已经有5人之多。而且隆多的脾气性格更硬，跟保罗打过架、跟小牛队前功勋教练卡莱尔不和。所以这个隐患也是让美国队没有挽留他的一个原因。<br><img data-src="/images/%E9%9A%86%E5%A4%9A%E5%9B%BD%E5%AE%B6%E9%98%9F%E7%85%A7.jpg"></p>
<h2 id="格里芬"><a href="#格里芬" class="headerlink" title="格里芬"></a>格里芬</h2><p>这个名单里我个人最惋惜的就是“给力芬”，以“扣将”出道的他当年人气无双，但是却多次冲击西决失败的他，更是需要一个奥运会金牌来弥补自己团队荣誉为零的尴尬，其实他也入选过美国梦十队，可以后来因为左膝盖软骨撕裂的伤势而无奈退出那届伦敦奥运会的最终名单，那时候他刚跟快船签了五年价值9500万的合同。而这一次伤病也让他的职业生涯出现了断崖式下跌，虽然这个赛季加入了篮网，但是功力恢复了几成，还是否能有为国出战的机会已经成了问号。</p>
<p>不过当年玫瑰罗斯大伤之后，随队出战在西班牙举办的男篮世界杯。也祝格里芬好好恢复，也能有这样一个机会吧。<br><img data-src="/images/%E6%A0%BC%E9%87%8C%E8%8A%AC%E5%9B%BD%E5%AE%B6%E9%98%9F%E7%85%A7.jpg"></p>
<h2 id="贾马尔-克劳福德"><a href="#贾马尔-克劳福德" class="headerlink" title="贾马尔-克劳福德"></a>贾马尔-克劳福德</h2><p>这位仁兄可以说是街头篮球的图腾，历史最佳第六人的代表。无论是他的J.corssover还是用手腕甩出来的中远投都十分具备观赏性，每次看着他运着球很若无其事的拉过去拉回来，再拉过去再拉回来，骚的一匹。但是这么优秀的替补球员却始终与全明星没缘分，主要的原因就是他同时代的后场球员都太强，他谁也顶替不下来，自然也不会得到国家队的青睐。</p>
<p>克劳福德拿过好几次单场50+，后期三分球得分占据了他总得分六成的比重，他拿手的正是那套潇洒的蝴蝶穿花过人然后一个中远投了事。可见他善于独立作战而不是在进攻体系里，板凳是他的最好开发火力的地方，而且他还不愿意增重和联系防守，也不关注篮板，所以说他是NBA里的街头浪客一族，是一道独特的风景。</p>
<h2 id="阿里纳斯"><a href="#阿里纳斯" class="headerlink" title="阿里纳斯"></a>阿里纳斯</h2><p>作为当年From Zero To Hero的阿迪五巨头之一，他的高光生涯是比较短暂的，但是在他的2003~2006年里，是完全有资格代表美国国家队出场的，要知道杀疯了的阿里纳斯曾一度是MVP的前几名。但是他在06年被美国梦之队当时的负责人杰里·克朗吉洛最后裁掉，这也让他认为是人生的奇耻大辱，于是面对杰里·克朗吉洛担任经理的太阳队，阿里纳斯疯狂砍下54分，并带领球队通过加时力克对手，终止了太阳的15连胜。纳什对那场比赛一定也印象深刻，拼尽全力拿下的42分12次助攻在杀红眼的阿里纳斯面前没了价值。07年美国国家队再次对他发出邀请，但是他以“膝伤未愈”直接拒绝了，0号探员这种有仇必报的草根性格也是他被球迷追捧的原因。</p>
<p>2007-08赛季阿里纳斯就有了下滑的趋势，当时的他只有25岁，结果却在新赛季的第8场比赛遭遇膝盖伤病。再加上后来的“更衣室持枪门”，他成了被“扫黑除恶”的典型，早早的离开了主流视野，但是他并不是骗钱的人，拿了大合同的他并不是悠哉悠哉的吃爆米花看HBO，而是积极地复建，只不过他的身体已经支持不住他的身体了。跟后来的罗伊和小以赛亚托马斯一样，心比天高，命比纸薄，但是他比罗伊有更严重的性格问题，复出更是镜中花，只能让人一声叹息。<br><img data-src="/images/%E9%98%BF%E9%87%8C%E7%BA%B3%E6%96%AF%E5%9B%BD%E5%AE%B6%E9%98%9F%E7%85%A7.jpg"></p>
<h2 id="阿尔德里奇"><a href="#阿尔德里奇" class="headerlink" title="阿尔德里奇"></a>阿尔德里奇</h2><p>这哥们跟格里芬一样，曾经入选了梦十队，但是由于受伤最后也没成行，那一次没成行以后就再也不行了…这个赛季又爆出得了心脏病而不得不退役，不得不说阿尔德里奇的天赋很棒，但是他没有达到人们对他的期望值。</p>
<h2 id="扎克兰多夫"><a href="#扎克兰多夫" class="headerlink" title="扎克兰多夫"></a>扎克兰多夫</h2><p>兰多夫以前在波特兰就是一个屌屌的混混，属于数据好看但是战绩乌鸦而且场下乱事一堆的球员，当年开拓者也是认为他可以担当大任于是放走了天尊华莱士，后来发现他就是一个毒瘤。而到了2009年到了孟菲斯后，端正了打球态度的这位大黑胖子，正式成为了那头“黑熊”，而且我强烈的怀疑灰熊现在的队标是按照兰多夫的脸画的。兰多夫手感柔和，面框背框能力俱佳，尤其抢前场篮板二次得分更是一绝。虽然他命中率不算高，但是在禁区里搅合的能力是当时联盟前五。</p>
<p>2009~2014年是扎克兰多夫的巅峰期，但是中途11年受重伤一次，几乎报废了一年。以他的巅峰身手参加内线贫瘠的美国队是绰绰有余，无论是搭配钱德勒还是后来的浓眉戴维斯应该都会有不错的效果。而且像兰多夫这种壮内线，无论是法国还是西班牙都有类似的球员。但是我觉得美国国家队不带他的主要原因就是，当时美国队更想把“小快灵”进行到底，而兰多夫是主打阵地进攻，慢慢磨的类型，如果可以他甚至能从三分线开始靠打，这与美国男篮的主流战术不合。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>其实说来说去，没有被梦之队选中的外界原因，无非就是“能力问题”、“性格形象问题”和“伤病问题”。上面那个列表里，除了格里芬、隆多和莱纳德是现役球员，其他都已经是退役球员了。至于格里芬和莱纳德将来说不定还有为国出战的机会。还有比如前状元唐斯，他是美国\多米尼加双重国籍，如果他选择了美国籍，那么将来为梦之队出战是迟早的事儿。而西蒙斯、胖虎威廉森等新生代现役球员，他们只是暂时没有进入梦之队大名单，要是保持健康、稳定进步的话，成为梦之队一份子不是大问题。</p>
<p>不过有自媒体传言，参加奥运会的奖金不过才3.75万美元（来源：<a href="https://www.sohu.com/a/483529793_120834764">https://www.sohu.com/a/483529793_120834764</a> ），对于这些NBA的千万富翁来说，也就是一顿酒的价钱。而在一个难得的假期又要集训打那么多比赛，增加了受伤的几率，比如上面提到的克里斯韦伯，韦伯在2000年打出了例行赛MVP排名第四的表现，他要在2001年续合同，于是就很自然的放弃了2000年的国家队，就是为了不受伤。最最重要的是相比较NBA总冠军，奥运会金牌实在也不是什么含金量很高的荣誉，所以现在球星身披梦之队战袍的意愿越来越低。再加上美国队现在明显内线长人质量不高，所以梦之队越来越平民化是未来的趋势，但是我觉得梦之队带上一名NCAA球员是一个不错的举动，虽然美国篮协一直没有明文规定这个事儿，但是我觉得这个“选择”以后可以持续下去。</p>
<p>以上九位球员是我个人认为梦之队的遗珠，虽然有了奥运会金牌对他们的历史地位不会有多大的影响，但是这个Olympic champion也是一个champion，能让他们一尝冠军滋味，为职业生涯少一个团队冠军的遗憾。</p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>篮球</tag>
        <tag>奥运会</tag>
        <tag>NBA</tag>
      </tags>
  </entry>
  <entry>
    <title>看杂书摘录</title>
    <url>/2022/10/07/%E6%9D%82%E4%B9%A6%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<p>最近读了两本电子书—《从甲午到抗战》、《中国底层访谈录》。这俩本书的风格完全不同，一本是台湾风格味很浓，讲述的是可歌可泣的民族抗争史，另一本就是重庆成都那种混不吝的文风，讲述底层人民的奇事乃是荒诞的故事。一个是记述大历史，一个是讲述小草民。但是不耽误，吃了鱼翅牛排也要吃吃油条豆腐脑。</p>
<h2 id="有感言的句子"><a href="#有感言的句子" class="headerlink" title="有感言的句子"></a>有感言的句子</h2><p>集体的狂欢突然之间沦为集体的痛苦。痛苦吗？痛苦是为欢乐所付的门票，记忆是为遗忘所付的门票。</p>
<p>她一手遮天，又网开一面。</p>
<p>人生先做加法，后做减法。许多人一辈子做加法，结果越活越累，累死不到头。</p>
<p>这是个不需要记忆的时代，一个人出车祸死了，脑浆涂满的轮胎依旧要在道路上滚动。</p>
<p>三年自然灾害饿死人一片接一片，我也照吹天下太平调，孝子当多了，人就没啥心肝。</p>
<p>一个人在公众面前，说了400多集“真话”，你相信吗？看电视节目上瘾的人，一般来说智力都比较低，因为电视的节奏使人不可能更深地思考问题，长期不思考，脑子就报废了。</p>
<p>我一进去亮出身份，大伙都笑了，问：艺术家？画画、写诗还是唱歌的？我说搞行为。大伙说，那叫啥艺术家？我们都搞行为。</p>
<p>我们这代人都这样，自我中心，不屑于了解父辈的内心世界，却口口声声称自己为“艺术家”。</p>
<p>谋士的尴尬处，自己觉得自己能力很强，不想甘居人下，但是又没找到一个好大腿，或者大腿又权力而无兵力。以至于自己“喜欢谈政治而不能搞政治”。</p>
<p>管内政的人，总是要规规矩矩、老老实实地做事。因此养成过半习惯。可是管外交的人，总是不重实际，专务外表，有时且专讲假话。</p>
<h2 id="词汇学习"><a href="#词汇学习" class="headerlink" title="词汇学习"></a>词汇学习</h2><p>台湾人写书，一些用语在大陆的书里并不常见，记录如下，以后用的时候可以装逼：<br>1.其为人也小有才,未闻君子之大道也</p>
<p>2.自郐以下</p>
<p>3.肉袒牵羊：2023春节补充，春节档有一个电影叫《满江红》，讲岳飞的，正好想起来这个成语。记得2021年有一个手游叫《江南百景图》，有一个活动就是给古代名人配一个属相。比如周瑜是兔，林则徐是虎等等。游戏里给岳飞安排的是羊，然后做的图是岳飞光个膀子旁边一只羊的造型，如图：<br><img data-src="/images/%E6%B1%9F%E5%8D%97%E7%99%BE%E6%99%AF%E5%9B%BE%E5%B2%B3%E9%A3%9E.png" title="左边是最开始的造型，右边是被举报后修改的样子"></p>
<p>结果被网友依这个成语而怒喷，说游戏官方夹杂私货有所企图，后来游戏官方不得不道歉修改。</p>
<p>4.不待智者而后明：不能等到别人去提醒你才去知道</p>
<p>5.去后之思：指地方士民對離職官吏的懷念</p>
<p>6.甘棠遗爱：表示对贤官廉吏的爱戴或怀念</p>
<p>7.凿枘不投：格格不入</p>
<p>8.治丝益棼（zhì sī yì fén）：是理丝不找头绪，结果越理越乱。比喻解决问题的方法不对，反而使问题更加复杂</p>
<p>9.颟顸（mān hān）：拎不清，不明事理，糊里糊涂</p>
<p>10.九秩</p>
<p>11.遽萎（jù wěi）</p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>每两周执行一次定时任务</title>
    <url>/2020/09/12/%E6%AF%8F%E4%B8%A4%E5%91%A8%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<p>crontab这个定时工具单对于日期默认颗粒度是“单”，也就是单天，单周，单月等等，但是如果需要每双周发送一次消息，那么原生态的crontab就做不到了。</p>
<p>正确的写法是：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">59</span> <span class="number">11</span> * * <span class="number">5</span> expr `date +\%W` \% <span class="number">2</span> &gt; /dev/null || cd /opt/golangproject &amp;&amp; ./DingdingBot &gt; golang钉钉机器人.log <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>这个规则的意思就是每双周的周五11点59分，启动DINGdingBot这个脚本。</p>
<p>先说<code>expr</code>,这是一个计算命令，一般用于整数值，比如<code>expr 14 % 9</code>，返回就是5。那么这个脚本的意思就很明白了，先用<code>date +\%W</code>获取当前的周数，如果可以被2整除，就是0，0可以执行后面的语句，如果不能被2整除，那么后面的语句也就不会执行。其实说白了，就是每周五的11点59分，判断一下当前周数是否是2的倍数，如果是就可以去执行脚本，如果不是就无视掉。</p>
<p>最后推荐一个好网站可以查看crontab的效果：<a href="https://www.matools.com/crontab">https://www.matools.com/crontab</a> ，不过这个网站只能看基础的crontab配置，想玩花就不行了。<br><img data-src="/images/%E5%8F%8C%E9%AC%BC%E5%A4%B9%E9%97%A8.jpg"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>定时任务</tag>
        <tag>Crontab</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析django里models.py、views.py与网页之间的爱恨纠葛</title>
    <url>/2018/05/14/%E6%B5%85%E6%9E%90django%E9%87%8Cmodels-py%E3%80%81views-py%E3%80%81page%E4%B9%8B%E9%97%B4%E7%9A%84%E7%BA%A0%E8%91%9B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Django + Boostrap</code>现在是运维开发的必备技能，因为他俩是运维可视化的关键技术，而本文就是简单说一下整个Django的<code>数据库---后台---前端</code>的工作原理。其实所谓Django开发，就是熟悉了 Django的规则之后，按照它的规则去填空，填你自己想要展现的东西。</p>
<p>环境：<code>django 2.0</code> + <code>python 3.6</code> + <code>pycharm 2018</code>  </p>
<p>django建立一个app之后就会有<code>models.py</code>、<code>views.py</code>、<code>admin.py</code>这几个文件，他们三个分别的用途如下： </p>
<p>1. <code>models.py</code>主要是用来设置数据在数据库的存储格式（比如默认值，字段类型和字段长度等等）;<br>2. <code>admin.py</code>是用来设置在&#x2F;admin&#x2F;后台里面的显示样式;<br>3. <code>views.py</code>是用来设置在前台网页里的显示样式；<br>4. <code>urls.py</code>是用来编辑域名规则；</p>
<p>上面4个文件里，重中之重的就是<code>views.py</code>，说它是整个django的灵魂都不为过！所以要是掌握了它，基本就明白了大半个django了。  </p>
<h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>假设有一个<code>models.py</code>，内容如下：     <br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.db import models     </span><br><span class="line">from django.contrib.auth.models import User   </span><br><span class="line">   </span><br><span class="line">class BlogType(models.Model):         </span><br><span class="line">	type_name = models.CharField(max_length=15)    #规定type_name是一个最大为15字节的charfield          </span><br><span class="line">def __str__(self):             </span><br><span class="line">	return &#x27;&lt;BlogType:%s&gt;&#x27; % self.type_name     </span><br></pre></td></tr></table></figure><br>	<br>然后随便加入一些内容，如图：<br><img data-src="/images/type_name1.png" alt="paradin"><br>	<br>而在<code>views.py</code>里，要求在前端网页里如此的显示：     <br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.shortcuts import render_to_response,get_object_or_404     </span><br><span class="line">from .models import BlogType    #这里引用了models.py里的那个class </span><br><span class="line">    </span><br><span class="line">def blog_list(request):         </span><br><span class="line">	context = &#123;&#125;         </span><br><span class="line">	context[&#x27;blog_types&#x27;] = BlogType.objects.all()         </span><br><span class="line">	return render_to_response(&#x27;pageblog/blog_list.html&#x27;,context)     </span><br></pre></td></tr></table></figure></p>
<p>在<code>views.py</code>里规定，如果有访问域名是<code>/blog_list/</code>的网页，就返回<code>pageblog/blog_list.html</code>这个页面，而这个<code>blog_list.html</code>只是一个框架，里面的内容是<code>context</code>。<code>context</code>本身是一个字典，里面的key对应的value是用ojbects这个函数获得的，<code>objects.all()</code>就是获取全部的意思。用来填充<code>blog_list.html</code>的context里面有<code>blog_types</code>这个key。</p>
<p>那么现在就可以在<code>blog_list.html</code>里使用<code>blog_types</code>这个key了，如下：     <br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 前面略 --&gt;     </span><br><span class="line">&lt;h4&gt;博客分类&lt;/h4&gt;     </span><br><span class="line">&lt;h3&gt; &#123;&#123; blog_types &#125;&#125; &lt;/h3&gt;     &lt;!-- html文件要用views.py里的变量要加上&#123;&#123;&#125;&#125; --&gt;</span><br><span class="line">&lt;!-- 后面略 --&gt;     </span><br></pre></td></tr></table></figure></p>
<p>这样的效果如下：<br><img data-src="/images/type_name2.png" alt="paradin">  </p>
<p>返回的是<code>QuerySet</code>类型，<code>QuerySet</code>是Django的查询集，可以通过<code>QuerySet</code>条件查询得到对应模型的对象集合。由此看出<code>blog_types</code>已经成功的引入到了<code>blog_list.html</code>里。</p>
<p>至于拆成每一个“博客类型”就很简单了，html部分如下：    <br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h4&gt;博客分类&lt;/h4&gt;                 </span><br><span class="line">&lt;!-- ul是无项目的标签 --&gt;                 </span><br><span class="line">&lt;ul&gt;                     </span><br><span class="line">	&#123;% for blog_type in blog_types%&#125;    #开始一个for循环                         </span><br><span class="line">		&lt;li&gt;&lt;a href=&quot;&#123;% url &#x27;blogs_with_type&#x27; blog_type.pk %&#125;&quot;&gt;&#123;&#123; blog_type.type_name &#125;&#125; &lt;/a&gt;&lt;/li&gt;        #对每一个类型加上一个a链接                     </span><br><span class="line">	&#123;% empty %&#125;        #如果为空就说“暂无分类”                         </span><br><span class="line">		&lt;!--  li是具体的项目 --&gt;                         </span><br><span class="line">		&lt;li&gt; 暂无分类 &lt;/li&gt;                     </span><br><span class="line">	&#123;% endfor %&#125;                     </span><br><span class="line">&lt;/ul&gt;     </span><br></pre></td></tr></table></figure></p>
<h2 id="再说urls-py"><a href="#再说urls-py" class="headerlink" title="再说urls.py"></a>再说urls.py</h2><p>上面说过了，<code>urls.py</code>是配置域名路由规则的。它的格式比较简单，就是<code>path(&#39;域名&#39;，views.py里的函数，name=&#39;自定义名称&#39;)</code>。比如下面这<code>个urls.py</code>：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.<span class="property">contrib</span> <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.<span class="property">urls</span> <span class="keyword">import</span> include,path</span><br><span class="line"><span class="keyword">from</span> article.<span class="property">views</span> <span class="keyword">import</span> blog_list		#article是django项目里自己创建的一个app</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="title function_">path</span>(<span class="string">&#x27;&#x27;</span>,blog_list,name=<span class="string">&#x27;home&#x27;</span>),	#这里的name可写可不写，如果写的话，在href跳转的时候就可以直接用</span><br><span class="line">    <span class="title function_">path</span>(<span class="string">&#x27;admin/&#x27;</span>, admin.<span class="property">site</span>.<span class="property">urls</span>),</span><br><span class="line">    <span class="title function_">path</span>(<span class="string">&#x27;blog/&#x27;</span>,<span class="title function_">include</span>(<span class="string">&#x27;article.urls&#x27;</span>)),	#引用的的include方法用在这里</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>上面这个是总的路由文件，当然可以把所有的app的路由都写到里面去，也可以在各自的app下写各自的路由，这样方便管理。比如我就在<code>article</code>这个app文件夹下面又单独了一个<code>urls.py</code>，这里面所有的域名就会自动添加<code>blog/</code>这个路径，而整个<code>urls.py</code>内容如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.<span class="property">urls</span> <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="title function_">path</span>(<span class="string">&#x27;&lt;int:blog_pk&gt;&#x27;</span>,views.<span class="property">blog_detail</span>,name=<span class="string">&#x27;blog_detail&#x27;</span>),	</span><br><span class="line">    <span class="title function_">path</span>(<span class="string">&#x27;type/&lt;int:blog_type_pk&gt;&#x27;</span>,views.<span class="property">blogs_with_type</span>,name=<span class="string">&#x27;blogs_with_type&#x27;</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><br>在上面的第一个path里，目的就是传入一个值<code>blog_pk</code>，而这个<code>blog_pk</code>就是在<code>views.py</code>里的<code>blog_detail</code>函数需要传入的参数，跟<code>request</code>一样。上面也说过了，这个两个path都会自动在前面加上<code>/blog/</code>路径。</p>
<h2 id="views-py与前端"><a href="#views-py与前端" class="headerlink" title="views.py与前端"></a>views.py与前端</h2><p>如何把数据库里的内容映射到前端页面呢？就是用<code>views.py</code>里的<code>render_to_response</code>，它是负责渲染的。<code>render_to_response</code>的用法是后面要加上对应的html页面和要映射的内容，比如下面这个<code>views.py</code>:<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.<span class="property">shortcuts</span> <span class="keyword">import</span> render_to_response,get_object_or_404</span><br><span class="line"><span class="keyword">from</span> .<span class="property">models</span> <span class="keyword">import</span> <span class="title class_">Blog</span>		#这里引用了models.<span class="property">py</span>里面的类：<span class="title class_">Blog</span></span><br><span class="line"></span><br><span class="line">def <span class="title function_">blog_detail</span>(request,blog_pk):		#每一次使用这个函数都要传入一个参数：blog_pk</span><br><span class="line">    context = &#123;&#125;</span><br><span class="line">    context[<span class="string">&#x27;blog&#x27;</span>] = <span class="title function_">get_object_or_404</span>(<span class="title class_">Blog</span>,pk=blog_pk)	#通过get_object_or_404这个方法生成一个字典</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">render_to_response</span>(<span class="string">&#x27;blog_detail.html&#x27;</span>,context)	#这个blog_detail.<span class="property">html</span>就是对应的前端页面</span><br></pre></td></tr></table></figure></p>
<p>从上面可以看到，<code>views.py</code>先引入了数据库文件<code>models.py</code>里的<code>Blog</code>这个class，然后设定一个空字典，将这个字典按照对应数据库默认的主键pk与浏览器输入的pk一一对应填满，最后就是按照<code>blog_detail.html</code>为前端框架，里面赋予整个填满值的context字典。</p>
<p>而对应的前端页面<code>blog_detail.html</code>如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">        &lt;meta charset=&#x27;UTF-8&#x27;&gt;</span><br><span class="line">        &lt;title&gt;&#123;&#123; blog.title &#125;&#125;&lt;/title&gt;		&lt;!-- 这里的blog就是views.py里context[&#x27;blog&#x27;]里的blog --&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">                &lt;a href=&quot;&#123;% url &#x27;home&#x27; %&#125;&quot;&gt;		&lt;!-- 这里就是返回首页，home是在urls.py里设定的 --&gt;</span><br><span class="line">                        &lt;h2&gt;BACK TO HOMEPAGE&lt;/h2&gt;</span><br><span class="line">                &lt;/a&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;h3&gt;&#123;&#123; blog.title &#125;&#125;&lt;/h3&gt;</span><br><span class="line">        &lt;p&gt;作者：&#123;&#123; blog.author &#125;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;分类：</span><br><span class="line">                &lt;a href=&quot;&#123;% url &#x27;blogs_with_type&#x27; blog.blog_type.pk %&#125;&quot;&gt;	&lt;!-- 就是将blog.blog_type.pk作为views.py里blog_detail函数的传入值 --&gt;</span><br><span class="line">                        &#123;&#123; blog.blog_type &#125;&#125;	</span><br><span class="line">                &lt;/a&gt;</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;p&gt; &#123;&#123; blog.blog_type.pk &#125;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;发表时间：&#123;&#123; blog.created_time|date:&quot;Y-m-d H:i:s&quot;&#125;&#125;&lt;/p&gt;	&lt;!-- 这里将输出时间做了规范化 --&gt;</span><br><span class="line">        &lt;hr&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123; blog.content &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈mysql的索引</title>
    <url>/2023/08/18/%E6%B5%85%E8%B0%88mysql%E7%9A%84%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h2 id="哪些情况不走索引"><a href="#哪些情况不走索引" class="headerlink" title="哪些情况不走索引"></a>哪些情况不走索引</h2><ol>
<li>隐式转化，说白了就是两边的参数的格式不一致，详情可见<a href="https://dev.mysql.com/doc/refman/5.7/en/type-conversion.html%EF%BC%9A">https://dev.mysql.com/doc/refman/5.7/en/type-conversion.html：</a>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 表字段类型和传参类型不一致，导致MySQL进行了类型转换。比如传入了`数值型`的值，而表结构中这个字段是`字符串`的。MySQL在处理这个类型不一致的时候，会进行隐式转化，转换成浮点型的类型，导致MySQL无法使用索引。</span><br><span class="line">2. JOIN 的时候，两张表JOIN的字段对应字符集不一致，也会导致隐式转化。</span><br><span class="line">3. 当where查询操作符左边为数值类型时发生了隐式转换，那么对效率影响不大，但还是不推荐这么做。当where查询操作符左边为字符类型时发生了隐式转换，那么会导致索引失效，造成全表扫描效率极低。</span><br></pre></td></tr></table></figure></li>
<li>函数运算：在字段上进行函数运算。如 <code>where a+1 = 1 ;</code>  <code>where DATE_FORMAT(c,&#39;%Y&#39;) = &#39;2024&#39;</code> <code>where upper(lastname)=&#39;smith&#39;</code>这样的。</li>
<li>like百分号前缀匹配: <code>where c1 like &#39;%xxxx&#39;;</code></li>
<li>非值查询：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. where a not in (1,2,3)</span><br><span class="line">2. where a != 1</span><br></pre></td></tr></table></figure></li>
<li>当cpu、内存、磁盘容量很高的时候，可能也会导致优化器没有充足资源去评估可能的执行计划，从而选错索引，所以数据库的系统水位和系统配置还是要保持健康。(我曾经见过一次客户端链接风暴，2分钟内创建了3万个链接，每个链接是256k内存，一下子就吃掉了7.5G内存，导致实例出现oom)</li>
<li>应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如<code>select id from t where num=10 or num=20;</code>可以这样查询：<code>select id from t where num=10 union all select id from t where num=20;</code>。</li>
</ol>
<h2 id="如何使用explain"><a href="#如何使用explain" class="headerlink" title="如何使用explain"></a>如何使用explain</h2><p>当我们分析为啥一个sql这么慢，我们肯定要用到<code>explain</code>命令，我们需要重点关注：</p>
<ol>
<li>id列：当 id 相同时，执行顺序由上向下；当 id 不同时，id 值越大，优先级越高，越先执行。</li>
<li>type列：如果出现<code>ALL</code> <code>INDEX</code> 需要重点关注，表示的是该表在执行计划中是全表扫描或者全索引扫描，性能分别是倒数第一和倒数第二。</li>
<li>rows列：表示的是通过索引过滤后有多少记录。一般来说，执行计划中这个列如果出现比较大的，就需要注意。如果出现扫描行数大于1000，但是只返回2条，那说明索引、SQL等存在优化的空间。</li>
<li>extra列：如果出现了<code>Using filesort</code>或者<code>Using temporary</code>，说明MySQL没有办法利用索引本身的有序性进行排序。此时，需要关注前面的rows是否有超过2000行以上。如果超过，排序成本会变高。</li>
<li>filtered列：表示的是返回行数和通过索引扫描的行数比值，最大值100，表示不需要回表过滤。filter 越小，说明索引优化的空间越大。</li>
</ol>
<p>举个例子：<br><img data-src="/images/%E7%B4%A2%E5%BC%95.png" alt="paradin" title="重点看上面说的那几列"></p>
<h2 id="优化法则"><a href="#优化法则" class="headerlink" title="优化法则"></a>优化法则</h2><ol>
<li>单表查询，返回的数据行数，小于整个表的30%，建议在这个字段上加上索引（非绝对）。</li>
<li>返回行数 &#x2F; 扫描行数  &lt; 1&#x2F;50，需要确认选择性好的字段是否都在索引里面。</li>
<li>SQL查询要遵守MySQL最左匹配原则，尽量将选择性好的字段放在索引的前面。</li>
<li>当过滤成本和排序成本两者不可兼得时，可以考虑牺牲成本较小的操作，来成全成本较大部分。</li>
<li>等值查询的字段尽量放在组合索引的左侧，范围查询的字段放在组合索引的右侧。</li>
<li>提高SQL filter。1：避免回表查询；2：降低无效索引扫描</li>
</ol>
<h2 id="基础知识，留给你面试装逼用"><a href="#基础知识，留给你面试装逼用" class="headerlink" title="基础知识，留给你面试装逼用"></a>基础知识，留给你面试装逼用</h2><ol>
<li>MySQL 索引是<code>B+Tree</code>数，是有序树。</li>
<li>MySQL组合索引<code>idx_ab(a, b,)</code>中，是先根据a排序。a相同的情况下，再根据b排序。</li>
<li>MySQL索引使用遵循最左匹配原则，针对a,b字段组合索引，需要先判断where条件里面有无a字段，如果没有，大概率是没办法走a,b 的组合索引的；如果有的话，再去判断b 字段是否在where条件里面</li>
</ol>
<p>使用索引的关注点：1. 过滤能否走索引，2. 排序能否走索引。</p>
<p>索引字段选择性：</p>
<ol>
<li>字段选择性代表这个字段在这个表里面的唯一性程度，例如我们需要查找某个员工的具体信息，已知道的条件是 where 部门&#x3D;’数据库产品事业部’ and 名字&#x3D;’张三’ and 性别&#x3D;’男’，那按照我们对数据分布的理解，“名字”是三个条件中选择率最高的列，如果创建单列索引，“名字”列上建索引是最好的选择。</li>
<li>字段选择性 &#x3D;  COUNT(DISTINCT col) &#x2F; COUNT(*) ，字段选择性越趋向于1，选择性越好。要提高定位效率，就要在选择率高的列上创建索引。</li>
<li>字段选择性越好，该字段上的查询越适合建立索引。</li>
</ol>
<h2 id="常见优化经典案例"><a href="#常见优化经典案例" class="headerlink" title="常见优化经典案例"></a>常见优化经典案例</h2><ol>
<li>缺失索引<br>sql:<code>select c1,c2 from t where c3=10086;</code><br>表结构：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;,</span><br><span class="line">  `c1` bigint(20) DEFAULT &#x27;0&#x27;,</span><br><span class="line">  `c2` bigint(20) DEFAULT &#x27;0&#x27;,</span><br><span class="line">  `c3` bigint(20) DEFAULT &#x27;0&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>查询扫描了100万行，返回了1行。原因是由于c3上面没有索引，导致SQL执行了全表扫描。explain一下的结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----+-------------+--------+------------+------+---------------+------+---------+------+---------+----------+-------------+</span><br><span class="line">| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows    | filtered | Extra       |</span><br><span class="line">+----+-------------+--------+------------+------+---------------+------+---------+------+---------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      |    t   | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 1000000 |    10.00 | Using where |</span><br><span class="line">+----+-------------+--------+------------+------+---------------+------+---------+------+---------+----------+-------------+</span><br></pre></td></tr></table></figure>

<p>因此可以在字段c3 上面添加一个普通索引。如果c3 是唯一，可以添加唯一索引。<code>alter table t add index idx_c3(c3);</code></p>
<ol start="2">
<li>索引优化1<br>sql:<code>explain  SELECT * FROM slow_log_history where sql_id=&#39;88891227eb51726145bf033966bc4574&#39; and &#39;slow_date&#39; =&#39;2024-07-15&#39;;</code></li>
</ol>
<p>表结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `slow_log_history` (</span><br><span class="line">  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;,</span><br><span class="line">  ...</span><br><span class="line">  `sql_id` varchar(100) DEFAULT NULL COMMENT &#x27;库名&#x27;,</span><br><span class="line"> ...</span><br><span class="line">  `slow_date` date DEFAULT &#x27;1970-01-01&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `idx_sql_id` (`sql_id`),</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=2124700 DEFAULT CHARSET=utf8</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>查询扫描了133行，返回了1行。其中filter 只有3.07，说明很多数据都需要回表判断。explain一下的结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain  SELECT * FROM slow_log_history where sql_id=&#x27;88891227eb51726145bf033966bc4574&#x27; and &#x27;slow_date&#x27; =&#x27;2024-07-15&#x27;;</span><br><span class="line">+----+-------------+------------------+------------+------+----------------------------------------+------------+---------+-------+------+----------+-------------+</span><br><span class="line">| id | select_type | table            | partitions | type | possible_keys                          | key        | key_len | ref   | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+------------------+------------+------+----------------------------------------+------------+---------+-------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | slow_log_history | NULL       | ref  | uniq_ins_id,idx_sql_id,idx_date_ins_db | idx_sql_id | 303     | const |  133 |     3.07 | Using where |</span><br><span class="line">+----+-------------+------------------+------------+------+----------------------------------------+------------+---------+-------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>因此可以将<code>idx_sql_id</code> (<code>sql_id</code>) 改成 <code>idx_sql_id_date</code> (<code>sql_id</code>, slow_date)</p>
<ol start="3">
<li>索引优化2<br>表结构：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `slow_log_history` (</span><br><span class="line">  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;,</span><br><span class="line">  ...</span><br><span class="line">  `sql_id` varchar(100) DEFAULT NULL COMMENT &#x27;库名&#x27;,</span><br><span class="line"> ...</span><br><span class="line">  `slow_date` date DEFAULT &#x27;1970-01-01&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `idx_date_sql_id` (`slow_date`, `sql_id`),</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=2124700 DEFAULT CHARSET=utf8</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<p>在该查询中，需要获取2024-07-10 之后特定sql_id 的所有记录。<br>由于我们的索引是(<code>slow_date</code>, <code>sql_id</code>) 的组合，我们的查询完全命中索引，可以直接在索引里面定位到第一条满足的记录，然后开始向右遍历。但是遍历的过程中，2024-07-10 这一天是有很多记录的，会导致不是我们需要的sql_id数据也被我们扫描到了。</p>
<p>同样的，2024-07-10 的记录遍历完后，开始遍历2024-07-11号的，一直到遍历到该索引的最右边。<br>相当于扫描的数据总量为  <code>slow_date</code> &#x3D;’2024-07-10’ and sql_id&gt;&#x3D;’xxx’   加上  <code>slow_date</code> &gt; ‘2024-07-10’</p>
<p><img data-src="/images/%E7%B4%A2%E5%BC%951.png" alt="paradin" title="说白了，就是以第一个作为主索引后面会带来很多无效查询"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain  SELECT * FROM slow_log_history force index(idx_date_sql_id)  where sql_id=&#x27;88891227eb51726145bf033966bc4574&#x27; and `slow_date` &gt;=&#x27;2024-07-10&#x27;;</span><br><span class="line">+----+-------------+------------------+------------+-------+-----------------+-----------------+---------+------+--------+----------+-----------------------+</span><br><span class="line">| id | select_type | table            | partitions | type  | possible_keys   | key             | key_len | ref  | rows   | filtered | Extra                 |</span><br><span class="line">+----+-------------+------------------+------------+-------+-----------------+-----------------+---------+------+--------+----------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | slow_log_history | NULL       | range | idx_date_sql_id | idx_date_sql_id | 307     | NULL | 381138 |    10.00 | Using index condition |</span><br><span class="line">+----+-------------+------------------+------------+-------+-----------------+-----------------+---------+------+--------+----------+-----------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/%E7%B4%A2%E5%BC%953.png" alt="paradin" title="扫描细节"></p>
<p>其实一个sql_id，一天就一条记录，SQL整体返回行数就只有5条左右。按照刚刚的理论，我们希望位于利用索引去查询，是能够定位到最小的一个范围，避免无效扫描。那我们的索引可以调整下顺序，改成   KEY <code>idx_sql_id_date</code> (<code>sql_id</code>,<code>slow_date</code>)这样我们的索引中，同样的sql_id的情况下，不同的<code>slow_date</code>是相邻是顺序排列的。</p>
<p><img data-src="/images/%E7%B4%A2%E5%BC%952.png" alt="paradin" title="这么一调整就紧凑多了"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain  SELECT * FROM slow_log_history force index(idx_sql_id_date)  where sql_id=&#x27;88891227eb51726145bf033966bc4574&#x27; and `slow_date` &gt;=&#x27;2024-07-10&#x27;;</span><br><span class="line">+----+-------------+------------------+------------+-------+-----------------+-----------------+---------+------+------+----------+-----------------------+</span><br><span class="line">| id | select_type | table            | partitions | type  | possible_keys   | key             | key_len | ref  | rows | filtered | Extra                 |</span><br><span class="line">+----+-------------+------------------+------------+-------+-----------------+-----------------+---------+------+------+----------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | slow_log_history | NULL       | range | idx_sql_id_date | idx_sql_id_date | 307     | NULL |    7 |   100.00 | Using index condition |</span><br><span class="line">+----+-------------+------------------+------------+-------+-----------------+-----------------+---------+------+------+----------+-----------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>新的索引，只需要扫描7行，效率大大提升，高下立判。</p>
<ol start="4">
<li>排序优化<br>sql是这样的:select c4, c5 from t where c1&#x3D;x and c2 in (x, y) order by c3 limit 100;</li>
</ol>
<p>假设1<br>c1 条件过滤后，有102万条记录。c1,c2 条件过滤后，有100万条记录。<br>如果我们建的索引是(c1,c2,c3)。由于c2是多个值，那么c3在索引里面是一个无序的状态，无法使用索引排序，在执行计划里面就会出现filesort。100万条记录进行filesort会比较慢。<br>优化方式：<br><code>调整索引 idx_c1_c3_c2(c1,c3,c2)</code><br>由于c3 前面的c1字段是等值查询，那么c3 在索引里面就是一个有序的状态。而c2 在二级索引，可以利用MySQL的ICP 特性完成过滤，去除了filesort成本。</p>
<p>注：<br>    a. filesort表示MySQL无法使用索引的有序性完成排序，需要进行额外排序。可能采用堆排，归并排序等方式。<br>    b. ICP 是MySQL的一个特性，未使用该特性的时候，某些过滤条件就算在索引里面，MySQL也无法使用索引过滤，被迫需要回表过滤。启用ICP特性后，Server层可以将该过滤条件传递到引擎，让引擎完成过滤，降低回表次数。（该特性会让rows_examined 指标失真）</p>
<p>假设2<br>c1 条件过滤后，有102万条记录。c1,c2 条件过滤后，有100条记录。<br>c1, c2  条件通过索引过滤后，剩余的数据只有100条记录，排序成本已经非常低。<br>优化方式：<br><code>调整索引 idx_c1_c2(c1,c2)</code></p>
<p>注：本例的Case，需要综合评估排序成本以及索引成本，将大头的成本用索引解决。如果两种成本差不多，需要考虑应用侧拆成多个等值查询，应用侧做合并。</p>
<ol start="5">
<li>索引覆盖<br>部分查询，像做计数，高频查询字段和条件，可以放在索引里面，避免回表的损耗。<br>Case1：<br><code>select count(*) from t where c1=x and c2=y;</code><br>如果count 没办法避免，则可以将<code>c1,c2</code>都加到索引里面，使用索引覆盖，提高count效率<br>解决方案就是：添加索引idx_c1_c2(c1,c2)</li>
</ol>
<p>Case2:<br><code>select c3 from t where c1 = x and c2 = y;</code><br>假设该查询是一个特别高频的，假设达到了1W+的QPS，可以考虑将c3 字段添加到索引里面，避免回表<br>解决方案就是：添加索引idx_c1_c2_c3(c1,c2,c3)</p>
<h2 id="当你新增一个索引的代价"><a href="#当你新增一个索引的代价" class="headerlink" title="当你新增一个索引的代价"></a>当你新增一个索引的代价</h2><p>当数据库管理系统向表中添加一行时，它必须在每一个索引上都添加相应的行。在当前的硬件条件下，在一个索引上添加一行，插入操作所花费的时间就是增加10ms，因为必须从磁盘上读取一个叶子页。</p>
<p>当一个事务向一张有10个索引的表里插入1行数据时，索引的维护就会使响应时间增加10*10ms&#x3D;100ms，这可能是可接受的。然而，如果一个事务向一张有10个索引的表里插入20行数据的话，索引的维护就会需要181次随机读，即耗费1.8s。这个估算基于的前提假设是，新的索引行会把表上其中一个索引（一直增大的键值上的索引）添加到同一个叶子页上，而会把其余9个索引添加到20个不同的叶子页上。从响应时间的角度来看，在一个有10个索引的大表上进行大的事务操作（每个事务中有许多插入或删除操作）可能是无法忍受的。</p>
<h2 id="练道题吧"><a href="#练道题吧" class="headerlink" title="练道题吧"></a>练道题吧</h2><p>有如下这个表：<br>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `tuser` (</span><br><span class="line">`<span class="built_in">id</span>` <span class="built_in">int</span>(<span class="number">11</span>) NOT NULL,</span><br><span class="line">`id_card` varchar(<span class="number">32</span>) DEFAULT NULL,</span><br><span class="line">`name` varchar(<span class="number">32</span>) DEFAULT NULL,</span><br><span class="line">`age` <span class="built_in">int</span>(<span class="number">11</span>) DEFAULT NULL,</span><br><span class="line">`ismale` tinyint(<span class="number">1</span>) DEFAULT NULL,</span><br><span class="line">PRIMARY KEY (`<span class="built_in">id</span>`),</span><br><span class="line">index `id_card` (`id_card`),</span><br><span class="line">index `name_age` (`name`,`age`)</span><br><span class="line">) ENGINE=InnoDB</span><br></pre></td></tr></table></figure><br>数据：<br>1,1,张三,26<br>2,2,李四,26<br>3,3,张六,26<br>4,5,王五,25</p>
<p>问题下面语句会走索引吗？走哪个索引，为什么？<br>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">select * <span class="keyword">from</span> tuser where name like ‘张%’;</span><br><span class="line">select * <span class="keyword">from</span> tuser where age = <span class="number">25</span>;</span><br></pre></td></tr></table></figure></p>
<p>答案：<br>1、like会走<code>name_age</code>索引，因为name 是组合索引 <code>name_age</code> 的第一个字段，<code>LIKE &#39;张%&#39; </code>是对 name 的前缀匹配，符合最左前缀原则,因此 MySQL 会使用该索引进行过滤。由于查询需要返回所有字段（*），MySQL 在找到匹配的 name 后，会通过主键 id 回表获取完整数据。<br>2、<code>age</code>不走索引，因为age 是组合索引<code>name_age</code>的第二个字段，但查询条件中没有包含 name，直接跳过第一个字段 name，违反了最左前缀原则。MySQL 只能通过全表扫描来查找符合条件的记录。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
        <tag>稳定性</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈SRE工作内容和方法论</title>
    <url>/2024/06/23/%E6%B5%85%E8%B0%88SRE%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AE%B9%E5%92%8C%E6%96%B9%E6%B3%95%E8%AE%BA/</url>
    <content><![CDATA[<p>今年的618大促是我第一次担任部门的S级大促负责人，做完了618大促的复盘，整体的618保障就算结束了，我也有空可以好好梳理一下我在这四年里工作内容的进化和方法论。之前看过一篇 <a href="https://www.kawabangga.com/posts/4481">https://www.kawabangga.com/posts/4481</a> ，这篇文章里比较系统的整理了一下SRE的工作。但跟我这4年所做的事情还是有点区别，这篇文章只是我个人的一个阶段性的总结和记录。</p>
<p>我要先说一下，SRE这玩意基本就是大厂才有的东西，小厂是不会专门养这样一个团队的。现在大厂里的SRE有两拨人，有些是属于开发团队，这些人一部分的okr是业务开发，另一部分okr是稳定性保障，他们比较垂直。还有一些SRE是在质量QA团队的，他们的工作主要是跟测试同学一起辅助开发，比较横向。QA团队的SRE不会很多，基本“开发:SRE”人数比应该是“50:1”（我所在的部门是100:1）。QA团队的SRE人太多的话，要么说明基础能力太差，很多东西都是手工作坊，要么就是无效的卷来卷去，精力都拿去搞一些奇奇怪怪的东西。上面说的“垂直”和“横向”的SRE在日常工作中是紧密合作的关系。</p>
<p>我这四年主要的工作内容是：</p>
<ol>
<li>灵活掌握公司内部的运维和监控平台如何使用。消除告警噪声，补全监控缺口。</li>
<li>熟悉开发流程，了解核心应用的发布计划、灰度计划和放量计划。</li>
<li>确定部门的故障场景，梳理出故障场景的等级，而且要跟上下游部门拉通对齐（很多人对“拉通对齐”这个词嗤之以鼻，但是我也不知道能有啥词来替换它）。</li>
<li>参与系统的设计，如果不能做到，那么至少要了解熔断、降级等策略。</li>
<li>深度参与压测，含单链路压测和全链路压测，了解系统的容量。</li>
<li>做容量规划，包含但不限于容器、数据库、缓存以及离线相关的云资源的容量规划。所以有些公司也会把降成本、做预算的工作交给SRE来做。</li>
<li>业务侧的 7-24 Oncall。</li>
<li>故障发生时参与定位，以及故障后复盘。</li>
<li>能独立开发一些平台、看板、工具，用于提升工作效率或者展示进度。</li>
<li>梳理核心链路，了解基本业务。</li>
</ol>
<p><img data-src="/images/SRE%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AE%B9.png" alt="paradin" title="这是我同行的规划来做个例子"></p>
<h2 id="梳理故障场景-核心链路"><a href="#梳理故障场景-核心链路" class="headerlink" title="梳理故障场景&amp;核心链路"></a>梳理故障场景&amp;核心链路</h2><p>做安全生产稳定性的方法论其实很简单，就是“变更前、变更中、变更后”。这里最好的抓手（好吧，又一个被人嗤之以鼻的词，但是我也不知道拿什么词替换它）就是故障场景，毕竟故障场景直接跟具体负责人的绩效挂钩。我见过很多开发牛的不行，在安全生产上特别狂野，结果搞出一个故障被业务方跟骂孙子似的骂了一顿后就怂的一匹。</p>
<p>通过故障场景也是一个了解业务的好机会，可能新人SRE刚到，还不了解自己所在部门的核心业务是啥，整个故障场景定义会全程是懵逼的。懵逼很正常，懵逼不要怕，多看看开发PRD文档和技术文档，把公司产品下载到自己手机里，去感受一下探索一下，就有更深刻的理解了。所以说，如果一个SRE连自己公司的产品都不咋用，那就别想当SRE了。</p>
<p>其实应用的服务故障说来说去就这么几种可能：<br>服务间<br>    ○ 网络通讯https&#x2F;vipserver; 这个一般由阿里云保障；<br>    ○ rpc 服务自动注册、发现、监控；这个一般也由阿里云保障；<br>    ○ 强弱依赖；<br>    ○ 上下游各类调用超限调用；<br>    ○ 依赖各类服务不稳定；<br>    ○ 分布式应用间调用有状态（不幂等）；<br>    ○ 分布式下数据一致性；<br>    ○ 上游服务流量突增；</p>
<p>服务内<br>    ○ 代码变更兼容性；<br>    ○ 配置变更&#x2F;系统配置不一致；<br>    ○ 线程池配置；<br>    ○ 服务响应时长；<br>    ○ 事务开启范围；<br>    ○ 异常处理；<br>    ○ 慢SQL；<br>    ○ 数据表ddl操作；<br>    ○ 服务调用超时时间；<br>    ○ 频繁&#x2F;耗时长IO；<br>    ○ 并发数据安全；</p>
<p>通过故障场景的等级定义的分布，我们可以“抓大放小”，优先关注高级别的故障情况。然后对高级别的故障情况进行拆解，也就是“要达到这样具体的故障情况”那么系统会有哪些不正常，那么针对这些不正常的情况，就准备对应的接口限流和降级方案。</p>
<p>然后我们还要梳理核心链路以及核心链路上的强弱依赖，啥样的算核心链路？大流量和有核心功能接口的链路肯定是核心链路。但是这里也要一定的拓宽范围，比如电商领域的“下单、支付”这无疑是核心链路，但是直接影响到用户使用与资金的核心能力，如“用户登录、余额提现”肯定也是核心链路。通过“大流量场景”和“核心业务场景”先把核心链路梳理出一个大概，然后先算出一个理论的qps跟监控平台上实际的qps，然后根据两者的差异看出来是不是有奇怪的流量方或者流量在某些地方被意外的放大，针对情况作出优化。同时我们也要知道哪些是边缘业务和降级操作，在出故障的时候可以紧急停定时器、停dump、停同步任务、降低监控采样等腾出非核心业务的容量供核心业务使用。</p>
<p>核心链路一定要重保！拿不会频繁更新的数据的场景来说，可以通过本地缓存、远程缓存mdb、远程缓存ldb、DB等4条链路来保障。保障用户在一条链路异常后能立即切换到可用的备份链路上去。</p>
<p>整个梳理完毕之后，才能教付于全链路压测来验收整个链路的稳定性，没经过压测的链路是绝对不可以上大促的。</p>
<h2 id="大促风险梳理"><a href="#大促风险梳理" class="headerlink" title="大促风险梳理"></a>大促风险梳理</h2><p>大促的风险梳理的方法论也很简单：<br>    <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">面向上游看业务玩法和业务方流量有哪些变化。</span><br><span class="line">面向自身和核心依赖看各域应用架构有哪些重要迭代。</span><br><span class="line">面向下游看基建有哪些升级，目前基本都在阿里云上，包括容器、中间件、数据存储和缓存、VPC拓扑、ECS和服务器、文件存储、网络等等。</span><br></pre></td></tr></table></figure></p>
<p>第一个是要跟产品和业务交流，而且是实时交流，因为有些时候大促突然间要有玩法的变更。比如我们今年618虽然公告说了没有官方预售，但是架不住几个KA商家非要自己玩，那我们也要配合。</p>
<p>第二个是要跟自己部门的开发同学交流，看看自己部门的应用架构有哪些重要的技改。举个例子，比如我们有些业务场景随着数据量的增加，是需要从memcache 改成rdb的，因为memcache只支持k-v格式，而rdb除了k-v格式，还支持<code>string、list、hash、set</code>等格式。那么这样的技改会对稳定性有哪些影响，同时rdb自身运维与mdb又有什么不同，都要check以及压测中验证。或者如导出报表对系统内存和cup消化都较大，也会对主业务有影响。那么这种技改都是风险，都要在压测里验证。</p>
<p>第三个是要跟下游的基建同学交流，看看基建有哪些升级。比如物理机的调整，数据库物理盘升级云盘，机房裁撤换了新的机房等等，这些也要check。</p>
<p>当然还是有一些小的经验，举个我们踩过坑的消息队列的例子：一次我们发现某个工具应用刚刚清空了磁盘，但是没几分钟又满了，经过排查发现它被接入了两个大吞吐的消息队列。后来紧急看了一下这俩消息队列能否在大促高峰期降级，毕竟这只是一个工具应用，往往机器数很少，那么这钟应用就不要接入那么多的业务侧大体量消息队列，会把磁盘打爆。</p>
<p>在正式大促的时候，还要关注包含“配置一致性、java异常进程、代码版本一致性、CPU水位阈值、JVM Metaspace使用率、应用HSF健康检查、online机器一致性巡检(vipserver&#x2F;skyline)、超大日志文件检查、JVM codecache使用率检查”等等巡检结果，争取提前发现问题。</p>
<h2 id="单链路压测-全链路压测"><a href="#单链路压测-全链路压测" class="headerlink" title="单链路压测&amp;全链路压测"></a>单链路压测&amp;全链路压测</h2><p>除了电商平台有全链路压测（包含：导购+交易+支付+商家+数据），我已知高德他们也会有全链路压测，因为他们也会有爆发流量。</p>
<p>作为业务域参加全链路压测准入的条件很简单，就是单链路压测通过。毕竟业务在变化在迭代，可能有了新的场景新的标，那么就要自己单链路跑通了之后才能上全链路，不然可能就会影响其他原本跑通的链路也跑不通。同时要计算需要多少资源，容量预估完要准备多少机器，这些是要事先算出来的，不是靠压测摸出来的。</p>
<p>单链路压测首先要确认你的压测场景。</p>
<p>举个例子，曾经我们要压测茅台抢购，那么就要先确认我们要压测的场景有哪些：<br>    1. 商品详情<br>    2. 购物车 （购物车是有动态计算的，比如你多选了一个，下面的价格就会变，或者你下拉购物车的时候，会刷新你新加到购物车的商品，这两个操作在实际人操作的时候其实很难同步，但是为了压测，也就放一起了）<br>    3. 订单确认<br>    4. 订单提交</p>
<p>确认了商品之后，我们还要看每个场景里我们都要重点关注啥。</p>
<p>比如现在在我司平台抢茅台是要提前预约的，而<code>商品详情</code>、<code>购物车</code>、<code>确认订单</code>这3个链路需要校验消费者是否预约，并且是将用户的预约记录缓存到同一个缓存当中，那么这个预约记录的缓存就非常重要，是压测的重要关注点之一。</p>
<p>然后呢，发现买茅台不是还赠袋子和小杯子么？实际中经常有丢掉赠品只发茅台的情况出现，每次都需要客服布防，然后仓库手动补发，链路体验极差。经排查发现，是因为库存限流导致赠品丢失（茅台场景赠品渲染有库存，下单无库存时并不会强阻断下单）。所以为了防止大量丢增，需要重点关注库存服务的整体稳定性。</p>
<p>最后因为热点是茅台，那么还要验证商品的热点散列是否生效。</p>
<p>以上确认好了压测场景和每个场景需要关注的点之后，就要拿出历史的数据，通过历史的数据和现在链路的变化（比如某个环节，原来调用3次接口，现在只调用两次了），得到我们本次的压测流量。</p>
<p>然后就要先挂出公告，通知相关方压测的时间和影响。再按照公告的约定找一个夜深人静的时候进行施压，根据业务实际情况看是脉冲还是需要一个预热再脉冲。在压测中记录问题。</p>
<p>压测结束的时候，我们也要对比一下压测结果，我认为判断压测是否成功通过主要就是以下几个标准：</p>
<ol>
<li>涉及的场景齐全，接口qps也符合事前预期。</li>
<li>模型是否充分得到验证，压测流量是否走到对应的代码。</li>
<li>各接口成功率满足4个9，这是首先要满足的，然后关注一下TP99等数据。</li>
<li>系统峰值水位（含容器、数据库、缓存、CDN等等）符合预期，且是一个较高的状态，这样才能压测出极限。</li>
<li>是否有接口压到限流，限流后的表现是预期内的么？</li>
<li>还有隐藏的一点，中间件的情况要跟日常情况相比较。我曾经压过一条链路，发现缓存命中率99%，但是实际日常缓存命中率只有95%左右，这代表我们的压测数据跟实际相差较大，没有压到DB，所以这次压测是不成功的。</li>
</ol>
<p>我们当时压茅台的时候就遇到“一次订单渲染请求，流量放大了10倍，直接给下游的读服务打限流了”。原因是：</p>
<ol>
<li>订单渲染的时候主品先查库存，再查优惠。发现有赠品的时候，赠品单独查一下库存，然后赠品会触发rerender，主赠合并一起再查库存。相当与有赠品的情况下，一次渲染查了3次库存。</li>
<li>库存域内，茅台+赠品会一次性查询3个模板（两个商家仓模板 一个菜鸟仓模板），到tair就是一个品对应3个查询。</li>
</ol>
<p>所以最终流量放大到了近10倍：（主品渲染查库存+ump查赠品库存+主赠从走流程查库存）✖️（2个商家仓库存模版+1个商家仓库存模版）。</p>
<p>然后又进行“调用次数优化”+“扩大库存tair hotzone机器，解决瞬时读流量过大，导致网卡被打限流问题”等等操作来解决问题。</p>
<p>这样这条单链路压测算是通过了，可以在全链路压测里登记并压测了。</p>
<p>全链路压测也会有自己的时间表：<br><img data-src="/images/%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B%E5%AE%89%E6%8E%92.png" alt="paradin" title="全链路压测的时间安排的时候很美好，但是基本上每一次压测都不会按时完成，都会有各种各样的问题，然后拖到凌晨"></p>
<p>通过了最后一次全链路压测之后，就不准许再有大促链路上生产环境变更了。如果非要有变更，需要提供邮件说明清楚如下几点才能通过审批：</p>
<ol>
<li>变更发起人</li>
<li>变更要发哪些应用</li>
<li>代码review人是谁</li>
<li>测试人是谁</li>
<li>是bug-fix or 稳定性优化 or 业务需求</li>
<li>发布理由：<br> a. 变更内容是啥？<br> b. 变更影响是啥？<br> c. 预发环境是否验证过？<br> d. 线上是否可以快速拿到结果？<br> e. 是否有业务独立隔离能力？<br> f. 是否有降级手段？<br> g. 回滚方案是啥？<br> h. 变更的价值是啥（大促期间，不能带来明显GMV收益的就不要提了）<br> i. 无比知晓且明确变更带来的责任风险划分。</li>
</ol>
<h3 id="促前"><a href="#促前" class="headerlink" title="促前"></a>促前</h3><p>● 稳定性保障信息收集：做好领域相关稳定性保障信息收集，如业务核心目标、活动节奏等<br>● 稳定性风险梳理：架构链路风险梳理，包含架构图（业务架构图、应用架构图、数据架构图）、核心链路时序图、风险识别（重点业务项目风险、重点技改项目风险、强弱依赖、限流配置、数据库性能与水位评估、机器及中间件资源容量评估）等<br>● 稳定性横向专项推进：全链路压测、故障演练、资金安全、监控专项、预案专项、功能预演、安全专项等<br>● 战前准备：大促作战手册、值班人员收集等</p>
<h3 id="促中"><a href="#促中" class="headerlink" title="促中"></a>促中</h3><p>● 促中做好协同，注意监控及线上反馈情况，问题及时响应<br>● 重点关注：核心业务大盘、核心系统大盘、预案触发与执行、线上问题处理、信息同步等</p>
<h3 id="促后"><a href="#促后" class="headerlink" title="促后"></a>促后</h3><p>做好领域技术复盘</p>
<h2 id="日常稳定性治理"><a href="#日常稳定性治理" class="headerlink" title="日常稳定性治理"></a>日常稳定性治理</h2><p>SRE在日常稳定性职责就是“日常打好稳定性基础，做好稳定性规划”。说一下具体内容：</p>
<p>● 稳定性基础能力建设：制定域内稳定性规划，并牵头领域的稳定性规划执行，推动领域稳定性建设，如域内稳定性风险、稳定性技术专项、预案、监控治理、资金安全、故障演练、慢SQL治理等<br>● 稳定性规范建设：团队内部稳定性规范制定，如研发规范、发布流程规范、问题复盘规范等<br>● 稳定性意识提升：领域稳定性培训、稳定性保障知识分享、案例分享等<br>● 稳定性周会机制：参加安全生产周会，周会内容在各域团队内部做好上传下达，做好域内相关稳定性工作安排<br>● 建立值班机制：明确领域值班组织分工方式，做好日常线上问题值班安排</p>
<p>SRE 角色面对故障的几个软要求：<br>● 「责任心」是 SRE 岗位的第一要求，日常情况下，线上的问题往往非常多，舆情、资金、线上预警，SRE 要具备从大量线上预警中筛选出高风险问题的能力，需要具备一定的敏感度，也应该是第一个吹哨人，当别人拉我们进会，往往已经失去了最佳处置窗口。在处置的时候要全面、妥善，时刻问自己一个问题：如果当前风险在半个小时后会升级到 P1、重大故障，你现在的处置是否妥当？有没有遗漏的点？有没有其他更稳妥的策略？<br>● 「客观」：在没有得到确定性的证据之前，不要猜原因、轻易下判断，任何决策的下发要基于客观事实和重大故障风险控制的决策标准。<br>● 「应急处置心态」：事中处置往往非常混乱，重大故障往往是多个问题的叠加，如何抽丝拨茧找出各种问题以及协调分工&amp;调度非常重要，SRE 角色要能够做到临危不乱，真正做到稳中有细，对现状的判断要客观，根据事实依据做出合理决策，果断从容指挥，沟通注意语速放缓，给到一线信心。<br>● 「能力提升」：很多时候，因为人员短缺、业务交接期等等原因，线上问题处置只有一个一线介入，甚至一线也不了解业务，SRE 角色要有一定的问题排查思路和能力，给到一线一定的帮助。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>要唠SRE肯定要唠“稳定性”，毕竟稳定性就是衡量SRE的重要标准，这个标准的具体量化就是SLI&#x2F;SLO。那么稳定性其实也分为两个方面，一个是稳定，字面意思很好理解。另一个是“性”，不过这个性不是18禁，而是性能优化。所以说基本上SRE要做的事情就是“发现问题”、“产出方案”、“跟进方案”、“解决问题”。那么整个安全生产也主要是这么几个阶段：<br><img data-src="/images/%E5%AE%89%E5%85%A8%E7%94%9F%E4%BA%A733.png" alt="paradin" title="稳定性保障每个阶段核心关注事项"></p>
<p>整个四年感受下来，我对业务的了解越来越深。SRE脱胎于开发&#x2F;运维，再往上走就是架构师。如果不懂业务的SRE，将来是会被AI替代的，这不是危言耸听。</p>
<p>SRE是不是擦屁股的救火队员，这一点其实是看自己的心态和心态驱动的工作内容的，如果你走在系统的后面，你能看到的就只有系统的屁股，也只能做擦屁股的工作，如果你走到了系统的前面，你就能看到系统的方向，做的也就是探索性的工作。</p>
<p>再推荐一篇文章，<a href="https://mp.weixin.qq.com/s/IB0p6hckb_2yRkQ-WNg8rw?spm=ata.21736010.0.0.27cb6d37fNavw7">https://mp.weixin.qq.com/s/IB0p6hckb_2yRkQ-WNg8rw?spm=ata.21736010.0.0.27cb6d37fNavw7</a> ，是我司SRE大神总结的，很长但是非常精华。</p>
<p>最后也是之前面试里遇到的一个很有意思的问题：如果你是集团安全生产的一号位，与业务一号位搭配，共同保障业务的稳定性，那么你会如何做？你的战略是什么？这个问题当然有点大，而且我也没当过一号位，我个人想了想主要是6个方面：</p>
<ol>
<li>监控体系的搭建：监控是最重要的一环，有了监控我们知道过去，知道现在，也会推测出未来。</li>
<li>稳定性与成本的平衡：稳定性不能要求无止境的完美，不然产品永远不能上线。同时也要关注哪些业务是赚钱的，那么这些业务的稳定性要更投入。</li>
<li>预案和容灾能力：单元化其实已经能解决一定的问题，但是有限。</li>
<li>一线开发同学的排查和小队配合能力：系统完备，人的技能也要跟上，尽量不要口口相传，而是有文字有配合。</li>
<li>内容安全、合规、数据审计：这块我觉得是最重要的，懂得都懂。</li>
<li>生产关系和职责边界：作为管理者，权责利的分配和内容肯定都是非常重要的，而生产关系单独拉出来说是因为有些产品由于历史组织架构变来变去的问题，导致相关方利益不清晰，进而可能会不配合，导致风险。</li>
</ol>
<p>在有限的认知里，我只能回答这么多，都是很具体的东西，果然农民一下子当了皇帝也是拿金锄头锄地的。<br><img data-src="/images/%E5%AE%89%E5%85%A8%E7%94%9F%E4%BA%A7%E8%A7%84%E5%88%92.png" alt="paradin" title="最后补一下安全生产目标和打法"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>安全生产</tag>
        <tag>sre</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈python装饰器的参数传入</title>
    <url>/2024/01/03/%E6%B5%85%E8%B0%88python%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<p>正好没事看到这样的一个图片：<br><img data-src="/images/%E8%A3%85%E9%A5%B0%E5%99%A8.jpeg" alt="paradin" title="说的通俗易懂"></p>
<p>整个过程说的通俗易懂，可以拿去用于校招面试考察基本功。</p>
<p>但是它图里的例子太简单了，而且是非常理想化的不带参数的装饰器。如果根据这个图照搬照抄想自己写一个带参数的装饰器，那么就会失败。</p>
<h2 id="被装饰的函数带有参数的情况"><a href="#被装饰的函数带有参数的情况" class="headerlink" title="被装饰的函数带有参数的情况"></a>被装饰的函数带有参数的情况</h2><p>举个例子，比如下面这个python，是完全仿照上面的例子写的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个装饰器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">zhuangshiqi</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">xiulian</span>(<span class="params">book</span>):</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;开始！&quot;</span>)</span><br><span class="line">        func()</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;他终于修炼成功了&quot;</span>+book)</span><br><span class="line">    <span class="keyword">return</span> xiulian</span><br><span class="line"></span><br><span class="line"><span class="comment"># 引用这个装饰器，原函数是传入一个参数，输出一顿话</span></span><br><span class="line"><span class="meta">@zhuangshiqi</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_book</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;经过努力&quot;</span>,name,<span class="string">&quot;得到了武功秘籍!&quot;</span>)</span><br><span class="line"></span><br><span class="line">find_book(<span class="string">&quot;杨过&quot;</span>,<span class="string">&quot;九阴真经&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>原以为这个输出的结果是：<br>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开始！</span><br><span class="line">经过努力 杨过 得到了武功秘籍!</span><br><span class="line">他终于修炼成功了九阴真经</span><br></pre></td></tr></table></figure></p>
<p>哪知道，结果是这样的：<br>    <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">zhuangshiqi.&lt;<span class="built_in">locals</span>&gt;.xiulian() takes <span class="number">1</span> positional argument but <span class="number">2</span> were given</span><br></pre></td></tr></table></figure></p>
<p>嗯，学习知识还是要通过实际的栽跟头和实际的场景去学习的。</p>
<p>首先这个错误的意思就是<code>xiulian()</code>这个函数里是只能传入一个函数的，但是调用的是传入了两个函数。所以我们需要确保<code>xiulian </code>函数接收到的参数能够正确传递给 <code>find_book</code> 函数。调整过的代码如下：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">zhuangshiqi</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">xiulian</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;开始！&quot;</span>)</span><br><span class="line">        func(*args, **kwargs)  <span class="comment"># 调用原函数</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(args) &gt;= <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;他终于修炼成功了&quot;</span> + args[<span class="number">1</span>])  <span class="comment"># 安全访问 args[1]</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;他终于修炼成功了&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> xiulian</span><br><span class="line"></span><br><span class="line"><span class="meta">@zhuangshiqi</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_book</span>(<span class="params">name, book_name=<span class="literal">None</span></span>):  <span class="comment"># 修改为接受两个参数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;经过努力&quot;</span>, name, <span class="string">&quot;得到了武功秘籍!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用时传入两个参数</span></span><br><span class="line">find_book(<span class="string">&quot;杨过&quot;</span>, <span class="string">&quot;九阴真经&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先就像图里的第四个小图说的，当使用<code> @zhuangshiqi</code> 装饰 <code>find_book</code> 时，等价于：<code>find_book = zhuangshiqi(find_book)</code>，这意味着 <code>find_book</code> 现在指向 <code>xiulian</code> 函数，<code>xiulian</code> 函数其实是包裹了原始的 <code>find_book</code> 函数的。而<code>find_book</code>看上去只有一个函数<code>name</code>，但是其实在<code>xiulian</code>里还有一个就是<code>args[1]</code>，所以我们把<code>func()</code>这里加上<code>*args, **kwargs</code>，确保这里是能吃进多个函数的。</p>
<p><code>find_book(&quot;杨过&quot;, &quot;九阴真经&quot;)</code>，这个调用实际上是调用了 <code>xiulian(&quot;杨过&quot;, &quot;九阴真经&quot;)</code>。只不过<code>九阴真经</code>在<code>find_book</code>里没有体现，但是确实<code>xiulian</code>的必须，所以如果传入2个参数的话，就会报错，因为它默认认为只需要1个参数。</p>
<p>这里<code>kwargs</code>是空的，传递的参数被 <code>*args</code> 捕获，所以<code>print (&quot;他终于修炼成功了&quot; + args[1])</code>这里就能顺利拿到“九阴真经”这个函数。</p>
<p>上面例子里用的是 <code>*args, *args</code>是位置参数是元组, <code>**kwargs </code>    是关键字参数是字典。如果想改造用 <code>**kwargs</code>的话，代码应该改成如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">zhuangshiqi</span>(<span class="params">func</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xiulian</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始！&quot;</span>)</span><br><span class="line">    func(*args, **kwargs)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;修炼了&quot;</span> + kwargs[<span class="string">&#x27;book&#x27;</span>])</span><br><span class="line"><span class="keyword">return</span> xiulian</span><br><span class="line"></span><br><span class="line"><span class="meta">@zhuangshiqi</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_book</span>(<span class="params">name, place,book</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;经过努力&quot;</span>, name, <span class="string">&quot;在&quot;</span>, place, <span class="string">&quot;得到了武功秘籍!&quot;</span>)</span><br><span class="line"></span><br><span class="line">find_book(name=<span class="string">&quot;林平之&quot;</span>,place=<span class="string">&#x27;岳不群家窗户外&#x27;</span>,book=<span class="string">&quot;辟邪剑谱&quot;</span>) <span class="comment"># 这里多家了一个函数</span></span><br></pre></td></tr></table></figure>

<p>这段代码的<code>args</code>是空的，<code>kwargs</code>是<code>{&#39;name&#39;: &#39;林平之&#39;,&#39;place&#39;: &#39;岳不群家窗户外&#39;,&#39;book&#39;: &#39;辟邪剑谱&#39;}</code>。 看上去kwargs的用法更加清晰，推荐！</p>
<p>还要注意一点，装饰器函数装饰器应该返回一个新函数，而不是立即执行原函数。所以例子里<code>zhuangshiqi</code>下面必须要有<code>xiulian</code>这个函数，不能直接接<code>func()</code>。</p>
<h2 id="装饰器本身带有参数的情况"><a href="#装饰器本身带有参数的情况" class="headerlink" title="装饰器本身带有参数的情况"></a>装饰器本身带有参数的情况</h2><p>装饰器本身也是可以带函数的，下面这个例子就比较明显：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delay</span>(<span class="params">seconds</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    装饰器，用于延迟函数的执行。</span></span><br><span class="line"><span class="string">    :param seconds: 延迟的秒数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">        @wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapped_function</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;等待 <span class="subst">&#123;seconds&#125;</span> 秒后执行 <span class="subst">&#123;func.__name__&#125;</span> 函数...&quot;</span>)</span><br><span class="line">            time.sleep(seconds)</span><br><span class="line">            result = func(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span> wrapped_function</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用装饰器</span></span><br><span class="line"><span class="meta">@delay(<span class="params"><span class="number">3</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@delay(<span class="params"><span class="number">2</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    result = a + b</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;结果是: <span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用被装饰的函数</span></span><br><span class="line">greet(<span class="string">&quot;Alice&quot;</span>)</span><br><span class="line">add(<span class="number">5</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>上面这个例子里，<code>delay(seconds)</code>这是一个装饰器函数，他返回的是一个真正的装饰器<code>decorator</code>。而装饰器<code>decorator</code>，它接收一个函数<code>func</code>作为参数。</p>
<p>而内部函数<code>wrapped_function</code>，该函数在调用被装饰函数之前等待指定的时间。并且通过<code>{func.__name__}</code>获取到被装饰函数的名字，并在调用被装饰函数之后打印出该函数的名字。这句话可以更好的帮你理解 <code>被调函数=装饰器（函数）</code>这个装饰器的基本逻辑。</p>
<p>而<code>@wraps(func)</code>是啥意思呢？它是为了确保装饰器不会改变被装饰函数的签名和文档字符串（docstring）而加上的。</p>
<p>装饰器本身带有参数的情况其实在工作中很常见，最常见的操作就是打印日志的时候，可以在装饰器添加参数<code>level=&quot;INFO&quot; or evel=&quot;DEBUG&quot;</code>来调整对应的日志级别。</p>
<p>总之，装饰器是python的一个进阶，有了它，能够使你的代码更加简洁和易维护，而且也让菜鸟们更加崇拜你。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器首页被劫持</title>
    <url>/2022/02/13/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%A6%96%E9%A1%B5%E8%A2%AB%E5%8A%AB%E6%8C%81/</url>
    <content><![CDATA[<p>过年没事，就突然想玩红警2，就在网上找了一个下载地址，但是下载下来是一个代理软件，然后再通过这个代理软件下载游戏本体。后来发现这个狗屎代理软件偷偷摸摸的把老子的浏览器首页劫持了，我明明选择了“开启继续浏览上次网页”，但是每次打开都是神马“桔梗网”，上面一堆自媒体的消息，假的要死还推送。<br><img data-src="/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%A6%96%E9%A1%B5%E5%8A%AB%E6%8C%81.png"></p>
<p>于是乎，老子要干掉他！</p>
<p>首先鼠标右键点击chrome，先把<code>常规</code>标签页的<code>只读</code>属性勾掉，不然的话会爆“无法将所做的改动保存到‘Google Chrome.Ink’拒绝访问”的错误。<br><img data-src="/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%A6%96%E9%A1%B5%E5%8A%AB%E6%8C%812.png"></p>
<p>然后切换到<code>快捷方式</code>标签页，将<code>目标</code>后面的桔梗网网址删干净，只保留干净的chrome.exe路径即可。这里可见Chrome 后面加上网址就是达到了首页打开对应网址的效果。然后保存，再打开浏览器看看吧！<br><img data-src="/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%A6%96%E9%A1%B5%E5%8A%AB%E6%8C%813.png"></p>
<p>然后别忘了把常规标签页的<code>只读</code>再打勾回来！</p>
<p><img data-src="/images/%E6%9D%8E%E6%B2%81.webp"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Chrome</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>漫谈世界杯</title>
    <url>/2022/06/14/%E6%BC%AB%E8%B0%88%E4%B8%96%E7%95%8C%E6%9D%AF/</url>
    <content><![CDATA[<h2 id="球王的囧境"><a href="#球王的囧境" class="headerlink" title="球王的囧境"></a>球王的囧境</h2><p>啥是球王？马拉多纳和贝利是当之无愧的球王，而梅西和C罗还在争议中，但是毫无疑问，先败人品的预测一下，要是梅西拿到了今年的世界杯，那么他就是可以跟马拉多纳和贝利并肩，也可以成为当之无愧的球王了。</p>
<p>那回归老问题，球王的标准是啥？按照国外的权威杂志的标准，球员的历史地位主要有以下几方面的因素：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">俱乐部荣誉：联赛冠军、欧冠冠军、国内杯赛等等等等</span><br><span class="line">国家队荣誉：这个是出圈的荣誉，影响力巨大</span><br><span class="line">个人数据：现在数据已经特别全面了，但是一些防守者在这里吃亏</span><br><span class="line">个人荣誉：金球奖的含金量要高于世界足球先生，因为世界足球先生是教练和队长投票出来的，有一定的人情票成分，而金球奖是记者评选的，权威性更高</span><br><span class="line">硬仗数据：这个数据加分项，有了的话增加传奇性</span><br><span class="line">球技表现：这部分是用来隔离那些只看Excel不看球的人的</span><br></pre></td></tr></table></figure></p>
<p>而球技表现说白了就是如下几个方面：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">传：良好的视野，一击必杀的传球能力</span><br><span class="line">停：球不离脚的那个球感</span><br><span class="line">带：惊艳的过人能力</span><br><span class="line">射：得分能力</span><br></pre></td></tr></table></figure></p>
<p>所以说，球王这个东西只能符合进攻球员，因为毕竟得分才是一场比赛里最高潮的那部分，而球王的任务就是让他的球迷各种高潮。以上“传停带射”这四点，一定都要强，满分100分至少都要拿下90分以上，最次最次就是单科85分，其他要97分。</p>
<p>至于其他的还有什么场外传奇加成啊，带病得分啊，那些都是锦上添花的。</p>
<p>于是可以看出球王踢法说白了就是进攻端一把抓，一切进攻组织调度都归我管。是这个球队的不二真核，但是这样就有了一个囧境，那就是对方要是封死你了，那你所在的球队进攻也就瘫痪了，也就是说如果被封死了，那么你就成为了你球队的弱点。所以像德国队这种“团队能力比较强，无明显个人优势”的队伍，收拾球王那是特别的专业。</p>
<p>所以说球王满足了球迷“个人英雄主义”的想象，又要承担“自己被锁死，球队输球”的风险，也就是俗话说的“欲戴王冠，必承其重”。而现在足球的发展，想在比赛里场场一打5早就是不可能的事儿了，越是淘汰赛那种1&#x2F;2球是不会让的。所以说球王周边一定要有一些功能性很强的帮手，这些帮手既能帮他分担压力，也不会抢走他很多的光芒。</p>
<p>当然球王也可以互相兼容，比如MSN当年就是三个球王踢法的人，私交本身就很好的南美三天王配合无间在那一年顺利拿下五冠王。但是如果私交配合不好，那就是反效果。</p>
<h2 id="世界杯进球有多难"><a href="#世界杯进球有多难" class="headerlink" title="世界杯进球有多难"></a>世界杯进球有多难</h2><p>世界杯目前只进了一个球的球星有很多，让我随便一抓：托蒂（你没看错，他就进了黄健翔老师的那一嗓子点球）、皮尔洛、巴洛特利、因扎吉、罗伊斯、卡卡、鲁尼、香川真司、里贝里、卡洛斯（面对中国队进了一个）、拉基蒂奇、菲尔米诺、鲁伊科斯塔等等等等。而一个球没进的球星也有不少，比如：莱万和贝尔（不过这俩都在刚结束不久的比赛里进球了，莱万还在淘汰赛里进了一个点球）。</p>
<p>上面这些人只进一个球也有各种各样的外部因素，比如罗伊斯，14年受伤了，18年德国小组没出线，他世界杯就踢了3场比赛进了一个也算不错了。而因扎吉一直在国家队不太受待见，出场时间本身就少，那进球肯定也少。卡洛斯、普约尔本人就是后卫，得分不是他们主要工作。</p>
<p>但是说来说去，其实还是世界杯本身影响力太大。这是一个很容易出圈的赛事，而且在这个地球上，国家与国家的足球水平差的很多的，很多underdog就是来摆大巴的—老子段位就不高，摆大巴也不丢人。那么面对大巴如何进球就是一个难事，但是进球就出圈了，在全球和自己国民心中的自身影响力有大幅度的提升。</p>
<h2 id="世界杯改变一生"><a href="#世界杯改变一生" class="headerlink" title="世界杯改变一生"></a>世界杯改变一生</h2><p>通过世界杯成为巨星的有很多，最出名的是小罗：韩日世界杯之前的小罗只是2001年才签约巴黎圣日耳曼队的一个快乐进球者，但是2002那一吊射马上整个人的气质就被包装出来了（其实小罗一辈子就世界杯进过两个球，除了这脚吊射就是对中国队的点球了），进而去了巴萨成了著名的足球精灵。而巧的是，同年的巴拉克也是，2001年三亚王巴拉克还不算出名，但是通过2002年的carry之后，整个人的巨星气质出现了。还有2014年的J罗，2014年的姆巴佩，也是通过世界杯一下知名度蹿升。</p>
<p>除了进攻球员，世界杯也成就了无数的门将：2002年卡恩，2014奥乔亚，2014扑点球的科鲁尔，2018化妆的韩国门将赵贤祐等等。这些人的高接抵挡的画面成了很多球迷的谈资。但是相比较进攻球员世界杯后不少螺旋升天大放光彩，上面说的这些人除了卡恩依旧高水平发挥之外，其他人在俱乐部的表现并不遂人意。这个可能主要是杯赛跟联赛的区别，毕竟杯赛时间短，让人短时间的把注意力集中相比较几乎一年的联赛的时长来说要简单许多。所以说世界杯出彩的防守球员的稳定性要比进攻球员的稳定性大概率要差一点。</p>
<p>同时世界杯&#x2F;欧洲杯等出圈赛事也是成名球星借机推销自己的好机会，比如踢完韩日世界杯的罗纳尔多就转会去了皇马。今年的C罗也全力押注世界杯的发挥，希望能留在欧洲，但是事与愿违，只能去沙漠淘金。这一正一负恰巧说明了“世界杯改变一生”。</p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>足球</tag>
        <tag>世界杯</tag>
      </tags>
  </entry>
  <entry>
    <title>《漫长的季节》观后感</title>
    <url>/2023/05/04/%E6%BC%AB%E9%95%BF%E7%9A%84%E5%AD%A3%E8%8A%82/</url>
    <content><![CDATA[<ol>
<li><p>这里面最惨的是哑巴哥，爱上一个不该爱的人。</p>
</li>
<li><p>哑巴哥在饭店动菜刀那集，其实他是找人买的摩托车，而恰巧那个摩托车是赃物，但是他还是要给那个摩托车主人钱，可见人品很好的。而且他骑着摩托车来维多利亚接沈墨下班，可见他是知道沈墨在夜总会弹琴挣钱的，买摩托是为了接她。</p>
</li>
<li><p>沈墨那件外套十八年没换，主要的原因我觉得是沈墨觉得那是她弟弟的保护。<br><img data-src="/images/%E6%BC%AB%E9%95%BF%E7%9A%84%E5%AD%A3%E8%8A%822.webp"></p>
</li>
<li><p>沈墨不能使用真实的身份，所以最后在内蒙古的砂厂出现是比较合理的，毕竟那里可能管理不严，不太对身份强要求。</p>
</li>
<li><p>作为观众我们都嘲笑范德彪和龚彪，其实现实里人人都是范德彪和龚彪。<br><img data-src="/images/%E6%BC%AB%E9%95%BF%E7%9A%84%E5%AD%A3%E8%8A%82.webp"></p>
</li>
<li><p>哑巴哥最后死在监狱，以当时的严打审判要是杀人肯定是要枪毙的，但是他却没有，可见李群是把他当成港商的小弟按照经济犯罪+故意伤害大爷儿子的胳膊的罪来审判的，但是这两个罪叠加一起按正常看肯定不够20年，可见当时严打之风下，哑巴哥成了牺牲品。</p>
</li>
<li><p>警察当时由于刑侦技术有限，认为沈墨死掉了，所以“碎尸案”最后结案的结论可能就是“王阳因为发现沈墨跟港商的关系，杀害了沈墨，然后畏罪自杀”。这就是为啥在车管所，那个保卫科科长说王响“你自己家里事没整明白”。</p>
</li>
<li><p>电影里老警察局长关心的重点是“桦钢下岗工人闹事”的维稳事情上，所以也自然关注港商和80万（80万应该就是下岗工人的安置款）的事情，他认为“碎尸案”的重要性不及维稳重要。但是马队长因为是刑警，刑警自然对“碎尸案”更关注而维稳不是他特别care的事情，这里是他俩的矛盾重点。</p>
</li>
<li><p>厂长被纪委带走，肯定会交代出港商的事情，但是港商失踪，按理说应该立案侦查。但是局里没有说，可见港商这个事儿公安就不了了之了。</p>
</li>
<li><p>这个片还有其他内涵公安的地方，最后一集王响从中风清醒的马队长的结论会上比两名公安后出来，又剪了后座的安全带，结果跑在公安之前接到了张静初扮演的沈墨。</p>
</li>
<li><p>我觉得这部片能在豆瓣拿高分，第一是情节严谨，第二是它是东北的伤痕文学。它的社会属性更浓，备受好评的第十一集就是证明。</p>
</li>
</ol>
<iframe height=498 width=510 src="//player.bilibili.com/player.html?aid=995508969&bvid=BV1ws4y1R7ZE&cid=1112352502&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>

<ol start="12">
<li><p>这个故事的两个始作俑者，一个是沈墨大爷，另一个就是厂长。这俩一个是家庭属性一个是社会属性，把逼人犯罪的客观条件都凑齐了。</p>
</li>
<li><p>范伟饰演的王响虽然有些时候很怂，跟平时一副劳模姿态指点江山的样子反差。但是总体来说他是一个有勇气有原则的人，而且是一个爱家过日子的踏实人，他的优点比缺点要多很多。</p>
</li>
<li><p>工人偷摸卖厂里的机器，厂长直接偷摸卖厂… </p>
</li>
<li><p>秦昊饰演的龚彪整部剧只有两个高光时刻，一个是在彩票站靠着出租车屁股后面的黄标抓住了黑车司机沈辉，另一个就是在职工大会上勇揍厂长，揍厂长一部分原因是自己被坑了，另一部分原因是因为小护士黄丽茹，可见他对黄丽茹是真爱，后来的彩蛋特别说明了这一点。<br><img data-src="/images/%E6%BC%AB%E9%95%BF%E7%9A%84%E5%AD%A3%E8%8A%823.png" title="真男人从来不回头"></p>
</li>
<li><p>娶的媳妇生不了孩子，养的鸽子还不下蛋。龚彪的确很难。</p>
</li>
<li><p>沈墨为啥选择去夜总会弹钢琴，是因为夜总会挣得多。这也就是为啥哑巴哥能那么快的开起来录像厅。</p>
</li>
<li><p>王北是在火车的轨道边被发现的，可见遗弃他的人原本是不想被发现才选择这么一个偏僻的地方，恰巧遇到了范伟饰演的王响。</p>
</li>
<li><p>这个片龚彪的剧情其实就是导演对《马大帅》的读后感。</p>
</li>
<li><p>宿命论在一定程度上是有道理的，因为阶级固化是一个社会发展到稳定的必然现象。一切的一切都在暗中标记好了价格，你拿到了什么就注定会失去一点其他的东西。<br><img data-src="/images/%E6%BC%AB%E9%95%BF%E7%9A%84%E5%AD%A3%E8%8A%823.JPG" title="拉丁队的老头衣服很骚"></p>
</li>
<li><p>任素汐客串的年轻徐姐踢开的那个大骨头应该不是人骨头，就是对面骨头店坑她的牛骨头，可见她跟对面骨头店的关系的确不好。</p>
</li>
<li><p>平凡人自古以来的“青天大老爷”情结的根本原因就是“当官的手里权力太大，一把手掌握人事变动的大权是基础”，而“砸人饭碗等于杀人父母”。人事变动权交给了领导，就只能祈祷遇到一个不坑人的领导。</p>
</li>
<li><p>劳模是对你技术和人品的认可。但是这个头衔如果没有家里疏通关系的辅助，那么就是一个沉甸甸的石头，只会压着你。</p>
</li>
<li><p>沈墨大爷出场的时候一副“认识这个领导”“认识那个领导”的劲儿，可见是装的，马队长能轻松查到他的职业和社交圈，他自己也交代自己就是一个工会司机。而且沈墨大爷老了后自己儿子在开黑车，还是骨折后遗症的条件下开黑车，可见他其实没有啥大本事，也是一个吹牛的人。<br><img data-src="/images/%E6%BC%AB%E9%95%BF%E7%9A%84%E5%AD%A3%E8%8A%825.JPG" title="小李端端正正的坐着"></p>
</li>
<li><p>我认为沈墨对王阳是有感情的，他不是单纯的工具人。说“沈墨故意害死王阳”是扯淡，王阳死了对她没好处。我觉得沈墨是假意跳水寻思目的是想要让王阳回头，因为她知道枯水期，但是王阳却因为救她死了。最后一集有一个镜头是沈墨在众人发现王阳尸体后悄悄溜走，可见沈墨是陪了王阳的尸体直到被人发现，但是警察尸检报告里说王阳没有什么外伤的痕迹，我觉得沈墨是学医的，她或许是有做过人工呼吸这类的救急措施，但是没卵用，但还是陪着王阳的尸体而不是抓紧逃跑，可见她对王阳是有情感依赖。</p>
</li>
<li><p>殷红觉得港商给了她钱但是玩弄她而不爽，但是哑巴哥对她是真心的，她又看不上，所以说殷红其实是想两头占。</p>
</li>
<li><p>整个故事的脉络还是挺严谨的，但是我觉得有一个小小的BUG，就是跟哑巴哥一起的磕巴哥前脚被厂区混混打进医院里。后面王响带着曲波来录像厅找王阳的时候，他却毫发无伤的在烧水…<br><img data-src="/images/%E6%BC%AB%E9%95%BF%E7%9A%84%E5%AD%A3%E8%8A%824.png" title="用快乐的东北嗑讲一个悲伤的故事"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>东北</tag>
        <tag>漫长的季节</tag>
        <tag>悬疑</tag>
      </tags>
  </entry>
  <entry>
    <title>点击表格里的单元格获取对应行首列首的信息</title>
    <url>/2021/07/11/%E7%82%B9%E5%87%BB%E8%A1%A8%E6%A0%BC%E9%87%8C%E7%9A%84%E5%8D%95%E5%85%83%E6%A0%BC%E8%8E%B7%E5%8F%96%E5%AF%B9%E5%BA%94%E8%A1%8C%E9%A6%96%E5%88%97%E9%A6%96%E7%9A%84%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>最近在用Django做一个项目室预定的功能，前端页面很简单，就是一个<code>table</code>表格，然后每个单元格里是一个<code>button</code>，然后这个<code>button</code>对应不同的<code>modal</code>弹窗,长相就是这样：<br><img data-src="/images/%E8%8E%B7%E5%8F%96%E8%A1%8C%E9%A6%96%E5%88%97%E9%A6%96.png"></p>
<p>由于项目室只有一个，所以无所谓项目室的id号了。预定页面的纵坐标就是日期，横坐标就是时间段。点击对应的<code>button</code>就可以获取到“日期+时间段”，再通过ajax传给后端，后端通过处理后交给数据库保存。表格部分的代码如下：<br>	<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">&quot;table table-bordered&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">th</span>&gt;</span>日期/时间段<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">th</span>&gt;</span>10：00~12：00<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">th</span>&gt;</span>12：00~14：00<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">th</span>&gt;</span>14：00~16：00<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">th</span>&gt;</span>16：00~18：00<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">th</span>&gt;</span>18：00~20：00<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">th</span>&gt;</span>20：00~22：00<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;today&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-success&quot;</span> <span class="attr">data-toggle</span>=<span class="string">&quot;modal&quot;</span> <span class="attr">data-target</span>=<span class="string">&quot;#booking-success&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;RunAlg(this)&quot;</span>&gt;</span>可预订<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-success&quot;</span> <span class="attr">data-toggle</span>=<span class="string">&quot;modal&quot;</span> <span class="attr">data-target</span>=<span class="string">&quot;#booking-success&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;RunAlg(this)&quot;</span>&gt;</span>可预订<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-success&quot;</span> <span class="attr">data-toggle</span>=<span class="string">&quot;modal&quot;</span> <span class="attr">data-target</span>=<span class="string">&quot;#booking-success&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;RunAlg(this)&quot;</span>&gt;</span>可预订<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-success&quot;</span> <span class="attr">data-toggle</span>=<span class="string">&quot;modal&quot;</span> <span class="attr">data-target</span>=<span class="string">&quot;#booking-success&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;RunAlg(this)&quot;</span>&gt;</span>可预订<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-success&quot;</span> <span class="attr">data-toggle</span>=<span class="string">&quot;modal&quot;</span> <span class="attr">data-target</span>=<span class="string">&quot;#booking-success&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;RunAlg(this)&quot;</span>&gt;</span>可预订<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-success&quot;</span> <span class="attr">data-toggle</span>=<span class="string">&quot;modal&quot;</span> <span class="attr">data-target</span>=<span class="string">&quot;#booking-success&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;RunAlg(this)&quot;</span>&gt;</span>可预订<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;tomorrow&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span>  <span class="comment">&lt;!-- 这个id设置见下面的script部分 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-danger&quot;</span> <span class="attr">data-toggle</span>=<span class="string">&quot;modal&quot;</span> <span class="attr">data-target</span>=<span class="string">&quot;#modal-danger&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;RunAlg(this)&quot;</span>&gt;</span>不可预订<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-success&quot;</span> <span class="attr">data-toggle</span>=<span class="string">&quot;modal&quot;</span> <span class="attr">data-target</span>=<span class="string">&quot;#booking-success&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;RunAlg(this)&quot;</span>&gt;</span>可预订<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-success&quot;</span> <span class="attr">data-toggle</span>=<span class="string">&quot;modal&quot;</span> <span class="attr">data-target</span>=<span class="string">&quot;#booking-success&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;RunAlg(this)&quot;</span>&gt;</span>可预订<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-success&quot;</span> <span class="attr">data-toggle</span>=<span class="string">&quot;modal&quot;</span> <span class="attr">data-target</span>=<span class="string">&quot;#booking-success&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;RunAlg(this)&quot;</span>&gt;</span>可预订<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-danger&quot;</span> <span class="attr">data-toggle</span>=<span class="string">&quot;modal&quot;</span> <span class="attr">data-target</span>=<span class="string">&quot;#modal-danger&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;RunAlg(this)&quot;</span>&gt;</span>不可预订<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-success&quot;</span> <span class="attr">data-toggle</span>=<span class="string">&quot;modal&quot;</span> <span class="attr">data-target</span>=<span class="string">&quot;#booking-success&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;RunAlg(this)&quot;</span>&gt;</span>可预订<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;today3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-success&quot;</span> <span class="attr">data-toggle</span>=<span class="string">&quot;modal&quot;</span> <span class="attr">data-target</span>=<span class="string">&quot;#booking-success&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;RunAlg(this)&quot;</span>&gt;</span>可预订<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-success&quot;</span> <span class="attr">data-toggle</span>=<span class="string">&quot;modal&quot;</span> <span class="attr">data-target</span>=<span class="string">&quot;#booking-success&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;RunAlg(this)&quot;</span>&gt;</span>可预订<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-success&quot;</span> <span class="attr">data-toggle</span>=<span class="string">&quot;modal&quot;</span> <span class="attr">data-target</span>=<span class="string">&quot;#booking-success&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;RunAlg(this)&quot;</span>&gt;</span>可预订<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-danger&quot;</span> <span class="attr">data-toggle</span>=<span class="string">&quot;modal&quot;</span> <span class="attr">data-target</span>=<span class="string">&quot;#modal-danger&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;RunAlg(this)&quot;</span>&gt;</span>不可预订<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-success&quot;</span> <span class="attr">data-toggle</span>=<span class="string">&quot;modal&quot;</span> <span class="attr">data-target</span>=<span class="string">&quot;#booking-success&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;RunAlg(this)&quot;</span>&gt;</span>可预订<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-success&quot;</span> <span class="attr">data-toggle</span>=<span class="string">&quot;modal&quot;</span> <span class="attr">data-target</span>=<span class="string">&quot;#booking-success&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;RunAlg(this)&quot;</span>&gt;</span>可预订<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 其他几个重复列就不写了 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;modal fade&quot;</span> <span class="attr">id</span>=<span class="string">&quot;booking-success&quot;</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">role</span>=<span class="string">&quot;form&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-dialog&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-content bg-success&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-header&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">h4</span> <span class="attr">class</span>=<span class="string">&quot;modal-title&quot;</span>&gt;</span>该时段可以占用项目室<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;close&quot;</span> <span class="attr">data-dismiss</span>=<span class="string">&quot;modal&quot;</span> <span class="attr">aria-label</span>=<span class="string">&quot;Close&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="symbol">&amp;times;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-body&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>预定人：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;booking_user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Mickey&quot;</span> <span class="attr">id</span>=<span class="string">&quot;booking_user&quot;</span> <span class="attr">required</span>=<span class="string">&quot;required&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>会议主题：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;theme&quot;</span> <span class="attr">id</span>=<span class="string">&quot;theme&quot;</span> <span class="attr">required</span>=<span class="string">&quot;required&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal-footer justify-content-between&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-outline-light&quot;</span> <span class="attr">data-dismiss</span>=<span class="string">&quot;modal&quot;</span>&gt;</span>Close<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-outline-light&quot;</span> <span class="attr">id</span>=<span class="string">&quot;booking&quot;</span> &gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 这里是弹窗，这里只放可以占用的情况，其他的略过了 --&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>对应的js写法如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- jQuery --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/static/plugins/jquery/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;!-- 用来获取点击单元格后，对应的行首和列首的内容 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">RunAlg</span>(<span class="params">ths</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  　　$(<span class="string">&quot;#myModal&quot;</span>).<span class="title function_">modal</span>(<span class="string">&#x27;show&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">var</span> $td = $(ths).<span class="title function_">parent</span>().<span class="title function_">parent</span>().<span class="title function_">children</span>();	<span class="comment">// </span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">var</span> date = $td.<span class="title function_">eq</span>(<span class="number">0</span>).<span class="title function_">text</span>(); 	<span class="comment">//获取对应的text,eq(0)选取第1个对应的元素（索引号为0），也就是行首</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">var</span> $th = $(ths).<span class="title function_">parent</span>().<span class="title function_">parent</span>().<span class="title function_">parent</span>().<span class="title function_">parent</span>().<span class="title function_">children</span>().<span class="title function_">children</span>().<span class="title function_">find</span>(<span class="string">&quot;th&quot;</span>); <span class="comment">// 找到对应的th标签</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">var</span> lie = $(ths.<span class="property">parentNode</span>).<span class="title function_">prevAll</span>().<span class="property">length</span>;	<span class="comment">//这里是获取对应的列数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">var</span> time = $th.<span class="title function_">eq</span>(lie).<span class="title function_">text</span>();  <span class="comment">// 这里的eq()，括号是一个变量</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(date,time)	<span class="comment">//验证</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">padStartConvert</span>(<span class="params">n</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    n = n.<span class="title function_">toString</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> n[<span class="number">1</span>] ? n : <span class="string">&#x27;0&#x27;</span> + n</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">formatDate</span>(<span class="params">num</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> nowTime = now.<span class="title function_">getTime</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> oneDayTime = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> <span class="title class_">ShowTime</span> = nowTime+num*oneDayTime;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> myDate = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="title class_">ShowTime</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> y = myDate.<span class="title function_">getFullYear</span>();   <span class="comment">//获取年</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> m = myDate.<span class="title function_">getMonth</span>() + <span class="number">1</span>; <span class="comment">//获取月</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> d = myDate.<span class="title function_">getDate</span>(); 		<span class="comment">//获取日</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> weekday = myDate.<span class="title function_">getDay</span>();		<span class="comment">// 这个写法缺点就是“星期日是星期0”</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> [y, m, d].<span class="title function_">map</span>(padStartConvert).<span class="title function_">join</span>(<span class="string">&#x27;-&#x27;</span>) + <span class="string">&quot; 星期&quot;</span>+weekday	<span class="comment">// 这里是日期格式，给纵坐标用的</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;today&quot;</span>).<span class="property">innerHTML</span> = <span class="title function_">formatDate</span>(<span class="number">0</span>); 	<span class="comment">// 这里是的id就可以给单元格用获取今天的日期</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;tomorrow&quot;</span>).<span class="property">innerHTML</span> = <span class="title function_">formatDate</span>(<span class="number">1</span>); <span class="comment">// 纵坐标是未来7天的日期，所以有7个，给对应的id使用</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;today3&quot;</span>).<span class="property">innerHTML</span> = <span class="title function_">formatDate</span>(<span class="number">2</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &lt;!-- 其他日子就略掉了 --&gt;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>效果如下：<br><img data-src="/images/%E8%8E%B7%E5%8F%96%E8%A1%8C%E9%A6%96%E5%88%97%E9%A6%962.png"></p>
<p>本例子所用的js文件来自于 <a href="https://adminlte.io/">https://adminlte.io/</a> 开源框架。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/libin-1/p/6277797.html">https://www.cnblogs.com/libin-1/p/6277797.html</a><br><a href="https://blog.csdn.net/DFSETHTDFD/article/details/80951728">https://blog.csdn.net/DFSETHTDFD/article/details/80951728</a><br><a href="https://blog.csdn.net/czz1315114877/article/details/76694631">https://blog.csdn.net/czz1315114877/article/details/76694631</a><br><a href="https://blog.csdn.net/erdouzhang/article/details/70669990">https://blog.csdn.net/erdouzhang/article/details/70669990</a><br><a href="https://blog.csdn.net/itmyhome1990/article/details/7005784">https://blog.csdn.net/itmyhome1990/article/details/7005784</a></p>
<p><img data-src="/images/%E6%A2%85%E8%A5%BF%E6%A2%A6%E5%9C%86%E7%BE%8E%E6%B4%B2%E6%9D%AF.jpg" title="恭喜梅老板梦圆美洲杯"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title>爬取当前IP并且修改阿里云安全组的脚本</title>
    <url>/2018/08/07/%E7%88%AC%E5%8F%96%E5%BD%93%E5%89%8DIP%E5%B9%B6%E4%B8%94%E4%BF%AE%E6%94%B9%E9%98%BF%E9%87%8C%E4%BA%91%E5%AE%89%E5%85%A8%E7%BB%84%E7%9A%84%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="动机与脚本"><a href="#动机与脚本" class="headerlink" title="动机与脚本"></a>动机与脚本</h2><p>我工位所用的网络是公司特批的海外专线，速度OK还能翻墙出去看看，自从有了这条线爽的飞起，但缺陷就是每周IP地址都会变，IP一变很多的阿里云ecs安全组就要重新配置，因为有一些公网端口比如grafana或者跳板机是只能公司运维人员访问的。这样每周都要手动改一次IP地址太烦了，于是乎，写了下面这个脚本，一劳永逸的解决这个问题：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#coding=utf-<span class="number">8</span></span><br><span class="line">#这个脚本在python3<span class="number">.6</span>下自验通过，用途是去爬当前的<span class="variable constant_">IP</span>地址然后给阿里云安全组添加新的<span class="variable constant_">IP</span>，并且删除掉老的<span class="variable constant_">IP</span></span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore <span class="keyword">import</span> client</span><br><span class="line"><span class="keyword">from</span> aliyunsdkecs.<span class="property">request</span>.<span class="property">v20140526</span> <span class="keyword">import</span> <span class="title class_">AuthorizeSecurityGroupRequest</span></span><br><span class="line"><span class="keyword">from</span> aliyunsdkecs.<span class="property">request</span>.<span class="property">v20140526</span> <span class="keyword">import</span> <span class="title class_">RevokeSecurityGroupRequest</span></span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.<span class="property">profile</span> <span class="keyword">import</span> region_provider</span><br><span class="line"><span class="keyword">import</span> requests,sys,re,os</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> <span class="title class_">BeautifulSoup</span></span><br><span class="line"></span><br><span class="line">clt = client.<span class="title class_">AcsClient</span>(<span class="string">&#x27;这里是AK&#x27;</span>, <span class="string">&#x27;这里是SK&#x27;</span>, <span class="string">&#x27;cn-hangzhou&#x27;</span>)			#鉴权</span><br><span class="line">file = <span class="string">&quot;F:\\ip.txt&quot;</span></span><br><span class="line"></span><br><span class="line">def <span class="title function_">checkDIR</span>():</span><br><span class="line">    <span class="variable language_">global</span> file</span><br><span class="line">    <span class="keyword">if</span> os.<span class="property">path</span>.<span class="title function_">exists</span>(file) == <span class="title class_">True</span>:	#先判断文件是否存在</span><br><span class="line">        <span class="keyword">with</span> <span class="title function_">open</span>(file, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> <span class="attr">f</span>:</span><br><span class="line">            old_ip = f.<span class="title function_">read</span>()</span><br><span class="line">            <span class="keyword">return</span> (old_ip)		#获取旧ip</span><br><span class="line">    <span class="attr">else</span>:</span><br><span class="line">        <span class="title function_">print</span>(<span class="string">&quot;ip.txt文件不存在，请手动生成！&quot;</span>)</span><br><span class="line">        sys.<span class="title function_">exit</span>()		#文件不存在直接退出</span><br><span class="line"></span><br><span class="line">def <span class="title function_">getIP</span>():</span><br><span class="line">    <span class="variable language_">global</span> file</span><br><span class="line">    r = requests.<span class="title function_">get</span>(<span class="string">&#x27;http://www.ip111.cn/&#x27;</span>)        #这里输入要爬的网站域名</span><br><span class="line">    soup = <span class="title class_">BeautifulSoup</span>(r.<span class="property">text</span>, <span class="string">&quot;lxml&quot;</span>)</span><br><span class="line">    context = []</span><br><span class="line">    <span class="keyword">for</span> link <span class="keyword">in</span> soup.<span class="title function_">find_all</span>(<span class="string">&#x27;td&#x27;</span>):    #获取所有td标签内容</span><br><span class="line">        context.<span class="title function_">append</span>(link.<span class="title function_">get_text</span>())     #添加一个列里</span><br><span class="line">    str = context[<span class="number">4</span>]</span><br><span class="line">    ip = re.<span class="title function_">split</span>(r<span class="string">&#x27;[\n\s]\s*&#x27;</span>, str)[<span class="number">1</span>]			#多符号分割字符串</span><br><span class="line">    <span class="keyword">with</span> <span class="title function_">open</span>(file, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> <span class="attr">f</span>:</span><br><span class="line">        f.<span class="title function_">write</span>(ip)</span><br><span class="line">    <span class="keyword">return</span> ip</span><br><span class="line"></span><br><span class="line">def <span class="title function_">addnewRULE</span>(func):</span><br><span class="line">    <span class="variable language_">global</span> clt</span><br><span class="line">    # 设置参数</span><br><span class="line">    <span class="keyword">for</span> port <span class="keyword">in</span> [<span class="string">&#x27;3000/3000&#x27;</span>, <span class="string">&#x27;34872/34872&#x27;</span>]:		#这里是端口</span><br><span class="line">        request = <span class="title class_">AuthorizeSecurityGroupRequest</span>.<span class="title class_">AuthorizeSecurityGroupRequest</span>()</span><br><span class="line">        request.<span class="title function_">set_accept_format</span>(<span class="string">&#x27;json&#x27;</span>)</span><br><span class="line">        request.<span class="title function_">add_query_param</span>(<span class="string">&#x27;RegionId&#x27;</span>, <span class="string">&#x27;cn-hangzhou&#x27;</span>)</span><br><span class="line">        request.<span class="title function_">add_query_param</span>(<span class="string">&#x27;SecurityGroupId&#x27;</span>, <span class="string">&#x27;目标安全组ID&#x27;</span>)</span><br><span class="line">        request.<span class="title function_">add_query_param</span>(<span class="string">&#x27;IpProtocol&#x27;</span>, <span class="string">&#x27;tcp&#x27;</span>)</span><br><span class="line">        request.<span class="title function_">add_query_param</span>(<span class="string">&#x27;PortRange&#x27;</span>, port)</span><br><span class="line">        request.<span class="title function_">add_query_param</span>(<span class="string">&#x27;SourceCidrIp&#x27;</span>,<span class="title function_">func</span>())</span><br><span class="line">        request.<span class="title function_">add_query_param</span>(<span class="string">&#x27;NicType&#x27;</span>, <span class="string">&#x27;intranet&#x27;</span>)      #如果不加这句话就是公网添加</span><br><span class="line">        <span class="keyword">if</span> port == <span class="string">&#x27;3000/3000&#x27;</span>:</span><br><span class="line">            request.<span class="title function_">add_query_param</span>(<span class="string">&#x27;Description&#x27;</span>, <span class="string">&#x27;Grafana使用端口&#x27;</span>)</span><br><span class="line">        <span class="attr">else</span>:</span><br><span class="line">            request.<span class="title function_">add_query_param</span>(<span class="string">&#x27;Description&#x27;</span>, <span class="string">&#x27;Zabbix和堡垒机使用端口&#x27;</span>)</span><br><span class="line">        # 发起请求</span><br><span class="line">        response = clt.<span class="title function_">do_action</span>(request)</span><br><span class="line">        <span class="title function_">print</span> (response)</span><br><span class="line"></span><br><span class="line">def <span class="title function_">deloldRULE</span>(func):</span><br><span class="line">    <span class="variable language_">global</span> clt</span><br><span class="line">    # 设置参数</span><br><span class="line">    <span class="keyword">for</span> port <span class="keyword">in</span> [<span class="string">&#x27;3000/3000&#x27;</span>,<span class="string">&#x27;34872/34872&#x27;</span>]:</span><br><span class="line">        request = <span class="title class_">RevokeSecurityGroupRequest</span>.<span class="title class_">RevokeSecurityGroupRequest</span>()</span><br><span class="line">        request.<span class="title function_">set_accept_format</span>(<span class="string">&#x27;json&#x27;</span>)</span><br><span class="line">        request.<span class="title function_">add_query_param</span>(<span class="string">&#x27;RegionId&#x27;</span>, <span class="string">&#x27;cn-hangzhou&#x27;</span>)</span><br><span class="line">        request.<span class="title function_">add_query_param</span>(<span class="string">&#x27;SecurityGroupId&#x27;</span>, <span class="string">&#x27;目标安全组ID&#x27;</span>)</span><br><span class="line">        request.<span class="title function_">add_query_param</span>(<span class="string">&#x27;IpProtocol&#x27;</span>, <span class="string">&#x27;tcp&#x27;</span>)</span><br><span class="line">        request.<span class="title function_">add_query_param</span>(<span class="string">&#x27;PortRange&#x27;</span>, port)</span><br><span class="line">        request.<span class="title function_">add_query_param</span>(<span class="string">&#x27;SourceCidrIp&#x27;</span>, <span class="title function_">func</span>())</span><br><span class="line">        request.<span class="title function_">add_query_param</span>(<span class="string">&#x27;NicType&#x27;</span>, <span class="string">&#x27;intranet&#x27;</span>)      #如果不加这句话就是公网删除</span><br><span class="line">        # 发起请求</span><br><span class="line">        response = clt.<span class="title function_">do_action</span>(request)</span><br><span class="line">        <span class="title function_">print</span> (response)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="title function_">checkDIR</span>()</span><br><span class="line">    <span class="title function_">deloldRULE</span>(checkDIR)</span><br><span class="line">    <span class="title function_">getIP</span>()</span><br><span class="line">    <span class="title function_">addnewRULE</span>(getIP)</span><br></pre></td></tr></table></figure></p>
<p>整个脚本的逻辑就是先在F盘下有<code>ip.txt</code>里面就保存当前IP地址，然后执行脚本的时候就会先在目标安全组里删除掉这个IP相关的3000端口和34872端口，然后去<code>www.ip111.cn</code>里爬取当前的网址，把新IP写入到<code>ip.txt</code>的同时，再去目标安全组里添加这个新IP相关的3000端口和34872端口。</p>
<h2 id="新的知识点"><a href="#新的知识点" class="headerlink" title="新的知识点"></a>新的知识点</h2><ol>
<li><p>把上一个函数结果当作参数在下一个函数里执行的方法：<br><img data-src="/images/func1.png" alt="akb48"></p>
</li>
<li><p>python的退出有两个：<code>os._exit()</code>和<code>sys.exit()</code>：<code>os._exit()</code>会直接将python程序终止，之后的所有代码都不会执行；<code>sys.exit()</code>会抛出一个异常: <code>SystemExit</code>，如果这个异常没有被捕获，那么python解释器将会退出。如果有捕获该异常的代码，那么这些代码还是会执行。使用<code>sys.exit()</code>来退出程序比较优雅，一般情况下也用这个，<code>os._exit()</code>可以在<code>os.fork()</code>产生的子进程里使用。</p>
</li>
<li><p>在windows里定时执行python脚本的方法：<br>打开<code>控制面板</code>—&gt;<code>系统和安全</code>—&gt;<code>计划任务。</code>如图：<br><img data-src="/images/func2.png" alt="akb48"></p>
</li>
</ol>
<p>点击右侧的<code>创建基本任务</code>，输入任务名称和可选的描述。点击<code>下一步</code>，设置任务的开始时间，可以选择每日执行、每周执行或每月执行。点击<code>下一步</code>，<code>操作</code>选择<code>启动程序</code>，点击下一步输入参数。如图：<br><img data-src="/images/func3.png" alt="akb48"><br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">程序或脚本：python.<span class="property">exe</span>  </span><br><span class="line">添加参数：输入要执行的python脚本路径（包括文件名）</span><br><span class="line">起始于：输入python.<span class="property">exe</span>的目录（不包括文件名） </span><br></pre></td></tr></table></figure></p>
<p>最后点击<code>下一步</code>，整个过程搞定。</p>
<ol start="4">
<li>目前<code>http://www.ip111.cn/</code>网站已经更改了网页格式，上述的代码有一段已经不好使了，需要将<code>getIP()</code>这个函数改成如下的方法: <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">def <span class="title function_">getIP</span>():</span><br><span class="line">    <span class="variable language_">global</span> file</span><br><span class="line">    r = requests.<span class="title function_">get</span>(<span class="string">&#x27;http://2018.ip138.com/ic.asp&#x27;</span>)        #改用这个域名</span><br><span class="line">    soup = <span class="title class_">BeautifulSoup</span>(r.<span class="property">text</span>, <span class="string">&quot;lxml&quot;</span>)</span><br><span class="line">    context = []</span><br><span class="line">    <span class="keyword">for</span> link <span class="keyword">in</span> soup.<span class="title function_">find_all</span>(<span class="string">&#x27;body&#x27;</span>):    #获取body内容</span><br><span class="line">        context.<span class="title function_">append</span>(link.<span class="title function_">get_text</span>())     #添加一个列里</span><br><span class="line">    str = context[<span class="number">0</span>]</span><br><span class="line">    ip = re.<span class="title function_">split</span>(r<span class="string">&#x27;[\[\]]&#x27;</span>,str)[<span class="number">1</span>]		#进行分割</span><br><span class="line">    <span class="keyword">with</span> <span class="title function_">open</span>(file, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> <span class="attr">f</span>:</span><br><span class="line">        f.<span class="title function_">write</span>(ip)</span><br><span class="line">    <span class="keyword">return</span> ip</span><br></pre></td></tr></table></figure>
<img data-src="/images/suyaleisi2.gif" alt="akb48" title="苏牙点球点头球攻破皇马大门"></li>
</ol>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>阿里云</tag>
        <tag>爬虫</tag>
        <tag>python3.6</tag>
      </tags>
  </entry>
  <entry>
    <title>用sdwebui跑prompt的小经验</title>
    <url>/2023/04/15/%E7%94%A8sdwebui%E8%B7%91prompt%E7%9A%84%E5%B0%8F%E7%BB%8F%E9%AA%8C/</url>
    <content><![CDATA[<h2 id="小经验和小心得"><a href="#小经验和小心得" class="headerlink" title="小经验和小心得"></a>小经验和小心得</h2><p>AI从下围棋跨界到聊天现在是作画，最近的大火让prompt也跟着火了起来。prompt是啥呢？就是跟AI交流的指令，目前prompt是支持英文和emoji图标的。AI通过阅读prompt传入的指令，来分析然后再反馈一个结果给人类。所以说如果职业是跟AI有交集的，都建议了解一下prompt，这个任意真的提升效率太多了（我现在业余时间的代码AI包办了80%了,剩下的20%具体情况要自己看）。</p>
<p>当然我们的网络环境很拉，这是耽误各位进步的一个头疼问题…</p>
<p>说回sdwebui的prompt。要用sdwebui画图，肯定要有一个<code>checkpoint</code>，那么这个就是AI画图的原材料。比如我个人比较喜欢的<code>BRA(beautiful realistic Asians)V3</code>这个<code>checkpoint</code>，他的效果就是产出的图非常真实，画亚洲人特别是韩国人，感觉就是照片照出来的照片，所以很多人都拿这个模型产出的图去那种XX论坛上卖…<br><img data-src="/images/ai%E7%94%BB%E5%9B%BE9.JPG" title="这个图我的prompt改了好几次，基本很满意，可惜耳环没画好，跟助听器似的"></p>
<p>prompt里的元素是有前后的，推荐上来先顾全大局，写上<code>best quality</code>、<code>4K</code>、<code>masterpiece</code>这样的话，要求AI产出的图是很高清的。要表达的中心物体放前面写，就好像你拍照，拍人物照，肯定镜头的重心就是人物，然后远处的山啊水啊鸟啊狗啊都是配菜，那么prompt里，就把人物放在最前面。这里人物就要有一番描述了，比如是美国人还是日本人还是韩国人，皮肤如何，男性女性，戴个警察帽子，带一个手表，浅浅的微笑这样的细节描述；然后是场景，比如在银行里，或者在办公室里，黑天白天；动作，比如坐在椅子上翘二郎腿，双手叉腰等等，这样基本就能描述出来一个场景了。差不多也可以产出一个图了。</p>
<p>prompt里也可以用<code>()</code>和<code>[]</code>来调整权重，每一个<code>()</code>代表权重多加1.1，每一个<code>[]</code>代表权重减少1.1。词语之间可以用下划线来链接，比如<code>long_wave_hair</code>就会产出大波浪。</p>
<p>具体的prompt例子我就不说了，C站上有的是，discount和reddit也都有prompt交流群。随便看看就有收获，在那里即学习了prompt又学习了英语单词又学习了英语语法又伤了身体（囧）…</p>
<p>但是要注意，不是每次你的prompt写的所有元素都会被AI全部展示到图片上的，权重大的会优先产出，权重小的可能压根就被舍弃掉了。所以建议同一个prompt多跑几次，然后慢慢挑图，跑的多了，之前没跑出来的元素就会都出现了。</p>
<p>而有一些动作可能跑好几百次也不会跑出来，这种大概率就是这个chickpoint原生不支持，比如我上面说的<code>BRA(beautiful realistic Asians)V3</code>不支持<code>standing split</code>（一字马），估计是做了限制，所以这种情况就要搭配lora，让lora来帮助你完成一字马。当然有些也是失败的，那么就要不停的变换chickpoint。这里建议先去C站看看前任用这个chickpoint做出来的图，如果他们show出来的图是有一字马而且用的prompt是没有使用其他的lora，那么代表这个原生的chickpoint肯定能做一字马，是你的prompt不对，就继续重试，直到出现为止。</p>
<p>通过<code>chickpoint</code>+<code>lora</code>+prompt这样的组合拳来产出图片，这样可以极大地提高出图效率、丰富出图的内容。</p>
<p>最后再来一点实操prompt心得：想好了自己的图片样子，然后就照着这个样子去做。千万不要被眼花缭乱的prompt效果图打乱了计划，我知道C站上美女很多，看着看着就让人心猿意马…虽然他们的prompt能生成你想要的效果，但是他们也是好几次里挑出来那么一次的。一点一点丰富自己的prompt，失败了也不要灰心，只要前任跑出来过，那么多跑几次肯定能得到自己想要的图。如果觉得有些图弃之可惜，可以干脆自己动手，PS掉不爽的那部分。</p>
<h2 id="目前AI的不足"><a href="#目前AI的不足" class="headerlink" title="目前AI的不足"></a>目前AI的不足</h2><ol>
<li><p>还是那句话，产出的图的手脚大概率都是不正常的，这里直接上图：<br><img data-src="/images/ai%E7%94%BB%E5%9B%BE8.JPG" title="多好的姑娘啊，可惜手指头和脚都不对..."><br>但是好的lora+好的chickpoint可以有效的降低手脚畸形的概率。</p>
</li>
<li><p>prompt可以用emoji里的”自拍”、”比耶”、”开心”等等表情来代替英语单词，进而来提升出图的准确性。emoji是能被AI识别的，但是不会每次都识别到。我见过最简单的一个prompt里面的内容就是：<code>🏃🏻‍♀️ 🎒 爬山的emoji</code>，这三个符号就完成了一幅画。但是我尝试把”自拍”的emoji放到prompt里，十几次就出来2次左右的效果。还有一次尝试”比耶”的emoji，直接比出来4个手指头，不知道的还以为是追梦格林…<br><img data-src="/images/%E8%BF%BD%E6%A2%A6%E6%A0%BC%E6%9E%97.JPG" title="老子我有四个总冠军"></p>
</li>
<li><p>目前AI只能从一个checkpoint里学习，玩不了混搭。而且<code>lora</code>虽然方便了一些动作的prompt，但是他还是有使用限制的，比如<code>dolllikeness</code>这个<code>lora</code>，它只能用于近景，如果prompt里又写了<code>full body</code>的话，就跟<code>lora</code>相冲突，<code>full body</code>的效果如果小于lora的权重的话那产出的图就不会出现全身的效果。</p>
</li>
<li><p>AI目前的视角还比较死板，笔直的站着拍正面照的效果是最好的，其次背景效果也很好，然后背转身看镜头这种就有几率失败了，来一点复杂动作就要更加复杂的prompt，而这些prompt很多时候ai还不识别（估计跟英语一个词多个意义有关）。这种就需要sdwebui其他的一些功能来解决问题了。</p>
</li>
<li><p>AI画出来的表情也比较受限，除了微笑、张嘴、吐舌头（这个也一定几率有BUG）、脸红。其他的好像就没啥了，哭泣都不是很明显。除此之外，AI图片的影子也有问题，经常影子跟人相差的得太过离谱，让人细思极恐。</p>
</li>
<li><p>prompt上一些指令被AI识别的结果也让人哭笑不得，我炼丹想做一个”一只手拿着冰棍的妹子”，结果AI画出来妹子手里拿的是冰棍的冰的那部分，棍是冲着嘴的…</p>
</li>
<li><p>除了手脚不行，kiss也不行。之外还有一些动作，比如弹吉他也不行，手根本也没有搭上吉他（感觉好像还是手的问题啊！）。听说<code>controlnet</code>可以解决多指的问题，但是只能解决明显的手问题，比如抱臂这种重叠交叉的场景它还是无能为力。</p>
</li>
<li><p>AI目前没有一个反馈机制，比如它prompt执行的好执行的不好，需要有人类进行反馈，这样来达到训练它的目的，但是sdwebui没有这样的打分机制，这点跟chatgpt不同。</p>
</li>
</ol>
<p>综上所述，可见目前的AI不是万能的，很多地方还需要人手工介入，就冲着它交工不能百分百让人满意，它就注定是一个工具。不要被别人妖言惑众，说AI可以代替谁谁谁的。掌握了工具，用好了工具大家都HAPPY。</p>
<h2 id="如果我想用AI画知名人物"><a href="#如果我想用AI画知名人物" class="headerlink" title="如果我想用AI画知名人物"></a>如果我想用AI画知名人物</h2><p>很多人看到了网上的AI画出来什么特朗普被捕啊普京被捕啊就也想用sdwebui去试试，但是原生的sdwebui里的AI是只知道资料但是不清楚长相的，所以直接输入名字就想是画效果是不好的，比如你输入一个<code>kobe bryant</code>，能出一个穿湖人24号的光头黑人，但是脸跟Kobe差的挺多。</p>
<p>比如二次元圈出名的蒂法，你在prompt里输入<code>Tifa Lockhart</code>，AI画的并不像，那么也想要得到蒂法就需要去训练一个蒂法模样的lora。让这个lora来帮你实现蒂法的长相，lora训练的越好，做出来的画就越逼真，如图：<br><img data-src="/images/ai%E7%94%BB%E5%9B%BE10.JPG" title="盔甲使用ai创造的，脸蛋使用lora校正的"><br><img data-src="/images/ai%E7%94%BB%E5%9B%BE11.JPG" title="这个也是一个上品了，手生成的很不错"></p>
<p>但是lora就有一个问题，因为训练lora多半都是拿正脸照，所以生成的图片也基本都是正脸的，不太能有侧脸或者其他的样子。这一点也证实了上面的第四点“AI目前的视角还比较死板”。</p>
<p>AI直接画名人要面临很严重的法律问题，所以即使你训练了lora，C站也不会直接让你放上去的，所以这种lora你也就只能自己本地留着，或者商用授权卖掉，毕竟这个世界宅男很多，愿意花钱的宅男也很多…</p>
<p>不过前几天发现有一个妹子把自己的照片训练成了lora，并且放到了C站上，<a href="https://civitai.com/models/34102/nana">https://civitai.com/models/34102/nana</a> ，这个妹子倒也不拿兄弟们当外人，任由别人来拿她的脸做福利姬。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/619247417">https://zhuanlan.zhihu.com/p/619247417</a><br>正面prompt学习：<a href="https://gooptions.cc/chickpoint-prompt%E6%95%99%E5%AD%B8/">https://gooptions.cc/chickpoint-prompt%E6%95%99%E5%AD%B8/</a><br>负面prompt学习：<a href="https://vocus.cc/article/amp/642520acfd89780001223a22">https://vocus.cc/article/amp/642520acfd89780001223a22</a><br>控制人物视角：<a href="https://m.huke88.com/article/8069.html">https://m.huke88.com/article/8069.html</a></p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>AI</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>用非root启动进程以及启动docker</title>
    <url>/2018/04/18/%E7%94%A8%E9%9D%9Eroot%E5%90%AF%E5%8A%A8%E8%BF%9B%E7%A8%8B%E4%BB%A5%E5%8F%8A%E5%90%AF%E5%8A%A8docker/</url>
    <content><![CDATA[<h2 id="使用非root用户启动普通进程"><a href="#使用非root用户启动普通进程" class="headerlink" title="使用非root用户启动普通进程"></a>使用非root用户启动普通进程</h2><p>使用非root用户启动进程是运维安全的一个主要环节，拿tomcat进程来说，如果是使用root用户去启动了tomcat，那么有一个严重的问题，那就是tomcat具有root权限。这意味着你的任何一个jsp脚本都具有root权限，所以那些不怀好意的人可以轻易地用jsp脚本去搞破坏，甚至删除你整个硬盘里的东西！所以为了活着，我们要极力避免这种现象。</p>
<p>很多的软件都自带的用户&#x2F;用户组，比如nginx、zabbix、elasticsearch，但是也有更多的软件没有这么贴心的服务，这就需要我们手动的更改了。</p>
<h2 id="docker不应该使用root启动"><a href="#docker不应该使用root启动" class="headerlink" title="docker不应该使用root启动"></a>docker不应该使用root启动</h2><p>1.8版本之前的docker是不支持<code>user namespace</code>的，所以那样的话，如果在docker容器内部使用root运行app，那么不可否认，这个root和宿主机的root是同一个UID。但是，需要特别注意的是，容器内的root与宿主机上的root权限并不一定是相等的。</p>
<p>但是为了绝对的安全，还是推荐把docker升级到1.8以上，然后彻底避免用root去启动容器，在<a href="http://www.projectatomic.io/docs/docker-image-author-guidance/%E9%87%8C%E6%9C%80%E4%B8%8B%E9%9D%A2%E4%B8%80%E6%AE%B5%E4%B9%9F%E6%98%8E%E6%96%87%E8%AF%B4%E4%BA%86---">http://www.projectatomic.io/docs/docker-image-author-guidance/里最下面一段也明文说了---</a><font color=red>生产环境里不要用root用户去启动docker!!!</font><br><img data-src="/images/noroot.png" alt="paradin"></p>
<p>使用非root用户启动docker的办法如下：<br>创建docker组：<code>sudo groupadd docker</code><br>将当前用户加入docker组：<code>sudo gpasswd -a ${USER} docker</code><br>重新启动docker服务：<code>sudo service docker restart</code>或<code>sudo systemctl restart docker</code><br>当前用户退出系统再重新登陆。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.zhihu.com/question/25580965">https://www.zhihu.com/question/25580965</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>由一个实例浅析sed用法</title>
    <url>/2018/01/23/%E7%94%B1%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BE%8B%E6%B5%85%E6%9E%90sed%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>首先，假设我们有一个文件，叫123.txt，<code>cat</code>一下看到里面的内容是这样的：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@func-lms-<span class="number">001</span> ~]# cat <span class="number">123.</span>txt </span><br><span class="line">james</span><br><span class="line">curry</span><br><span class="line">  durant</span><br><span class="line">wade</span><br><span class="line">yaoming</span><br><span class="line">   	 messi</span><br><span class="line">[root@func-lms-<span class="number">001</span> ~]#</span><br></pre></td></tr></table></figure></p>
<p>如果我们想在james前面加上lebron，那么采用的sed语句就是：<code>sed -i &#39;/^james/s/^/lebron /&#39; 123.txt</code>，如果要在curry后面加上champion，那么采用的语句就是：<code>sed -i &#39;/^curry/s/$/ champion!/&#39; 123.txt</code>。</p>
<p>使用完上面两句话之后，再#cat一下，看下效果：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@func-lms-<span class="number">001</span> ~]# cat <span class="number">123.</span>txt </span><br><span class="line">lebron james</span><br><span class="line">curry champion!</span><br><span class="line">  durant</span><br><span class="line">wade</span><br><span class="line">yaoming</span><br><span class="line">     messi</span><br><span class="line">[root@func-lms-<span class="number">001</span> ~]#</span><br></pre></td></tr></table></figure></p>
<p>现在我们要把durant前面加上FMVP这几个字母，按照上面的语句找葫芦画瓢的话，应该是：<code>sed -i &#39;/^durant/s/^/FMVP /&#39; 123.txt </code>。但是很抱歉，这个语句是错误的！因为<code>^</code>是匹配开头durant的意思，而我们再看一下durant那一行的开头是空格。</p>
<p>那么就要用liunx的正则来匹配空格，于是这句话就变成了：<code>sed -i &#39;/^\s\+durant/s/^/FMVP/&#39; 123.txt</code>，<code>^\s\+</code>这个就是正则里匹配空格的意思 。</p>
<p><code>cat</code>一下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@func-lms-<span class="number">001</span> ~]# cat <span class="number">123.</span>txt </span><br><span class="line">lebron james</span><br><span class="line">curry champion!</span><br><span class="line"><span class="variable constant_">FMVP</span>   durant</span><br><span class="line">wade</span><br><span class="line">yaoming</span><br><span class="line">     messi</span><br><span class="line">[root@func-lms-<span class="number">001</span> ~]#</span><br></pre></td></tr></table></figure></p>
<p>那么现在要在messi后面加上”GOAL !!!”，就很简单了。语句是：<code>sed -i &#39;/^\s\+messi/s/$/ GOAL !!!/&#39; 123.txt</code>。</p>
<p>以上我们把有&#x2F;无空格情况下的首尾添加字符都练习了一遍，下面我们要看看如果要在中间添加怎么办？</p>
<p>比如说，有一天苦逼的运维接到开发PL的邮件，说”由于安全基线要求，现在需要监听内网端口“，具体的需求就是把所有含tomcat的模块里的server.xml的文件里添加上内网IP。</p>
<p>原有的server.xml的节选如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Service</span> name=<span class="string">&quot;LMS&quot;</span>&gt;</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span>  <span class="attr">enableLookups</span>=<span class="string">&quot;false&quot;</span> <span class="attr">disableUploadTimeout</span>=<span class="string">&quot;true&quot;</span> <span class="attr">maxThreads</span>=<span class="string">&quot;500&quot;</span> <span class="attr">minSpareThreads</span>=<span class="string">&quot;20&quot;</span> <span class="attr">acceptCount</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span></span><br><span class="line"></span><br><span class="line">         <span class="language-xml"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8088&quot;</span> <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span>  <span class="attr">enableLookups</span>=<span class="string">&quot;false&quot;</span> <span class="attr">disableUploadTimeout</span>=<span class="string">&quot;true&quot;</span> <span class="attr">maxThreads</span>=<span class="string">&quot;500&quot;</span> <span class="attr">minSpareThreads</span>=<span class="string">&quot;20&quot;</span> <span class="attr">acceptCount</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span></span><br><span class="line">                </span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8099&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;AJP/1.3&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span></span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">Engine</span> <span class="attr">defaultHost</span>=<span class="string">&quot;localhost&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Catalina&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                 <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.realm.LockOutRealm&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                                <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;</span> <span class="attr">resourceName</span>=<span class="string">&quot;UserDatabase&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                 <span class="tag">&lt;/<span class="name">Realm</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>现在要把<code>&lt;Connector port=&quot;8099&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</code>这一句里面加上内网IP:<code>1.2.3.4</code>，改成这样：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Service</span> name=<span class="string">&quot;LMS&quot;</span>&gt;</span><br><span class="line">               <span class="language-xml"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span>  <span class="attr">enableLookups</span>=<span class="string">&quot;false&quot;</span> <span class="attr">disableUploadTimeout</span>=<span class="string">&quot;true&quot;</span> <span class="attr">maxThreads</span>=<span class="string">&quot;500&quot;</span> <span class="attr">minSpareThreads</span>=<span class="string">&quot;20&quot;</span> <span class="attr">acceptCount</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span></span><br><span class="line"></span><br><span class="line">                <span class="language-xml"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8088&quot;</span> <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span>  <span class="attr">enableLookups</span>=<span class="string">&quot;false&quot;</span> <span class="attr">disableUploadTimeout</span>=<span class="string">&quot;true&quot;</span> <span class="attr">maxThreads</span>=<span class="string">&quot;500&quot;</span> <span class="attr">minSpareThreads</span>=<span class="string">&quot;20&quot;</span> <span class="attr">acceptCount</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span></span><br><span class="line">                       </span><br><span class="line">               <span class="language-xml"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8099&quot;</span> <span class="attr">address</span>=<span class="string">&quot;1.2.3.4&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;AJP/1.3&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span></span><br><span class="line">               <span class="language-xml"><span class="tag">&lt;<span class="name">Engine</span> <span class="attr">defaultHost</span>=<span class="string">&quot;localhost&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Catalina&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.realm.LockOutRealm&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                                       <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;</span> <span class="attr">resourceName</span>=<span class="string">&quot;UserDatabase&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;/<span class="name">Realm</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>请问怎么做？</p>
<p>答案1：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;/&lt;Connector port=&quot;8099&quot;/s/port=&quot;8099&quot;/port=&quot;8099&quot; address=&quot;1.2.3.4&quot;/g&#x27;</span> server.<span class="property">xml</span></span><br></pre></td></tr></table></figure></p>
<p>答案2：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s@Connector port=&quot;8099&quot;@&amp; address=&quot;1.2.3.4&quot;@&#x27;</span> server.<span class="property">xml</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>研究一下Zabbix 3.4的服务主动发现功能</title>
    <url>/2019/06/21/%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8BZabbix-3-4%E7%9A%84%E6%9C%8D%E5%8A%A1%E4%B8%BB%E5%8A%A8%E5%8F%91%E7%8E%B0%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>我所在组一直以来对不同服务的监控方针是：针对不同的服务（比如nginx,tomcat,mysql等等）创建不同的template，然后将这个template应用于对应的服务器上，在每一个template里添加具体的item和trigger。今天尝试一下全新的自动发现<code>Low-level discovery</code>（LLD）。</p>
<p>LLD对返回的内容有一个json格式，这个json格式必须要被<code>zabbix-server</code>识别。所以我们需要准备一个脚本，脚本的结果就是生成这个json。本文<code>zabbix-server</code>和<code>zabbix-agent</code>的版本都是<code>3.4.15</code>。</p>
<h2 id="服务器内部操作"><a href="#服务器内部操作" class="headerlink" title="服务器内部操作"></a>服务器内部操作</h2><p>首先在被监控服务器里，创建一个脚本<code>/etc/zabbix/script/discovery_services.sh</code>，内容如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">proarray=($(find /var/run/ -name <span class="string">&quot;*.pid&quot;</span>|egrep -v <span class="string">&#x27;(rpc|php_daemon|haldaemon|irqbalance|console-kit-daemon)&#x27;</span> |awk -<span class="string">F&#x27;/&#x27;</span> <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span>|awk -<span class="string">F&#x27;.&#x27;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>))    <span class="comment"># 排除不监控的服务</span></span><br><span class="line"></span><br><span class="line">length=$&#123;<span class="comment">#proarray[@]&#125;		#$&#123;#var&#125;是用来取长度</span></span><br><span class="line">printf <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">printf  <span class="string">&#x27;\t&#x27;</span><span class="string">&quot;\&quot;data\&quot;:[&quot;</span></span><br><span class="line">printf <span class="string">&quot;\t&quot;</span></span><br><span class="line">printf <span class="string">&#x27;\n\t\t&#123;&#x27;</span></span><br><span class="line">printf <span class="string">&quot;\&quot;&#123;#PRO_NAME&#125;\&quot;:\&quot;iptables\&quot;&#125;&quot;</span>       <span class="comment">#必须要添加的iptables</span></span><br><span class="line">printf  <span class="string">&quot;,&quot;</span></span><br><span class="line"><span class="keyword">for</span> ((i=<span class="number">0</span>;i&lt;$length;i++))</span><br><span class="line">do</span><br><span class="line">        printf <span class="string">&#x27;\n\t\t&#123;&#x27;</span></span><br><span class="line">        printf <span class="string">&quot;\&quot;&#123;#PRO_NAME&#125;\&quot;:\&quot;$&#123;proarray[$i]&#125;\&quot;&#125;&quot;</span>	<span class="comment">#for循环取每一项</span></span><br><span class="line">        <span class="keyword">if</span> [ $i -lt $[$length-<span class="number">1</span>] ];then</span><br><span class="line">                printf <span class="string">&#x27;,&#x27;</span></span><br><span class="line">        fi</span><br><span class="line">done</span><br><span class="line">printf  <span class="string">&quot;\n\t]\n&quot;</span></span><br><span class="line">printf <span class="string">&quot;&#125;\n&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>这里我们设定将所有的进程文件的pid统一放到&#x2F;var&#x2F;run下，这样能取到所有进程的文件。脚本里的<code>{PRO_NAME}</code>这个就是自动发现规则中的宏变量，另外这个脚本返回的是符合<code>zabbix-server</code>的json格式。如图：<br><img data-src="/images/LLD7.png" alt="akb48"></p>
<p>同时在加上一个判断进程是否运行的脚本<code>/etc/zabbix/script/program_status.sh</code>，内容如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">procjetName=<span class="string">&quot;$&#123;1:-NULL&#125;&quot;</span></span><br><span class="line">LOCK_PATH=<span class="string">&quot;/var/lock/subsys&quot;</span>     </span><br><span class="line">RUN_PATH=<span class="string">&quot;/var/run&quot;</span></span><br><span class="line">ret_ok=<span class="number">1</span></span><br><span class="line">ret_critical=<span class="number">3</span></span><br><span class="line">ret_unknown=<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>  [[ $&#123;procjetName&#125; == <span class="string">&quot;NULL&quot;</span> ]] ; then</span><br><span class="line">        echo $&#123;ret_unknown&#125;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">&quot;$&#123;LOCK_PATH&#125;/$&#123;procjetName&#125;&quot;</span> ] || [ -f <span class="string">&quot;$&#123;RUN_PATH&#125;/$&#123;procjetName&#125;.pid&quot;</span> ]  || [ -f <span class="string">&quot;$&#123;RUN_PATH&#125;/$&#123;procjetName&#125;/$&#123;procjetName&#125;.pid&quot;</span> ] ; then</span><br><span class="line">        echo $&#123;ret_ok&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        echo $&#123;ret_critical&#125;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p>这个脚本的结果就是：服务若存在就返回1，否则返回3。如图：<br><img data-src="/images/LLD8.png" alt="akb48"></p>
<p>然后在<code>zabbix_agentd.conf</code>里添加两个<code>items</code>，如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">UserParameter=services.scan,/<span class="built_in">bin</span>/bash /etc/zabbix/script/discovery_services.sh</span><br><span class="line">UserParameter=services.status[*],/<span class="built_in">bin</span>/bash /etc/zabbix/script/program_status.sh $<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>服务端操作到此结束。</p>
<h2 id="WEB端操作"><a href="#WEB端操作" class="headerlink" title="WEB端操作"></a>WEB端操作</h2><p>添加自动发现规则与添加item很相似，先<code>configuation</code>—<code>templates</code>—<code>create template</code>:<br><img data-src="/images/LLD1.png" alt="akb48"></p>
<p><img data-src="/images/LLD2.png" alt="akb48"></p>
<p>在新生成的“服务进程自动发现”的template里添加<code>Discovery rules</code>，设定Key是<code>Services.scan</code>如下：<br><img data-src="/images/LLD3.png" alt="akb48"></p>
<p>上面那个<code>Services.scan</code>到时候要写到<code>zabbix-agent.conf</code>里的，切记保持一模一样。然后在点击Filters标签页，如下：<br><img data-src="/images/LLD4.png" alt="akb48"></p>
<p>此处的<code>{PRO_NAME}</code>就是我们的脚本返回的变量，保存之。然后创建一个<code>item prototypes</code>，如图：<br><img data-src="/images/LLD5.png" alt="akb48"></p>
<p>此处需要注意的<code>$1</code>和<code>键值</code>是我们之前定义的，也即是服务名，保存之。</p>
<p>然后创建一个<code>trigger prototype</code>，如图：<br><img data-src="/images/LLD6.png" alt="akb48"></p>
<p>图中的解释器是：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(&#123;auto Service discovery:services.status[&#123;<span class="comment">#PRO_NAME&#125;].last()&#125;&lt;&gt;1) and (&#123;auto Service discovery:services.status[&#123;#PRO_NAME&#125;].last(,1h)&#125;=1)</span></span><br></pre></td></tr></table></figure></p>
<p>这句话的意思是“最后状态不是1同时一小时前的状态是1”的服务出现了问题会发生报警，这主要是因为当启动一些临时进程，比如yum，当yum完毕了之后，进程就不存在了，那么如果只是通过判断进程数的话，就会报<code>yum is down</code>。</p>
<p>至此web端配置结束。</p>
<h2 id="错误解决"><a href="#错误解决" class="headerlink" title="错误解决"></a>错误解决</h2><p>如果web界面出现了<code>Value should be a JSON object.</code>的错误，如图：<br><img data-src="/images/LLD9.png" alt="akb48"></p>
<p>跑到zabbix-server去zabbix-get一下发现有错误：<br><img data-src="/images/LLD10.png" alt="akb48"></p>
<p>将mdadm这个文件夹改成755即可。回到web页面查看一下<code>latest data</code>:<br><img data-src="/images/LLD11.png" alt="akb48"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.zabbix.com/documentation/3.4/zh/manual/discovery/low_level_discovery">https://www.zabbix.com/documentation/3.4/zh/manual/discovery/low_level_discovery</a><br><a href="https://www.xiaomastack.com/2015/07/04/zabbix-auto-tcp-port/">https://www.xiaomastack.com/2015/07/04/zabbix-auto-tcp-port/</a><br><a href="https://www.cnblogs.com/fengbohello/p/5954895.html">https://www.cnblogs.com/fengbohello/p/5954895.html</a> （Linux Shell 截取字符串）<br><a href="http://caosiyang.github.io/2017/03/06/zabbix-get-value-error/">http://caosiyang.github.io/2017/03/06/zabbix-get-value-error/</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>端午南京三日行</title>
    <url>/2020/06/28/%E7%AB%AF%E5%8D%88%E5%8D%97%E4%BA%AC%E4%B8%89%E6%97%A5%E8%A1%8C/</url>
    <content><![CDATA[<p>从2月份新冠肺炎破坏了俺的春节开始，这几乎半年的时间里，俺就只能在杭州本地不能动弹。杭州近期新冠的情况已经有了大幅好转，而且随着天气动不动就30多度，越来越多的人也开始不带口罩。俺跟媳妇出门旅游的心在端午假期里急剧的活动起来，由于端午只有三天，而且北京最近又有了扎堆爆发的新闻，思来想去就选择了南京。</p>
<p>我在购票的时候，发现南京的高铁票还是挺难买的，但是实际高铁上人没有想象的那么多，可能是控制车厢人数的缘故吧。从杭州出发，一小时多一点就抵达南京，从南京南站出来之后，直接打车到新街口，找到酒店办理入住手续。<br><img data-src="/images/%E5%8D%97%E4%BA%AC%E5%8D%97%E7%AB%99.JPG" alt="akb48" title="南京南站的晚上10点，人并不多"></p>
<p>把行李卸在坊间之后，出来溜达一下顺便找便利店买点水。话说新街口真的很繁华，各种商业中心高楼大厦在这里林立，10点多钟还是有不少人在街边。我住的酒店不远的商场有一个大屏幕，滚动播放刘雯、周杰伦、杨幂、邓伦等人的广告，偶尔还穿插一条“祝杨芸睛火箭少女毕业”的10秒视频…</p>
<h2 id="南京的玩"><a href="#南京的玩" class="headerlink" title="南京的玩"></a>南京的玩</h2><p>端午时节，南方正值酷暑，虽然天频繁降大雨，但是没有多么凉快，反而把空气弄得很潮湿。所以我在安排旅程上都是尽量安排室内，端午三天里分别去了南京博物院、总统府、老门东、玄武湖和夫子庙夜市。</p>
<p>南京有很多个“XX博物X”，比如南京博物院跟南京博物馆是两个地方，网上很多人都推荐去博物院。虽然是凭身份证免费进入，但是要提前预约。博物院上面都是从古到今的文物，而底下一层是民国一条街，那里人气比较旺，很多人在这里拍照。不过有管理人员在巡逻，一旦发现你摘下口罩就会提醒，于是俺给媳妇儿拍照都是趁管理人员不注意的时候，摆好pose摘下口罩按快门的。<br><img data-src="/images/%E9%93%9C%E7%BA%A2%E7%81%AF.JPG" alt="akb48" title="南京博物院这个汉代铜红灯造型看上去萌萌哒"></p>
<p>但是由于疫情的缘故，南京博物院很多演出没有开放，比如民国一条街的茶楼以及演出。总统府就更过分了，网上提前一天预约，结果里面所有的文物展出一个都没开放，到看到了不少的野猫—现在总统府成了很多野猫的家，这些猫在草丛里跑来跑去，毫不怕人。除了看看猫和建筑楼之外，32块钱连一个文物都没看到。只是进去转了一圈而已。话说这点真的很坑，里面文物不提供参观，但是门票费到是不打折。<br><img data-src="/images/%E6%80%BB%E7%BB%9F%E5%BA%9C.JPG" alt="akb48" title="这个旗杆光秃秃了70多年，但是大门依旧很挺拔"><br><img data-src="/images/%E4%B8%A4%E6%B1%9F%E6%80%BB%E7%9D%A3%E5%A4%A7%E5%8E%85.JPG" alt="akb48" title="两江总督这个位置很少有干长久的"><br><img data-src="/images/%E5%AD%99%E4%B8%AD%E5%B1%B1%E4%BC%9A%E5%AE%A2%E5%AE%A4.JPG" alt="akb48" title="跟现在同级别会议室的气势没法比了"><br><img data-src="/images/%E5%AD%99%E4%B8%AD%E5%B1%B1%E5%8A%9E%E5%85%AC%E5%AE%A4.JPG" alt="akb48" title="看上去跟以前课本学的周总理办公室差不多格局"></p>
<p>总而言之，在疫情的特殊环境下，南京的景点游都是“阉割”版。本身主力就是室内游，但是演出又被cut，这样转来转去没啥特别的意思，还不如买杯DQ加喜茶早点回酒店吹着空调看《乘风破浪的姐姐》…</p>
<p>不过户外还是挺不错的，老门东一条街里有好多身着汉服袍子的人，各种老小、无论男女。街边也有不少的店做“出租汉服+做发型+拍照”的生意，德云社还是没有开，城墙上有几个人走来走去，老门东有一些文青的店可以去淘淘。对比夫子庙，老门东的艺术元素更多一点。夫子庙现在的确商业化挺严重，东西挺贵的，然后除了秦淮河没有什么特别的卖点了，科举博物馆到是还不错，还能在里面近距离的看秦淮河游船。<br><img data-src="/images/%E8%80%81%E9%97%A8%E4%B8%9C.JPG" alt="akb48" title="杭州的河坊街跟老门东有一定的差距"><br><img data-src="/images/%E5%8F%B3%E6%B4%BE%E6%AF%95%E4%B8%9A%E4%B9%A6.JPG" alt="akb48" title="当时被划成右派的人真是不知道怎么挺过来的"></p>
<h2 id="南京的吃"><a href="#南京的吃" class="headerlink" title="南京的吃"></a>南京的吃</h2><p>俗话说得好，没有一只鸭子可以活着离开南京城。到了南京的第二天，我一个懒觉睡到10点多，就爬起来去有名的“金宏兴鸭子店”排队。这个鸭子店在老城区，离新街口不远。店里有两个窗口，一个窗口是提供”切片”服务，一个不提供，直接整只鸭子提走。由于天实在太热，我就排了“整只提走”的窗口，要了半只烤鸭，37块钱。带回酒店里跟媳妇撕着吃了当午饭。话说虽然很多南京人喜欢吃盐水鸭，但是烤鸭是我的爱啊！金宏兴的烤鸭也的确不错，把焦焦的鸭皮和嫩肉撕扯下来，沾一下他们的蘸料，一大口吃下去很爽的。他们的烤鸭偏甜，不像北京烤鸭，并不用裹薄饼，全是肉。<br><img data-src="/images/%E9%87%91%E5%AE%8F%E5%85%B4%E9%B8%AD%E5%AD%90%E5%BA%97.JPG" alt="akb48" title="南京南站的晚上10点，人并不多"></p>
<p>既然外面天那么热，就平时多在室内吹空调吧。除了金宏兴的鸭子不得不室外排队之外，剩下的饭我们都是在室内解决。其实南京的美味还是挺多的，本次下来印象最深的是两个店—“民国红公馆”和“可西玛西班牙餐厅”。</p>
<p>南京有很多民国红公馆，我去的是在老门东的那家。里面的装修环境是民国风，他们的“芥末虾球”超级好吃！每一个虾球都很大颗，肉很饱满，虽然有芥末，但是味道并不是很呛，我一口气吃了4个！“秦淮煮干丝”也不错，是很有特色的淮扬菜，煮的汤好像是鸡汤。“美龄粥”我个人觉得比“南京大牌档”更好吃一点，虽然是小份但是也上了挺大一个盆，粥里面豆浆和牛奶的味道很明显。虽然民国红公馆整体来说价钱有点小贵，但是味道还是挺不错的，我媳妇一通暴风吸入,直吃到胸脯高出下巴两寸。</p>
<p>可西玛西班牙餐厅位置在南京大学附近，是一个超级mini店，小到室内只有3张桌子，员工就老板一个人，他身兼服务员的角色。我去之前先打了一个电话，幸好还有一个坑。点了他家的“西班牙海鲜饭”、“蒜香烤翅”和“烤猪排”。海鲜饭两个人吃有点小多，米饭糯糯的，里面的大虾和芝士都不错。烤猪排是最赞的，烤的又软又香，肉的分量也足，还有一点香草味。据说做西餐最难的就是找国外正宗的调料，看样子老板还是挺有门路的。</p>
<p>除了这两家之外印象最深之外，其他吃的比如“南京大牌档”、“鸡鸣汤包”这些，网上有很多评价了。在滴滴车上与跟南京司机大哥唠嗑，他推荐了两家苍蝇馆子：一个是中华门的“无名面条店”，另一个是在雨花台区的“鸿鑫酸菜鱼馆”。尤其是“鸿鑫酸菜鱼馆“，这位司机大哥，极力推荐让我们去尝尝他家的红烧鸡块，说做的特别好吃。可惜距离我们住的酒店太远，本次只能作罢…</p>
<p>至于“鸭血粉丝汤”和“阳春面”，据网上说鸭血粉丝汤原来是没有粉丝的，加入粉丝是80年代后的事儿了；“阳春面”就更别提了，虽然“南京大牌档”的阳春面实惠又好吃，但是它压根就不是南京土著的菜…</p>
<h2 id="南京的人"><a href="#南京的人" class="headerlink" title="南京的人"></a>南京的人</h2><p>南京在官方宣传是“六朝古都”，据说这个说法来自于《资治通鉴》。但是司马光写的“六朝”都是小政权。主要是北宋被金揍的只能南迁，丢了北方大片土地，于是读书人就改认“占中原者方为正统”而自我欺骗。到了明朝随着朱元璋的发家称帝、江南总督府的设立、太平天国建国、民国临时政府成立等等大事给了这座城市更重的政治意义。而这样的政治意义也给了这座城市很多次的伤害，无论是太平天国、湘军、日本人（其实前两者对平民的践踏要远比日本人要多得多得多）留下的伤痕都是难以磨灭的。新中国成立以后，六朝古都在经历过政治轮替沧桑后尚未缓过神，就一头扎进了市场经济的大浪潮中，努力找寻自己的新角色。虽然在江苏省内贵为长子，南京却在经济辐射等层面感受到来自苏州无锡等竞争者的压力，而不像其他唯我独大的中部省会那么骄傲至尊；提及历史文化，南京又常常与夜泊秦淮、六朝金粉等词汇紧密联系。现在的南京，你可以摩挲，可以凭吊，可以悠然遐想；想到六朝的兴废，王谢的风流，秦淮的艳迹。这些也许只是老调子，不过经过自家一番体贴，便不同了。</p>
<p>南京自古就是教育重点城市，现在更是著名的大学之城，最新的数据表示南京一共10所高校排名亚洲TOP 500，于是坊间戏语：“在南京读书，在杭州挣钱”。其实现在随着京东和国美的牛逼，南京也有了不少的互联网公司。而且南京有钱人也很多，我所住新街口的酒店地下通道走几步就是徳基广场，那是一个很高档的购物中心，里面一线大牌一应俱全。在奢侈店门口排队的人挺多的，不少人也是左手一个袋右手一个兜，心满意足的从店里出来了。</p>
<p>总之，政治略失落、经济略弱势、文化略阴柔的南京城，在文艺上也有绵柔内敛的气质。在风风雨雨数千年里它有过很多名字，“江南佳丽地，金陵帝王州”，无疑金陵是它的名字里最好听的。</p>
<h2 id="一点tips"><a href="#一点tips" class="headerlink" title="一点tips"></a>一点tips</h2><p>1.南京商场和九点都需要支付宝上申请“苏康码”，绿码才能进入。第一次申请不要紧，可以通过微信的大数据查到你过去的行程。你的行动范围都在老大哥的关注下，幸福吧~<br><img data-src="/images/%E5%A4%A7%E6%95%B0%E6%8D%AE.JPG" alt="akb48" title="老大哥关心着你..."></p>
<p>2.南京地铁买票是不能刷手机的，但是可以在支付宝上搜索“南京地铁”直接进入；<br>3.最后一段留给南京市民逼哥，你的歌不会被人忘记的…</p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>旅游</tag>
        <tag>国内</tag>
        <tag>南京</tag>
      </tags>
  </entry>
  <entry>
    <title>端午澳门3日行</title>
    <url>/2024/06/06/%E7%AB%AF%E5%8D%88%E6%BE%B3%E9%97%A83%E6%97%A5%E8%A1%8C/</url>
    <content><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>媳妇是李宗盛的歌迷，一直以来的愿望就是想亲眼看看李宗盛。而我在上大学的时候，就看过纵贯线的演出了。所以这次为了满足她，就想买李宗盛演唱会的门票，奈何杭州场太火爆，就转投澳门场。</p>
<p>澳门的门票可以用cityline去购买，用cityline购买的好处就是可以直接选座，再结合网上的座位图就能知道自己坐的位置。这点比大麦要好，大麦的选座完全就是开盲盒。cityline支持支付宝付款，买好票后选择去票点取票，不要选邮寄，邮寄费据说200人民币…<br><img data-src="/images/cityline%E8%B4%AD%E7%A5%A8.png" alt="paradin" title="购票成功，还会给你一个二维码，然后在取票机上扫描二维码即可·"></p>
<p>搞定演唱会门票和机票，然后就是在澳门选择酒店了，我这次毕竟是端午假期，几个大酒店价格都好贵，比较了很多app，也没有一个最优解，后来选择了新中央酒店，据说这个酒店有个光荣的过去，但是后来因为经营不善衰败了，后来被新的老板购入后直接关门装修，又不幸的遇到了新冠疫情，推迟到今年4月份才重新开业，我看了几个up主的探店视频，觉得里面的装修还挺有特色，价钱比较友好亲民，而且距离大三巴、玫瑰圣母堂都很近，就选择了这家。</p>
<p>然后就是搞定港澳签注，我之前就办理过港澳通行证，但是一直没用过。先去支付宝，搜索“移民局”预约签注。在约好的日子去派出所办理，照个照片交40，上交通行证拿到一个回执单，大约7天后，凭借回执单就取回自己的港澳通行证，后面就有有效期。</p>
<p>这里多说一下，港澳通行证的一年签不是一年内只能去一次的意思，是一年内可以去多次，但是每次的有效期内必须返回内地，不然算违约，违约的话连澳门的赌场都不会让你进的。</p>
<p>下一步，去银行兑换澳门币，我大约兑换了2000澳门币，再加上之前剩下的零散的港币。大约2500左右，剩下的就靠扫支付宝了。</p>
<p>最后一步就是搞定境外流量，其实我是不懂为啥都是中国，但是港澳的流量是单独的一套，但是现实就是这么一个现实，中国移动有免费的3G境外流量相赠，在澳门落地的时候流量自动生效，在移动app上领取后就等待出发的那天了！</p>
<h2 id="玩玩玩"><a href="#玩玩玩" class="headerlink" title="玩玩玩"></a>玩玩玩</h2><p>Day 1: 飞机中午抵达澳门刷通行证出机场，机场右边出门就能看到六辆酒店免费“发财车”，我们坐上葡京的发财车大巴，先去上葡京再转新葡京，然后从新葡京走去新中央酒店，路程大约10分钟。<br><img data-src="/images/%E5%8F%91%E8%B4%A2%E8%BD%A6.jpeg" alt="paradin" title="发财车的攻略可以查“珠海本地宝”微信公众号"></p>
<p>酒店说是3点才可以入住，但是我们是2点多办理check-in也拿到了房卡，酒店的装修和服务员的服饰的确很有民国特色，服务员也非常的热情主动，房间里还赠了一瓶malo红酒。打开电视，里面能看到台湾中天、香港TVB、澳门本地电视台和葡语频道，再往后翻还有日本nhk、韩国KBS、看热闹不怕事大的半岛电视台、法语频道以及土耳其电视台等等全球不少的频道。<br><img data-src="/images/%E6%96%B0%E4%B8%AD%E5%A4%AE%E9%85%92%E5%BA%97.jpeg" alt="paradin" title="这里主打一个交通方便，去几个景点都是步行"></p>
<p>然后休息了一下就出门走去了大三巴，不巧天下了不小的雨，但是大三巴的游客依旧很多。顶着雨拍了几张照，琢磨路太滑了就不去旁边大炮台了，在旁边的优衣库避了避雨，想到今天雨这么大，袜子湿了，买了双袜子。<br><img data-src="/images/%E5%A4%A7%E4%B8%89%E5%B7%B4.jpeg" alt="paradin" title="雨中的大三巴"></p>
<p>从大三巴出来走几步就到了玫瑰圣母堂，话说澳门本地除了一个妈祖庙就是各种教堂，和尚庙几乎没有。玫瑰圣母堂是一个依旧在用的教堂，里面装修很有欧洲的教堂特色，门口的海报还有礼拜的时间安排、当天的布道牧师甚至还有做礼拜的语种。<br><img data-src="/images/%E7%8E%AB%E7%91%B0%E5%9C%A3%E6%AF%8D%E5%A0%82.jpeg" alt="paradin" title="一个老人在祈祷"></p>
<p>从圣母堂出来往酒店方向走，就是市政厅，市政厅前有一个喷泉，澳门的市政厅很小，里面的公告栏里很多都是法律的传人单和各种公示单。市政厅小是对的，搞得机构那么庞大冗余养一大堆效率低下的公务员才是真扯淡。<br><img data-src="/images/%E5%B8%82%E6%94%BF%E5%8E%85.jpeg" alt="paradin" title="不晓得这里是不是还用来办公"><br><img data-src="/images/%E5%B8%82%E6%94%BF%E5%8E%85%E5%85%AC%E5%91%8A.jpeg" alt="paradin" title="这哥们是内地一个家，澳门一个家啊..."></p>
<p>澳门的公交车是可以刷支付宝或者支持港币投币的，不过这次我们打算坐一下他们的空轨，于是就一直往妈阁站走。路上经过了玛嘉烈蛋挞店，买了6个蛋挞60元，感觉就是肯德基水平，不如杭州的裕莲茶楼的蛋挞好吃。后来我网上看了才知道，蛋挞原来的发明者叫做安德鲁，一个英国人，他的老婆叫玛嘉烈，他俩后来离婚了，但是各自有各自的蛋挞配方，后来玛嘉烈把自己的配方卖给了肯德基。<br><img data-src="/images/%E7%8E%9B%E5%98%89%E7%83%88%E8%9B%8B%E6%8C%9E.jpeg" alt="paradin" title="蛋蛮多"></p>
<p>经过一连串的老楼区，发现了圣老楞佐堂，这个名字的中文翻译很奇怪，其实原名是S.lawrence Church。在慈幼中学旁边，也是澳门最古老的三个教堂之一，整个教堂的装修非常具有欧洲风格，里面非常的安静肃穆，有两两三三上了年纪的基督徒在里面低声祷告，窗上的画、屋顶的灯都有宗教气息，大厅里是有一个管风琴，有人弹琴起来，整个声音在教堂里回荡，很好听。<br><img data-src="/images/%E5%9C%A3%E8%80%81%E6%A5%9E%E4%BD%90%E5%A0%82.jpeg" alt="paradin" title="据说这个教堂已经五百多年了，经历了5次大翻修"></p>
<p>马上到妈阁空轨站的时候，就看到了妈阁庙，话说这一路的景点包括大三巴都是免费的，因为下雨的缘故，我们就是简单走了一下。到了妈阁庙的车站，在自助售票机前买票，投进纸币，自助售票机吐出来一把5块的钢镚，这下坐公车的钱有了。话说澳门的空轨原来也是不用安检的，可见地铁安检应该是内地特色吧。</p>
<p>空轨离开澳门半岛到了凼仔这边，我们在银河演艺馆下车，凭借cityline的二维码拿到票后就直接落座了。</p>
<p>话说李宗盛一把年纪了，从20点10分唱到23点15左右，连talking带唱几乎了3个小时，也是蛮有体力的，整个演唱会听下来，感觉是他的一个人生小总结。从他的创作轨迹可以印证了一句王家卫的台词：“见众生、见天地、见自己”，这个小老头无愧于音乐匠人的身份。<br><img data-src="/images/%E6%9D%8E%E5%AE%97%E7%9B%9B.jpeg" alt="paradin" title="90年代到2000年是他的一个创作高峰"><br><img data-src="/images/%E6%9D%8E%E5%AE%97%E7%9B%9B2.jpeg" alt="paradin" title="离开了滚石后，他开始更多的唱人生"></p>
<p>从银河综艺馆出来，一拐弯就看到了巴黎人酒店门口的埃菲尔铁塔，夜景下的埃菲尔铁塔也是很好看的，拍了几张照片后，就坐26A公车返回酒店。<br><img data-src="/images/%E6%BE%B3%E9%97%A8%E9%93%81%E5%A1%94.jpeg" alt="paradin" title="这是按照巴黎铁塔一半的规格仿造的"></p>
<p>下了车，感觉有些肚饿，发现街边还有午夜炒饭，就买了一个牛腩粉和一份炒粉，带回去慢慢享用。</p>
<p>Day 2: 酒店的早餐是持续到10点45，昨天折腾一天的我们这次足足睡到了10点下楼，酒店的早餐不是自助的，是选择套餐后服务员端过来，他们有中西两种早餐，外加可以再选一杯饮品，豆奶很不错。<br><img data-src="/images/%E6%96%B0%E4%B8%AD%E5%A4%AE%E4%B8%AD%E5%BC%8F%E6%97%A9%E9%A4%90.jpeg" alt="paradin" title="早餐还是很丰富"></p>
<p>第二天不再下雨，天气开始闷热，整个城市仿佛是在大蒸笼里，我们一路走一路拍照，步行去了永利皇宫看发财树。话说澳门虽然室外景点不多，但是几个五星级大酒店各个都是景点。发财树那浑身24K的金片片看的人震撼不已，发财树前一拐弯就到了永利皇宫的赌场，话说一般赌场都是有围栏遮挡的，但是这个没有。<br><img data-src="/images/%E4%B8%8A%E8%91%A1%E4%BA%AC.jpeg" alt="paradin" title="很多人也在我这个角度拍照，上葡京是这里的标志建筑"><br><img data-src="/images/%E6%B0%B8%E5%88%A9%E7%9A%87%E5%AE%AB.jpeg" alt="paradin" title="永利的logo"><br><img data-src="/images/%E5%8F%91%E8%B4%A2%E6%A0%91.jpeg" alt="paradin" title="缓缓升起，金光灿灿，周围好多人在拍拍拍"></p>
<p>从永利皇宫出来后我们坐车往官也街出发，话说现在官也街也是游客成群，基本所有的店都要排队，在官也街七逛八逛，竟然走到了澳门的民事登记局。然后就顺道去了喜莲咖啡吃了一下，再坐车去伦敦人。<br><img data-src="/images/%E6%BE%B3%E9%97%A8%E6%B0%91%E6%94%BF%E5%B1%80.jpeg" alt="paradin" title="办理结婚离婚请到此"></p>
<p>伦敦人、巴黎人、威尼斯人这三个都是同一个“金沙集团”下的五星级高端酒店，这哥三的距离也不远，中间还夹着一个Four Season高端卖场，整条街是非常的奢华。而且威尼斯人酒店还是韩国著名歌星鸟叔PSY《new face》 MV的拍摄地，里面的人造河和人造天空还是很美丽的。<br><img data-src="/images/%E5%A8%81%E5%B0%BC%E6%96%AF%E4%BA%BA.jpeg" alt="paradin" title="坐船一人178"></p>
<p>这几家高端酒店的建筑也是各有各的风味，在彼此相连的长廊里能看到很多网红在凹造型拍照。酒店里面的还有饮食一条街，有Lady M这样的精品蛋糕店。我们逛了逛几个包的店，服务生小妹妹听普通话表情非常专注，有一点好玩，但是总体来说还是沟通没问题的。我们在这里足足逛到晚上8点，上了巴黎人门口的铁塔免费的观景区拍了拍照就坐车返回酒店。<br><img data-src="/images/%E6%BE%B3%E9%97%A8%E9%93%81%E5%A1%942.jpeg" alt="paradin" title="澳门铁塔有一层是可以免费观光，顶层观光是收费的，70元"><br><img data-src="/images/%E4%BC%A6%E6%95%A6%E4%BA%BA%E5%A4%A7%E5%A0%82.jpeg" alt="paradin" title="这个大堂是按照维多利亚火车站设计的，上面站的是希腊的爱神"><br><img data-src="/images/%E4%BC%A6%E6%95%A6%E4%BA%BA%E5%A4%A7%E9%92%9F.jpeg" alt="paradin" title="这个大笨钟是跟伦敦真实的大笨钟一样比例的，而且也有到点报时功能"></p>
<p>这次肚饿就没有选择午夜炒饭，而是看到了一个牛杂摊，话说澳门的牛杂也是名声在外，买了一份牛杂外加单独的一份牛肚，75澳币，感觉很不错。回到家打开电视，看澳门本地频道在播他们今天的龙舟比赛新闻，看到赌王的四姨太有出场颁奖。<br><img data-src="/images/%E7%89%9B%E6%9D%82.jpeg" alt="paradin" title="这张照片很市井"></p>
<p>Day 3：这是澳门的最后一天了，起床去了赛车博物馆，话说博物馆旁边是澳门理工大学，我先去附近的书店转了转，买了几个冰箱贴，澳门书店里有些书是从上往下看的，跟台湾一样。<br><img data-src="/images/%E6%BE%B3%E9%97%A8%E4%B9%A6%E5%BA%971.jpeg" alt="paradin" title="这里卖很多外文杂志"><br><img data-src="/images/%E6%BE%B3%E9%97%A8%E4%B9%A6%E5%BA%972.jpeg" alt="paradin" title="澳门当地的大学教科书"></p>
<p>到了赛车博物馆，扫码取票，里面有很多赛车以及摩托车，都是当年的冠军车辆。里面也有摩托车和赛车的vr体验游戏，整个博物馆玩下来大约1个小时，舒马赫、汉密尔顿的等身蜡像也可以用来一顿拍照。<br><img data-src="/images/%E6%B1%89%E5%AF%86%E5%B0%94%E9%A1%BF%E5%92%8C%E8%B5%9B%E8%BD%A6.jpeg" alt="paradin" title="当年汉密尔顿和舒马赫都在澳门比赛过，天王郭富城也来比赛过两次"><br><img data-src="/images/%E8%B5%9B%E8%BD%A6%E5%8D%9A%E7%89%A9%E9%A6%86%E7%9A%84%E6%91%A9%E6%89%98%E8%BD%A6.jpeg" alt="paradin" title="格兰披治赛的东望洋赛道非常难，无论是摩托车还是赛车，出意外的概率还是挺高的，无愧于刺激的运动"></p>
<p>博物馆出来就到了渔人码头，整个渔人码头是仿罗马斗兽场建筑，里面有很多的婚礼拍照，现在渔人码头不是很热闹，好多的店都是空着，不过那里最近要办一个美食街，很多的小车摊位都在装修中。<br><img data-src="/images/%E6%B8%94%E4%BA%BA%E7%A0%81%E5%A4%B4.jpeg" alt="paradin" title="古罗马斗兽场风格，远处拍照老哥的马步扎的很帅"><br><img data-src="/images/%E8%9B%8B%E6%8C%9E%E5%86%B0%E7%AE%B1%E8%B4%B4.jpeg" alt="paradin" title="蛋挞的冰箱贴是这里的特色，我毫不犹豫的买了一个"></p>
<p>从渔人码头返回酒店，办理退房顺道再看看另一个比较有名的蛋挞店bamu bakery，但是可惜去的时候蛋挞都卖光光了，要等1个小时才能好，只能抱憾离开。看到对面店有卖炸蟹钳，买了一个尝尝。<br><img data-src="/images/%E7%82%B8%E8%9F%B9%E9%92%B3.jpeg" alt="paradin" title="搭配甜辣酱吃"><br><img data-src="/images/%E7%8C%AA%E6%89%92%E5%8C%85.jpeg" alt="paradin" title="就那样吧，尝尝特色"></p>
<p>拎着箱子去了上葡京准备蹭发财车去机场，结果刚到上葡京手机app提示飞机晚点一个小时，这下更不用着急了，就在上葡京的赌场里逛逛溜溜，然后坐酒店大巴到澳门机场，在免税店买了两条seven stars，返回杭州，游程结束～</p>
<h2 id="澳门的赌博"><a href="#澳门的赌博" class="headerlink" title="澳门的赌博"></a>澳门的赌博</h2><p>澳门是一个赌博城市，他是亚洲的拉斯维加斯。早在2006年，澳门的赌博市场就超过了拉斯维加斯，是世界最大的赌博中心。随着疫情管控结束，它又重夺世界第一的宝座。这里有大大小小的30家合法娱乐场，里面装修的金碧辉煌，我这次去就逛了两家娱乐场，一个是永利皇宫一个是上葡京，赌场里人不少，上至白发老太太下到刚满足21岁能进赌场的人都在里面。里面有各种各样的机器，比如老虎机，屏幕上“多福多寿”的金色字样还有年画上的胖娃娃，赢钱后就跟拼多多的界面似的，满屏幕的爆金币放礼花，看的人热血沸腾。还有赛马机，原理跟老虎机一样，把钱或者筹码塞进去，然后就是听天由命了，机器跑出来什么结果就是什么结果，你什么都控制不了。</p>
<p>赌大小是非机器类最简单的赌博节目，荷官揭开手边的盖子亮出三个骰子的结果，然后在屏幕上输入三个骰子的数值，放筹码的对应数字板如果是符合的就会亮，反之就不亮。如果只是猜三个骰子是大是小，那么赔率会很低，如果要猜的更进一步赔率就很高。这个其实也是赌运气，荷官旁边有电子屏幕，会记录最近几十次的结果，我留意一下，很多机器结果的概率根本不是50%，我甚至看到过一个屏幕上10次连着大，然后又连着7次小。所以完全指望50%是不现实的。</p>
<p>总来玩赌博的人往往比较迷信，要么穿的特别红，要么就是有其他的一套装扮说法。有的荷官前玩的人就很多，有的赌台一个人都没有，就荷官自己干坐着。</p>
<p>上面几个都是不用动脑子，就拼运气的。赌场还有一些有技术含量的，比如21点或者幸运6，这些是需要算概率和拼胆量的。但是所有的赌局都很快，平均1～2分钟一把。<br><img data-src="/images/%E8%B5%8C%E5%9C%BA.jpeg" alt="paradin" title="赌场里不让拍照，毕竟拍到明星或者官员就不好了"></p>
<p>赌场里面让我印象最深的就是时不时赌场的另一边就一个人“嗷”的吼一嗓子同时砸一下机器，然后听到有人开始鼓掌，还有女性的欢笑声，我想那一定是这哥们中大的了，高低得吃顿好的。</p>
<p>赌场里面的矿泉水是免费的，据说有些赌场还有免费的蛋挞吃，这里主打一个管吃管喝一条龙服务，甚至你想固定玩一台机器，比如这个机器“运势”非常好或者它积累的钱很多，但是有内急或者其他紧急事儿，那么你可以要求场内的保安帮你看住这个机器等你回来。甚至你赢的钱也可以存在赌场，用于你下一次再来玩，只不过存在这里没有利息。</p>
<p>都说小赌怡情，但是赌博的快感给人的刺激是很大的，赌场都是24小时运营，据说赌通宵的人大把，凌晨3点多也有睡不着的赌徒跑进来晃晃，观察到手气不错的人就跟着他押注。既然涉及到钱，也难免要有金钱的纠纷，澳门的几个大酒店基本都有人命案，甚至有几次法医警察直接就从大堂进来直扑出事的房间，给其他旅客造成恐慌，然后添油加醋被传成都市悬疑剧。一般来说出事后，酒店往往会将问题房间所在的一层都重新装修，把那一层的门牌号都调整。</p>
<p>总体来说，赌场带来了治安的问题，同时也给澳门政府带来了大量的就业岗位和税收，是一个无法割舍的肥肉。看新闻每月光从内地来澳门的游客就200万左右，再加上香港、台湾还有其他地区的游客，正是这帮人支撑起来澳门的运营。不过澳门也有些博彩业在消失，比如赛狗、赌赛车、赛鸽、山票。就连赛马也在2024年4月1日终止运作，不晓得那一块赛马场将来要留着有什么规划。</p>
<h2 id="澳门印象"><a href="#澳门印象" class="headerlink" title="澳门印象"></a>澳门印象</h2><p>这是我第一次来到特区，总体感觉这里的确跟内地很多城市不同，给了我很新奇的观感。首先澳门是一个多国文明混杂的小城市，这里不仅有内地人和澳门土著，还有越南人、葡萄牙人、黑人以及其他看不出具体国家的人以及上面所有人种的混血后代，他们的手机里有完全不同于内地人常用的app，他们的小孩子在这里上学，他们在这里上班纳税，是这里的合法居民。</p>
<p>澳门很多学校还是宗教学校，据说葡语只是他们少部分学校的必修课，所以满大街虽然也有葡语的场景，但是基本没啥华人看得懂。</p>
<p>澳门景区有很多的药店，里面卖的跟日本药妆店差不多的东西，上到中药下到牙膏。新马路两侧的金店也很多，橱窗里金光闪闪，各式各样的金子或者玉石在blingbling的show。</p>
<p>澳门的物价不便宜，但是他们本地人的工资也很高，据说澳门本地居民工资中位数达到了18000澳币，折合人民币1万6左右，这个工资水平放在内地的二线城市算是一个不错的收入了。而且政府也会额外发钱，所以澳门有些楼看起来又旧又破，但是澳门人并不穷，供房供车压力比内地要小一点。不过在澳门的公车电视里，也有公益广告提醒“如果假办澳门工签，发现后会罚很重的款”。<br><img data-src="/images/%E6%96%B0%E4%B8%AD%E5%A4%AE%E7%9C%8B%E4%B8%8A%E8%91%A1%E4%BA%AC.jpeg" alt="paradin" title="在新中央酒店的天台看雨中景还是不错的"></p>
<p>说到罚款，澳门的罚款力度也是很大的，这一点跟新加坡差不多。<br><img data-src="/images/%E7%BD%9A%E6%AC%BE%E5%9B%BE%E7%89%87.jpeg" alt="paradin" title="发现就罚1500，挺狠"></p>
<p>我这次在澳门吃的东西不算多，基本都是街头庶民食物：蛋挞、牛杂、猪扒包、凉茶、炸蟹钳、街头炒粉炒饭、还有一些糖水。味道都还可以，价钱不便宜，基本人均100多澳元。澳门是有美食的，它除了粤菜还有葡菜。而且比较有名的mezza 9就在君悦酒店，话说要是在官网买入场券要799一人，在klook上买是719，但是klook买不到周末的票…如果要说吃到最好的东西，应该是钜记手信的炭烧猪肉脯，178一磅，小贵但是真的很不错。还有澳门机场的滑蛋鳗鱼饭，鳗鱼和滑蛋下面的炒饭很好吃。<br><img data-src="/images/%E6%BE%B3%E9%97%A8%E6%9C%BA%E5%9C%BA%E6%BB%91%E8%9B%8B%E9%B3%97%E9%B1%BC%E9%A5%AD.jpeg" alt="paradin" title="鳗鱼肉很肥"><br><img data-src="/images/mezza9%E8%B4%AD%E7%A5%A8.png" alt="paradin" title="在官网先预定，然后大约提前两周左右会邮件通知你付款，如果你忘了还会电话通知你"></p>
<p>澳门在中国历史上从明朝的时候就已经被葡萄牙人低价租走，鸦片战争之后被强占，《中葡和好通商条约》的原件至今保存在台北故宫博物馆里。但是葡萄牙人没有用心好好管理澳门，只是把它当成一个发财的工具。后期加上地理水浅大船进不来的多重客观原因，导致澳门跟旁边的香港比，优势逐渐丧失。所以殖民者决定很多在葡萄牙本国违法的行为在澳门却是可以的，比如黄赌毒以及人口买卖。大三巴是一个神圣的教堂，但是它前面的一条街在清朝中后期就是“卖猪仔”的地方，在澳门档案里能查到的“猪仔馆”就有95家之多！20多万华工就是在这里被卖到美国修铁路或者卖到南美干苦活。而在新中央酒店旁边就是福隆新街，那里在清末民初的时候是有“濠江风月”之称的红灯区。我在看新中央酒店老板的采访，他说他希望像《繁花》那样，澳门也拍一个自己的城市史，那我觉得不妨找个游戏商来以澳门为背景做一个中国人的GTA。</p>
<p>也正是因为葡萄牙人对澳门管理的腐败和不上心，导致澳门人对葡萄牙殖民者的印象很不好，反更对大陆有较强的文化认同感。其实葡萄牙早就1976年就申请将澳门归还，甚至早早的将自己的军队撤离澳门，但是当时我们正值文革后期，没有立即答应接收。现在的澳门相比较香港，俨然成了“一国两制”的优秀模板。但是总体而言，在这里能找到一些老中国的模糊样子和粤区的传统文化，还是一个很好玩的事儿。</p>
<p>不过澳门有一点不太好，就是路面不平整，而且景区的路很窄又人挤人，对残疾人出行来说很不方便。</p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>旅游</tag>
        <tag>澳门</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈raid0,raid1,raid10,raid01等等硬盘阵列搭配</title>
    <url>/2018/01/31/%E7%AE%80%E6%9E%90raid0-raid1-raid10-raid01%E7%AD%89%E7%AD%89%E7%A1%AC%E7%9B%98%E6%90%AD%E9%85%8D/</url>
    <content><![CDATA[<h2 id="RAID-0"><a href="#RAID-0" class="headerlink" title="RAID 0"></a>RAID 0</h2><p>RAID 0可用于两个或更多硬盘或SSD。目标是提高读的性能。</p>
<p>数据以特定大小（通常为64KB）的块写入，并在可用驱动器中平均分配。下图显示了带有三个硬盘的RAID 0阵列的示意图。RAID控制器将第一个数据块写入硬盘1，第二个数据块写入硬盘2，第三个数据块写入硬盘3，第四个数据块再次写入硬盘1,以此类推，RAID 0中的三个1TB硬盘提供3TB的存储空间。<br><img data-src="/images/raid1.png" alt="paradin"></p>
<p>由于数据分布均匀，所以在访问的时候会从硬盘1~硬盘3提取数据，然后拼接在一起就是一个完整的数据。理论上从3个硬盘的RAID 0阵列读取数据比从一个硬盘读取要快3倍，换言之，使用RAID 0读数据的能力跟磁盘数量成正比。</p>
<p>RAID 0也有缺点：如果其中一个磁盘出现故障，从其他磁盘上的数据拼起来就不再是一个完整的数据了。另外，磁盘越多，则发生磁盘故障的可能性也越高。所以如果磁盘阵列里包含着对您来说很重要的数据，则最好创建频繁的备份。</p>
<h2 id="RAID-1"><a href="#RAID-1" class="headerlink" title="RAID 1"></a>RAID 1</h2><p>RAID 1用于创建数据的自动副本。RAID 1会将同一份数据写入两个单独的磁盘，如果A盘出现故障，仍然可以在B磁盘上读取所有数据，当然这是比较壕的，毕竟做一件事用了两块盘。这里要注意！<font color=red>镜像和备份可不是一样！！！如果你不小心从一个磁盘A上删除了一个文件，或者某个文件被病毒侵蚀了，那它再另一个磁盘B上也是一样的待遇。只有真正的备份才能使所有文件保持其保存状态。</font>因此，如果想不让宝贵数据陷入灾难，创建频繁的备份是必须的。</p>
<p>RAID 1中的读性能通常与单独的硬盘差不多—-从A和B里一起读数据，谁出数据快就采用谁的，写的话就是要同时写到两个盘里去。因此，使用RAID 1来获得额外更多的读写性能是不太可能的。以下是RAID 1的工作原理图，如果HDD1坏了，那么HDD2直接上任，若HDD1里的东西被删除了，那么HDD2也会被删除，即使它上任了也是坏的。<br><img data-src="/images/raid2.png" alt="paradin"></p>
<h2 id="RAID-10和RAID-01"><a href="#RAID-10和RAID-01" class="headerlink" title="RAID 10和RAID 01"></a>RAID 10和RAID 01</h2><p>所谓RAID 10,其实就是磁盘阵列<code>先RAID 1,后RAID 0</code>,同理，RAID 01也是先<code>RAID 0,后RAID 1</code>。无论是1+0还是0+1，都至少需要4个硬盘。</p>
<p>这里先看一下RAID 10和RAID 01的效果图：<br><img data-src="/images/raid3.png" alt="paradin"></p>
<p>就像图里说的“在六个硬盘列里，RAID 10比RAID 01更安全”。的确，RAID 10也凭借很棒的容错能力和恢复能力当选了大多数的RAID配置，为什么不要RAID 01呢？那就是如果在RAID 0那一步磁盘就坏了，那RAID 1那步就没有意义了，因为生成的镜像全是坏镜像。</p>
<h2 id="RAID-3"><a href="#RAID-3" class="headerlink" title="RAID 3"></a>RAID 3</h2><p>RAID 3是这样的：若有n块盘，其中拿出1块盘作为校验盘，剩余n-1块盘相当于作RAID 0同时读写，当n-1那里的其中一块盘坏掉时，可以通过校验码还原出坏掉盘的原始数据。这个校验方式比较特别，事奇偶检验，1 XOR 0 XOR 1&#x3D;0，0 XOR 1 XOR 0&#x3D;1，最后的数据是校验数据，当中间缺了一个数据时，可以通过其他盘的数据和校验数据推算出来。但是这存在了问题，由于n-1块盘做了RAID 0，每一次读写都要牵动所有盘来服务，而且万一校验盘坏掉就完蛋了。</p>
<h2 id="RAID-5-and-6"><a href="#RAID-5-and-6" class="headerlink" title="RAID 5 and 6"></a>RAID 5 and 6</h2><p>上面说了RAID 10是一个很棒的方案，但是它的实现至少需要4个硬盘，这一点太伤钱了，于是就出现了RAID 5。与RAID 0一样，数据被分成块并执行写入处理，同时把RAID 3的“校验盘”也分成块分散到所有的盘里。同时，产生并写入称为“奇偶校验”的冗余代码。因此，即使其中的一个硬盘出现故障，也可以根据剩余的数据和奇偶校验来计算出丢失的数据，然后生成完整的状态数据。由于无论需要配置多少个硬盘，保存校验只使用一台设备的容量，容量效率随着待配置硬盘数量的增加而提高。<font color=red>RAID 5模式下硬盘读取数据的速度很快，因为它是从多个驱动器同时处理的</font>。预计速度将与要配置的驱动器的数量成比例地增加。但是，数据的写入&#x2F;更新涉及奇偶校验的创建&#x2F;更新，所以<font color=red>写入性能不高</font>。</p>
<p>RAID 5已经提供了一定程度的可靠性,然而也牺牲了一定的读取速度。RAID 5的局限性还表现在RAID 5仅能在一块硬盘发生故障的情况下修复数据,如果2块硬盘同时发生故障,RAID 5则无能为力。于是RAID 6应需诞生了，RAID 6同RAID 5最大的区别就是在RAID 5的基础上除了具有P校验位以外,还加入了第2个校验位Q位。当一块磁盘出现数据错误或者丢失的时候,恢复方法同RAID 5,无须使用Q校验位。当两块磁盘上的数据出现错误或者丢失的时候,恢复方法为:利用上边给出的P,Q的生成公式,联立方程组,无论受损的数据是否包括P或者Q,总是能够解出损失的两位的数据。</p>
<h2 id="RAID-50-and-60"><a href="#RAID-50-and-60" class="headerlink" title="RAID 50 and 60"></a>RAID 50 and 60</h2><p>在硬盘数量较少的情况下，RAID 5是极好的选择，如7-8块硬盘组成的RAID。但是，当硬盘的数量更多的时候，如10块、20块甚至100块，那么RAID 5就无法胜任了。RAID 50是在RAID 5的基础上，将多个RAID 5组以RAID 0的形式组成在一起。可以这么认为，一个RAID 5组在这里就是一个“大硬盘”，再把这些“大硬盘”以RAID 0的形式组成在一起。而RAID 60的组成就是在RAID 6组的上面组成一个RAID 0。理论上说在写入性能方面，RAID 50相比RAID 5要好太多，而RAID 50相比性能冠军RAID 10要差一点，考虑到RAID 5在一些负载面前的平庸性能，RAID 50是个不错的中间选择。和RAID 5和RAID 10一样，RAID 50也提供极好的读性能，同时RAID 50即使使用最低配置，也需要六个硬盘，所以安装成本很高。</p>
<p>如果担心一个RAID组里面同时有2块硬盘发生故障，导致数据丢失，那么可以选择使用RAID 60。RAID 60提供更高的安全性，相应的其可用容量会比RAID 50少点，RAID 60即使使用最少的配置，也需要8个硬盘，所以安装成本相当高。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上几个磁盘阵列，从读的能力来说：RAID 5 ≈ RAID 6 ≈ RAID 60 &gt; RAID 0 ≈ RAID 10 &gt; RAID 3 ≈ RAID 1<br>从写的能力来说:RAID 10 &gt; RAID 50 &gt; RAID 1 &gt; RAID 3 &gt; RAID 5 ≈ RAID 6 ≈ RAID 60<br>如果将来有一天你对这篇文章记得不是很清晰了，那么但愿你可以记住下面这张图，这几幅图虽然对于RAID 上不是完全的准确，但是已经很大的表达清楚了各种RAID的特点了。<br><img data-src="/images/raid4.png" alt="paradin"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://us.hardware.info/reviews/4123/raid-0-raid-1-raid-10-and-raid-5-how-do-they-actually-work">https://us.hardware.info/reviews/4123/raid-0-raid-1-raid-10-and-raid-5-how-do-they-actually-work</a><br><a href="http://support.huawei.com/enterprise/zh/knowledge/KB1000149118/">http://support.huawei.com/enterprise/zh/knowledge/KB1000149118/</a><br><a href="https://zh.wikipedia.org/wiki/RAID">https://zh.wikipedia.org/wiki/RAID</a><br><a href="http://www.hpc.co.jp/raid_kaisetsu.html">http://www.hpc.co.jp/raid_kaisetsu.html</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>raid</tag>
        <tag>磁盘阵列</tag>
      </tags>
  </entry>
  <entry>
    <title>电商稳定性的个人感悟</title>
    <url>/2020/03/27/%E7%94%B5%E5%95%86%E7%A8%B3%E5%AE%9A%E6%80%A7%E7%9A%84%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%82%9F/</url>
    <content><![CDATA[<p>电商的稳定性是一个很严肃而且很值钱的话题，尤其是大促时候的稳定性更是无比的重要。我参与大促次数跟老江湖比还是太嫩，只是借此文章做一个这阶段的总结，为以后的大促稳定性做基石。</p>
<p>稳定性最关注的就是三点—“新”、“先”、“细”。</p>
<p>先说新，每次大促一定要对新的组织、新的业务、新的技术要了如指掌，并且从他们中挖掘到可能会给大促带来不稳定性的元素，举两个例子：<br>1）本次大促出了小程序，那么这种H5的小程序安全性是否可以得到保证？会不会影响到大促安全？<br>2）本次大促集团提出“下沉市场”，即业务也会考虑三线以下的城市及农村，那么这样以来，可能单笔订单金额会下降，但是GMV又要稳定一个上升的局面，所以订单数就会大幅度增加。而现在已有的吞吐能力应付大量的订单，势必会延长高峰时间，延长1~2分钟还则罢了，要是延长10分钟呢？20分钟呢？系统在这样高水位的压力下能顶得住么？</p>
<p>再说说“先”，“先”就是要在大促前做的准备工作。</p>
<p>技术是可以解决问题的，但是技术也有一定的局限性，比如人手不足，比如时间紧迫，比如成本紧张。那么遇到高难度复杂性的挑战，单纯的靠技术肯定会就比较吃力了，那么可能这个时候就要“业务+管理”一起参与进来，比如购物车，本来购物车是可以展示40个商品，但是大促期间购物车模块压力过大，这个时候我们需要对其暂时做降级，比如展示25个，反正用户手机屏幕就那么大，他手指头划一下也不会有太差的用户体验，就这样我们就用最小的代价也获得了相对不错的结果。</p>
<p>定期回溯，其实每一次大促到双十一都会有很多的问题，这些问题在review会议上的时候，虽然提出了action，但是其实很多都没有改进，这一点要“往前看”，将那些“云action”彻底落地。</p>
<p>最后说“细”，大促稳定性说白了，其实最根本的就是四个词八个字—“容量、预案、预热、限流”。基本上做到这四点，大促就不会翻大车。</p>
<ol>
<li>容量：要事前准确评估流量和承受能力，准确的评估可以降低成本。那么这个时候就需要算对机器的容量，也要算对应用的容量。因为随着业务的迭代，机器性能的退化必然导致系统能力退化，这一点就需要单独链路压测，摸好自己的水位，但是这里引申出一个压测的方式方法，比如某个应用可以接受HTTPS请求和RPC请求，但是HTTPS请求占大头，但是压测的时候做得请求只有RPC类型的，这样得出的系统负载能力肯定不对，因为HTTPS有鉴权和协议转换等等步骤，实际的负载能力会远远低于压测出来的值，那么这个值拿去大促，后果可想而知；</li>
<li>预案：预案是大促的保命草，我们说的预案既有提前预案也有止血预案，止血预案一般来说都是迫不得已的时候才拿出来使用，而且可能需要总裁级别的领导批准方可通行。而提前预案要在链路压测的时候提前验证，通过压测确认预案的有效性，毕竟过了一年的预案从灰尘里翻出来，谁都不敢用；</li>
<li>预热：预热有两个对象，一个是预热应用另一个是预热数据，做好了数据预热，整个链路都会变得精简，所以每次大促前热点商家、爆款商品等大量访问的数据都必须预热到位；</li>
<li>数据治理：这里插播一句数据治理，数据如果一直不精简，那么预热的数据就会越来越多，预热的环节就会消耗大量的时间。数据治理前要先全量备份，然后跟业务方讨论历史数据是保留“30天”还是“60天”；</li>
<li>限流：限流不是一层的，而是多层的。限流限什么？限QPS、用户数、线程数、资源使用率。这里注意新应用，因为新应用跟注重的是作用而不是安全，所以一定要注意新应用的限流方案；</li>
</ol>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>电商</tag>
        <tag>大促</tag>
        <tag>双十一</tag>
      </tags>
  </entry>
  <entry>
    <title>纪念我的姥姥</title>
    <url>/2020/01/22/%E7%BA%AA%E5%BF%B5%E6%88%91%E7%9A%84%E5%A7%A5%E5%A7%A5/</url>
    <content><![CDATA[<p>李惠中老人在2020年1月20日夜10点左右驾鹤西游，永远离开了这个世界，而她就是我的姥姥。</p>
<p>她这次意外是出于夜里上厕所自己不小心摔了一跤，导致胯部骨裂。医生检查后发现，年纪太大，骨质疏松已经很严重，所以不建议开刀做手术只能选择静养的保守治疗。随着这么一次折腾，她的各种并发症也一起并发了，元旦我回家看她的时候，甲亢已经很严重了，脖子胖胖的，摸上去软软的，同时还有肺炎，据说严重的时候整个人浮肿的厉害，手指头摸上去，很明显的感受得到老手皮下的液体。不过整个人是清醒的，头发又白又长又乱，眼袋很大，穿着毛衣，外面套着病号服，屁股下垫着成人尿不湿，她整个人木木的坐在被子里，呼噜呼噜的，医生嘱咐不能久坐，所以她更多的时间是平躺或者侧躺。我的几个姨姨和舅妈经也换着花样给她做点鸡蛋羹或者小米粥这样的东西给她喂饭。她食量忽高忽低，我第二次离开医院的时候，她状态很好，吃了一杯酸奶和一碗麦片。后来我到了杭州，听我妈说她的状态是往好转的，水肿消了不少而且甚至可以站起来了，只是不能走动。明明一切情况都是积极的，但是这个肺炎最后还是出现了情况恶化，夺走了她的生命。俗话说七十三八十四，我姥姥还是没有坚持过84这个坎。</p>
<p>我现在还记得姥姥家老房子的客厅结构，那是一个很小的客厅，没有阳台，窗户下面是暖气片，旁边就是一个木头的组合单人床，单人床对面是一个木头的青灰色大书桌，大书桌上有日历、座机电话和一个电视机。书桌上面有局部地方漆掉了，露出了里面的木头。单人床左边是一个长沙发，大约能并排坐下四个成年男子，沙发再左边又是一个单人床，这个单人床挨着墙壁，而墙里还嵌着一个柜子，里面放一些棉被枕头等东西。这个客厅在过年聚会的时候就会热闹，大人们在这里打麻将，小孩子这时候要不就是在单人床上七扭八歪的看电视，要不就是来回的从这个单人床跑跳到对面的单人床上，打打闹闹。</p>
<p>在我印象里，我姥姥并不是一个做饭的好手，她只会做一点简单的炒菜，以及大米饭炒鸡蛋，炖鸡炸鱼我个人是从来没见她做过。主要是她做的菜并不是很好看，所以每次我去她家都是猛劲儿吃蛋炒饭和熟食的。我姥爷走得早，我姥姥的房间在聚会散去之后就会显得很冷清，她自己也习惯了这种喧闹之后突然安静的日子，自己自有自己过的生活。我姥姥信佛，记得老房子里她的卧室还有一个挺大的佛台，供着瓷做的观音和小童子等摆件，佛台上还有一些附近寺里拿回来的经书和烛台。不过这些东西再在家之后好像就扔掉了。</p>
<p>除了信佛之外，我姥姥就没有别的什么业余生活了，她不怎么看书写字，看电视更多就是《西游记》这样的老片儿，朋友来往不算多，平常时候会自己下楼买菜或者遛弯，如果没什么事就早早上床睡了。如果子女忙工作没时间去看她的话，就这样从白天到黑夜，再由黑夜到第二个白天。为了怕她孤独，我的几个姨姨和舅舅也会抽时间过去跟她吃饭，顺便给她带点牛奶蔬菜等食物。姥姥说话很少，虽然到东北多年，但是一口的山西话还是很浓重。后来姥姥牙齿掉光，给她配了假牙，她也随身有一个小杯子，假牙不用了就泡进去。再后来她的耳朵也背了，但是她坚持不要带助听器，无论别人怎么劝。以至于后期跟她交流基本靠吼，打电话基本能累死一个人。也就这样，原本就不太与人交流的她更加沉默。她后来罗圈腿比较严重了，走路颤颤巍巍的，也偶有爬楼梯摔跤的经历，于是搬离了老房子去与我三姨同住。我去年春节回家的时候，全家去三姨家过年，看她自己在一个小屋里躺着，三姨给她调好IPAD，她就一集接着一集的看电视剧，有字幕和声音的帮助来了解剧情，以此来消磨时间。到了吃饭的时候，也是颤颤巍巍的走出来，在桌子边的角落吃点稀饭素菜，依旧不停的给我们小孩这些夹肉夹鸡蛋，或者一个劲儿的让我们喝雪碧可乐。她过年也会给我们这样的孙子辈准备红包，一笑起来，满脸的褶子更多了，一一分发给我们，哪怕我们都已经上班好几年了。</p>
<p>我姥姥是一个普普通通的石油工人家属，相比较我姥爷“郭老大”年轻时候的威风，她更多一种幕后后勤的角色。姥姥有七个子女，四女三男，其中有一个舅舅由于历史原因就一直在老家生活。那时候家里条件不算很好，我姥姥就这样坚持把这六个在身边的子女养大，并且安排他们一个一个都成了家，甚至有了我们这第三代。记得我大舅说过，在他年轻浪荡时，经常打个招呼就出门了，玩好了后再去朋友家喝酒喝通宵，当时没有什么通讯手段，我姥姥就一个一个朋友家的找过去，把醉酒的大舅找到。</p>
<p>我姥姥也有她自己的缺点，她有苏大强的那一面：偏心、固执、对弱者耍脾气对强者逃避。家里能长期忍受她脾气的人不多，除了我大姨也就是我三姨大舅一家了。她有一个弟弟，我叫舅老爷，俩人不知道怎么回事，突然就闹翻了，这一翻就翻了十多年。搞得现在子女往来都有点尴尬，我结婚的时候，舅老爷那边人也没有过来现场祝贺。但是身后第二天烧姥姥遗物的时候，舅老爷家来人悼念了。</p>
<p>今天已经是身后第三天了，我没有赶的回去，听几个已经到东北老家的弟弟说，一大早就出殡做了遗体告别，骨灰也暂放在殡仪馆百日。等头七的时候，我就要带着媳妇儿去给我姥姥磕头烧纸。</p>
<p>但是这几天我就一直在想，待我大年初二到了老家后，看到曾经总有一个人的那张床上空空如也，自己会是一个什么样的心情呢？那会是一种什么样的无奈失落和不适应？</p>
<p>仁厚黑暗的地母呵，愿在你怀里永安她的灵魂！<br><img data-src="/images/%E5%A7%A5%E5%A7%A5.jpg" alt="akb48"></p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>心情</tag>
        <tag>亲情</tag>
      </tags>
  </entry>
  <entry>
    <title>云服务器的内存竟然少了500M...</title>
    <url>/2018/07/27/%E7%AE%97%E7%AE%97%E5%86%85%E5%AD%98%E7%9A%84%E8%BF%99%E4%B8%80%E7%AC%94%E7%B3%8A%E6%B6%82%E5%B8%90/</url>
    <content><![CDATA[<h2 id="故障发现"><a href="#故障发现" class="headerlink" title="故障发现"></a>故障发现</h2><p>今天发现有一台阿里云线上环境的服务器内存在告急，使用<code>free -m</code>一看，果然剩余的内存不多了，而且<code>buffers</code>和<code>cached</code>也都不高，如图：<br><img data-src="/images/memcache1.png" alt="paradin"></p>
<p>用<code>top</code>一看，里面的情况是这样的:<br><img data-src="/images/memcache2.png" alt="paradin"></p>
<p>很奇怪，<code>top</code>里的<code>res</code>即物理内存加起来也就2200M多一点，但是<code>free</code>命令里显示已经用掉了几乎3.4个G，那这1.2G的空头内存去哪了？要知道，<code>free</code>命令会把<code>Slab缓存</code>统计到了<code>used memory</code>里，那就看看<code>slab缓存</code>有多少吧。</p>
<p><code>yum install -y nmon</code>，使用<code>nmon</code>看一下，如图：<br><img data-src="/images/memcache3.png" alt="paradin"></p>
<p>发现里面有几乎650MB的slab内存，这样还是少了大约550MB，那么使用<code>slabtop</code>查看细节，如图：<br><img data-src="/images/memcache5.png" alt="paradin"></p>
<p>再用<code>cat /proc/meminfo</code>去查看一下内存详细情况，如图：<br><img data-src="/images/memcache4.png" alt="paradin"></p>
<p><a href="https://blog.famzah.net/2014/09/22/know-your-linux-memory-usage/">https://blog.famzah.net/2014/09/22/know-your-linux-memory-usage/</a> 这里提到内存的计算公式：<br> 	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">MemTotal</span> = <span class="title class_">MemFree</span> + (<span class="title class_">Buffers</span> + <span class="title class_">Cached</span> + <span class="title class_">SwapCached</span>) + <span class="title class_">AnonPages</span> + (<span class="title class_">Slab</span> + <span class="title class_">PageTables</span> + <span class="title class_">KernelStack</span>)</span><br><span class="line"><span class="title class_">MemTotal</span> = <span class="title class_">MemFree</span> + (<span class="title class_">Active</span> + <span class="title class_">Inactive</span>) + (<span class="title class_">Slab</span> + <span class="title class_">PageTables</span> + <span class="title class_">KernelStack</span>)</span><br><span class="line"><span class="title class_">MemTotal</span> = <span class="title class_">MemFree</span> + (<span class="title class_">Buffers</span> + <span class="title class_">Cached</span> + <span class="title class_">SwapCached</span>) + <span class="title class_">AnonPages</span> + ((<span class="title class_">SReclaimable</span> + <span class="title class_">SUnreclaim</span>) + <span class="title class_">PageTables</span> + <span class="title class_">KernelStack</span>)</span><br><span class="line"><span class="title class_">MemTotal</span> = <span class="title class_">MemFree</span> + ((“<span class="title class_">Active</span>(anon)” + “<span class="title class_">Active</span>(file)”) + (“<span class="title class_">Inactive</span>(anon)” + “<span class="title class_">Inactive</span>(file)”)) + ((<span class="title class_">SReclaimable</span> + <span class="title class_">SUnreclaim</span>) + <span class="title class_">PageTables</span> + <span class="title class_">KernelStack</span>)</span><br></pre></td></tr></table></figure></p>
<p>虽然作者说他测试的机器内核是3.2的，但是这几个公式对我这个服务器（内核2.6）都可以用，虽然肯定不能严丝合缝但是相差值并不大，我用前两个公式算了一下我这个机器的情况：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">MemTotal</span>（<span class="number">3495620</span>） = <span class="title class_">MemFree</span>（<span class="number">251396</span>） + <span class="title class_">Buffers</span>（<span class="number">11456</span>） + <span class="title class_">Cached</span>（<span class="number">292324</span>） + <span class="title class_">SwapCached</span>（<span class="number">0</span>） + <span class="title class_">AnonPages</span>（<span class="number">2302484</span>） + <span class="title class_">Slab</span>（<span class="number">627068</span>） + <span class="title class_">PageTables</span>（<span class="number">8972</span>） + <span class="title class_">KernelStack</span>（<span class="number">1920</span>） </span><br><span class="line"><span class="title class_">MemTotal</span>（<span class="number">3495592</span>） = <span class="title class_">MemFree</span>（<span class="number">251396</span>） + <span class="title class_">Active</span>（<span class="number">2450960</span>） + <span class="title class_">Inactive</span>（<span class="number">155276</span>） + <span class="title class_">Slab</span>（<span class="number">627068</span>） + <span class="title class_">PageTables</span>（<span class="number">8972</span>） + <span class="title class_">KernelStack</span>（<span class="number">1920</span>）</span><br></pre></td></tr></table></figure></p>
<h2 id="猜测一下"><a href="#猜测一下" class="headerlink" title="猜测一下"></a>猜测一下</h2><p>我特么的法克，这个memtotal跟3921112差距很远啊！相差了412MB！为什么会少了这么多？会不会这412MB就是那<code>used memory</code>减去slap内存的那部分神秘内存？他为什么没有统计在<code>/proc/meminfo</code>里？</p>
<p>于是果断给阿里云提工单，截图发锤，让他们给一个完美的解释。</p>
<p>等待阿里云回复的时间里，我又找了几个其他的机器，各种型号的都算了一下，发现一个现象：凡是装了这个模块的服务器都出现了<code>MemTotal</code>不相符的问题，大约误差值都是400M~500M，而除了这个模块，<code>MemTotal</code>的误差值基本就是50M以内。</p>
<p>呃…这好像不能怪阿里云了…不过的确<code>MemTotal</code>是有误差的啊！</p>
<p>找开发了解了一下，这个服务器里用了大量的tcp长连接，而且是https的，使用<code>netstat -na|grep ESTABLISHED|wc -l</code>一看，有95000个左右。</p>
<p>而在开发环境的机器里查看，<code>MemTotal</code>的相差率很小，而tcp连接数则不到20个。那用排除法可以确定是TCP长连接的锅，于是我猜测<strong>TCP长连接占用掉了一部分内存，而这部分内存又没有在meminfo（SLAB）里体现出来，进而导致free命令与top命令相差过大</strong>。</p>
<h2 id="小心求证"><a href="#小心求证" class="headerlink" title="小心求证"></a>小心求证</h2><p><strong>未完待续…</strong></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://farll.com/2016/10/high-memory-usage-alarm/#comment-9881">http://farll.com/2016/10/high-memory-usage-alarm/#comment-9881</a><br><a href="http://lday.me/2017/09/02/0012_a_memory_leak_detection_procedure/">http://lday.me/2017/09/02/0012_a_memory_leak_detection_procedure/</a> （虽然跟本文没啥关系，但是强力推荐）<br><a href="http://blog.yufeng.info/archives/2456">http://blog.yufeng.info/archives/2456</a><br><a href="http://lovestblog.cn/blog/2015/08/21/rssxmx/">http://lovestblog.cn/blog/2015/08/21/rssxmx/</a><br><a href="https://www.mawenbao.com/research/linux-ate-my-memory.html">https://www.mawenbao.com/research/linux-ate-my-memory.html</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>内存泄漏</tag>
      </tags>
  </entry>
  <entry>
    <title>给Django添加用户登录登出界面</title>
    <url>/2019/03/21/%E7%BB%99Django%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2%E3%80%81%E9%AA%8C%E8%AF%81%E7%A0%81%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    <content><![CDATA[<p>我的Django运维平台很不幸的被公司安全系统扫描出来了，给了我一个超级大警告。主要也怪我当时偷懒，只是在SLB层面做了IP访问限制但是没有给服务器nginx里做白名单，所以网站是可以通过“IP地址加端口”访问的。恰巧ping里面用了一个AES加解密的脚本，那个算法有问题，可以获取当前用户的权限，我特么的还是直接用root启动的nginx，而且这个机器里面还有ansible，当然后果很严重。</p>
<p>出了问题，不能消极对待而要积极解决，于是要先给网站做一个完善的用户登录鉴权系统。再一次背景介绍：<br>	python：3.6.5<br>	Django：2.1.1<br>	Project：Kubernetes，文件夹路径就是&#x2F;django&#x2F;Kubernetes&#x2F;<br>	App：createyaml，文件夹路径就是&#x2F;django&#x2F;Kubernetes&#x2F;createyaml</p>
<h2 id="实现用户登录鉴权"><a href="#实现用户登录鉴权" class="headerlink" title="实现用户登录鉴权"></a>实现用户登录鉴权</h2><p>首先，先编写一个<code>index.html</code>的页面做登录界面，如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">        &lt;head&gt;</span><br><span class="line">                &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">                &lt;title&gt;请先登录&lt;/title&gt;</span><br><span class="line">                &lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;/static/bootstrap-3.3.7/css/bootstrap.min.css&quot;</span>&gt;	<span class="comment">#引入css样式</span></span><br><span class="line">                &lt;link rel=<span class="string">&quot;icon&quot;</span> href=<span class="string">&quot;/static/pic/batman.ico&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;image/x-icon&quot;</span>&gt;	<span class="comment">#引入一个标签图</span></span><br><span class="line">        &lt;/head&gt;</span><br><span class="line">        &lt;body background=<span class="string">&quot;/static/pic/easyplane.jpg&quot;</span>&gt;	<span class="comment">#背景图片设置</span></span><br><span class="line">                &lt;div style=<span class="string">&quot;margin-top: 200px&quot;</span>&gt;</span><br><span class="line">                &lt;div style=<span class="string">&quot;text-align:center;&quot;</span>&gt;</span><br><span class="line">                        &lt;font color=<span class="string">&#x27;brown&#x27;</span>&gt;&lt;h1&gt;请输入您的账号密码&lt;/h1&gt;&lt;/font&gt;</span><br><span class="line">                                &lt;div&gt;</span><br><span class="line">                                        &lt;div&gt;</span><br><span class="line">                                                &lt;form <span class="keyword">class</span>=<span class="string">&quot;ui form&quot;</span> method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;&quot;</span>&gt;</span><br><span class="line">                                                &lt;div <span class="keyword">class</span>=<span class="string">&quot;field&quot;</span>&gt;</span><br><span class="line">                                                &lt;<span class="built_in">input</span> <span class="built_in">type</span>=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span> placeholder=<span class="string">&quot;username&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">                                                &lt;/div&gt;</span><br><span class="line">                                                &lt;div <span class="keyword">class</span>=<span class="string">&quot;field&quot;</span>&gt;</span><br><span class="line">                                                &lt;<span class="built_in">input</span> <span class="built_in">type</span>=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password&quot;</span> placeholder=<span class="string">&quot;password&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">                                                &lt;/div&gt;</span><br><span class="line">                                                &lt;font color=red&gt;&#123;&#123; error &#125;&#125;&lt;/font&gt;&lt;br&gt;	<span class="comment">#登录错误红色表示</span></span><br><span class="line">                                                &lt;button <span class="keyword">class</span>=<span class="string">&quot;btn btn-default&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;submit&quot;</span>&gt;登陆&lt;/button&gt;</span><br><span class="line">                                                &#123;% csrf_token %&#125;</span><br><span class="line">                                                &lt;/form&gt;</span><br><span class="line">                                        &lt;/div&gt;</span><br><span class="line">                                &lt;/div&gt;</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">        &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>效果如下：<br><img data-src="/images/django45.png" alt="akb48"></p>
<p>在Kubernetes这个app文件夹里的<code>urls.py</code>里给这个鉴权网站添加一个路由：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;&#x27;</span>,views.login_action,name=<span class="string">&#x27;login&#x27;</span>),	<span class="comment">#首页就是login_action的函数</span></span><br><span class="line">    path(<span class="string">&#x27;homepage.html&#x27;</span>,views.home,name=<span class="string">&#x27;home&#x27;</span>),	<span class="comment">#将原来的首页改成叫homepage.html</span></span><br><span class="line">	path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">	...其余省略</span><br><span class="line">	]</span><br></pre></td></tr></table></figure></p>
<p>在同级的<code>views.py</code>里编写<code>login_action</code>函数，如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render,render_to_response</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse,HttpResponseRedirect</span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> auth</span><br><span class="line"></span><br><span class="line"><span class="comment">#登陆</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login_action</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:	<span class="comment">#通过post形式获取，get的话会在地址栏里看到账号密码</span></span><br><span class="line">        username = request.POST.get(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        password = request.POST.get(<span class="string">&#x27;password&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        user = auth.authenticate(username=username, password=password)	<span class="comment">#使用django自带方式鉴权</span></span><br><span class="line">        <span class="keyword">if</span> user <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            auth.login(request, user)  <span class="comment"># 登录</span></span><br><span class="line">            request.session[<span class="string">&#x27;user&#x27;</span>] = username  <span class="comment"># 将session信息记录到浏览器</span></span><br><span class="line">            response = HttpResponseRedirect(<span class="string">&#x27;homepage.html&#x27;</span>)	<span class="comment">#鉴权OK就跳转到homepage.html</span></span><br><span class="line">            <span class="keyword">return</span> response</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> render(request,<span class="string">&#x27;index.html&#x27;</span>, &#123;<span class="string">&#x27;error&#x27;</span>: <span class="string">&#x27;账号密码有误，请联系管理员!&#x27;</span>&#125;)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">&#x27;index.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#首页</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">home</span>(<span class="params">request</span>):</span><br><span class="line">    context = &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> render_to_response(<span class="string">&#x27;homepage.html&#x27;</span>,context)</span><br></pre></td></tr></table></figure></p>
<p>登陆的用户&#x2F;密码就是django后台的账号&#x2F;密码，可以用superuser来登陆。保存文件之后，系统会重启django，查看效果如图：<br><img data-src="/images/django47.gif" alt="akb48"></p>
<h2 id="render和render-to-response的区别"><a href="#render和render-to-response的区别" class="headerlink" title="render和render_to_response的区别"></a>render和render_to_response的区别</h2><p>上面的<code>login_action</code>函数里，用了<code>render</code>和<code>render_to_response</code>，如果只用<code>render_to_response</code>，同时把所有的<code>render</code>改成<code>render_to_response</code>，那么在访问首页的时候就会出现<code>TemplateDoesNotExist at /</code>这样的错误：<br><img data-src="/images/django46.png" alt="akb48"></p>
<p>明明他俩都是用来展示模板页面的。为什么会有模板不存在这样？原因是<code>render_to_response()</code>的第一个参数必须是要使用的模板名称。如果要给定第二个参数，那么该参数必须是为该模板创建Context时所使用的字典。如果不提供第二个参数，<code>render_to_response()</code>使用一个空字典。而<code>render</code>第一个参数可以是request。</p>
<p>所以如果都要用<code>render_to_response</code>，那么就要改成如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span>:</span><br><span class="line">           <span class="keyword">return</span> render_to_response(<span class="string">&#x27;index.html&#x27;</span>, &#123;<span class="string">&#x27;error&#x27;</span>: <span class="string">&#x27;账号密码有误，请联系管理员!&#x27;</span>&#125;，context_instance=RequestContext(request))</span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">       <span class="keyword">return</span> render_to_response(<span class="string">&#x27;index.html&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>但是这样的话，可能在登录的时候就会有csrf的错误，需要把csrf去掉。</p>
<h2 id="实现登出功能"><a href="#实现登出功能" class="headerlink" title="实现登出功能"></a>实现登出功能</h2><p>有了登录还得有登出，还是老套路，先编写路由如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path(<span class="string">r&#x27;logout/&#x27;</span>, views.logout,name=<span class="string">&quot;logout&quot;</span>),</span><br></pre></td></tr></table></figure></p>
<p>然后对应去views.py里写logout这个函数：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponseRedirect</span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> auth	<span class="comment">#引入django默认的auth功能</span></span><br><span class="line"><span class="comment">#注销</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">logout</span>(<span class="params">request</span>):</span><br><span class="line">    auth.logout(request)</span><br><span class="line">    <span class="keyword">return</span> HttpResponseRedirect(<span class="string">&#x27;/login&#x27;</span>)	<span class="comment">#跳转到登录页/login</span></span><br></pre></td></tr></table></figure></p>
<p>然后就是在首页里添加一个登出的链接，链接指向就是<code>/logout/</code>。测试一下效果：<br><img data-src="/images/django48.gif" alt="akb48"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.nowamagic.net/academy/detail/1318431">http://www.nowamagic.net/academy/detail/1318431</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>认证鉴权</tag>
      </tags>
  </entry>
  <entry>
    <title>网易雷火运维面试全纪录</title>
    <url>/2019/06/20/%E7%BD%91%E6%98%93%E9%9B%B7%E7%81%AB%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="电话一面"><a href="#电话一面" class="headerlink" title="电话一面"></a>电话一面</h2><ol>
<li><p>都搞过什么linux的发行版，区别是啥？</p>
</li>
<li><p>为什么云服务器普遍不装swap？</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">小内存主机由于内存不足导致持续swapping后会严重影响存储设备的IO性能。其实如果需要使用swap的话，主机性能也已经是烂的一塌糊涂，根本不能满足使用了，建议增加内存为上。 </span><br></pre></td></tr></table></figure>
</li>
<li><p>localhost与127.0.0.1的区别</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">localhost（local）是不经网卡传输！这点很重要，它不受网络防火墙和网卡相关的的限制。<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>是通过网卡传输，依赖网卡，并受到网络防火墙和网卡相关的限制。</span><br></pre></td></tr></table></figure>
</li>
<li><p>iptables的四表五链是啥？</p>
</li>
<li><p>出现延迟都有原因？</p>
</li>
<li><p>如何把数据库恢复到指定时刻？</p>
</li>
<li><p>你从业以来参与的比较大的故障是什么？怎么解决的？</p>
</li>
<li><p>如果要大量insert数据到数据库，有什么优化的方法？</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>)一条SQL语句插入多条数据:比如一次insert插入多个values，INSERT INTO `insert_table` (`datetime`, `uid`, `content`, `<span class="built_in">type</span>`) VALUES (<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;userid_0&#x27;</span>, <span class="string">&#x27;content_0&#x27;</span>, <span class="number">0</span>), (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;userid_1&#x27;</span>, <span class="string">&#x27;content_1&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">这样的好处是减少binlog和innodb的日质量，降低了日志刷盘的频率提高效率，同时减少了网络传输的IO，这个优化效果特别明显；</span><br><span class="line"><span class="number">2</span>）把多一个insert写成一个事务，进行一个insert操作时，MySQL内部会建立一个事务，在事务内才进行真正插入处理操作。通过使用事务可以减少创建事务的消耗，所有插入都在执行后才进行提交操作；</span><br><span class="line"><span class="number">3</span>）数据按照主键有序插入，因为数据库插入时，需要维护索引数据，无序的记录会增大维护索引的成本，不过这个方法提高的并不明显；</span><br><span class="line"><span class="number">4</span>）以上方法综合使用；</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="电话二面"><a href="#电话二面" class="headerlink" title="电话二面"></a>电话二面</h2><ol>
<li><p>介绍一下你自己</p>
</li>
<li><p>使用docker遇到了什么坑？</p>
</li>
<li><p>docker的网络模式有哪些？为什么不能选hosts？</p>
</li>
<li><p>服务器调整进程优先级的命令是啥？</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">一般来说微服务（即一个云服务器只跑一个进程）的场景来说，这个问题很少遇到，但是实际很多公司是一个服务器（比如<span class="number">80</span>核160G）跑多个进程，那么对后台的程序有优先级限制就要使用`nice`命令。</span><br><span class="line">Linux系统中，进程有-<span class="number">19</span>到<span class="number">19</span>这<span class="number">39</span>个优先级。-<span class="number">19</span>最优先，<span class="number">19</span>最不优先。进程的默认优先级为<span class="number">0</span>。如果希望将进程调整为最优先，则将进程的nice值设置为-<span class="number">19</span>；如果希望进程最不优先，占用最少的系统CPU时间，则将其设置为<span class="number">19</span>。</span><br><span class="line"></span><br><span class="line">修改已经存在的进程的优先级</span><br><span class="line">将PID为<span class="number">1799</span>的进程优先级设置为最低（<span class="number">19</span>）：renice <span class="number">19</span> <span class="number">1799</span></span><br><span class="line">将PID为<span class="number">1799</span>的进程优先级设置为最高（-<span class="number">19</span>）：renice -<span class="number">19</span> <span class="number">1799</span></span><br><span class="line"></span><br><span class="line">新建进程并设置优先级</span><br><span class="line">nice -<span class="number">19</span> tar zcf pack.tar.gz documents		<span class="comment">#这里-19并不是最高优先级，而是最低优先级，要设定最高优先级是--19</span></span><br></pre></td></tr></table></figure></li>
<li><p>python的&#x3D;&#x3D;和is有什么不同？</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">is</span>比较的是<span class="built_in">id</span>是不是一样，==比较的是值是不是一样。</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何删除某文件下所有名称带有空格的文件？</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">可以通过转义符，或者获取文件的inode，根据inode删除对应的文件:find -inum 编号 -delete</span><br><span class="line">比如想rm文件名为“my file”的文件可以用rm my\ file</span><br></pre></td></tr></table></figure>
</li>
<li><p>ansibleplaybook的回滚方法？</p>
</li>
<li><p>如果nginx的server设置了add header，同时子location也设置了add header，那么会有什么现象？</p>
</li>
<li><p>如何判断查询是否用到了索引？</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">使用explain，如果<span class="built_in">type</span>类型是<span class="built_in">all</span>就是没有用到索引，如果是其他具体类型就是用到了索引。</span><br><span class="line">索引依次从好到差：system，const，eq_ref，ref，fulltext，ref_or_null，unique_subquery，index_subquery，<span class="built_in">range</span>，index_merge，index，ALL，除了<span class="built_in">all</span>之外，其他的<span class="built_in">type</span>都可以使用到索引，除了index_merge之外，其他的<span class="built_in">type</span>只可以用到一个索引。</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="现场技术一面"><a href="#现场技术一面" class="headerlink" title="现场技术一面"></a>现场技术一面</h2><ol>
<li><p>写一下Python序列循环移位的方法，原来是[1,2,3,4,5,6]，变成[3,4,5,6,1,2]，任意语言都可以。</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">使用切片，简单易理解，速度最快，可同时实现循环左移（k&gt;<span class="number">0</span>）和右移（k&lt;<span class="number">0</span>）。</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">demo</span>(<span class="params">lst, k</span>):</span><br><span class="line">    <span class="keyword">return</span> lst[k:] + lst[:k]</span><br></pre></td></tr></table></figure>
</li>
<li><p>你们平时备份mysql使用什么方法？为什么用这个开源软件？</p>
</li>
<li><p>服务器你们是如何初始化的？</p>
</li>
<li><p>简单的介绍一下python的生成器？</p>
</li>
<li><p>如果发现慢sql你怎么排查？</p>
</li>
<li><p>发现java服务出现了CPU飙升的现象，怎么排查？</p>
</li>
<li><p>除了代码问题之外，都有哪些情况会导致CPU 100%？</p>
</li>
<li><p>都做过什么优化？（主动运维方向）</p>
</li>
</ol>
<p>剩下的就是一些流程性的问题了。<br><img data-src="/images/%E4%B8%80%E6%8B%B3%E6%AD%A6%E6%9C%AF.jpg" alt="akb48"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>大牛之路</tag>
      </tags>
  </entry>
  <entry>
    <title>给Django添加登录拦截器和登录验证码</title>
    <url>/2019/03/22/%E7%BB%99Django%E6%B7%BB%E5%8A%A0%E7%99%BB%E5%BD%95%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
    <content><![CDATA[<p>前一篇文章里写了如何做登录、登出界面，看上去效果好像很不错，但是却有一个致命的漏洞：如果有人直接在地址栏里输入对应的url，那么就可以跳过登录验证直接访问！</p>
<p>这种情况我们需要做一个登录拦截器，这个拦截器的作用就是通过session来判断，如果在没有session的前提下登录网站内部url就会强制跳转到首页，让访问的人登录。</p>
<h2 id="自建的登陆拦截器"><a href="#自建的登陆拦截器" class="headerlink" title="自建的登陆拦截器"></a>自建的登陆拦截器</h2><p>首先是在APP的目录里（我的project叫Kubernetes）新建一个叫<code>middleware.py</code>的文件，代码如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> HttpResponseRedirect</span><br><span class="line"><span class="keyword">from</span> django.utils.deprecation <span class="keyword">import</span> MiddlewareMixin</span><br><span class="line"></span><br><span class="line"><span class="comment">#强制登录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleMiddleware</span>(<span class="title class_ inherited__">MiddlewareMixin</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_request</span>(<span class="params">self, request</span>):</span><br><span class="line">        <span class="keyword">if</span> request.path != <span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> request.path != <span class="string">&#x27;/login/&#x27;</span>:	<span class="comment">#判断请求的地址不是首页和/login/</span></span><br><span class="line">            <span class="keyword">if</span>  request.session.get(<span class="string">&#x27;user&#x27;</span>,<span class="literal">None</span>):		<span class="comment">#如果session里不存在</span></span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> HttpResponseRedirect(<span class="string">&#x27;/login/&#x27;</span>)	<span class="comment">#自动跳回到登录页面</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#多次访问IP拉黑</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockedIpMiddleware</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_request</span>(<span class="params">self, request</span>):</span><br><span class="line">        <span class="keyword">if</span> request.META[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>] <span class="keyword">in</span> <span class="built_in">getattr</span>(settings, <span class="string">&quot;BLOCKED_IPS&quot;</span>, []):	<span class="comment">#如果有IP短时间内多次访问</span></span><br><span class="line">            <span class="keyword">return</span> http.HttpResponseForbidden(<span class="string">&#x27;&lt;h1&gt;Forbidden&lt;/h1&gt;&#x27;</span>)	<span class="comment">#针对此IP给予403</span></span><br></pre></td></tr></table></figure></p>
<p>然后在APP的目录里（我的project叫Kubernetes）的<code>setting.py</code>里把这两个中间件加进去。如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MIDDLEWARE = [</span><br><span class="line">    <span class="string">&#x27;django.middleware.security.SecurityMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.common.CommonMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Kubernetes.middleware.SimpleMiddleware&#x27;</span>,	<span class="comment">#这个就是新加的</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>系统自动重启之后，来验证一下效果，是否在不登录的前提下成功拦截直接访问的url。</p>
<h2 id="Django自带的登陆拦截器"><a href="#Django自带的登陆拦截器" class="headerlink" title="Django自带的登陆拦截器"></a>Django自带的登陆拦截器</h2><p>上面那个方法逻辑上来说比较简单，能实现功能但是并不是很强力，Django也自带一个“强制登录”的功能，效果比那个强一丢丢。</p>
<p>首先我们先把APP目录里<code>setting.py</code>刚刚新加的<code>&#39;Kubernetes.middleware.SimpleMiddleware&#39;</code>注释掉。在文件末尾添加一句：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#登录路径</span></span><br><span class="line">LOGIN_URL = <span class="string">&#x27;/login/&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>然后返回到<code>views.py</code>，给需要登陆才能访问的页面添加一个装饰器：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.decorators <span class="keyword">import</span> login_required</span><br><span class="line"><span class="meta">@login_required	</span><span class="comment">#这个页面需要登陆</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tt</span>(<span class="params">request</span>):</span><br><span class="line">    name = [<span class="string">&#x27;james&#x27;</span>,<span class="string">&#x27;wade&#x27;</span>,<span class="string">&#x27;bosh&#x27;</span>,<span class="string">&#x27;yaoming&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> render_to_response(<span class="string">&#x27;test111.html&#x27;</span>,&#123;<span class="string">&#x27;names&#x27;</span>:name&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ttt</span>(<span class="params">request</span>):	<span class="comment">#这个页面就不需要了，公共读</span></span><br><span class="line">   	cpu = <span class="number">9.66</span></span><br><span class="line">   	mem = <span class="number">66.6</span></span><br><span class="line">   	disk = <span class="number">16.88</span></span><br><span class="line">   	<span class="keyword">return</span> render_to_response(<span class="string">&#x27;test222.html&#x27;</span>,&#123;<span class="string">&#x27;CPU&#x27;</span>:cpu,<span class="string">&#x27;MEMORY&#x27;</span>:mem,<span class="string">&#x27;DISKUSED&#x27;</span>:disk&#125;)</span><br></pre></td></tr></table></figure></p>
<p>我在<code>views.py</code>里设定，访问tt这个函数（urls.py里配置的域名是&#x2F;k8s&#x2F;test111)的时候需要强制登陆,访问ttt这个函数（urls.py里配置的域名是&#x2F;k8s&#x2F;test222）就可以直接打开。系统重启django之后，我们试一下效果：<br><img data-src="/images/django49.gif" alt="akb48"></p>
<p>可见当访问到<code>/k8s/test111</code>的时候，浏览器会自动跳转到&#x2F;login&#x2F;?next&#x3D;&#x2F;k8s&#x2F;test111&#x2F; 让你登录，登陆完毕之后才能顺利访问。而<code>/k8s/test222</code>就可以直接访问了。这个方法就是可以更加对受保护的网页有针对性配置，而不是上一个方法统一都跳转到登录面去。</p>
<p>测试的时候出现<code>TypeError: object() takes no parameters</code>报错，看一下是否是post方法请求的，因为get方法是产生一个tcp包，而post是两个。</p>
<h2 id="登录验证码"><a href="#登录验证码" class="headerlink" title="登录验证码"></a>登录验证码</h2><p>为了防止机器人暴力破解密码，我们往往增加验证码来阻挡一下。市面上开源的比较高级的验证码是<code>google recaptcha2</code>，但是由于国内政策，大陆内的网站往往打不开这个界面。所以用<code>Django Simple Captcha</code>这个比较大众的验证码方式。</p>
<p>首先<code>pip install django-simple-captha</code>，然后在<code>setting.py</code>里把<code>captha</code>加入到<code>INSTALL_APPS</code>里。</p>
<p>然后是执行<code>python manage.py makemigrations</code>和<code>python manage.pymigrate</code>，再打开<code>url.py</code>，添加一句<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;&#x27;</span>,views.login,name=<span class="string">&#x27;login&#x27;</span>),	<span class="comment">#登录页</span></span><br><span class="line">    path(<span class="string">&#x27;homepage.html&#x27;</span>,views.home,name=<span class="string">&#x27;home&#x27;</span>),	<span class="comment">#首页</span></span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>,admin.site.urls),</span><br><span class="line">    path(<span class="string">&#x27;captcha/&#x27;</span>,include(<span class="string">&#x27;captcha.urls&#x27;</span>)),   <span class="comment">#这句是新加的，验证码专用</span></span><br><span class="line">    path(<span class="string">&#x27;k8s/&#x27;</span>,include(<span class="string">&#x27;createyaml.urls&#x27;</span>)),    <span class="comment">#工具平台分支</span></span><br><span class="line">    path(<span class="string">&#x27;ag/&#x27;</span>,include(<span class="string">&#x27;accessgateway.urls&#x27;</span>)),  <span class="comment">#堡垒机分支</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>修改一下<code>views.py</code>，如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> auth</span><br><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> forms</span><br><span class="line"><span class="keyword">from</span> captcha.fields <span class="keyword">import</span> CaptchaField</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CaptchaForm</span>(forms.Form):		<span class="comment">#引入一个类</span></span><br><span class="line">    captcha = CaptchaField()</span><br><span class="line"></span><br><span class="line"><span class="comment">#登陆</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">if</span> request.POST:</span><br><span class="line">        form = CaptchaForm(request.POST)	<span class="comment">#将类实例化</span></span><br><span class="line">        username = request.POST.get(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        password = request.POST.get(<span class="string">&#x27;password&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        user = auth.authenticate(username=username, password=password)</span><br><span class="line">        <span class="keyword">if</span> form.is_valid():		<span class="comment">#如果form合法</span></span><br><span class="line">            human = <span class="literal">True</span>	<span class="comment">#判断是人操作，而不是机器人</span></span><br><span class="line">            <span class="keyword">if</span> user <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                auth.login(request, user) <span class="comment"># 登录</span></span><br><span class="line">                <span class="comment">#request.session[&#x27;user&#x27;] = username 	# 记录session信息</span></span><br><span class="line">                response = HttpResponseRedirect(<span class="string">&#x27;homepage.html&#x27;</span>)</span><br><span class="line">                response.set_cookie(<span class="string">&#x27;username&#x27;</span>,username,<span class="number">3600</span>)  <span class="comment">#将username写入cookie,超时时间是10分钟</span></span><br><span class="line">                <span class="keyword">return</span> response</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> render(request,<span class="string">&#x27;index.html&#x27;</span>, &#123;<span class="string">&#x27;error&#x27;</span>: <span class="string">&#x27;账号密码有误，请联系管理员!&#x27;</span>,<span class="string">&#x27;login_form&#x27;</span>:form&#125;)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> render(request,<span class="string">&#x27;index.html&#x27;</span>, &#123;<span class="string">&#x27;error&#x27;</span>: <span class="string">&#x27;验证码有误，请重新输入!&#x27;</span>,<span class="string">&#x27;login_form&#x27;</span>:form&#125;)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        form = CaptchaTestForm() <span class="comment"># 否者要求重新输入</span></span><br><span class="line">        <span class="keyword">return</span> render_to_response(<span class="string">&#x27;index.html&#x27;</span>,&#123;<span class="string">&#x27;login_form&#x27;</span>:form&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#其他部分略</span></span><br></pre></td></tr></table></figure></p>
<p>最后修改对应的html页面，在对应的地方加入即可：<br>	<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&#x27;yellow&#x27;</span>&gt;</span>验证码(看不清请刷新页面):<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">    &#123;&#123; login_form.captcha &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><br>	<br>保存之后，系统重新启动django，在浏览器输入网址，就能看到效果了：<br><img data-src="/images/django50.gif" alt="akb48"></p>
<p>这个页面还没有完美，应该再加入一个ajax，实现“点击验证码，刷新页面”的功能就更完美了。</p>
<p>登录验证码的方式还有很多，除了这个<code>django-simple-captha</code>，还有像<a href="https://pypi.org/project/django_click_captcha/">https://pypi.org/project/django_click_captcha/</a> 点击倒字的登录方法，甚至还有手机短信的登陆方法，这些高级的方法以后再研究吧。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://code.ziqiangxuetang.com/django/django-middleware.html">https://code.ziqiangxuetang.com/django/django-middleware.html</a><br><a href="https://www.jianshu.com/p/1a95808faed9">https://www.jianshu.com/p/1a95808faed9</a><br><a href="https://blog.csdn.net/xxm524/article/details/48370337">https://blog.csdn.net/xxm524/article/details/48370337</a><br><a href="http://www.calmkart.com/?p=332">http://www.calmkart.com/?p=332</a><br><a href="https://fanquqi.github.io/2018/03/30/Django%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81/">https://fanquqi.github.io/2018/03/30/Django%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81/</a><br><a href="https://blog.csdn.net/teavamc/article/details/77566781">https://blog.csdn.net/teavamc/article/details/77566781</a><br><a href="https://blog.51cto.com/syklinux/2052484">https://blog.51cto.com/syklinux/2052484</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>url拦截</tag>
      </tags>
  </entry>
  <entry>
    <title>美妙的东京八日游</title>
    <url>/2019/12/03/%E7%BE%8E%E5%A6%99%E7%9A%84%E4%B8%9C%E4%BA%AC%E5%85%AB%E6%97%A5%E6%B8%B8/</url>
    <content><![CDATA[<p>9月份的时候，俺就跟媳妇琢磨想要一起休有薪假，原本打算去台湾转转，但是由于国家政策变化只能作罢，而我个人对韩国、老挝、柬埔寨也没啥感觉，于是选来选去还是决定二刷日本，不过这次目的地不再是大阪了，而是东京。</p>
<p>买了国航的票，一大早9点半从杭州坐机场大巴到浦东机场，当时上海正值国际进口博览会，刚入上海还要停车—所有人下车安检。之后顺利到达浦东机场，办理值机托运和出关手续之后，我和媳妇买了两个汉堡王套餐垫垫肚子。终于等到1点半起飞，4点抵达成田机场。</p>
<p>在日本办理入关的时候还有一个小插曲，我媳妇随身携带的布包里有飞机上吃剩的柚子和玉米，结果入关时被搜查犬盯上闻来闻去，然后与搜查犬一起的小姐姐就拿出一个纸片，上面有中文：“您的包裹里有食物，请配合我们检查”，于是我们就配合的检查了一下，检查完毕食物并没有没收照样还给了我们。插曲结束，跳上skyline直达东京市区，又买了东京3日地铁卡，然后按照google导航顺利找到酒店办理入住。</p>
<p>我们住的是平价酒店，在店员的指导下用机器checkin，到了房间里发现什么东西都很小，桌子小、卫生间小、浴缸小，除了大床剩下的基本能上墙的都上墙了。虽然小，但该有的都有，而且很整洁，很精致。我也人生第一次使用了他们的水冲屁屁马桶，那感觉还真有点“酸爽”。每天早上宾馆还有早餐，虽然免费的只有两个套餐，但是可颂抹黄油再配上一杯红茶还是挺好吃的。</p>
<p>我住的酒店位于茅长町。茅长町在当地是一个普通的住宅区，初到的那个晚上把行李放好之后，在酒店四处走了走，发现附近都是人家、小商店、写字楼、小公园，并没有什么特别的景点。不过日本的街道很好玩，因为楼与楼很近，感觉就像迷宫一样，我就在各种小路里溜达探索，意外的发现了一个小神社，神社里还有人再出售神符。而且这个神社还挺有人气的，又一次我早上来溜达的时候，看到一个穿正装的女子前来拜祭，啪啪拍了两下手低头鞠躬，然后还往功德箱里面扔了几个硬币。估计这位妹子是去求职面试吧，希望自己能有一个好运气。<br><img data-src="/images/tokyo7.jpg" alt="akb48" title="可惜我没有零钱，又不能扫码支付..."></p>
<p>具体的行程表如下：<br>11月9日	杭州东站—上海浦东机场—东京成田机场入关—茅长町酒店入住，周围小转<br>11月10日  台场—自由女神–杜莎夫人蜡像馆–SEGA欢乐城—海贼王公园—东京塔观光<br>11月11日  东京迪士尼海洋公园<br>11月12日  东京国立博物馆—不忍池—秋叶原<br>11月13日  雷门—浅草寺—上野动物园—茑屋书店（代官山店）<br>11月14日  镰仓小町通—鹤岗八幡宫—镰仓高校打卡—歌舞伎町一番街<br>11月15日  新宿买买买<br>11月16日  东京成田机场买买买—上海浦东机场—杭州东站</p>
<h2 id="东京迪士尼海洋公园"><a href="#东京迪士尼海洋公园" class="headerlink" title="东京迪士尼海洋公园"></a>东京迪士尼海洋公园</h2><p>东京迪士尼毫无疑问是本次东京之行的重头戏，非常值得独立出来说，它的篇幅也的确有点大。我们去的是迪士尼海洋园区。为了这趟迪士尼，本人着实下一番功夫：先去东京迪士尼的官网注册会员然后购买了门票并且打印出二维码。东京迪士尼跟上海的迪士尼不一样—<code>FAST PASS</code>卡不是用钱买的，而是需要抢的，如果不想自己掐着表在园区里跑来跑去，那么就需要下载两个app—<code>Disney Resort</code>和<code>TDL/S时间</code>：<br><img data-src="/images/tokyo4.jpg" alt="akb48" title="APP是必不可少的！"></p>
<p>但是这里要注意，只有日版的<code>apple store</code>才能下载到这俩个app，所以你需要用一个邮箱来申请一个日区的<code>apple store</code>账号，下载APP完毕之后，在<code>Disney Resort</code>需要登陆的也是你在东京迪士尼网络上注册买票的账号！这里是比较坑的一个地方。</p>
<p>这样在官网买了票，又准备了APP抢<code>FAST PASS</code>卡，带上几瓶水和简单的干粮。我和媳妇就一大早起床出发，直奔迪士尼海洋，到了园区拿了中文地图就方便多了，我俩足足玩了一整天，各种打卡拍照不亦乐乎。东京迪士尼我个人觉得必刷的几个项目：</p>
<ol>
<li>百老汇演出，这个第一场是随便进的，强烈推荐去看！除了第一场剩余的都要抢票才可以；</li>
<li>玩具总动员，这个跟上海迪士尼不一样，比上海迪士尼的更好玩；</li>
<li>惊魂古塔，超级超级超级的跳楼机，我跟媳妇琢磨了许久，最后没敢上…</li>
</ol>
<p>至于忿怒双神（过山车），飞跃地平线等项目也都很棒，但是跟上海迪士尼的差不太多，所以我强烈建议优先搞定上面三个。至于龟龟漫谈、神灯阿拉丁还有其他的部分项目，是有日语对白的，所以如果不懂日语就只能看个热闹。<br><img data-src="/images/tokyo3.jpg" alt="akb48" title="这个就是忿怒双神，不过见识过环球影城的翼龙飞行的我，对它就是微微一笑"></p>
<p>迪士尼海洋馆是没有花车游行的，但是中午会有露天舞蹈演出，我们去的时候已经属于圣诞节期，所以NPC们穿的都是圣诞装束了。到了晚上八点半，园区中央同样会有游船表演和烟火，只不过规模没有旁边迪士尼主区那么大。虽然东京迪士尼相比较大阪的环球影城更加偏低龄化，但是也非常值得花一天去享受，里面的火鸡腿也很好吃！</p>
<h2 id="东京的文化"><a href="#东京的文化" class="headerlink" title="东京的文化"></a>东京的文化</h2><p>东京国立博物馆是收费的，同样可以先在官网购买票，打印出票或保存二维码直接入门。我自己都没想到我花在东京国立博物馆的时间竟然比当时在大英博物馆的时间都要长，可能是因为国立博物馆主馆部分游客不多，许多展品可以一件一件的看过去，在这个空旷的展厅一个字一个字的读铂了金的佛经也是一个乐事。国立博物馆正馆里有一个特殊的小展厅，它里面每个月都会换国宝文物来展出，我去的时候正好是展出唐朝《群书治要》的手抄卷的一部分。<br><img data-src="/images/tokyo16.jpg" alt="akb48" title="《群书治要》不能拍，只能拍黑漆大小"></p>
<p>出了正馆，右手边就是东洋馆，不过先不急，天气特别好。我就在长凳上慢慢喝了一杯热咖啡，顺便晒晒太阳。东洋馆的“人，神，自然”特别展出给我留下的印象比较深刻—展厅中央是两具古尸，周围是各种公元前时代各种的祭品。人类本相通，无论什么种族肤色，都是从祭祀敬天慢慢的进化到娱己重我，那些静静躺着的文物也无声的证明这这段时光。在东洋馆3、4楼有较大的一片区域专门展出中国文物，有商朝的摇钱树、唐朝的器皿、宋朝的字画。底楼是展出波斯柬埔寨等国的文物，在展厅二楼中间可以掷骨算命和印章这样的小互动，免费玩一玩游戏还是蛮有意思的。</p>
<p>今年是日本新天皇上任，所以国立博物馆特意安排了奈良的正仓院举行特别展出，这次特别展出的招牌就是传世唯一唐朝五弦琵琶。果然那个琵琶附近全是人，排成队的流动。这次正仓院展出是额外收费的，而且只能凭借纸质票补差价，如果是电子票必须全额买，这一点比较坑。话说日本有很多老头老太太来逛博物院，一个个走的颤颤巍巍的。<br><img data-src="/images/tokyo17.jpg" alt="akb48" title="东京国立博物馆的设计布局还是很棒的，逛起来很舒服"></p>
<p>除了博物馆，东京还有很多的美术馆，这里面我个人强烈推荐根津美术馆，它是一个私人收藏馆，整个园林的布置非常的考究。但是很遗憾，我在的八天的时间里由于根津美术馆维修，我只能缘悭一面。后来我媳妇的闺蜜在12月初去了根津美术馆，媳妇闺蜜后来发微信跟我媳妇说12月枫叶红了，整个根津美术馆特别漂亮和雅致，惊艳到她了。</p>
<h2 id="东京的买"><a href="#东京的买" class="headerlink" title="东京的买"></a>东京的买</h2><p>说到买，东京有著名五大购物区—新宿、银座、池袋、涩谷、六本木。我俩行程里只安排了一天的购物，所以就在新宿泡了一整天。今年人民币贬值比较厉害，所以在东京购物相比较大陆，实惠的力度稍打折扣，不过还是比国内便宜很多，我买了一个加南大鹅的棉马夹，淘宝要4000，日本价格不到3100人民币。除此之外，买了三盒蒸汽眼罩。</p>
<p>江湖传言Adidas和North Face在日本都能买到特殊设计的服装，果然这两个品牌店在东京也是比较好找的。里面的款式也的确是国内专卖店没有的，看上去都很潮。不过很可惜，日本的男性普遍都是瘦身材，所以衣服最大码就是L码，对于我说来看到喜欢的衣服却没有XL码真是一个很痛苦的事情。</p>
<p>说完了买衣服再说说别的。台场商业中心是高达死忠粉必打卡的地方，中心门口的巨型高达已经足够吸睛，据说每天有两场灯光秀。而商场里最顶层有一半的空间是高达基地。这个简直可以称之为“高达博物馆”的地方里面有各式各样的高达手办，甚至可以自己DIY给高达配色和组装零部件。<br><img data-src="/images/tokyo5.jpg" alt="akb48" title="门口的独角兽简直太威风了！"><br><img data-src="/images/tokyo18.jpg" alt="akb48" title="我全都要啊啊啊啊"></p>
<p>如果你是NBA死忠粉，那么在台场商场的NBA店会看到许多NBA巨星的签名和球鞋，从飞人乔丹魔术师约翰逊鲨鱼奥尼尔再到艾弗森库里，中国长城姚主席的球衣也在展列柜里：<br><img data-src="/images/tokyo6.jpg" alt="akb48" title="梦一队队服和球鞋，7号是拉里伯德"><br><img data-src="/images/tokyo19.jpg" alt="akb48" title="大姚的鞋果然很大..."></p>
<p>到了东京怎么能不去秋叶原？秋叶原以死宅的“圣域”而闻名，里面手办、游戏、漫画、写真、COSPLAY的衣服，无论是见过的没见过的，知道名的不知道名的，应有尽有。当然如果你乱走，也会有可能误入出售岛国爱情动作片和成人用品的地区，完全是意外之喜啊！</p>
<p>AKB48的剧场也位于秋叶原，如果你看过WorldOrder舞团的《Have a nice day》的MV，应该会对这里有点印象：<br><img data-src="/images/tokyo9.jpg" alt="akb48"></p>
<p><img data-src="/images/tokyo10.jpg" alt="akb48" title="这么多年了，海报还是最初的那几个元老"></p>
<p>我是斋藤飞鸟的死宅粉，那么买一个我鸟的写真集也是早早就列入愿望list里的。而代官山的茑屋书店是一个很著名的书店，书店是全玻璃体，分三个部分，有露天楼梯相通，书店里出售书籍、影像、CD、文具、蓝牙音箱、车模乃至超市用具都有，甚至可以在里面边看书边吃饭。我在网上看它是一个东京少数的24小时店，甚至还提供住宿服务，不过我转了一圈并没有发现可以睡觉的地方…<br><img data-src="/images/tokyo2.jpg" alt="akb48" title="意外的发现了《三体》"></p>
<p><img data-src="/images/tokyo20.jpg" alt="akb48" title="披头士签名唱片"></p>
<h2 id="东京的吃"><a href="#东京的吃" class="headerlink" title="东京的吃"></a>东京的吃</h2><p>在东京吃东西很贵，我一个普通工薪族也没有安排特别高大上的东西。几天下来我个人觉得最好吃的就是在新宿店吃的“鸟贵族”，他们以烧鸟作为招牌菜。先叫上两杯梅子酒，吃上几串芝士鸡肉丸，我个人非常喜欢他们的天妇罗，炸的软软的，入口即化。鸡皮盐味烤也不错，鸡皮烤得脆焦程度刚好，而且并不油腻。咬下去汁液在口腔中四溅，像盛开的烟花。再叫上一杯大扎啤，歇歇逛了一天的脚，感觉好极了。<br><img data-src="/images/tokyo21.jpg" alt="akb48" title="一杯冰冰啤酒，一定要带沫喝"></p>
<p>在七里滨，我跟媳妇慕名来尝尝这里的bills—传说中最棒的早餐。我俩到达的时候已经是下午4点左右，已经开始排起了小队，但是队伍并不长。这里招牌的就是pancake，好吃到流泪，随着松饼温度而慢慢溶化的蜂蜜奶油，更增添香味。奶油让松饼入口即化，细细咀嚼后能够感受到淡淡的乳香，搭配上烤过的香蕉片，清爽甜蜜的美味让人难忘。虽然银座也有bills，但是七里滨的bills位于海边，当时正好是渐渐夕阳的时间段，在店里靠窗户的位置还能看着大海里一个一个冲浪结束返回的人，无敌的海景view。<br><img data-src="/images/tokyo1.jpg" alt="akb48" title="七里滨的海景"></p>
<p>在上野公园，正好有机会去尝了尝一兰拉面，一进店门机器投币下单，机器打印小票，每人单人隔间，把外套挂到身后的衣架上，小票放到小盘里按一下桌子上的按钮，就会从店员从帘子后面伸出手来把小票拿走，根据小票内容准备食物。如果想要多加一份面或者半份面也是在门口的机器上投币下单，然后重复的把票放到小盘里按按钮即可。豚骨拉面还是很好吃的，他家的绿茶豆腐也很棒，没有那么甜，绿茶味挺浓。</p>
<p>陈晓卿先生在《圆桌派》里说过：想了解一个城市，就一定要去它的菜市场，饱览里面的食材，饱尝各种美味。筑地市场现在也成了东京的一个景点，那是一个当地很有名的水产市场，很可惜它要搬走了，由于2020东京奥运会的缘故。</p>
<p>至于女仆咖啡店，老夫只是在秋叶原的街上遇到上穿羽绒服下穿短裙的卡哇伊妹子发传单，而没有亲身尝试。现在很多女仆咖啡店也开始对中国人做生意了，提供中文菜单，而且可以跟众多女仆妹子们一起嗨。秋叶原的女仆店价钱比新宿的女仆店要便宜一点，但是秋叶原的咖啡店玩法比较多，除了女仆还有三国系列，为什么会有三国设定？学赵子龙七进七出嘛…<br><img data-src="/images/tokyo8.jpg" alt="akb48" title="女仆店的宣传单"></p>
<h2 id="东京的玩"><a href="#东京的玩" class="headerlink" title="东京的玩"></a>东京的玩</h2><p>东京作为国际级别大都市，地标建筑很多，我们第一天晚上就去了东京塔。东京塔有一个网红拍摄地，就是在一个地下室的台阶上仰拍整个东京塔，我跟媳妇去的时候发现那里已经有不下50个人在排队拍照，有些是拍塔，有些是连塔带人一起拍。东京塔里吃的东西一般，但是海贼王主题乐园就在东京塔里，在网络上购票比现场买便宜，而且还可以买东京塔观光的联票。海贼王主题乐园的周边出售到没有什么特别新奇的，而且很多一看就是义乌小商品。但是里面的真人表演还是挺棒的，还原度挺高，每人还发一个荧光棒来配合演员唱歌，剧情是独立的内容。<br><img data-src="/images/tokyo22.jpg" alt="akb48" title="二楼展区有作者的亲笔签名"></p>
<p>出了海贼王我们就直接上塔观光，东京塔有两层用来观光，高度不同价钱自然也不同。其实在main deck里能看到东京大部分的市容风景，top deck风景更佳。虽然现在东京的晴空塔更新更高，但是在很多东京人的心中，东京塔还是有一个无法磨灭的地位在。<br><img data-src="/images/tokyo13.jpg" alt="akb48"></p>
<p>SEGA欢乐城其实就是一个超大的电子游戏机厅，除了常规的游戏机之外（不过我在东京的游戏机厅里没见过《拳皇》），里面也有一些全体作战的重量型主题游戏机，需要4~10人一起玩的。如果你日文读的能力差一点的话，可能有些地方就要乱按键，看看能不能瞎猫碰上死耗子了。</p>
<p>上野动物园跟不忍池都在东京国立博物馆旁边的上野公园里，我去的时候池塘的荷花已经败掉了，但是在上野动物园看到了著名的鲸头鹳，呆呆傻傻的，偶尔一张开翅膀惊得很多人欢呼。在动物园经常看到日本的老头老太太在笼子外做手势，嘴巴里还轻轻的呼唤着里面的动物，希望可以得到动物的注意而跑过来。除了鲸头鹳，上野动物园的镇馆之宝就是大熊猫了，毫无疑问，熊猫馆排队也是非常惊人的，我跟媳妇没有去凑这个热闹。<br><img data-src="/images/tokyo11.jpg" alt="akb48"></p>
<p>我们这次还抽出了一天的时间去镰仓，拜访了著名了镰仓高校车站。这个车站已经被众多《灌篮高手》的粉丝打卡，尤其是火车过站的时候，很多中国游客在狂热的拍照。车站往上走一点点就能看到镰仓高校，学校门口有一个告示牌：“请游客不要入内拍照”，可见这个学校虽然作为湘北高校的原型而红遍大江南北，但是也饱受游客骚扰之苦。<br><img data-src="/images/tokyo12.jpg" alt="akb48" title="这个景色没有因为是傍晚而失去魅力"></p>
<p>说完了健康的娱乐，再说一点不健康的…在上野公园出来的路边，我惊喜的发现了成人电影院（囧）。看广告应该是500日元可以看一小时，可以一直看到深夜，成人影院门口贴满热辣的马赛克海报以及门口也摆了一两个穿制服的塑料模特。我驻足一会，顶着被抓的风险，拍了几张照就离开了…<br><img data-src="/images/tokyo15.jpg" alt="akb48" title="实不相瞒，我很想进去与民同乐..."></p>
<h2 id="东京的人"><a href="#东京的人" class="headerlink" title="东京的人"></a>东京的人</h2><p>这此是我第二次来东京，觉得其实日本人还是很好分辨的。日本女人不用多说，妙龄少女打扮的很精致，贴假睫毛，牙齿又不算太整齐的话，那基本就是日本妹子了（甚至女厕所里会有梳妆台！别问我怎么知道的…）。而东京男人的体态特征也很明显，首先他们由于瘦，脸长且面部的棱角比较突出，而且感觉他们还都很喜欢鹰钩鼻，不知道是否有专门做这方面整容的医院。除了面部器官，头发也是识别东京男人的一个标志，很多年轻人都喜欢卷卷的头发，或长发或刘海，配上他们苗条的身材和不大的脸蛋，有些“花美男”的味道。</p>
<p>日本人超级能排队，当然据说他们心理对于“排队”也是拒绝的，但是身体却很诚实。上到美术馆下到拉面店，日本人在哪里都能排队。记得在迪士尼海洋，在环球喷泉最佳拍摄角度那里，日本人都会自发排队一个一个拍照…据说这是一种从众的体现。而且东京没有共享单车，因为几乎家家都有自行车，如果是住独栋的，院子里也会停一辆小排量的家用车。</p>
<p>日本的电车跟伦敦的一样，没有安检。站台非常干净，车厢里也是十分安静，很多人戴着口罩，不知道是遮住早起的倦容，还是藏着工作了一天的疲惫。刷手机，听歌，或者玩switch。看着车上的上班族，让我不自觉的想起日本综艺节目《让我去你家》里的一个一个小故事。想必国际大都市大抵都是这样，挤满了人，灯火辉煌的后面是一颗颗孤独的心。站在银座伊势丹的顶层，俯瞰这来往穿梭的人群车流，绝对是独一无二的景致。</p>
<p>上一次在大阪没有机会感受柏青哥，这次到了秋叶原也去转了一圈。发现里面各种柏青哥游戏机，小的是一个人玩的飞牌机，最大的有8个人一起玩的。在柏青哥店里，同样有吃有喝，排队等机器的话甚至可以看店家提供的杂志和漫画。店里20~80岁的各年龄层的男女顾客在这霹雳哗啦吵杂的声音里专注的盯着自己的屏幕消磨时间。有的人甚至旁边有一个小筐，筐里全是钢珠。但是柏青哥店并不是通宵营业，11点就关门了。<br><img data-src="/images/tokyo14.jpg" alt="akb48" title="光看着我就已经晕了"></p>
<p>除了以上几点，东京给我更大的感触，就是虽然警车会在街上巡逻，但是生活中没有那么多的安检—–地铁没有，博物馆没有，甚至在机场也没有人来摸你检查有没有带违规东西。这一现象大陆几乎不可能，而对于我来说是很舒服的。</p>
<h2 id="东京tips"><a href="#东京tips" class="headerlink" title="东京tips"></a>东京tips</h2><ol>
<li>从成田到东京市内可以坐skyliner，这个可以在网上直接订票，然后凭借二维码直接刷码入场。不过价钱有点小贵，但是车上很空；</li>
<li>东京迪士尼海洋馆没有漫威和星球大战的区域，也没有他们的周边卖；</li>
<li>宫崎骏美术馆需要至少提前一个月买票，如果实在没有票可以尝试去闲鱼购买，价钱比淘宝上便宜很多；</li>
<li>如果三年内两次入境日本，可以办理日本免签了；</li>
</ol>
<p>8天很快就过去了，我这一次没有去的地方还很多：明治神宫、吉普力博物馆、晴空塔、棒球场、涩谷、池袋等等等等。但是整体玩下来，感觉到东京无愧于亚洲第一城市，繁华、奢靡、喧闹、庞大，这样的形容词来形容它的日和夜。静与杂，非常和谐的充斥在这座城市的24小时。对于日本来说，东京承担着“北京+上海”的职责。它在1945年被美军轰炸，而1964年就举办了东京奥运会，再生速度简直惊人！</p>
<p>东京，是一个规则更加分明、细节更加发达的城市，但是这个城市里又容纳了各种各样的人和他们的文化，无论是奥特曼还是哥斯拉，火影忍者还是AKB48，每天发生着不同的故事，为这个城市增加了无限多的可能性。我这次仅仅是走马观花，东京给我的感觉就是这样一个干净、安全，人与人之间礼貌、尊重、信任的城市。作为一个游客，我还是想再玩一次！</p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>旅游</tag>
        <tag>日本</tag>
      </tags>
  </entry>
  <entry>
    <title>肝通了《刺客信条起源》</title>
    <url>/2021/07/26/%E8%82%9D%E9%80%9A%E4%BA%86%E3%80%8A%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A1%E8%B5%B7%E6%BA%90%E3%80%8B/</url>
    <content><![CDATA[<p>周末说会有台风登陆杭州，于是老老实实的在家里蹲，也利用这个周末彻底打穿了《刺客信条 起源》，从本作加上两个DLC。</p>
<p>玩《起源》之前，我就打通了同系列的《刺客信条 奥德赛》，男号一遍女号一遍，累计玩了200多小时。说实话，我个人觉得《奥德赛》全家死光光的结局才应该是正规的结局，因为古希腊很多的故事都是伦理故事而且悲剧结尾。不过也正是先玩的《奥德赛》后玩的《起源》，所以从操作的角度来说，《奥德赛》更爽，格挡比《起源》的盾挡更加轻松。缺点就是后期打一下好几十万乃至上亿的半神伤害，导致后期我拔据点基本就是狂战士无双模式，在伤害方面这一点《起源》的伤害和等级控制更合理。</p>
<p>其实这种开放世界RPG游戏，玩着玩着就会发现跟《魔兽世界》差不多，“接到任务–&gt;看地图找目标–&gt;下马杀杀杀然后拿东西走人”的套路，主线做完之后就一路看风景咔嚓照相。不过我个人比较喜欢古希腊和古埃及的历史，觉得很神秘，所以这俩游戏的故事背景看得我还挺津津有味的。说到起源就尤其要说《法老诅咒》这个DLC，我个人觉得比《奥德赛》的DLC做的更好，尤其是那几个法老死后世界的刻画是在太漂亮了，哪里是阴间有些简直就是天堂。而且在几个法老的身后世界无法冥想，系统会提示你“这里的时间是永恒的…”</p>
<p>最后上几幅图，感受一下《起源》，反正现在也不能出国，云旅游一下古埃及还是极好的…但是这里要吐槽一下，育碧的美工明显对待《奥德赛》是亲儿子，对比卡姐有那么多套服装，各种风格都有甚至未来战士都有，《起源》里八爷的服装少得可怜。</p>
<p><img data-src="/images/%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A1%E8%B5%B7%E6%BA%901.jpg"><br><img data-src="/images/%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A1%E8%B5%B7%E6%BA%902.jpg"><br><img data-src="/images/%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A1%E8%B5%B7%E6%BA%903.jpg"><br><img data-src="/images/%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A1%E8%B5%B7%E6%BA%904.jpg"><br><img data-src="/images/%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A1%E8%B5%B7%E6%BA%905.jpg"></p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>游戏</tag>
        <tag>育碧</tag>
        <tag>开放</tag>
        <tag>RPG</tag>
      </tags>
  </entry>
  <entry>
    <title>给非root开放tcpdump命令权限</title>
    <url>/2018/06/22/%E7%BB%99%E9%9D%9Eroot%E5%BC%80%E6%94%BEtcpdump%E5%91%BD%E4%BB%A4%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<p>这周给开发们上了堡垒机，使用的是开源的<code>jumpserver</code>，官网是<a href="http://www.jumpserver.org/">http://www.jumpserver.org/</a> 。</p>
<p>注册了账号下发给各位开发之后，开发反馈了一个问题：无法用<code>tcpdump</code>抓包。因为<code>tcpdump</code>默认是只能被root调用的，如果是非root用户使用就会报错：<code>You don&#39;t have permission to capture on that device</code>。</p>
<p>如果要让普通用户也能顺利用上<code>tcpdump</code>，方法很简单，就是对tcpdump这个文件修改成<code>u+s</code>即可。整个过程如下图：<br><img data-src="/images/tcpdump1.png" alt="akb48"></p>
<p>在堡垒机的web界面试一下：<br><img data-src="/images/tcpdump2.png" alt="akb48"></p>
<p>但是<code>jstack</code>这个命令不能按照上面的方法配置给非root用户，因为<code>jstack</code>命令只能是当前java进程的用户才能用。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>脚本里添加crontab的方法</title>
    <url>/2018/02/08/%E8%84%9A%E6%9C%AC%E9%87%8C%E6%B7%BB%E5%8A%A0crontab%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>一般来说，增加计划任务都是<code>crontab -e</code>，然后在里面添加内容。但是在一些脚本里，需要自动添加，那么这种情况怎么办？</p>
<h2 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h2><p>重定向crontab到其他文件：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">crontab -l &gt; crontab.<span class="property">bak</span></span><br><span class="line">echo <span class="string">&quot;*/1 * * * * ./yourscript  &gt; /dev/null 2&gt;&amp;1&quot;</span> &gt;&gt; crontab.<span class="property">bak</span></span><br><span class="line">crontab crontab.<span class="property">bak</span></span><br></pre></td></tr></table></figure></p>
<p>如果想删除某个计划任务，就进去<code>crontab -e</code>删除就好，<code>crontab.bak</code>不用管，不用担心内容会自动变成<code>crontab.bak</code>的样子。</p>
<h2 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h2><p>如果你觉得使用<code>crontab 文件</code>这种方法心里没有底的话，就选择最妥善的方式，也就是下面这样：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">echo <span class="string">&quot;*/1 * * * * ./yourscript &gt; /dev/null 2&gt;&amp;1&quot;</span> &gt;&gt; <span class="regexp">/var/</span>spool/cron/root</span><br></pre></td></tr></table></figure></p>
<p>当crontab突然失效时，可以尝试<code>/etc/init.d/crond restart</code>解决问题。或者查看日志看某个job有没有执行&#x2F;报错<code>tail -f /var/log/cron</code>。<br><img data-src="/images/vc15.jpg" alt="paradin" title="半人半神！"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>crontab</tag>
      </tags>
  </entry>
  <entry>
    <title>自己动手搭建一个hexo博客demo</title>
    <url>/2018/01/10/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAhexo%E5%8D%9A%E5%AE%A2demo/</url>
    <content><![CDATA[<p>曾几何时，自己动手做一个博客的想法愈加强烈，想在里面放一些更多除了技术之外的东西，比如烹饪的美食，比如PVP的视频，比如拍摄的照片，比如篮球足球的评论。在这种需求下，我从众多博客框架里面选择了hexo，原因就是“很多人都推荐hexo”….（囧）于是乎我在windows里搞一个，由于我在公司的网络是可以跨越长城的，所以搞github有一点天然的优势。而且github的博客不用花钱搞域名，他直接免费提供…</p>
<p><strong>在搞github的时候墙裂推荐各位去用命令行，有linux的基本基础就可以很熟练的使用命令行搞github， 它的客户端真的不如命令行好用。</strong></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>先去注册一个github，然后去<a href="https://git-scm.com/">https://git-scm.com</a> 上下载一个最新的git windows的客户端，我下载的是2.15.1版本，如图：<br><img data-src="/images/zhucegithub.png" alt="抱光妹" title="windows下载github"></p>
<p>下载完毕之后，就把这个exe文件安装，然后在“开始”里找到git再打开“Git Bash”，我的github账号是<code>RorschachChan</code>，电子邮件也已经配置过，所以现在就在这个bash窗口里写入如下语句：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git config --<span class="variable language_">global</span> user.<span class="property">name</span> <span class="string">&quot;RorschachChan&quot;</span></span><br><span class="line">git config --<span class="variable language_">global</span> user.<span class="property">email</span> <span class="string">&quot;chenx1242@163.com&quot;</span></span><br></pre></td></tr></table></figure></p>
<p><img data-src="/images/config1.png" alt="抱光妹" title="确定用户名和邮箱"><br>上面<code>git config --global</code>参数，表示你这台机器上所有的Git仓库都会使用这个配置。</p>
<p>再去<code>https://nodejs.org/en/download/</code>上根据自己windows的情况，下载最新的<code>nodejs</code>，下载完了之后就一路next，然后需要退出重进一下<code>git bash</code>，在bash的命令行里输入<code>node -v</code>，看到版本号就是OK，同时输入node，<code>$</code>会变成<code>&gt;</code>，然后输入.exit就可以退出返回到bash。<br><img data-src="/images/nodeV.png" alt="抱光妹" title="查看node版本"></p>
<p>然后就是安装hexo，hexo的安装比较简单，就是在git bash里输入<code>npm install -g hexo-cli </code>和<code>npm install -g hexo</code>，然后需要等待一会，如果出现了<code>npm ERR!</code>不要怕，重新输入一次应该就会好了，安装完毕之后，输入<code>hexo -v</code>查看hexo的版本，如图：<br><img data-src="/images/installhexo1.png" alt="抱光妹" title="安装hexo-cli"><br><img data-src="/images/installhexo2.png" alt="抱光妹" title="安装hexo"></p>
<p>然后建立一个github ssh密钥，在git bash里输入<code>ssh-keygen -t rsa -C &quot;你的邮箱&quot;</code>，然后告诉密钥生成的路径（下图黄框）以及会让你输入对应的口诀（红色箭头），这个口诀很重要，要妥善保存，如图：<br><img data-src="/images/githubak.png" alt="抱光妹" title="配置密钥"></p>
<p>这个密码会在你提交项目（<code>hexo d</code>）时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。这时候去<code>C:\Users\33664\.ssh</code>的路径里就会看到一对钥匙，<strong>id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</strong><br><img data-src="/images/miyao.png" alt="抱光妹" title="密钥在这里"></p>
<p>来到github的个人配置里，选择<code>SSH and GPG keys</code>，然后输入title和id_rsa.pub的内容，点击<code>add ssh key</code>。如图：<br><img data-src="/images/addak.png" alt="抱光妹" title="在github添加ak"><br>准备工作的最后一步，就是建立一个文件夹，我的文件夹建立在E盘下，名字就叫hexo。</p>
<h2 id="开始搭建博客"><a href="#开始搭建博客" class="headerlink" title="开始搭建博客"></a>开始搭建博客</h2><p>首先在git bash里进入&#x2F;e&#x2F;hexo，然后输入<code>hexo init</code>，这个命令是初始化命令，再输入<code>hexo -g</code>来生成静态文件，执行之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github上你的用户名.github.io的仓库上去的。然后可以输入<code>hexo s</code>来本地启动hexo，这个时候跑到浏览器里输入<code>localhost:4000</code>就会看到hexo博客最初的一个样子，如图：<br><img data-src="/images/hexo1.png" alt="抱光妹" title="最初是状态的hexo"></p>
<p>这个默认的主题比较难看，我们去<code>https://github.com/iissnan/hexo-theme-next</code>下载最近一个比较火爆的主题next,并且把这个下载到hexo文件夹里的themes&#x2F;next里，语句是：<code>git clone https://github.com/iissnan/hexo-theme-next.git themes/next</code><br><img data-src="/images/installnext.png" alt="抱光妹" title="安装next主题"></p>
<p>然后打开hexo文件夹里的<code>_config.xml</code>，把原有的theme注释，换成新的next，注意，中间是有空格的！<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#<span class="attr">theme</span>: landscape</span><br><span class="line"><span class="attr">theme</span>: next</span><br></pre></td></tr></table></figure></p>
<p>然后<code>hexo clean</code>和<code>hexo g</code>清除 Hexo 的缓存和重新生成静态文件，再次<code>hexo s</code>启动进程，来到浏览看一下发现博客的样子就变成下面的样子了：<br><img data-src="/images/next1.png" alt="抱光妹" title="展示next主题"></p>
<p>这个看上去就简单大方很多了吧。</p>
<h2 id="把博客上传到github"><a href="#把博客上传到github" class="headerlink" title="把博客上传到github"></a>把博客上传到github</h2><p>现在有人问了，这个博客看上去好像很美，但是有两个致命的缺陷：第一，内容都是在我的windows里，如果我这个电脑坏了&#x2F;出差&#x2F;换新硬盘，那么如何保证我以前文件？第二，我启动进程需要执行 <code>hexo -s</code>，如果我电脑关机了，岂不是博客无法打开？</p>
<p>需要解决就要把磁盘上的内容传递到github库里了，同时github是常开进程的，这样既可以更新我们的内容又不会关闭博客进程，除非github这个网站黄了。</p>
<p>先去github网站去建立一个库（repository），这里我直接选择了公共读，如图：<br><img data-src="/images/repository.png" alt="抱光妹" title="建立一个新库"></p>
<p>然后在hexo文件夹里面，修改一下_config.xml的几个地方：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># <span class="title class_">Site</span></span><br><span class="line"><span class="attr">title</span>: 石锤淡啤酒    #这个是网站在标签页的标题</span><br><span class="line"><span class="attr">subtitle</span>: 生活就是等待戈多    #这个是副标题</span><br><span class="line"><span class="attr">description</span>: 这里记录的不只有代码，还有生活和思想！    #这里也可以写网站的关键词，也可以矫情的写点别的</span><br><span class="line"><span class="attr">author</span>: <span class="title class_">Chris</span> <span class="title class_">Chan</span>    #这个作者会在网页最下面显示</span><br><span class="line"><span class="attr">language</span>: zh-<span class="title class_">Hans</span>    #这里表示简体中文</span><br><span class="line"><span class="attr">timezone</span>:</span><br><span class="line"></span><br><span class="line"># <span class="title class_">Deployment</span></span><br><span class="line">## <span class="title class_">Docs</span>: <span class="attr">https</span>:<span class="comment">//hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy</span>:</span><br><span class="line"> 		<span class="attr">type</span>: git</span><br><span class="line"> 		<span class="attr">repository</span>: git@github.<span class="property">com</span>:<span class="title class_">RorschachChan</span>/<span class="title class_">RorschachChan</span>.<span class="property">github</span>.<span class="property">io</span>.<span class="property">git</span>    #这里写的就是刚刚申请的库名</span><br><span class="line"> 		<span class="attr">branch</span>: master</span><br></pre></td></tr></table></figure><br>建立完库以及修改保存了_config.xml之后，我们执行一句<code>hexo d</code>部署命令，在执行的时候需要输入当时你建立id_rsa时候的口诀，刚刚申请的那个口诀不会这么快就忘了吧。<br><img data-src="/images/hexod.png" alt="抱光妹" title="部署博客"></p>
<p>返回到github的网站就看到hexo里所有的内容都上传到了github网站里了，如图:<br><img data-src="/images/hexod2.png" alt="抱光妹" title="上传成功"></p>
<p>在浏览器里输入“https:&#x2F;&#x2F;你的用户名.github.io”，就看到了博客界面：<br><img data-src="/images/newnext.png" alt="抱光妹" title="更改了主题和作者的界面"></p>
<p>同理，如果你的github用户名是test，建立的是<code>test.github.io</code>的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是<code>http://test.github.io</code>了，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。</p>
<p>【2025年更新】现在如果上传的话，会要求你输入一下github的账号密码，但是你输入了可能也不好使。研究了一下，是因为github其实不支持账号密码的形式，而是要用token，于是就需要先去<a href="https://github.com/settings/tokens">https://github.com/settings/tokens</a> 创建一个新的token，这个token要保存好，刷新后就看不见了。然后在hexo 的<code>_config.yml</code>里，把原来的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">repository: https://你的github名称.github.io</span><br><span class="line">改成</span><br><span class="line">repository: https://你刚刚申请的token/你的github名称.github.io</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>重新执行<code>hexo d -g</code>就OK了。</p>
<p>至此，建立一个博客demo就到此结束了！</p>
<h2 id="如果报错hexo-ps1无法执行"><a href="#如果报错hexo-ps1无法执行" class="headerlink" title="如果报错hexo.ps1无法执行"></a>如果报错hexo.ps1无法执行</h2><p>如果当执行<code>hexo d -g</code>发现报错<code>hexo.ps1</code>无法执行，此时可以修改一下<code>set-executionpolicy remotesigned</code>，就搞定问题了：<br><img data-src="/images/hexops1.jpg" alt="抱光妹" title="开一个权限"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://baoyuzhang.github.io/2017/04/28/%E3%80%90Hexo%E6%90%AD%E5%BB%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2%E5%85%A8%E7%BA%AA%E5%BD%95%E3%80%91%EF%BC%88%E4%B8%80%EF%BC%89%E4%BD%BF%E7%94%A8Git%E5%92%8CGithub/">https://baoyuzhang.github.io/2017/04/28/【Hexo搭建独立博客全纪录】（一）使用Git和Github/</a><br><a href="https://github.com/iissnan/hexo-theme-next">https://github.com/iissnan/hexo-theme-next</a><br><a href="http://opiece.me/2015/04/09/hexo-guide/">http://opiece.me/2015/04/09/hexo-guide/</a><br><a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html">http://shenzekun.cn/hexo的next主题个性化配置教程.html</a> 强烈推荐这篇文章，可以让你把next主题的博客做的更加漂亮！ </p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>伦敦八日游记</title>
    <url>/2019/01/02/%E8%8B%B1%E4%BC%A610%E6%97%A5%E6%B8%B8/</url>
    <content><![CDATA[<p>这次的伦敦八日行其实是我的蜜月假期，原本打算跟媳妇去一趟巴塞罗那，但是网上攻略查了查发现巴塞罗那的小偷太多，甚至还有拦路抢包的事情发生。毕竟出门旅游，不想遇到什么添堵的事情，于是想来想去就选择了治安情况更好的伦敦作为本次的落脚点。</p>
<h2 id="前期工作"><a href="#前期工作" class="headerlink" title="前期工作"></a>前期工作</h2><p>办理英国签证还是比较麻烦的，虽然在杭州可以直接办理，但是需要提交很多的证件—收入证明、公司营业执照复印件等等，然后要等待一个月左右再去照相按手印。若心急的话，可以走付费的加速通道。机票我媳妇选择了国航，路线是“杭州–&gt;北京–&gt;伦敦”，选择国航的主要原因是“行李在转机的时候可以直挂”。至于住宿，伦敦毕竟也是寸土寸金的地方，住宿还是蛮贵的，100磅一晚是正常价格，我媳妇选择了Airbnb，地址很不错，是靠近牧羊丛地铁站的Richman街道，交通很便利，周围也很安静。</p>
<p>出门游玩得需要现金吧，于是乎去中国银行兑换英镑，兑换汇率是8.9，我媳妇兑换了1000磅，兑换完了才知道原来市场上流通的英镑最大面值才50…最后就是在淘宝上购买英国电话卡，我俩八天里使劲用才用了6G左右，所以其实10G完全够用了，20G流量纯粹浪费。</p>
<h2 id="具体行程"><a href="#具体行程" class="headerlink" title="具体行程"></a>具体行程</h2><p>这10天的具体行程如下：<br>22日 	从杭州出发，中午北京转机，晚上抵达伦敦希斯罗机场，办理oyster card，入住Airbnb<br>23日		大英博物馆 + 考文特花园 + 海德公园嘉年华<br>24日		杜莎夫人蜡像馆 + 贝克街散步 + 伦敦眼 + 去媳妇的朋友家圣诞聚餐<br>25日		圣诞节全城休息，步行去摄政街看灯，在唐人街吃饭<br>26日 	WestField购物 + 温布利看球 + 哈罗德百货购物<br>27日		西敏寺 + 伦敦塔桥 + 大本钟 + 泰晤士河游船<br>28日		温莎城堡 + 碎片大厦观景<br>29日		由于前几天太累了，原定的去剑桥大学参观取消，改成了牛津街购物<br>30日		WestField购物 + 返程到北京<br>31日  	抵达杭州</p>
<h2 id="伦敦的人"><a href="#伦敦的人" class="headerlink" title="伦敦的人"></a>伦敦的人</h2><p>伦敦是一个特别国际化的都市，出飞机场坐上地铁的那一刻，我发现车厢里有好多的印度人，让我一度怀疑飞机是不是飞到了新德里。伦敦大街上也是各种肤色，既有黑人白人也有头戴面纱的穆斯林，各路人马聚齐于此。伦敦人给人感觉是很友好的—只要人看到你拿着手机在路上一副不知所措的神情，就会上前主动问你“Are you lost?”记得我跟我媳妇第一天晚上9点多拖着行李找Airbnb的时候，就是一个黑人胖大姐帮我们联系了房东，而且还与我们一起找房东留下的钥匙。</p>
<p>我所住的Airbnb是提供有线电视的，总共有700个频道（另外还有100个电台），其中收费频道大约是400个，剩下300个频道里只有一个中文频道—凤凰卫视。但是我个人更感兴趣的是那些印度频道、巴基斯坦频道和穆斯林频道，因为第一次能接触到他们的电视节目觉得很新奇好玩。为什么能收到这些频道？我猜可能是英国政府为了照顾当地的印度人和中东人，让他们可以在千里之外看到自己家乡的节目。每天早上，穆斯林频道每天早上都有念经（古兰经？）的环节，屏幕上一盏烛火，背景是巨大的清真寺，然后飘过一行又一行的阿拉伯字，一个浑厚的男声在咿咿呀呀的念经…这个节目基本陪我度过了两个早上煮方便面的时间。<br><img data-src="/images/apartment.jpg" alt="akb48" title="我们住的公寓，空间很大景色不错！"></p>
<p>伦敦街头的卖艺人随处可见，多数是自弹自唱的音乐艺人，也有杂技艺人和幽默剧艺人。英国人很喜欢唱歌，尤其是喝酒的时候大家一起大合唱更是壮观。而每到周五周六的晚上，酒吧一条街人满为患，甚至有人在店外喝酒，同时马路上也会有临时的简易厕所供男士们方便。</p>
<p>英国不愧是腐国，本身洋人就比较高大，所以“彩虹小哥”在马路上就更有视觉冲击力，部分街道甚至会出售男同用品，而他们对这种现象也是司空见惯、习以为常。</p>
<p>英国男人最有名的，除了腐之外，那就是秃了。上到威廉、哈里两个王子下到地铁里的普通上班族，秃头的概率的确很高，我经常感叹那些白人们有着帅气的面庞和隐隐看到头皮的后脑勺。为什么英国是秃头的重灾区？有人说是因为英国的水质硬，所以毛孔不通畅，也有人说英国雨水多，而且当地人还不喜撑伞，频繁的冷水对头发也有伤害。但是我看到的几个印度和中东的店员却都不秃，那么英国白人秃头的真实原因不得而知，不过秃头的杀伤力的确对他们造成了很大的伤害，所以他们戴帽子的人不在少数。</p>
<p>说完了男人说女人，英国的女人不秃，头发茂密的很，而且他们还特别抗冷！零度左右的天气，我看到很多穿着破洞牛仔裤的女性，甚至还有穿短袖的，在大街上走来走去。至于什么“发热御寒丝袜”在英国都没得卖。这种抗冷属性应该算是他们的种族天赋。</p>
<p>顺便插一句题外话，伦敦街头的抗议行动我们看到了三处，第一处是大英博物馆门口有法轮功的静坐和散发传单；第二处是在摄政街的动物保护组织抗议“加拿大鹅”店残杀郊狼扒毛；第三处也是摄政街，有5个左右的伊斯兰人手持经书控诉美国政府。这里面让我印象比较深的是动物保护组织，他们堵着加拿大鹅的门店喊口号，但是抗议归抗议，并没有进去打砸，而且店里依旧有客人在购买，可以说除了闹一点之外都比较和谐。</p>
<h2 id="伦敦的吃"><a href="#伦敦的吃" class="headerlink" title="伦敦的吃"></a>伦敦的吃</h2><p>有人说伦敦的美食很少，因为英国人本身对于吃的想象力特别匮乏；也有人说伦敦的美食很多，因为它是地球上米其林餐厅最多的城市。其实这两个对立的说法都对，英国人自身对吃仅仅定义为“填饱肚子的行为”而已，所以纵然电视里的美食节目不少，但是英国本土并没有什么饮食文化而言。如果肯舍得钱下馆子的话，那么伦敦还是有很多上佳口味的饭店供人选择。</p>
<p>我在这几天在伦敦吃到了如下几种菜：牛排（网红店Flat Iron Steak和Bill’s）、龙虾（网红店Burger &amp; Lobster）、披萨（网红店Pane Cunzato）、中国菜（唐人街的金龙轩）、麦当劳、烤鸡（网红店Nando’s）、日料（超赞而且实惠的Eat Tokyo），反倒是鼎鼎大名的“炸鱼薯条”却只是看而没有吃。总体上来说，原味的欧洲菜跟亚洲口味的确有很大的不同，首先是每餐必有薯条（我个人喜欢薯条搭配蛋黄酱吃），其次各种酱汁种类很多，味道七七八八，再其次就是肉蛮好吃的，但是水果基本没有。当然我去的店相对平民，如果去米其林餐厅肯定会吃到高档的菜肴。</p>
<p>上面说了那么多饭里，我个人最喜欢的还是中国菜—-金龙轩的福建炒饭，蟹肉芡勾的很棒，而且分量十足！<br><img data-src="/images/bills.jpg" alt="akb48" title="在温莎车站bill&#39;s吃的牛排，分量很多肉质不错"></p>
<h2 id="伦敦的买"><a href="#伦敦的买" class="headerlink" title="伦敦的买"></a>伦敦的买</h2><p>从行程规划里可以看到，我跟我媳妇准备了大量买买买的时间，因为圣诞节之后，就是会持续十天左右的Boxing Day。在此期间，几乎所有的商品都会让利，新品可能折扣少一点，部分老款甚至会打五折乃至更低！</p>
<p>作为二次元的拥趸，Forbidden Planet是绝对不能错过的书店！它在大英博物馆附近，一楼是各种周边，地下室是书籍出售。在里面我买了两个蝙蝠侠周边。那里的日漫也很多，《暗杀教室》两本只需要三磅，划算的很！<br><img data-src="/images/ForbiddenPlanet1.jpg" alt="akb48" title="精美的手办，门口橱窗里甚至还有海王1：1的叉子"></p>
<p>若要正经购物的话，伦敦也有很多去处。我跟媳妇先去了考文特花园，那里能买到很多好玩又精美的小玩意，比如银制的勺子和挂链，甚至还有潘海立根。摄政街跟哈罗德百货更是购物的火拼集中地，附近的商铺应该有100家，消费群体主要是中东人和亚洲人。白人和黑人更多的是聚集在像JD那种体育用品专卖店买鞋。至于为什么高端店被外国人包围，我想因为英国本身福利比较给力，所以土著平民都没有攒钱的意识，过着“今朝有酒今朝醉”的月光生活，自然也不会拿出那么多钱来买奢侈品。</p>
<p>大名鼎鼎比斯特小镇我俩没有去，因为那个地方在这种打折季肯定人满为患，事实也印证了我俩的预测。</p>
<p>不过英国的退税跟日本的不同，日本是在商家处直接退税，而英国是要在指定地点退税或者机场退税。机场退税有两条路，一条是去直接退英镑，但是排队非常夸张，大约要排4小时左右；还有一条就是直接退本国的货币，需要收取不俗的手续费而且兑换的汇率也很低，所以英国的退税政策其实并不友好。</p>
<h2 id="伦敦文化"><a href="#伦敦文化" class="headerlink" title="伦敦文化"></a>伦敦文化</h2><p>几天接触下来，只管感觉到伦敦是一个“传统与现代”并存的城市。说它现代，就是各种高大上的各路品牌、宝马奔驰在马路上驰骋、超市基本都实现了无人结账而且几乎各处都配有免费wifi（最良心的是注册wifi只填写电子邮件，而根本不需要填写手机号，这一点跟国内众多注册很不一样！）；说它传统呢，就是普通居民建筑还保留传统英式风格，大大小小的教堂无论年代目前都在服务，特殊地方还有骑马巡警。景点里那些百年以上的软文化都妥善保存，景点外伦敦人喜欢看戏剧的习惯流传至今。这种“新与旧”和谐共存最明显的体现就是在温莎城堡，女王家虽然面积远不如故宫那么大，但是论奢华一点不虚我们。<br><img data-src="/images/ximinsi.jpg" alt="akb48" title="西敏寺著名的十牧师雕像，最右边是苗族牧师王志明"><br><img data-src="/images/yvonne.jpg" alt="akb48" title="Yvonne Fletcher警察的墓碑，她殉职之后的一系列事件导致英国与比利亚断交"></p>
<p>不过，伦敦公共设施维护的普遍都不咋地，最让人吐槽的就是以下几点：垃圾箱很少导致街边烟头满地，非居民区垃圾袋随处可见，喝剩的纸杯也随意放在路边橱窗上，地铁没信号不说而且椅套看上去都旧旧的。据我媳妇在伦敦的朋友说，伦敦居民区的环卫工人每周三才会出来清理一次街道的垃圾袋，所以平时都是把垃圾袋放在家里，到了周三才一并拿出去扔掉，如果平时乱扔会被罚很重的款。</p>
<h2 id="伦敦看球"><a href="#伦敦看球" class="headerlink" title="伦敦看球"></a>伦敦看球</h2><p>到了伦敦怎能不现场观看英超比赛？伦敦是著名的“足球之城”，当地就有6支英超联赛球队（切尔西、热刺、阿森纳、西汉姆、富勒姆、水晶宫），但是圣诞节期间主场作战的只有热刺一家，于是我在StubHub上买了两张热刺VS伯恩茅斯的门票。不过我真的不推荐各位去StubHub上买票，手续费高不说，而且出票速度奇慢，我是11月30日下单，12月21号才通知可以下载球票电子档，中途还不能退票。主要是StubHub毕竟是卖2手票的，只有有人卖才会出单通知你，所以还是在官网买票是最省心最效率的，但是要提前注册会员。<br><img data-src="/images/qiupiao.png" alt="akb48" title="原来英超的球票是长这个样子的"></p>
<p>到了温布利下车一出门就能看到温布利球场，路上都是卖热刺队围巾的小贩，5磅一条。到了球场，首先对背包大小有要求，包不能大于4A纸的面积，否则就是要花10磅寄存。进场的时候要求安检并且把饮料瓶盖扔掉，在机器上扫描电子票的二维码入场，不检查实名制。</p>
<p>进了球场就是要狂躁起来，那场比赛热刺队也很给力，5：0痛击伯恩茅斯，孙球王梅开二度，我身后手持太极旗的韩国妹子们兴奋不已。热刺的球迷很热情，每个球员有了上佳表现，球迷都会唱歌，从穆萨登贝莱唱到哈里凯恩。出场之后，意犹未尽的我还跟温布利球场的雕像们一一合影。如果将来有一次能去巴塞罗那，肯定也会去诺坎普朝圣一下。<br><img data-src="/images/bobby.jpg" alt="akb48" title="波比摩尔的雕像"></p>
<h2 id="其他轶事"><a href="#其他轶事" class="headerlink" title="其他轶事"></a>其他轶事</h2><p>倒时差的小秘诀：静下心来或者把自己弄疲惫，该睡觉的时候一定要正常睡觉，哪怕只有几个小时。</p>
<p>都说英国不准许肉类入境，但是我媳妇带的鸭脖子、鸡爪子在行李箱里就大摇大摆的登陆了。</p>
<p>伦敦地铁没有安检，Paddington火车车厢里也压根没有检票。</p>
<p>伦敦的热水非常方便，而且他们的自来水是可以直接饮用的，如果不能饮用的话会有提示。</p>
<p>伦敦普通居民区的门锁完全不是国内常见的“防盗门+防盗锁”，而是很老式的“木门+插钥匙锁”，所以那些特工电影里一脚破门的镜头果然不是在骗人…</p>
<p>伦敦市区电子屏幕上铺天盖地的是“抖音”海外版app的广告，而华为的广告只有商场里才有，但是我并没有发现卖华为手机的地方…</p>
<p>这八天里唯一看到的中国公众人物是杨幂，在杜莎夫人蜡像馆里(其实还有达赖喇嘛的蜡像，但是他毕竟自建流亡政府，就不能算中国人了)。她周围很冷清，跟布拉德皮特、约翰尼德普、乔治克鲁尼等人气大户完全没法比。</p>
<p>伦敦黑人很多，我看见不少的黑人喜欢把裤裆穿的很低，然后漏出来半截内裤甚至是屁股（囧），不知道这是不是他们的什么衣着文化…</p>
<h2 id="其他小tips"><a href="#其他小tips" class="headerlink" title="其他小tips"></a>其他小tips</h2><ol>
<li>大英博物馆的语音向导是有数的，请提早去拿；</li>
<li>杜莎夫人蜡像馆和伦敦眼可以买连票，价钱优惠而且都有快速通行权限；</li>
<li>圣诞期间碎片大厦晚上10点才关门，所以如果看不到日落那就干脆不用急了；</li>
<li>London Pass卡的游船晚上5点05就停业了；</li>
<li>London Pass卡支持两种大巴车，我个人推荐Golden Tours，虽然它的APP可能做得不太好，但是营业时间长，至少晚上9点我还看到车在马路上跑，而BIG BUS六点多就休息了；</li>
<li>准备的APP：航旅纵横+CityMapper+TripAdvisor；</li>
<li>一定要带伞！虽然伦敦各个小店都有卖伞，但是基本10磅一把，价格还是蛮贵的；</li>
<li>自带拖鞋、牙刷、毛巾等用品，还有插销转换头；</li>
<li>伦敦行李寄存地点不多，而且价格不菲，8磅一个箱子，当然啦，土豪可以无视此条；</li>
</ol>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>旅游</tag>
        <tag>伦敦</tag>
      </tags>
  </entry>
  <entry>
    <title>苹果手机无信用卡注册区美国apple store的办法</title>
    <url>/2018/05/30/%E8%8B%B9%E6%9E%9C%E6%89%8B%E6%9C%BA%E6%97%A0%E4%BF%A1%E7%94%A8%E5%8D%A1%E6%B3%A8%E5%86%8C%E5%8C%BA%E7%BE%8E%E5%9B%BDapple-store%E7%9A%84%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>这次去霓虹国在心斋桥Apple体验店买了一个256G的iphone X，由于政府政策的原因，中国区的apple store有很多应用是没有的，于是乎我就打算注册一个美国版的账号，从而登录美国版的apple store去下载那些“你懂得”的app。</p>
<p>首先先登录<code>https://www.apple.com/</code> ，在网页最下面先确定国家是<code>United States</code>，然后点击<code>Manage Your Apple ID</code>，如图：<br><img data-src="/images/apple1.png" alt="paradin"></p>
<p>在<code>https://appleid.apple.com/#!&amp;page=signin</code>页面里，点击<code>Create your Apple ID</code>建立一个新的apple账号，名称正常写，国家还是<code>United States</code>不要动，生日如实填写，但是如果是未成年人的话，有些成人的app是不可以被下载的。然后就是写好自己的登陆问题，这个问题已经要记住，每次登陆都要输入，忘记的话就麻烦了。注册账号这里其他部分我就不多说了。</p>
<p>账号注册完毕之后，就直接在苹果网站上登录，登录之后，就会看到账号的详细信息，在<code>Payment &amp; Shipping</code>的地方点击<code>Add Payment Method… </code>，如图：<br><img data-src="/images/apple2.png" alt="paradin"></p>
<p>这里有一个<code>PAYMENT METHOD</code>的地方，要填写<code>none</code>，如果你用apple手机上登录这个账号的话，这里是不能选none的，无论是<code>Dr.</code>还是<code>Mr.</code>都没有none这个选项，所以说一定要在网页登录账号。然后就是需要你填写一些用户地址、邮编等信息，由于是账号注册时候选择的是美国，那么也需要填写美国的地址，可以在<code>http://www.haoweichi.com/Index/random</code>里生成一个身份信息填写。如图：<br><img data-src="/images/apple3.png" alt="paradin"></p>
<p>下面那个<code>SHIPPING ADDRESS</code>就是账单邮寄的地址，想填就填，不想填就放那。填写好了之后点击save，但是目前这个账号还是不能通过的，如果你在apple手机登录了这个账号然后登录apple store的话，会有一个提示：<code>该账号没有被使用过，请填写细节</code>。</p>
<p>这里如果你还手机上操作填写细节，发现你刚刚在电脑上填写的地址和邮编已经同步到手机的账号了，但是支付卡那一栏还是没有<code>none</code>，也就是说依旧要一个信用卡。此时请在电脑上下载itunes，然后在电脑的itunes里登录这个美国区账号，由于电脑itunes里的支付渠道依旧可以选择none，所以我们可以在这里绕一个弯，使用itunes这个渠道来完成这个美国区账号的彻底注册。</p>
<p>在itunes把整个账号完整过程都注册完毕之后，再登录到手机端，就可以在美国的apple store里尽情的下载app了！<br><img data-src="/images/apple4.jpg" alt="paradin"></p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>apple</tag>
      </tags>
  </entry>
  <entry>
    <title>获取网站title的脚本</title>
    <url>/2018/07/31/%E8%8E%B7%E5%8F%96%E7%BD%91%E7%AB%99title%E7%9A%84%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="脚本在此"><a href="#脚本在此" class="headerlink" title="脚本在此"></a>脚本在此</h2><p>公司的商城需要添加一个脚本，这个脚本就是观察首页页面是否正常，虽然已经配置了zabbix监控网站是否200，但是有一些特殊的情况，比如网页可以打开但是页面是“file not found”，类似这样就需要被运维第一时间监控到然后通知开发。</p>
<p>原本我打算直接爬取整个首页然后与服务器里的<code>index.html</code>对比一下，如果不符合就报警，但是跟前端同事说了这个思路之后，前端说服务器上是没有<code>index.html</code>的，因为这个<code>index.html</code>是结合其他的php拼接的。前端说“只要能检测title正常就OK，一般来说title能获取到就证明系统是OK的，如果titleOK但是html内容获取不到就是前段代码的问题，跟系统无关”。于是我就写了这么一个爬虫脚本来获取网站title，如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/usr/</span>bin/env python</span><br><span class="line">#coding=utf-<span class="number">8</span></span><br><span class="line">#这个脚本的用途是用来爬取商城首页title，然后判断是否正常</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests,sys</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> <span class="title class_">BeautifulSoup</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">reload</span>(sys)</span><br><span class="line">sys.<span class="title function_">setdefaultencoding</span>(<span class="string">&#x27;utf-8&#x27;</span>)		#不然就会<span class="title class_">UnicodeEncodeError</span>: <span class="string">&#x27;ascii&#x27;</span> codec can<span class="string">&#x27;t encode characters in position 0-4: ordinal not in range(128)</span></span><br><span class="line"><span class="string">r = requests.get(&#x27;</span><span class="attr">https</span>:<span class="comment">//www.lechange.com&#x27;)	#这里输入要爬的网站域名</span></span><br><span class="line">r.<span class="property">encoding</span> = requests.<span class="property">utils</span>.<span class="title function_">get_encodings_from_content</span>(r.<span class="property">content</span>)[<span class="number">0</span>]</span><br><span class="line">soup = <span class="title class_">BeautifulSoup</span>(r.<span class="property">text</span>,<span class="string">&#x27;lxml&#x27;</span>)			#这一步需要事前pip install lxml</span><br><span class="line">print soup.<span class="property">title</span>.<span class="property">string</span></span><br></pre></td></tr></table></figure></p>
<p>说一下，如果在<code>from bs4 import BeautifulSoup</code>爆出<code>ImportError: No module named &#39;bs4&#39;</code>是因为安装的库装错了，应该是<code>pip install beautifulsoup4</code>而不是<code>pip install beautifulsoup</code>。启动脚本效果如下：<br><img data-src="/images/spider1.png" alt="paradin"></p>
<h2 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h2><p>上面那个脚本里的<code>soup.title.string</code>的类型是<code>bs4.element.NavigableString</code>，如果不用print那么它的形式是<code>unicode</code>的，如图：<br><img data-src="/images/spider2.png" alt="paradin"></p>
<p>这种现象并不新鲜，比如<code>list</code>在python2里一直都不是正常输出中文的，如图：<br><img data-src="/images/spider3.png" alt="paradin"></p>
<p>可见只有<code>for in</code>的时候才会正常编码，那么这样的情况怎么办？</p>
<p>最简单的方法，改用python3。不过上面那个脚本是可以直接把中文放到<code>soup.title.string</code>进行判断的。</p>
<h2 id="安装python-3-6-4"><a href="#安装python-3-6-4" class="headerlink" title="安装python 3.6.4"></a>安装python 3.6.4</h2><p>首先要先安装相关依赖包<code>yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make</code>，其中<code>readline-devel</code>这个很重要，他是管方向键的，如果python运行的时候方向键不好使，那么就要<code>yum install readline-devel</code>安装，安装完毕后重新<code>configure</code>和<code>make</code>。</p>
<p>然后过程如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yum -y install epel-release	#运行这个命令添加epel扩展源</span><br><span class="line">#安装pip</span><br><span class="line">yum install python-pip</span><br><span class="line">pip install wget</span><br><span class="line">wget <span class="attr">https</span>:<span class="comment">//www.python.org/ftp/python/3.6.4/Python-3.6.4.tar.xz</span></span><br><span class="line">#解压</span><br><span class="line">xz -d <span class="title class_">Python</span>-<span class="number">3.6</span><span class="number">.4</span>.<span class="property">tar</span>.<span class="property">xz</span></span><br><span class="line">tar -xf <span class="title class_">Python</span>-<span class="number">3.6</span><span class="number">.4</span>.<span class="property">tar</span></span><br><span class="line">#进入解压后的目录，依次执行下面命令进行手动编译</span><br><span class="line">./configure prefix=<span class="regexp">/usr/</span>local/python3</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">#将原来的链接备份</span><br><span class="line">mv /usr/bin/python /usr/bin/python.<span class="property">bak</span></span><br><span class="line">#添加python3的软链接</span><br><span class="line">ln -s /usr/local/python3/bin/python3<span class="number">.6</span> /usr/bin/python</span><br><span class="line">#测试是否安装成功了</span><br><span class="line">python -V</span><br></pre></td></tr></table></figure></p>
<p>更改yum配置，因为其要用到python2才能执行，否则会导致yum不能正常使用，需要分别修改<code>/usr/bin/yum</code>和<code>/usr/libexec/urlgrabber-ext-down</code>这两个文件，把他们的<code>#! /usr/bin/python</code>修改为<code>#! /usr/bin/python2</code>。</p>
<p>然后还要给python3的pip3做一个软连接: <code>ln -s  /usr/local/python3/bin/pip3 /usr/bin/pip3</code>。</p>
<p>注意！如果你用了python3那么上面那个脚本就会有很大的变动。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html">https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html</a><br><a href="http://scrapy-chs.readthedocs.io/zh_CN/1.0/intro/tutorial.html">http://scrapy-chs.readthedocs.io/zh_CN/1.0/intro/tutorial.html</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>获取阿里云RDS磁盘容量的脚本</title>
    <url>/2019/04/28/%E8%8E%B7%E5%8F%96%E9%98%BF%E9%87%8C%E4%BA%91RDS%E7%A3%81%E7%9B%98%E5%AE%B9%E9%87%8F%E7%9A%84%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="需求以及脚本正文"><a href="#需求以及脚本正文" class="headerlink" title="需求以及脚本正文"></a>需求以及脚本正文</h2><p>开发人员提出一个需求，想要每天从企业微信号里获取一下阿里云几个RDS的今天和昨天的磁盘容量，对比一下结果来判断删除模块是否正常运行，由于阿里云的相关API不支持查询历史数据，所以我们要建立一个数据表，把磁盘容量按照日期保存在数据表里，这个table的结构如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#以下是创建databases的语句</span></span><br><span class="line">CREATE TABLE IF NOT EXISTS `onlinerds`(</span><br><span class="line">`<span class="built_in">id</span>` INT UNSIGNED AUTO_INCREMENT,</span><br><span class="line">`rds_id` VARCHAR(<span class="number">100</span>) NOT NULL,		<span class="comment">#记录数据库ID号</span></span><br><span class="line">`rds_name` VARCHAR(<span class="number">100</span>) NOT NULL,	<span class="comment">#记录数据库名称</span></span><br><span class="line">`rds_diskused` VARCHAR(<span class="number">40</span>) NOT NULL,	<span class="comment">#记录使用磁盘容量</span></span><br><span class="line">`date` VARCHAR(<span class="number">40</span>) NOT NULL,	<span class="comment">#记录日期</span></span><br><span class="line">PRIMARY KEY ( `<span class="built_in">id</span>` )</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure></p>
<p>有了这个table，于是就写了一个py3的脚本，内容如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="comment">#这个py3脚本是用来获取阿里云线上数据库的磁盘容量</span></span><br><span class="line"><span class="comment">#pip install pymysql &amp; pip install aliyun-python-sdk-rds &amp; pip install aliyun-python-sdk-core</span></span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.client <span class="keyword">import</span> AcsClient</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.acs_exception.exceptions <span class="keyword">import</span> ClientException</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.acs_exception.exceptions <span class="keyword">import</span> ServerException</span><br><span class="line"><span class="keyword">from</span> aliyunsdkrds.request.v20140815.DescribeDBInstanceAttributeRequest <span class="keyword">import</span> DescribeDBInstanceAttributeRequest</span><br><span class="line"><span class="keyword">import</span> math,pymysql,urllib.request,json,datetime</span><br><span class="line"></span><br><span class="line"><span class="comment">#字典确定kv对应关系，这样可以取到服务器姓名</span></span><br><span class="line"><span class="built_in">dict</span> = &#123;<span class="string">&#x27;第一台RDSid&#x27;</span>: <span class="string">&quot;对应数据库名称&quot;</span>,<span class="string">&#x27;第2台RDSid&#x27;</span>: <span class="string">&quot;对应数据库名称&quot;</span>，<span class="string">&#x27;第3台RDSid&#x27;</span>: <span class="string">&quot;对应数据库名称&quot;</span>，<span class="string">&#x27;4台RDSid&#x27;</span>: <span class="string">&quot;对应数据库名称&quot;</span>，<span class="string">&#x27;第5台RDSid&#x27;</span>: <span class="string">&quot;对应数据库名称&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">usedcap=[]	<span class="comment">#今天磁盘量</span></span><br><span class="line">usedcap_yes=[]	<span class="comment">#昨天磁盘量</span></span><br><span class="line">pro = []    <span class="comment">#比例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建获取磁盘容量的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">getRDS</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,ak,sk,domain</span>):</span><br><span class="line">        <span class="variable language_">self</span>.ak = ak</span><br><span class="line">        <span class="variable language_">self</span>.sk = sk</span><br><span class="line">        <span class="variable language_">self</span>.domain = domain</span><br><span class="line">        client = AcsClient(ak,sk,domain)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">#自动换算单位</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">convertBytes</span>(<span class="params">self,<span class="built_in">bytes</span>,lst=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> lst <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            lst = [<span class="string">&#x27;Bytes&#x27;</span>, <span class="string">&#x27;KB&#x27;</span>, <span class="string">&#x27;MB&#x27;</span>, <span class="string">&#x27;GB&#x27;</span>]  <span class="comment"># 这里是单位，如果需要TB，PB，在后面添加进去即可</span></span><br><span class="line">        i = <span class="built_in">int</span>(math.floor(  <span class="comment"># 舍弃小数点，取小</span></span><br><span class="line">            math.log(<span class="built_in">bytes</span>, <span class="number">1024</span>)  <span class="comment"># 求对数(对数：若 a**b = N 则 b 叫做以 a 为底 N 的对数)</span></span><br><span class="line">        ))</span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(lst):</span><br><span class="line">            i = <span class="built_in">len</span>(lst) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&#x27;%.2f&#x27;</span> + <span class="string">&quot; &quot;</span> + lst[i]) % (<span class="built_in">bytes</span> / math.<span class="built_in">pow</span>(<span class="number">1024</span>, i))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">DiskUsed</span>(<span class="params">self,rdsid</span>):</span><br><span class="line">        lst = [<span class="string">&#x27;Bytes&#x27;</span>, <span class="string">&#x27;KB&#x27;</span>, <span class="string">&#x27;MB&#x27;</span>, <span class="string">&#x27;GB&#x27;</span>]</span><br><span class="line">        client = AcsClient(<span class="variable language_">self</span>.ak,<span class="variable language_">self</span>.sk,<span class="variable language_">self</span>.domain)</span><br><span class="line">        request = DescribeDBInstanceAttributeRequest()</span><br><span class="line">        request.set_accept_format(<span class="string">&#x27;json&#x27;</span>)</span><br><span class="line">        request.set_DBInstanceId(rdsid)</span><br><span class="line">        response = client.do_action_with_exception(request)</span><br><span class="line">        result = <span class="built_in">str</span>(response, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        data = json.loads(result)</span><br><span class="line">        DiskUsed = ((data)[<span class="string">&#x27;Items&#x27;</span>][<span class="string">&#x27;DBInstanceAttribute&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;DBInstanceDiskUsed&#x27;</span>])    <span class="comment">#获取当前使用磁盘</span></span><br><span class="line">        DiskTotal = ((data)[<span class="string">&#x27;Items&#x27;</span>][<span class="string">&#x27;DBInstanceAttribute&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;DBInstanceStorage&#x27;</span>])    <span class="comment">#获取总磁盘</span></span><br><span class="line">        DiskUsed_GB = getRDS.convertBytes(<span class="variable language_">self</span>,DiskUsed,lst=lst)	<span class="comment">#使用“自动换算单位”的函数</span></span><br><span class="line">        DiskUsed_num = <span class="built_in">float</span>(getRDS.convertBytes(<span class="variable language_">self</span>,DiskUsed,lst=lst).split(<span class="string">&#x27; &#x27;</span>, <span class="number">1</span>)[<span class="number">0</span>])    <span class="comment">#提取纯数字</span></span><br><span class="line">        Proportion = <span class="string">&quot;%.2f%%&quot;</span> % ((DiskUsed_num / DiskTotal) * <span class="number">100</span>)      <span class="comment">#转化成百分比</span></span><br><span class="line">        <span class="keyword">return</span> DiskUsed_GB,Proportion	<span class="comment">#返回两个值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取昨天的日期</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getYesterday</span>():</span><br><span class="line">    today = datetime.date.today()</span><br><span class="line">    oneday = datetime.timedelta(days=<span class="number">1</span>)</span><br><span class="line">    yesterday = today-oneday</span><br><span class="line">    <span class="keyword">return</span> yesterday</span><br><span class="line"></span><br><span class="line"><span class="comment">#MYSQL录入</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mysql</span>(<span class="params">i,usedcapacity</span>):</span><br><span class="line">    db = pymysql.connect(<span class="string">&quot;数据库地址&quot;</span>, <span class="string">&quot;数据库用户&quot;</span>, <span class="string">&quot;密码&quot;</span>, <span class="string">&quot;databases&quot;</span>,charset=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    sql = <span class="string">&quot;INSERT INTO onlinerds (rds_id,rds_name,rds_diskused,date) VALUES (&#x27;%s&#x27;,&#x27;%s&#x27;,&#x27;%s&#x27;,now())&quot;</span> % (i,<span class="built_in">dict</span>[i],usedcapacity)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        cursor.execute(sql)        <span class="comment"># 执行sql语句</span></span><br><span class="line">        db.commit()         <span class="comment"># 执行sql语句</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        db.rollback()           <span class="comment"># 发生错误时回滚</span></span><br><span class="line">    db.close()  <span class="comment">#关闭数据库连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取昨天的数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">yes_mysql</span>():</span><br><span class="line">    db = pymysql.connect(<span class="string">&quot;数据库地址&quot;</span>, <span class="string">&quot;数据库用户&quot;</span>, <span class="string">&quot;密码&quot;</span>, <span class="string">&quot;databases&quot;</span>,charset=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    yes_sql = <span class="string">&quot;select rds_diskused from onlinerds where date like &#x27;%s&quot;</span> % (getYesterday()) + <span class="string">&quot; 20:%&#x27;;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        cursor.execute(yes_sql)</span><br><span class="line">        results = cursor.fetchall()</span><br><span class="line">        <span class="keyword">for</span> GB <span class="keyword">in</span> results:</span><br><span class="line">            aaa = GB[<span class="number">0</span>] 	<span class="comment">#增加一个aaa变量来调整格式</span></span><br><span class="line">            usedcap_yes.append(aaa)		<span class="comment">#获取的数据添加到列表里</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error: unable to fecth data&quot;</span>)</span><br><span class="line">    db.close()  <span class="comment">#关闭数据库连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将类实例化</span></span><br><span class="line">gethzRDS = getRDS(<span class="string">&quot;杭州区ak&quot;</span>,<span class="string">&quot;杭州区sk&quot;</span>,<span class="string">&quot;cn-hangzhou&quot;</span>)</span><br><span class="line">getszRDS = getRDS(<span class="string">&quot;深圳区ak&quot;</span>,<span class="string">&quot;深圳区sk&quot;</span>,<span class="string">&quot;cn-shenzhen&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取企业微信token，用来发送微信企业号</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_token</span>(<span class="params">url, corpid, corpsecret</span>):</span><br><span class="line">    token_url = <span class="string">&#x27;%s/cgi-bin/gettoken?corpid=%s&amp;corpsecret=%s&#x27;</span> % (url, corpid, corpsecret)</span><br><span class="line">    token = json.loads(urllib.request.urlopen(token_url).read().decode())[<span class="string">&#x27;access_token&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> token</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建告警信息json，用来发送微信企业号</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">messages</span>(<span class="params">msg</span>):</span><br><span class="line">    values = &#123;</span><br><span class="line">        <span class="string">&quot;touser&quot;</span>: <span class="string">&#x27;@all&#x27;</span>,</span><br><span class="line">        <span class="string">&quot;msgtype&quot;</span>: <span class="string">&#x27;text&#x27;</span>,</span><br><span class="line">        <span class="string">&quot;agentid&quot;</span>: 微信企业号应用号码,</span><br><span class="line">        <span class="string">&quot;text&quot;</span>: &#123;<span class="string">&#x27;content&#x27;</span>: msg&#125;,</span><br><span class="line">        <span class="string">&quot;safe&quot;</span>: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    msges=(<span class="built_in">bytes</span>(json.dumps(values), <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> msges</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送告警信息，用来发送微信企业号</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_message</span>(<span class="params">url, token, data</span>):</span><br><span class="line">    send_url = <span class="string">&#x27;%s/cgi-bin/message/send?access_token=%s&#x27;</span> % (url, token)</span><br><span class="line">    respone = urllib.request.urlopen(urllib.request.Request(url=send_url, data=data)).read()</span><br><span class="line">    x = json.loads(respone.decode())[<span class="string">&#x27;errcode&#x27;</span>]</span><br><span class="line">    <span class="comment"># print(x)</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Success!&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Failed&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">list</span> = [<span class="string">&#x27;第一台RDSid&#x27;</span>,<span class="string">&#x27;第2台RDSid&#x27;</span>,<span class="string">&#x27;第3台RDSid&#x27;</span>,<span class="string">&#x27;第4台RDSid&#x27;</span>,<span class="string">&#x27;第5台RDSid&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">        mysql(i,gethzRDS.DiskUsed(i))</span><br><span class="line">		x,y = gethzRDS.DiskUsed(i)  <span class="comment">#函数return多个值，就这样拆开，一一添加到list里</span></span><br><span class="line">       	usedcap.append(x)	<span class="comment">#添加到列表</span></span><br><span class="line">       	pro.append(y)		<span class="comment">#添加到列表</span></span><br><span class="line">        <span class="built_in">print</span> (i+<span class="string">&quot;  OKok!&quot;</span>)	<span class="comment">#证明已经录入到数据库里了</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span> = [<span class="string">&#x27;第一台RDSid&#x27;</span>,<span class="string">&#x27;第2台RDSid&#x27;</span>,<span class="string">&#x27;第3台RDSid&#x27;</span>,<span class="string">&#x27;第4台RDSid&#x27;</span>,<span class="string">&#x27;第5台RDSid&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">        mysql(i,getszRDS.DiskUsed(i))</span><br><span class="line">        x, y = getszRDS.DiskUsed(i)</span><br><span class="line">       	usedcap.append(x)</span><br><span class="line">       	pro.append(y)</span><br><span class="line">        <span class="built_in">print</span> (i+<span class="string">&quot;  OKok!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    yes_mysql()</span><br><span class="line">    <span class="built_in">print</span>(usedcap)</span><br><span class="line">    <span class="built_in">print</span>(usedcap_yes)</span><br><span class="line"></span><br><span class="line">    corpid = <span class="string">&#x27;微信企业号corpid&#x27;</span></span><br><span class="line">    corpsecret = <span class="string">&#x27;微信企业号应用的秘钥&#x27;</span></span><br><span class="line">    url = <span class="string">&#x27;https://qyapi.weixin.qq.com&#x27;</span></span><br><span class="line">    msg  = <span class="string">&#x27;&#x27;&#x27;【第一台数据库】此时的容量是%s，昨天的容量是%s，当前的比例是：%s；</span></span><br><span class="line"><span class="string">    【第2台数据库】此时的容量是%s，昨天的容量是%s，当前的比例是：%s；</span></span><br><span class="line"><span class="string">    【第3台数据库】此时的容量是%s，昨天的容量是%s，当前的比例是：%s；</span></span><br><span class="line"><span class="string">    【第4台数据库】此时此时的容量是%s，昨天的容量是%s，当前的比例是：%s；</span></span><br><span class="line"><span class="string">    【第5台数据库】此时的容量是%s，昨天的容量是%s，当前的比例是：%s；</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span> % (usedcap[<span class="number">0</span>],usedcap_yes[<span class="number">0</span>],pro[<span class="number">0</span>],usedcap[<span class="number">1</span>],usedcap_yes[<span class="number">1</span>],pro[<span class="number">1</span>],usedcap[<span class="number">2</span>],usedcap_yes[<span class="number">2</span>],pro[<span class="number">2</span>],usedcap[<span class="number">3</span>],usedcap_yes[<span class="number">3</span>],pro[<span class="number">3</span>],usedcap[<span class="number">4</span>],usedcap_yes[<span class="number">4</span>],pro[<span class="number">4</span>],usedcap[<span class="number">5</span>],usedcap_yes[<span class="number">5</span>],pro[<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">#发送微信告警</span></span><br><span class="line">    test_token = get_token(url, corpid, corpsecret)</span><br><span class="line">    msg_data = messages(msg)</span><br><span class="line">	send_message(url, test_token, msg_data)</span><br></pre></td></tr></table></figure></p>
<p>执行之后，效果如下：<br><img data-src="/images/getRDS.png" alt="akb48"></p>
<h2 id="小数和百分数的相互转换"><a href="#小数和百分数的相互转换" class="headerlink" title="小数和百分数的相互转换"></a>小数和百分数的相互转换</h2><p>百分比转换为小数的代码如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;20%&#x27;</span>  <span class="comment"># 默认要转换的百分比是字符串</span></span><br><span class="line">aa = <span class="built_in">float</span>(s.strip(<span class="string">&#x27;%&#x27;</span>)) <span class="comment"># 去掉s 字符串中的 %</span></span><br><span class="line">bb = aa/<span class="number">100.0</span>  <span class="comment">#运行环境是Python2.7   其中Python2.X  与 python 3X中的除法是有区别</span></span><br><span class="line"><span class="built_in">print</span> bb	<span class="comment"># 输出结果是 0.2</span></span><br></pre></td></tr></table></figure></p>
<p>小数转换为百分比的代码如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">0.3214323</span></span><br><span class="line">bb = <span class="string">&quot;%.2f%%&quot;</span> % (a * <span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span> bb	<span class="comment"># 输出结果是32.14%</span></span><br></pre></td></tr></table></figure></p>
<h2 id="如果函数返回了多个值"><a href="#如果函数返回了多个值" class="headerlink" title="如果函数返回了多个值"></a>如果函数返回了多个值</h2><p>如果函数一次性return了多个值，如何单独获取到这些值？其实这个函数返回的是一个元组。把元组解包，返回结果也可以赋值给单个变量，这时候这个变量值就是函数返回的那个元组本身了。如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">myfun</span>():</span><br><span class="line"><span class="meta">... </span><span class="keyword">return</span> <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, c = myfun()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<h2 id="智能转换存储单位"><a href="#智能转换存储单位" class="headerlink" title="智能转换存储单位"></a>智能转换存储单位</h2><p>智能转换<code>bytes</code>为<code>kb/mb/gb/tb/pb</code>的代码如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">convertBytes</span>(<span class="params"><span class="built_in">bytes</span>, lst=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> lst <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        lst=[<span class="string">&#x27;Bytes&#x27;</span>, <span class="string">&#x27;KB&#x27;</span>, <span class="string">&#x27;MB&#x27;</span>, <span class="string">&#x27;GB&#x27;</span>, <span class="string">&#x27;TB&#x27;</span>, <span class="string">&#x27;PB&#x27;</span>]</span><br><span class="line">    i = <span class="built_in">int</span>(math.floor( <span class="comment"># 舍弃小数点，取小</span></span><br><span class="line">             math.log(<span class="built_in">bytes</span>, <span class="number">1024</span>) <span class="comment"># 求对数(对数：若 a**b = N 则 b 叫做以 a 为底 N 的对数)</span></span><br><span class="line">            ))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(lst):</span><br><span class="line">        i = <span class="built_in">len</span>(lst) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="string">&#x27;%.2f&#x27;</span> + <span class="string">&quot; &quot;</span> + lst[i]) % (<span class="built_in">bytes</span>/math.<span class="built_in">pow</span>(<span class="number">1024</span>, i))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    lst = [<span class="string">&#x27;Bytes&#x27;</span>, <span class="string">&#x27;KB&#x27;</span>, <span class="string">&#x27;MB&#x27;</span>, <span class="string">&#x27;GB&#x27;</span>, <span class="string">&#x27;TB&#x27;</span>, <span class="string">&#x27;PB&#x27;</span>]</span><br><span class="line">    <span class="built_in">bytes</span> = <span class="built_in">input</span>(<span class="string">&#x27;Bytes: &#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span> convertBytes(<span class="built_in">bytes</span>, lst=lst)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p>
<p>但是要注意！<code>bytes</code>作为传入值不能为负数，所以如果是负数想要转换单位，先要用<code>abs</code>取绝对值再计算。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/xuchunlin/p/6305720.html">https://www.cnblogs.com/xuchunlin/p/6305720.html</a><br><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c07/p04_return_multiple_values_from_function.html">https://python3-cookbook.readthedocs.io/zh_CN/latest/c07/p04_return_multiple_values_from_function.html</a><br><a href="https://my.oschina.net/guoenzhou/blog/2989650">https://my.oschina.net/guoenzhou/blog/2989650</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title>装懂和真不懂</title>
    <url>/2022/09/01/%E8%A3%85%E6%87%82%E5%92%8C%E7%9C%9F%E4%B8%8D%E6%87%82/</url>
    <content><![CDATA[<p>财新网有一个女记者叫袁小珊，长得很漂亮。她采访过很多财经界的大佬：张维迎、陈志武、许小年等等。这几个大佬在采访里基本都在呼吁一个事儿—“经济的趋势就是小政府大市场”。</p>
<p>这两天读完了哈耶克先生的《通往奴役之路》和陆铭教授的《大国大城》这两本书，再加上许小年教授的一些访谈就更直白了。他们认为一个经济的本质，就是“尽可能最大限度的释放生产要素市场，然后借助人类追求富裕的本性和依靠市场这双看不见手，把生产力带动起来”。同时政府借助司法负责查缺补漏，将过程中出现非法的过程进行有效的取缔，而经济类的操作（比如生产效率高的企业吞并生产效率低的企业这样的优胜劣汰）就完全让市场去主导就行了。</p>
<p>而我个人从这几天的阅读里感受到的是这些内容：</p>
<ol>
<li><p>掌握了生产要素的人，就掌握了这个行业，这个行业将不会再有自由，至少没有了选择自由的权利。比如人口放开了流动，哪怕先不给户籍，但是依旧有大量的人从穷地方涌去富地方，这样就一定程度上的帮助了需要“消耗类劳动力”的市场，同时穷地方的过量生产力也得到了释放，效率更高，两个地方的整个生产力都获得了极大提升；</p>
</li>
<li><p>集体主义只能出现在特殊场合里，全民性质的集体主义是非人类的，因为它与人类许多的天性相悖，是少数人给绝大多数人做选择的体制。既然与天性相悖，那么无论手段是文是武都是非道德的。但是恰恰对于集体主义这种“宗教主义”的进化版本而言，它存在的前提就是需要一个高高在上的道德标准。拥有高高在上的道德标准，却使用非道德的手段，这是很讽刺的事情；</p>
</li>
<li><p>国际集体主义是一个二逼的行为，虽然现在经济是趋势全球化，但是不能强迫他国一定要如何如何。因为宗教国情语言等等要素，各国的实际情况很难“一刀切”或者通过数字量化。但是如果一个集体主义国家，难免内部民族主义旺盛，那么难免会将自身的“集体主义”推波到周边国家来发展“国际集体主义”，这样搞的下场只能是战争，就好比二战时候的日本；</p>
</li>
<li><p>计划是一个好东西，领导听了你的计划会觉得你这个人有统筹、有前瞻性、有条理。但是计划经济跟计划是两回事，不可混为一谈。计划做砸了只会影响一个项目，但是计划经济做砸了影响了一大批人。而且现在经济错综复杂，只做一块的计划是没用的，为了目标就要做越来越多方面的计划，最后整个国家就好像巨型的编好的程序，按下回车键就要按部就班的运行，一旦出现了问题，进行hot-fix可能就要牵扯到一大波人的福祉，引起社会动乱；</p>
</li>
<li><p>讲究GDP总量是发展初期的目标，这就叫“让一部分先富起来”。这个说法在后期对于发达地区是没太大意义的，比人均GDP、中位数收入才是王道。居民人均GDP高了，犯罪率就低了。“国富民穷”的情况，不是蛋糕大小不对，多半是蛋糕分配的不合理；</p>
</li>
<li><p>从经济学上来说，地理的生产优势、物流优势是客观存在的，生产方式肯定还是存在一个更优解。而且经济学的结果跟直观的结果就是会有天差地别的不同，所以经济学家往往语出惊人是很正常的。毕竟普通人不是领域的专家，不专业的人由于信息的不完备，更多是靠直觉生活，运气或许会降临到他们某个人，但是运气本身就是一个不靠谱的东西。不过也有一些经济学家是昧良心说话的，要甄别；</p>
</li>
<li><p>在社交APP里，模仿是致富的一条比较稳的办法，由于中国特殊的互联网环境，照搬照抄是屡见不鲜的，抄完了靠法律漏洞先攒一波用户量，然后吸引投资靠财力垄断掉当前的市场。一旦形成垄断，这种制造内容类的社交APP很难被打破（因为反垄断法在制造内容类的一些场景不能完美使用），除非有一个高级的创新，否则这个领域一般来说是一个人的红海；</p>
</li>
<li><p>超过对手的方法有很多种，但是归根结底的结局是“比你对手活得长”；</p>
</li>
<li><p>资本与工人阶级的矛盾不是“贫富差距”。而是因为商业里竞争是无处不在的，所以在民营企业里，这种竞争情绪就会从高到低层层传达，为什么会从高到低？因为权力基础来自哪里很重要，权力来自高层认命，那肯定要对高层俯首帖耳。但是作为底层劳动者是不喜欢竞争的，劳动者脑子里只想的是“钱多事少离家近”，这就是最核心的矛盾。解决这种问题还是要回归法治和行业内部规范—-野蛮生长不可取，风口野蛮生长可能只会有短期的繁荣，引来的是长期的一地鸡毛。这个结局只会制造大量的资本跟工人的矛盾。竞争也是要依赖法治的，法治就不能有“口袋罪”，不能有不确定性，一旦资本家没有信心，现金流就有断的危险。政府的适度干预是必要的，但是不要做不专业的事儿；</p>
</li>
<li><p>38线是人类发展的一个重要试验田，这是一个A&#x2F;B test，虽然各有各的问题，但是可以直观的对比两边的发展水平，只不过一个是跟100分去比，另一个是去跟50分去比；</p>
</li>
<li><p>欧盟也是人类发展的一个重要试验田，我个人不看好会它会存活100~200年，虽然欧洲那么点地方挤进去那么多国家，但是宗教语言历史恩怨错综复杂，还有地缘政治因素。所以只是靠开会让各成员国一切行动听指挥，说实话是一个很难的事儿。真出事了，发达国家里牺牲谁不牺牲谁难免会扯皮。这其实本质上是一个底座并不牢靠的联盟，当年苏联靠着武力镇压，活了69年，欧盟目前还不到30年，看看不靠武力的欧盟还能活多久；</p>
</li>
<li><p>经济学家除了为资本家还会为劳动者发声，但是往往不少的良心经济学家因为说真话，被一群无知的只看立场的民族主义的人网暴，我只能说这真的是一个悲哀。不过这也很容易想通，经济学家跟政治家的目标就是不同的，经济学家考虑的是经济，但是政治家考虑的是稳定和掌控。经济学家做的最极限也就是一个批判者，而政治家则是掌握大权力的；</p>
</li>
<li><p>陆铭教授的《大国大城》大多数观点我是同意的，但是也有一点理想化，比如他说留在大城市可能让专业人才通过周围的高级人才的耳濡目染更加专业，今儿提升收入。但是现在大城市里有不少是底层的服务业人员，比如外卖、服装销售、滴滴司机、邮递小哥。这种底层服务业往往最直观提升他们收入的方法就是有一个更好的体能，他们本身一天繁重的机械工作，也很难去有时间思考反思自己的进步的地方；</p>
</li>
<li><p>鄙视链是客观存在的，我们天天嘲笑美国黑白种族歧视，其实在中国也有大量的地域歧视、职业歧视、肥胖歧视、性别歧视。但是在中国有一点比较好，就是有钱了，那么对于你而言，这些歧视不但会通通不存在还会成为你的逸闻，但是一旦你失去了财富，那么这些歧视会加倍奉还；</p>
</li>
<li><p>为啥马克思说工人阶级是最先进的阶级？不是因为工人有多少知识，不是工人天生有多少的精神高度，仅仅是因为工人人多、怨气大…在上面国际集体主义里，他的学说进化成了“工人无祖国”，来避免各国“最先进阶级”之间的彼此仇恨，而事实说明“工人无祖国”本身是一种很扯的言论。但是在统治学中，标签化是一个很重要的事儿，政府打击了阿里，京东的工人看着会很爽；罚款了滴滴，B站的群众高潮了，虽然他们都是“最先进的阶级”，这就叫分而破之。不过核酸是不分职业厂家的，只分阶级，那么打击面很广引起全民反弹是必然的；</p>
</li>
<li><p>“中央的政策是好的，下面执行歪了”，那么我们要看是怎么执行歪掉的，其实大量地方无论是防疫还是经济发展，做的都是“安全性”措施，这种安全性措施可以保住自己的乌纱帽，“因为没有十全十美的政策，政策一定会有一定的偏向性，没做好是政策有问题，我没错误”。所以地方的保守性操作，难免就要层层加码，折腾底层；</p>
</li>
<li><p>共产主义跟法西斯主义是集体主义的两个分支，这注定了他们是殊途同归的。越强调政府控制，越抹杀作为人的创造性。因为人类是群居生物，从自然角度出发，人类世界就是需要精英的，这些精英需要“想象力”+“判断力”。我们经常说思想家是被历史记住的，但是思想家提供的是一个理论可能性，而企业家是一个稳定社会里真正给社会带来改变的人，虽然资本的产出是企业家的朋友，但是用户也受到了很大的利益，双方从表面上说是双赢；</p>
</li>
<li><p>如果政权需要的仅仅是听话的官僚而不是一个堂堂正正的官员，那么肯定会打压读书人的积极性和敢于说话的品质，那么最好的办法就是控制言论。这样收缩了官员的积极性，同时也给民一点好处来获取民的支持。但是这样的后果就是越来越多的官员因为“听话而懒惰、没脾气、只是执行的机器人，甚至媚上和腐败”，一旦腐败了，那么原本给民的好处也都进了这些贪官污吏的腰包，最后还是逼得民反，这就是恒久不变的矛盾。</p>
</li>
</ol>
<iframe width="560" height="315" src="https://www.youtube.com/embed/TFTkxoKTKhU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>经济学</tag>
      </tags>
  </entry>
  <entry>
    <title>苹果手机实现隐藏APP图标</title>
    <url>/2020/12/22/%E8%8B%B9%E6%9E%9C%E6%89%8B%E6%9C%BA%E5%AE%9E%E7%8E%B0%E9%9A%90%E8%97%8FAPP%E5%9B%BE%E6%A0%87/</url>
    <content><![CDATA[<p>作为一名成年人，手机是我们隐私的集中地。比如说你有小秘密照片，可以使用keepsafe来妥善保存，但是如果你不想让别人看到 keepsafe这个图标，怎么办呢?</p>
<p>苹果是没有天生的“隐藏图标”功能的，但是我们也可以达到我们的目的。</p>
<p>首先屏幕长按某一个图标，选择“编辑主屏幕”，此时你的桌面图标就会晃动，可以拉拽图标到任意位置或者合并图标。如图：<br><img data-src="/images/apple%E9%9A%90%E8%97%8F%E5%9B%BE%E6%A0%871.jpg"></p>
<p>此时将你要隐藏的图标，单独拖拽到一个页面里，然后点击收集下方，常态栏上方的几个点点，这些点点就是对应的屏幕：<br><img data-src="/images/apple%E9%9A%90%E8%97%8F%E5%9B%BE%E6%A0%872.jpg"></p>
<p>点击之后，可以编辑对应的屏幕是否要展示&#x2F;隐藏，打勾&#x2F;勾掉即可，然后保存，这样我们就达到了隐藏APP图标的目的！</p>
<p>最后我要吐槽一句，为啥飞猪的订单要在淘宝的“已购买”上有显示啊？这个产品经理的脑子是装屎的么？<br><img data-src="/images/%E6%9D%9C%E5%85%B0%E7%89%B9%E4%B8%80%E6%9D%A1%E9%BE%99%E6%89%A3%E7%AF%AE.gif"></p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>苹果</tag>
      </tags>
  </entry>
  <entry>
    <title>蚂蚁金服运维面试全纪录</title>
    <url>/2018/03/07/%E8%9A%82%E8%9A%81%E9%87%91%E6%9C%8D%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E5%85%A8%E7%BA%AA%E5%BD%95/</url>
    <content><![CDATA[<p>早上接到蚂蚁金服的运维面试电话，有点突然袭击，下面是整个的面试记录。</p>
<p>首先，面试官先向我讲述了一下他们平时运维的工作内容，然后结合我的简历开始提问。</p>
<p>1）都用过我们的什么产品？<br>这一阶段老老实实、正常回答工作中所用到的阿里云产品和使用情景。</p>
<p>2）VPC网络有哪些好处？<br>我就答出来更加安全…面试官说其他方面呢，我就不知道了。<br>【事后补充】VPC网路的灵活性更高，可以自由定义网段划分、IP地址和路由网络。</p>
<p>3)一个vpc的服务器如何与外网交互？<br>我说可以改写路由或者通过<code>iptables</code>转发。</p>
<p>4）iptables里PREROUTING和POSTROUTING都是啥？<br><code>PREROUTING</code>处理刚到达本机并在路由转发前的数据包；<code>POSTROUTING</code>处理即将离开本机的数据包。</p>
<p>5）问：RDS在什么操作下会CPU飙升，任举一例？<br>答：在我实际工作中，比较明显的是在数据同步的时候会飙升。</p>
<p>6）RDS为什么会在DTS的时候有飙升的现象？<br>这个我答的不好，有点东拉西扯…（尴尬）</p>
<p>7）mysql备份的时候使用过什么参数？<br>答：<code>--skip-opt</code> 防止运行中的MYSQL锁库<br>加速数据备份的参数是什么？<br><code>-q</code> 提高导出性能<br><code>-e</code> 提高导入性能，使用包括几个<code>VALUES</code>列表的多行<code>INSERT</code>语法；<br><code>--max_allowed_packet=XXX</code> 客户端&#x2F;服务器之间通信的缓存区的最大大小；<br><code>--net_buffer_length=XXX</code> TCP&#x2F;IP和套接字通信缓冲区大小，创建长度达到<code>net_buffer_length</code>的行；</p>
<p>注意！<code>max_allowed_packet</code>和<code>net_buffer_length</code>在mysql里有参数值，不能超过参数值！<br>查看方法：<code>show variables like &#39;max_allowed_packet&#39;;</code></p>
<p>8）cache和buffer有什么区别？<br><code>cache</code>是缓存，弥补高速设备与低速设备的鸿沟引入的中间层，达到数据快取的目的（救火车与蓄水池）；<br><code>buffer</code>是缓冲区，用户流量整形，把大量的小的io整理一个平稳的大io，减少磁盘响应次数；<br><code>buffer</code>是即将要写入磁盘的，<code>cache</code>是要被从磁盘里读出来的。当然这只是普通用途，<code>buffer</code>用来读、<code>cache</code>用来写也是有可能的。具体问题具体分析。</p>
<p>9）他俩的调用有什么区别？<br>我问是要说“块读取”什么的么，面试官说是。我就蒙说cache是块读取，buffer我不清楚…（尴尬 again）<br>【事后补充】</p>
<p>10）谈一谈time_wait和close_wait，各自在什么情况下出现？<br><code>time_wait</code>和<code>close_wait</code>是出现在“四次挥手”的环节里，<code>time_wait</code>是服务器接收到客户端发来的断开TCP连接的请求，并且服务器发送确认断开的包给客户端，此时服务器处于<code>time_wait</code>状态，如果服务器等待两个<code>msl</code>的话，就会默认断开连接，如果想修改<code>msl</code>可以通过修改<code>/etc/systl.conf</code>文件；<br><code>close_wait</code>是客户端已经发送了断开TCP请求，但是服务器端没有接收到，也就是<code>time_wait</code>的上一步，此时这个资源就一直被程序霸占。</p>
<p>11）为什么time_wait需要等待两个msl?1.99行不行？2.01行不行？<br>我当时说防止上一次连接中的包，迷路后重新出现，影响新连接。面试官好像觉得不是很满意…（尴尬 again）<br>【事后补充】MSL是指一个片段在网络中的最大存活时间，2MSL是一个发送和一个回复所需的最大时间，如果直到2MSL，客户端都没有收到fin包，那么客户端就可以断定他发出去的ack已经被服务端接收，结束TCP连接。</p>
<p>12）说出一个你使用过的python库。<br>我说我前两天用<code>matpoltlib</code>画图，就谈了谈这个画图的库。</p>
<p>13）python装饰器了解么？<br>没什么深入的了解，就没敢答，怕被问死。</p>
<p>14）僵尸进程和孤儿进程，了解么？<br>马蛋，这个让我给说反了…(闹心啊啊啊啊啊啊啊)<br>【事后补充】孤儿进程：父进程退出，而它的一个或者多个子进程还在运行，这些子进程就叫孤儿进程，孤儿进程被init进程收养，由init进程对它们完成状态收集工作；<br>僵尸进程：一个进程用fork创建了子进程，然后这个子进程退出了，而父进程并没有调用wait或者waitpid去获取子进程的状态信息，那么这个子进程的进程描述符还在系统中，这种进程叫僵尸进程；</p>
<p>孤儿进程不怕，由于孤儿虽然没有父母，但是有民政局（init进程）收养，孤儿进程退出后也有init做一切善后工作；而僵尸进程会一直霸占其PID号，但是系统总共的PID是有限的，这样就会让可用的PID越来越少，所以僵尸进程是要避免的。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>大牛之路</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Waiting(TTFB)过长的问题</title>
    <url>/2018/06/04/%E8%A7%A3%E5%86%B3Waiting-TTFB-%E8%BF%87%E9%95%BF%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>电商平台整套系统是从上海商派公司（ecshop）那里购买的整套代码，结合我们公司自己的二开功能的3.0版本在上周几经波折终於部署上去了，经过了一个周末之后，今天市场运营的人在微信群里叫：“官方网站打开速度好慢。”果然整个官网首页要5~6秒钟才打得开，这个显然是不能忍受的，使用F12查看细节，发现<code>Waiting(TTFB)</code>的时间非常长，如图：<br><img data-src="/images/TTFB1.png" alt="akb48"></p>
<p>正常来说TFFB时间通常建议在200ms以下，如果超过推荐值，会引起队列中其他资源下载都跟着变慢。TFFB高主要有两个原因：一是客户端和服务器之前网络情况比较差；二是服务器应用响应比较慢；第三：重定向太多，重定向跟TFFB时间成正比。</p>
<p>于是乎检查网络情况以及各应用负载情况，都是OK的，重定向也很少。那么就减少DNS查询，把所有能用IP的地方都替换了域名，比如nginx的<code>localhost</code>里使用对应服务器的域名而不是127.0.0.1，比如在配置文件里的阿里云的数据库和redis都用IP地址替代。然而收效甚微，该慢依旧是慢。</p>
<p>这个时候就返回到后台去查看，左翻翻右翻翻，最后找到了这个地方，如图：<br><img data-src="/images/TTFB.jpg" alt="akb48"></p>
<p>启动全页缓存，一切就都好了…</p>
<h2 id="补充故障"><a href="#补充故障" class="headerlink" title="补充故障"></a>补充故障</h2><p>前端妹子跑来问一个问题，界面上一个1.1k的js文件，为什么加载用248ms？如图：<br><img data-src="/images/CDN1.png" alt="akb48"></p>
<p>可见大量时间都用在了<code>Content Download</code>上，但是这个文件明明已经很小了。况且旁边还有150K左右的文件也用了不到80ms，可见应该不全是网络传输慢那么简单。</p>
<p>看了一下这个js的细节，发现这个js需要去访问阿里云的OSS资源。如图：<br><img data-src="/images/CDN2.png" alt="akb48"></p>
<p>是不是时间花费在访问资源上了呢，于是我单独访问一下这个png图片，发现单独访问的时间根本不长：<br><img data-src="/images/CDN3.png" alt="akb48"></p>
<p>这个js已经没有压缩的余地了，那么究竟是什么这么消耗时间？这个我要慢慢查，先把问题记录一下…</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.oschina.net/question/244077_221319">https://www.oschina.net/question/244077_221319</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>运维技术</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Zabbix在web界面中文显示的问题</title>
    <url>/2018/01/22/%E8%A7%A3%E5%86%B3Zabbix%E5%9C%A8web%E7%95%8C%E9%9D%A2%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><font color=red>注意！这个是解决web界面中文显示乱码的问题，不是zabbix web界面全中文汉化的问题。</font></p>
<h2 id="2-2版本的处理方法"><a href="#2-2版本的处理方法" class="headerlink" title="2.2版本的处理方法"></a>2.2版本的处理方法</h2><p>zabbix里给host或者item等项目起中文名字的时候，可能在graph上无法正确显示中文字符，如图：<br><img data-src="/images/zabbixchinese1.jpg" alt="paradin"></p>
<p>那么遇到这样的情况其实很简单，就是zabbix的web界面没有安装中文字库的问题，那就对症下药，下载中文字库。</p>
<p>中文字库的下载地址在这里：<code>http://linux.linuxidc.com/2012%E5%B9%B4%E8%B5%84%E6%96%99/11%E6%9C%88/22%E6%97%A5/Zabbix%E4%B8%AD%E6%96%87%E4%B8%8D%E8%83%BD%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/</code> ，下载“LinuxIDC.com下载-kaiti.tar.gz”。</p>
<p>后把这个文件改一下名，可能很多linux不识别那个中文字“下载”,<code>mv LinuxIDC.com下载-kaiti.tar.gz kaiti.tar.gz</code>，<code>tar -zxvf kaiti.tar.gz</code></p>
<p>然后就会发现当前路径里生成了一个叫<code>kaiti.ttf</code>，这个就是我们所需要的中文“楷体”字体文件。</p>
<p>来到zabbix的web字体路径，在我的机器里，这个负责字体的文件夹叫<code>/usr/local/nginx/html/zabbix/fonts/</code>。虽然各位安装zabbix的路径各有差别，但是这个文件夹一般都是在<code>nginx or apache</code>的html下，所以很好找的。</p>
<p>在这个fonts文件夹里默认已经有一个叫<code>DejaVuSans.ttf</code>的文件了，于是就把这个<code>kaiti.tff</code>也放到这个文件夹下。</p>
<p>光有字体文件没有用，还需要在配置文件里使用这个字体文件，于是就vim一下同样在<code>nginx or apache/html/zabbix/include</code>的<code>defines.inc.php</code>。把里面所有的<code>DejaVuSans</code>替换成<code>kaiti</code>，.<code>tff</code>这个后缀是不用加的。然后保存退出，重新刷一下界面就看到效果了。</p>
<p>vim的替换语句 :<code> %s/DejaVuSans/kaiti/g</code><br><img data-src="/images/zabbixchinese2.png" alt="paradin"></p>
<p><img data-src="/images/zabbixchinese3.png" alt="paradin"></p>
<h2 id="3-x版本的处理方法"><a href="#3-x版本的处理方法" class="headerlink" title="3.x版本的处理方法"></a>3.x版本的处理方法</h2><p>现在zabbix已经升级到3.x了，上述的方法已经失效了，这里记录一下新的中文配置方法。</p>
<p>首先从windows里，拷贝一个中文字体的文件到zabbix的服务器的<code>/usr/share/zabbix/fonts</code>文件夹里，比如我先择了“楷体”，这个文件叫<code>simkai.ttf</code>，<code>chmod +x simkai.ttf</code> 给予可执行权限。<br><img data-src="/images/zabbixchinese4.png" alt="paradin"></p>
<p>然后<code>vim /usr/share/zabbix/include/defines.inc.php</code>，修改两处地方，分别是第四十五行，把原来的改成<code>simkai</code>，如图：<br><img data-src="/images/zabbixchinese5.png" alt="paradin"></p>
<p>还有一处就是第九十三行，也是改成<code>SIMKAI</code>：<br><img data-src="/images/zabbixchinese6.png" alt="paradin"></p>
<p>保存文件之后，刷新一下zabbix界面即可。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
        <tag>运维与监控</tag>
      </tags>
  </entry>
  <entry>
    <title>梅西不需要道歉</title>
    <url>/2024/02/21/%E8%A6%81%E6%A2%85%E8%A5%BF%E9%81%93%E6%AD%89%EF%BC%9F%E5%87%AD%E5%95%A5/</url>
    <content><![CDATA[<h2 id="梅西没有错"><a href="#梅西没有错" class="headerlink" title="梅西没有错"></a>梅西没有错</h2><p>今年春节最大的舆情就是除了“湖北高速公路堵车好几天”、“上证指数跌破2700，抓了几个人后终于开始回涨”之外就是“梅西辱华”，后来临近春节假期的尾声又爆了一个“美女老师跟16岁男学生处对象”的新闻。但是说来说去，后两者让流量自媒体们看到了赚钱的机会，一个是当世球王，另一个是桃色新闻，不愁没有点击量。而前面那几个事儿是没胆量去跟进报道的，不然警察可能会找上门一顿大嘴巴子把屎尿扇出来。</p>
<p>当然还有山东日照除夕杀人案和俄罗斯著名反对派阿列克谢·纳瓦利内死在监狱至今尸体下落不明的新闻，连“湖北高速公路春节堵车”都不敢写的人这俩话题肯定更不敢碰。</p>
<p>梅西之前来过中国不止一次，唯独这一次被扣上了“辱华”的帽子。梅西最近也在微博上发了本人出镜的视频，说整个事情没有政治因素，是单纯的身体原因不能出场。这个视频算不上是一个道歉视频，更准确的说是一个澄清视频。但是骂他的网友依旧不买账，因为他们认为梅西需要向比赛到场的球迷道歉，因为他没有对他们微笑。梅西还需要向港首李家超道歉，因为他故意躲着李家超没有跟他握手。</p>
<p>那么先说第一个问题，梅西真的没有对香港球迷微笑么？</p>
<p>迈阿密这场比赛是从沙特而来，在香港只停留了短短48小时不到。期间梅西做了如下事情：</p>
<p><img data-src="/images/%E6%A2%85%E8%A5%BF%E6%9D%A5%E6%B8%AF1.png"><br><img data-src="/images/%E6%A2%85%E8%A5%BF%E6%9D%A5%E6%B8%AF4.png"><br><img data-src="/images/%E6%A2%85%E8%A5%BF%E6%9D%A5%E6%B8%AF5.png"><br><img data-src="/images/%E6%A2%85%E8%A5%BF%E6%9D%A5%E6%B8%AF6.png"></p>
<p>可见梅西在训练和其他的环节都一如既往的表现出职业和谦逊的态度，但是唯独到了比赛中途却不高兴了，那么这中间发生了什么？就像董路在咪咕《你懂球么》里提到的，这里面肯定发生了事情。根据事后这个中间商Tatler asia又退款又声明唯独不去找迈阿密打官司来看，迈阿密和梅西是有理的一方，是不需要承担法律责任的，不然这也就是为啥梅西不道歉的原因，这也是为啥赤水河白酒和极兔快递等中国企业即使被网络暴民骂到在京东下架商品也不跟梅西解约的原因—因为梅西没做错，所以没有理由解约。</p>
<p><img data-src="/images/%E6%A2%85%E8%A5%BF%E6%9D%A5%E6%B8%AF3.png"><br><img data-src="/images/%E6%A2%85%E8%A5%BF%E6%9D%A5%E6%B8%AF2.png"></p>
<p>其实整件事情说白了，就是中间商Tatler asia钱没给足，虽然合约里面写了“梅西等人没伤病要出场30分钟”，但是毕竟钱没给足，这场比赛对于梅西本人来说可踢可不踢。但是日本的比赛出场费到位了，梅西必须要遵守合约踢够时间，所以梅西选择香港这场保守观战，整个事情就这么简单，他自己在微博的话也是这个意思。</p>
<p>所以说，从梅西在其他环节可见所谓的“梅西看不起香港人”纯属放屁。但是梅西在比赛最后为啥不高兴，那么就要问问当事人，比赛的时候到底发生了啥。退一步说，梅西在训练里微笑，对小朋友微笑，但是在比赛里对场边的球迷不微笑就是辱华，那么去年阿根廷在中国比赛后，梅西直接离队，而其他阿根廷国家队国家队去了印尼继续比赛，是不是印尼人要跳“梅西压根不来我们国家，梅西辱印尼”了？</p>
<p>但是这一切架不住有人跳出来写小作文不是？真的是应了那句话—“学好不容易，学坏一出溜”。</p>
<p>还有人说，梅西故意绕开李家超，绕开政府代表就是辱华了。首先，我不明白“绕开李家超 &#x3D; 辱华了”这个逻辑在哪。其次对于梅西来说，他可能不知道李家超是谁，但是他应该知道那是一个政治人物。那么梅西是有理由拒绝政治人物的，因为作为一个体育运动员，梅西本身就不跟政治参与很多，从梅西这几十年来看，他唯独对阿根廷国内的政治表态过之外，对生活了好几十年的加泰罗尼亚都没有表态。更不用提什么针对香港表达政治立场，至于什么共济会，什么转移731视线那都是些鬼扯的东西了。</p>
<p>换位思考，姚明在美国的纽约打了一场篮球商业表演赛，然后纽约的某议员结束在大庭广众场地中央要跟姚明握手，你觉得姚明会放心的跟他握手吗？更何况李家超还不是迈阿密的直接签约方，迈阿密的签约方是Tatler asia！而Tatler asia只是一个两头吃的中间商而已。所以梅西对于这种突发转变乙方的情况不表态不发言是对的。</p>
<p>其他更多的事情细节在 <a href="https://www.163.com/dy/article/IR7MD0GK0553AOVQ.html">https://www.163.com/dy/article/IR7MD0GK0553AOVQ.html</a> 里都有写，我也不多说了。</p>
<p>但是我还是想展开一下，为啥梅西这个事情会有这么大的影响？首先，梅西是历史级球星，名声在外关注度高。其次，前脚c罗深圳行草草收尾，梅西这次的事情更是将“足球走穴商业比赛不完美结束”的案例推到一个新的高度。但是《环x日报》跳出来说有疑似有政治势力控制梅西，就让“辱华”这个性质得到了类似官方的认证。进而阿根廷3月杭州比赛取消，央视开始软封杀梅西。整个事情到现在这个局面，这里面有没有人搅浑水？答案是肯定有的，我想不仅有人搅浑水也顺便甩了一个锅。</p>
<h2 id="辱华到底是个啥"><a href="#辱华到底是个啥" class="headerlink" title="辱华到底是个啥"></a>辱华到底是个啥</h2><p>“辱华”跟“寻衅滋事”一样，现在已经成了一个口袋罪。只不过一个是对老外的，一个是对自己人的。</p>
<p>在中国互联网上，现在很多场景都可以符合“辱华”的定义:外国产品里用眯眯眼的中国模特就是辱华，中国模特长得不好看也算辱华，country有台湾就是辱华，汽车广告里石狮子鞠躬敬礼就是辱华，詹姆斯不受中国仙女诱惑击败恶龙也是辱华，用lunar new year不用chinese new year就是辱华，用dragon不用loong就是辱华，索尼广告在“77事件”附近播出也是辱华，张学友说“香港加油”，哦这个不是辱华，是“港独”，算“寻衅滋事”。王刚在11月27日教大家做蛋炒饭也是“寻衅滋事”。</p>
<p>当然，上面我说的这些事情如果是俄罗斯人搞，那肯定算不得辱华了。</p>
<p>成龙都曾经抱怨过：“为啥在电影里只能是中国人揍外国人？外国人打中国人了，就说这个中国演员是汉奸是狗屎是辱华了。这就是一个电影而已啊！” </p>
<p><img data-src="/images/%E6%88%90%E9%BE%99%E8%B0%88%E7%94%B5%E5%BD%B1.gif"><br><img data-src="/images/%E6%9D%8E%E8%BF%9E%E6%9D%B0%E8%B0%88%E7%94%B5%E5%BD%B1.gif"></p>
<p>当然，在喜欢说人辱华的人眼中，有些标准是变化的，奥运射击冠军杨倩拿金牌的时候，他们兴奋的嗷嗷直喊，后来杨倩摘了口罩，喊的声音小了点。再后来杨倩晒了耐克鞋，喊的声音又大了起来，这次让她直接“滚出中国”。这说明他们认为“有些人之前是不辱华的，可以后来辱华”，或者“骨子里就是崇洋媚外的，只不过当初藏得深”。</p>
<p>事实上的辱华被华人抵制天经地义。但是现在“辱华”的标准开始模糊，过分的滥用已经完全偏离了“歧视华人”的原本含义，再加上不少人骨子里喜欢“翻旧帐，找内奸，好听点叫忠诚，说白了就是投机”，所以“xxx辱华了！”是一个吸引眼球的事儿。这与我们日益增长的民族主义环境是分不开的。韩寒曾说“辱华的深层次是我们自卑”，我觉得并不是自卑或者玻璃心，相反现在很多人不自卑反而很莫名其妙的自傲，这些人不但早就“直起了腰杆子”，甚至就要借这个机会去骂去闹，反正不骂白不骂，党让我骂谁我就骂谁，骨子里是一种对权威的畏惧。而正利用这层心理外加上短视频“短平快”的特性，利用“辱华”来标榜自己“爱国”也可以做成一个生意，赚个盆满钵满，至于伤害当事人？“伤害辱华的人那叫伤害么？还应该给我一个大奖状呢！”。</p>
<p>干这种事儿的代表，一个是共x团，一个是《环x日报》，给这俩奉旨且专业的顶级搅屎棍一个忠告：“我知道仗着有互联网防火墙，靠信息差搞宣传是你们的kpi。但是有些事情，比流量重要的多，一个是脑子，一个是良心”。</p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>足球</tag>
        <tag>梅西</tag>
        <tag>自媒体</tag>
      </tags>
  </entry>
  <entry>
    <title>解决html里单引号转义的问题</title>
    <url>/2019/01/23/%E8%A7%A3%E5%86%B3html%E9%87%8C%E5%8D%95%E5%BC%95%E5%8F%B7%E8%BD%AC%E4%B9%89%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在使用Django展现页面的时候，会出现这样的一个需求：</p>
<p>我们在<code>views.py</code>里获取到的一个数组，比如叫name，内容是：<code>[&#39;james&#39;,&#39;wade&#39;,&#39;bosh&#39;,&#39;yaoming&#39;]</code>，然后<code>return render_to_response(&#39;a.html&#39;,{&#39;names&#39;:name,})</code>，让<code>a.html</code>可以使用到这个name数组。若在<code>a.html</code>里需要对这个name数组进行for循环展示，正常思路的话，js如下：<br>	<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">function test()</span><br><span class="line">	&#123;</span><br><span class="line">		var name=&quot;&#123;&#123;names&#125;&#125;&quot;.split(&quot;,&quot;)</span><br><span class="line">		alert(name)</span><br><span class="line">		进行for循环，略过不表</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么得到的会是如下效果：<br><img data-src="/images/django43.png" alt="akb48"></p>
<p>可见虽然name在<code>views.py</code>里是list，但是传入到html是一个字符串，对于字符串使用split按照逗号分隔。而html里会把单引号转义成了<code>&amp;#39;</code>，而<code>&amp;#39;</code>这个玩意儿比较恶心，它不能被<code>JSON.parse</code>加工成一个数组，进而不能被for循环。</p>
<p>那么遇到这种问题怎么办?改成这样：<br>	<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">function test()</span><br><span class="line">	&#123;</span><br><span class="line">		var str=&quot;&#123;&#123;names&#125;&#125;&quot;.replace(/<span class="symbol">&amp;#39;</span>/g,&#x27;&quot;&#x27;)</span><br><span class="line">   		var name=JSON.parse(str)</span><br><span class="line">  			alert(name)</span><br><span class="line">		进行for循环，略过不表</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行效果如下：<br><img data-src="/images/django44.png" alt="akb48"><br>上面代码首先先把所有的单引号replace成双引号，<font color=red>Html是不会转义双引号的</font>，所以就可以正常使用了。</p>
<p>当然如果<code>views.py</code>里提供的name直接是双引号的话，就不用这么折腾了。</p>
<h2 id="数组如何使用双引号而不是单引号"><a href="#数组如何使用双引号而不是单引号" class="headerlink" title="数组如何使用双引号而不是单引号"></a>数组如何使用双引号而不是单引号</h2><p>python默认生成数组是单引号的，也就是说是<code>[&#39;apple&#39;,&#39;banana&#39;,&#39;candy&#39;</code>]的样子，而不会自动生成<code>[&quot;apple&quot;,&quot;banana&quot;,&quot;candy&quot;]</code>，这一点是不能改变的。那么要获得到双引号的数组，比较好的办法是json：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>names = [<span class="string">&#x27;james&#x27;</span>,<span class="string">&#x27;wade&#x27;</span>,<span class="string">&#x27;bosh&#x27;</span>,<span class="string">&#x27;yaoming&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(json.dumps(names))</span><br><span class="line">[<span class="string">&quot;james&quot;</span>, <span class="string">&quot;wade&quot;</span>, <span class="string">&quot;bosh&quot;</span>,<span class="string">&quot;yaoming&quot;</span>]</span><br></pre></td></tr></table></figure></p>
<p>如果元素是中文的话，那么就要用<code>(json.dumps(names,ensure_ascii=False))</code>。</p>
<h2 id="与正文内容无关的补充"><a href="#与正文内容无关的补充" class="headerlink" title="与正文内容无关的补充"></a>与正文内容无关的补充</h2><p><code>Centos 7</code>修改中文字符集的方法：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">localedef -c -f <span class="variable constant_">UTF</span>-<span class="number">8</span> -i zh_CN zh_CN.<span class="property">UTF</span>-<span class="number">8</span></span><br><span class="line"><span class="keyword">export</span> <span class="variable constant_">LC_ALL</span>=zh_CN.<span class="property">UTF</span>-<span class="number">8</span></span><br><span class="line">echo <span class="string">&#x27;LANG=&quot;zh_CN.UTF-8&quot;&#x27;</span> &gt; <span class="regexp">/etc/</span>locale.<span class="property">conf</span></span><br></pre></td></tr></table></figure></p>
<p><img data-src="/images/%E9%87%8C%E7%9A%AE.gif" alt="akb48" title="冯潇霆失误后，气急败坏的里皮"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>html</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>解决https证书在赛门铁克认证失败的问题</title>
    <url>/2018/02/26/%E8%A7%A3%E5%86%B3https%E8%AF%81%E4%B9%A6%E5%9C%A8%E8%B5%9B%E9%97%A8%E9%93%81%E5%85%8B%E8%AE%A4%E8%AF%81%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>今天电子商城的市场接到一个故障，说更换了.lechange.com的https证书（原有的证书到期了，新买了一个依旧还是.lehcange.com域名证书）之后，订单在支付宝支付的时候提示支付失败。我把<code>request id</code>提供给支付宝的客服请他们查看一下后台，支付宝客服说我们电商的https证书没有认证成功。于是我就登陆<a href="https://cryptoreport.websecurity.symantec.com/checker/">https://cryptoreport.websecurity.symantec.com/checker/</a> 去检查一下电商的域名，果不其然，赛门铁克的反馈是错误的，如图：<br><img data-src="/images/saimentieke1.png" alt="paradin"></p>
<p>但是登陆网站，在浏览器里却显示https证书是OK的，如图：<br><img data-src="/images/saimentieke2.png" alt="paradin"></p>
<p>然后我用<code>symantec</code>的那个网站测试了一下电商平台开发环境的域名，发现也是OK的，如图：<br><img data-src="/images/saimentieke3.png" alt="paradin"></p>
<p>这就郁闷了，到底哪里出问题了？</p>
<h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><p>首先跟研发确认，开发环境与线上环境在涉及到证书的代码是否一致，得到研发的确认之后。就检查服务器里的<code>nginx</code>，发现服务器<code>nginx</code>的配置文件里是没有涉及到<code>ssl</code>，无论是开发环境和线上环境都是通过阿里云slb配置的https证书。而且两者的证书指纹一模一样，如图：<br><img data-src="/images/saimentieke4.png" alt="paradin"></p>
<p>既然都是用的一样的证书，为啥一个检验通过，另一个检验不通过呢？这个时候我想到线上环境与开发环境唯一的不同就是线上环境多了一个cdn，于是就登陆到cdn的控制页面，找到对应的https证书，发现cdn的https证书指纹也是跟上面的指纹一样，如图：<br><img data-src="/images/saimentieke5.png" alt="paradin"></p>
<p>既然指纹一样，那证书也应该是一样的，场面又进入了一个僵局。</p>
<p>于是我就到一台服务器里使用<code>curl -vv https://www.lechange.com</code>，看到的结果如下：<br><img data-src="/images/saimentieke6.png" alt="paradin"></p>
<p>提示<code>未配置签发者根证书</code>，我这时候想起来了，<font color=red>首先证书指纹一致不能说明证书是完全一致的，只能说明key文件是一样的！</font>其次这个https证书是中级机构证书，那么中级机构颁发的证书链规则是这样的：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-----<span class="variable constant_">BEGIN</span> <span class="variable constant_">CERTIFICATE</span>-----</span><br><span class="line"></span><br><span class="line">-----<span class="variable constant_">END</span> <span class="variable constant_">CERTIFICATE</span>-----</span><br><span class="line"></span><br><span class="line">-----<span class="variable constant_">BEGIN</span> <span class="variable constant_">CERTIFICATE</span>-----</span><br><span class="line"></span><br><span class="line">-----<span class="variable constant_">END</span> <span class="variable constant_">CERTIFICATE</span>-----</span><br></pre></td></tr></table></figure></p>
<p>那么我怀疑就是https证书链那部分可能在cdn配置错误了，或许在slb配置错误了，甚至两个都配置错误了！</p>
<p>于是干脆删除掉线上电商原有的https证书，重新导入cdn和slb的https证书，返回到<code>symantec</code>刷新，这次的检验结果就OK了。<br><img data-src="/images/saimentieke7.png" alt="paradin"></p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>虽然这个问题解决了，但是我还是不明白，为什么在网页端查看证书是绿色OK的呢？在<code>sf.gg</code>上提问之后，一个叫Avro的朋友是这么回答我的：</p>
<blockquote>
<p>以chrome为例，他信任了[所在平台的信任证书列表][1]，而这些平台集成了一系列信任的根证书，如iOS 11 中可用的受信任根证书列表可以找到你的根证书“04 00 00 00 00 01 15 4B 5A C3 94 ”(序列号)，因此验证过程中没有问题，而对于其他的工具，如果未使用这些平台根证书信任列表依然需要完整的证书链（这个证书链在ssl握手过程中被下发）进行校验。</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://openclub.alipay.com/read.php?tid=3451&fid=57&page=1">https://openclub.alipay.com/read.php?tid=3451&amp;fid=57&amp;page=1</a><br><a href="https://www.jianshu.com/p/84af353f43c5">https://www.jianshu.com/p/84af353f43c5</a><br><a href="https://help.aliyun.com/knowledge_detail/39468.html?spm=a2c4g.11186631.2.2.w2qcWT">https://help.aliyun.com/knowledge_detail/39468.html?spm=a2c4g.11186631.2.2.w2qcWT</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>https证书</tag>
      </tags>
  </entry>
  <entry>
    <title>让Nginx鉴权功能保护Kibana网页</title>
    <url>/2019/02/28/%E8%AE%A9Nginx%E9%89%B4%E6%9D%83%E5%8A%9F%E8%83%BD%E4%BF%9D%E6%8A%A4Kibana%E7%BD%91%E9%A1%B5/</url>
    <content><![CDATA[<p>Kibana本身是一个Web界面，但是出于安全和机密的考虑，我们肯定不会让互联网上所有的人都能随便看到Kibana里的内容，但是X-pack目前又不支持6.2以上的版本，于是我们可以使用Nginx的密码功能来保护Kibana的网页：要访问Kibana时需要先输入密码，正确就登陆到Kibana，如果错误就是403。</p>
<p>Kibana是容器安装的，安装过程可以去查看：<a href="https://rorschachchan.github.io/2019/01/21/%E5%B0%86kafka%E5%8A%A0%E5%85%A5%E5%88%B0Elk%E9%9B%86%E7%BE%A4/">https://rorschachchan.github.io/2019/01/21/%E5%B0%86kafka%E5%8A%A0%E5%85%A5%E5%88%B0Elk%E9%9B%86%E7%BE%A4/</a> </p>
<h2 id="事前准备"><a href="#事前准备" class="headerlink" title="事前准备"></a>事前准备</h2><p>Nginx也是容器安装，<code>docker pull nginx</code>拉取最新的nginx镜像，在下载的时候呢我们也别对着屏幕干巴巴的等。由于在nginx配置转发的时候，需要知道Kibana的容器IP，这是因为Kibana和正在下载的Nginx是两个不同的容器，Nginx是需要跨容器访问的。</p>
<p>默认的官方Kibana镜像登录是非root的，这种虽然安全，但是不能config也不能yum，于是我们首先要使用root账号登录进去，语句是：<br>	<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it --user root kibana容器ID /bin/bash</span><br><span class="line">yum update -y</span><br><span class="line">yum install -y net-tools	#下载ifconfig</span><br></pre></td></tr></table></figure></p>
<p>使用ifconfig和netstat查看容器的IP和工作端口：<br><img data-src="/images/kibana20.png" alt="办公室"></p>
<p>可以确认Kibana的IP是<code>172.17.0.4</code>，端口是5601。这时候我们就可以写一个<code>kibana.conf</code>，让nginx容器用这个配置文件达到跳转的目的！</p>
<p><code>kibana.conf</code>全文如下：<br>	<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">upstream kibana_server &#123;</span><br><span class="line">        server  172.17.0.3:5601 weight=1 max_fails=3  fail_timeout=60;	#这里写的就是kibana的容器IP和端口，如果是多台kibana想要按权重访问，就写weight</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen *:33664;	#nginx容器自己的端口</span><br><span class="line">        server_name _;</span><br><span class="line">        auth_basic &quot;Restricted Access&quot;;      # 验证</span><br><span class="line">        auth_basic_user_file /etc/nginx/conf.d/htpasswd.users;             # 验证文件</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_pass http://kibana_server;	#这个地方就是upstream</span><br><span class="line">                proxy_http_version 1.1;</span><br><span class="line">                proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">                proxy_set_header Connection &#x27;upgrade&#x27;;</span><br><span class="line">                proxy_set_header Host $host;</span><br><span class="line">                proxy_cache_bypass $http_upgrade;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>把这个文件保存在<code>/mnt/nginx</code>目录里。</p>
<h2 id="配置nginx密码"><a href="#配置nginx密码" class="headerlink" title="配置nginx密码"></a>配置nginx密码</h2><p>nginx要创建验证文件授权,需要先安装<code>httpd-tools</code>工具：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">yum install -y  httpd-tools </span><br><span class="line">htpasswd -bc /mnt/nginx/htpasswd.users kibana password123 <span class="comment"># 创建验证文件</span></span><br><span class="line">Adding password <span class="keyword">for</span> user admin</span><br></pre></td></tr></table></figure></p>
<p>这时我们就创建了一个<code>/mnt/nginx/htpasswd.users</code>，里面的用户是kibana，密码是password123。这个密码在文件里是加密的，用cat命令无法正常查看到的。</p>
<h2 id="启动nginx容器"><a href="#启动nginx容器" class="headerlink" title="启动nginx容器"></a>启动nginx容器</h2><p>此时nginx镜像应该下载完毕了，那么就直接启动镜像，启动语句是：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">docker run --hostname Kngx -p <span class="number">80</span>:<span class="number">33664</span> --name Knginx -v /mnt/nginx/:/etc/nginx/conf.d/ -d nginx</span><br></pre></td></tr></table></figure></p>
<p>简单说一下这个命令：这个容器名叫Knginx，hostname是Kngx，做了宿主机80端口到此容器33664端口的转发，将宿主机的<code>/mnt/nginx/</code>挂载到容器里的<code>/etc/nginx/conf.d/</code>，同时直接启动nginx。</p>
<p>启动成功之后，我们看到刚刚建立的<code>htpasswd.users</code>和<code>kibana.conf</code>都已经成功被Knginx容器配置上，然后打开浏览器，看看效果：<br><img data-src="/images/kibana21.gif" alt="办公室" title="kibana加载比较慢"></p>
<p>这样就达到了密码访问页面的效果，如果想加IP白名单呢，也可以直接在<code>kibana.conf</code>里补充相关配置，修改完毕之后，重启Knginx容器即可。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.hugeserver.com/kb/how-secure-kibana-nginx-centos/">https://www.hugeserver.com/kb/how-secure-kibana-nginx-centos/</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>nginx</tag>
        <tag>kibana</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Mysql的CPU过高的问题</title>
    <url>/2019/09/11/%E8%A7%A3%E5%86%B3Mysql%E7%9A%84CPU%E8%BF%87%E9%AB%98%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>今儿发现AWS有一个mysql5.6.40数据库从库（2核16G，最大IOPS 2000）的CPU很不正常，如图：<br><img data-src="/images/mysql4.png" alt="paradin"></p>
<p>先查看了一下mysql的总体情况：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Uptime: <span class="number">10471685</span>  Threads: <span class="number">894</span>  Questions: <span class="number">58466385559</span>  Slow queries: <span class="number">2466</span>  Opens: <span class="number">321642</span>  Flush tables: <span class="number">1</span>  Open tables: <span class="number">2000</span>  Queries per second avg: <span class="number">5583.283</span>		<span class="comment">#Questions是已执行的由客户端发出的语句</span></span><br><span class="line"></span><br><span class="line">MySQL [easyip]&gt; show status where `variable_name` = <span class="string">&#x27;Threads_running&#x27;</span>;</span><br><span class="line">+-----------------+-------+</span><br><span class="line">| Variable_name   | Value |</span><br><span class="line">+-----------------+-------+</span><br><span class="line">| Threads_running | <span class="number">2</span>     |</span><br><span class="line">+-----------------+-------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>跑到里用<code>show full processlist</code>一看，发现几乎都是sleep，只有偶尔才会刷出来一两条Query。</p>
<p>使用<code>tcpdump -s 65535 -x -nn -q -tttt -c 500000 -i any port 3306 &gt; mysql.txt</code>抓一个500M大小的包，然后<code>wget percona.com/get/pt-query-digest</code>和<code>chmod u+x pt-query-digest</code>来安装<code>pt-query-digest</code>，一会我们用它分析一下这个包。</p>
<p>插播一句，如果使用<code>pt-query-digest</code>的时候爆<code>Can&#39;t locate Digest/MD5.pm in @INC</code>这样的错误，请执行<code>yum install perl-Digest-MD5.x86_64</code>。</p>
<p>然后执行<code>./pt-query-digest --type tcpdump --watch-server=&#39;mysql的IP地址:3306&#39; mysql.txt &gt;3306.log</code>，打开这个<code>3306.log</code>一探究竟：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 91.2s user time, 4.1s system time, 38.76M rss, 203.35M vsz</span></span><br><span class="line"><span class="comment"># Current date: Wed Sep 11 13:25:02 2019</span></span><br><span class="line"><span class="comment"># Hostname: ip-10-10-153-64.eu-central-1.compute.internal</span></span><br><span class="line"><span class="comment"># Files: mysql.txt</span></span><br><span class="line"><span class="comment"># Overall: 107.03k total, 96 unique, 2.94k QPS, 2.89x concurrency ________</span></span><br><span class="line"><span class="comment"># Time range: 2019-09-11 13:22:21.774093 to 13:22:58.211771</span></span><br><span class="line"><span class="comment"># Attribute          total     min     max     avg     95%  stddev  median</span></span><br><span class="line"><span class="comment"># ============     ======= ======= ======= ======= ======= ======= =======</span></span><br><span class="line"><span class="comment"># Exec time           105s       0    73ms   984us     3ms     2ms   424us</span></span><br><span class="line"><span class="comment"># Rows affecte           0       0       0       0       0       0       0</span></span><br><span class="line"><span class="comment"># Query size        19.41M      18   1.59k  190.15  346.17  109.64  158.58</span></span><br><span class="line"><span class="comment"># Warning coun           0       0       0       0       0       0       0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Profile</span></span><br><span class="line"><span class="comment"># Rank Query ID                      Response time Calls R/Call V/M   Item</span></span><br><span class="line"><span class="comment"># ==== ============================= ============= ===== ====== ===== ====</span></span><br><span class="line"><span class="comment">#    1 0x17439B73926DAFE4B1F7504E... 62.6518 59.5% 62408 0.0010  0.01 SELECT macuserinfo pcs_sys_user</span></span><br><span class="line"><span class="comment">#    2 0x221ABFF7BE95D0B83774ECE7...  7.7099  7.3%  4374 0.0018  0.01 SELECT device_channel_config_info</span></span><br><span class="line"><span class="comment">#    3 0x8D042CE60A67A30092CD7CFD...  6.9497  6.6%  4978 0.0014  0.01 SELECT push_client_info pcs_user_dev_link pcs_sys_user</span></span><br><span class="line"><span class="comment">#    4 0xEBBF1DEAACA1353A4DD445F3...  4.5713  4.3%  3952 0.0012  0.00 SELECT pcs_adm_dev_storage_strategy</span></span><br><span class="line"><span class="comment">#    5 0x49348052DEA8C471AD64477C...  4.1641  4.0%  5227 0.0008  0.00 SELECT pcs_user_dev_link pcs_sys_user</span></span><br><span class="line"><span class="comment">#    6 0xF96D9A42E1EFE0A84717B273...  3.8453  3.7%  4970 0.0008  0.00 SELECT user_authorize_info</span></span><br><span class="line"><span class="comment">#    7 0x40FC0DACAACA50F36466B100...  2.7108  2.6%  4132 0.0007  0.00 SELECT pcs_adm_dev_storage_strategy</span></span><br><span class="line"><span class="comment">#    8 0x24A6818C09D884D5B2DD04FB...  2.2897  2.2%  2095 0.0011  0.01 SELECT device_config_info macuserinfo device_config_info</span></span><br><span class="line"><span class="comment">#    9 0x6E5549936C772E40EBAE1FEE...  1.8566  1.8%  3355 0.0006  0.00 SELECT macinfo</span></span><br><span class="line"><span class="comment">#   10 0x238C2BAB786EE59102CF0654...  1.7066  1.6%  2077 0.0008  0.01 SELECT pcs_user_dev_link pcs_sys_user</span></span><br><span class="line"><span class="comment">#   11 0x327C32C0EBADC5D17957E04C...  0.9152  0.9%  1771 0.0005  0.00 SELECT device_config_info</span></span><br><span class="line"><span class="comment">#   12 0x7190F54D663D68CFE1680408...  0.6966  0.7%  1021 0.0007  0.00 SELECT pcs_adm_dev_storage_strategy</span></span><br><span class="line"><span class="comment"># MISC 0xMISC                         5.2609  5.0%  6669 0.0008   0.0 &lt;84 ITEMS&gt;</span></span><br><span class="line"><span class="comment"># Query 1: 2.71k QPS, 1.72x concurrency, ID 0x17439B73926DAFE4B1F7504E191657C8 at byte 287906107</span></span><br><span class="line"><span class="comment"># This item is included in the report because it matches --limit.</span></span><br><span class="line"><span class="comment"># Scores: V/M = 0.01</span></span><br><span class="line"><span class="comment"># Time range: 2019-09-11 13:22:21.774093 to 13:22:58.211613</span></span><br><span class="line"><span class="comment"># Attribute    pct   total     min     max     avg     95%  stddev  median</span></span><br><span class="line"><span class="comment"># ============ === ======= ======= ======= ======= ======= ======= =======</span></span><br><span class="line"><span class="comment"># Count         58   62408</span></span><br><span class="line"><span class="comment"># Exec time     59     63s   171us    69ms     1ms     3ms     2ms   424us</span></span><br><span class="line"><span class="comment"># Rows affecte   0       0       0       0       0       0       0       0</span></span><br><span class="line"><span class="comment"># Query size    50   9.88M     159     179  166.01  158.58    0.63  158.58</span></span><br><span class="line"><span class="comment"># Warning coun   0       0       0       0       0       0       0       0</span></span><br><span class="line"><span class="comment"># String:</span></span><br><span class="line"><span class="comment"># Hosts        10.10.153.64</span></span><br><span class="line"><span class="comment"># Query_time distribution</span></span><br><span class="line"><span class="comment">#   1us</span></span><br><span class="line"><span class="comment">#  10us</span></span><br><span class="line"><span class="comment"># 100us  ################################################################</span></span><br><span class="line"><span class="comment">#   1ms  #############</span></span><br><span class="line"><span class="comment">#  10ms  #</span></span><br><span class="line"><span class="comment"># 100ms</span></span><br><span class="line"><span class="comment">#    1s</span></span><br><span class="line"><span class="comment">#  10s+</span></span><br><span class="line"><span class="comment"># Tables</span></span><br><span class="line"><span class="comment">#    SHOW TABLE STATUS LIKE &#x27;macuserinfo&#x27;\G</span></span><br><span class="line"><span class="comment">#    SHOW CREATE TABLE `macuserinfo`\G</span></span><br><span class="line"><span class="comment">#    SHOW TABLE STATUS LIKE &#x27;pcs_sys_user&#x27;\G</span></span><br><span class="line"><span class="comment">#    SHOW CREATE TABLE `pcs_sys_user`\G</span></span><br><span class="line"><span class="comment"># EXPLAIN /*!50100 PARTITIONS*/</span></span><br><span class="line">select  b.<span class="built_in">id</span> As user_id, b.PROJECT As project, a.user AS user  <span class="keyword">from</span> macuserinfo a, pcs_sys_user b where a.user=b.username <span class="keyword">and</span> a.devsequence=<span class="string">&#x27;4L05B49PAZE5806&#x27;</span> limit <span class="number">1</span>;\G</span><br><span class="line"></span><br><span class="line"><span class="comment"># Query 2: 120.17 QPS, 0.21x concurrency, ID 0x221ABFF7BE95D0B83774ECE7A62FCB96 at byte 319100665</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>从文件里可以看出这个select语句在本次分析中总的时间占比高达60%，但是单次调用耗时极少，不过QPS（每秒执行的查询次数）却高达2.71k QPS，这个应该是CPU高的原因。</p>
<p>执行一下explain看一下：<br><img data-src="/images/mysql5.png" alt="paradin"></p>
<p>然后有用<code>show columns from pcs_sys_user;</code>、<code>show index from pcs_sys_user;</code>和<code>show columns from macuserinfo;</code>、<code>show index from macuserinfo;</code>查看一下是否有漏建索引，发现没有，比如：<br><img data-src="/images/mysql6.png" alt="paradin"></p>
<p>这种就是典型的“QPS高导致CPU使用率高”的场景：查询语句比较简单、执行效率高、SQL优化余地小。一般解决的方法就是从应用架构、实例规格等方面入手：</p>
<ol>
<li>升级实例规格，增加CPU资源；</li>
<li>做了分库分表，将查询压力分担到多个RDS实例上；</li>
<li>使用批量操作，将多个操作合并为一次请求，但此种方式需要考虑是否可以一次批量的数据有多大，避免造成慢sql；</li>
</ol>
<h2 id="后续措施"><a href="#后续措施" class="headerlink" title="后续措施"></a>后续措施</h2><p>如上文所说，这个数据库里的sleep的进程也太多了，大量的sleep进程无法及时释放，也拖累系统性能，不过也不能把这个指设置的过小，否则可能会遭遇到<code>MySQL has goneaway</code>之类的问题，默认的等待时间是28000秒，如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MySQL [easyip]&gt; show <span class="keyword">global</span> variables like <span class="string">&#x27;wait_timeout&#x27;</span>;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| wait_timeout  | <span class="number">28800</span> |</span><br><span class="line">+---------------+-------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>改成3600就够用了…</p>
<p>注意！本文中的例子里where条件是经常变化的，所以这种场合没有打开<code>query_cache</code>。对于经常修改的表，使用查询缓存可能会加大副本滞后，因为缓存已锁定且会频繁刷新。而对于查询数据比较静态、查询重复度高、查询结果集小于3MB的场景，才考虑开启查询缓存。</p>
<p>最后，本次故障排查感谢arstercz大神的鼎力相助！<br><img data-src="/images/%E6%A8%B1%E6%9C%A8%E6%89%A3%E9%98%BF%E7%89%A7.png" alt="akb48"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://docs.aws.amazon.com/zh_cn/AmazonRDS/latest/UserGuide/CHAP_Troubleshooting.html">https://docs.aws.amazon.com/zh_cn/AmazonRDS/latest/UserGuide/CHAP_Troubleshooting.html</a><br><a href="https://aws.amazon.com/cn/blogs/china/pt-query-digest-rds-mysql-slow-searchnew/">https://aws.amazon.com/cn/blogs/china/pt-query-digest-rds-mysql-slow-searchnew/</a><br><a href="https://jin-yang.github.io/post/mysql-monitor.html">https://jin-yang.github.io/post/mysql-monitor.html</a><br><a href="https://tech.kujiale.com/shu-ju-ku-cpushi-yong-lu-100-pai-cha-ji/">https://tech.kujiale.com/shu-ju-ku-cpushi-yong-lu-100-pai-cha-ji/</a><br><a href="http://mysql.taobao.org/monthly/2015/05/02/">http://mysql.taobao.org/monthly/2015/05/02/</a> （强力推荐！）</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>AWS</tag>
        <tag>mysql</tag>
        <tag>主从同步</tag>
      </tags>
  </entry>
  <entry>
    <title>解决微信不支持阿里云OSS域名的问题</title>
    <url>/2019/04/29/%E8%A7%A3%E5%86%B3%E5%BE%AE%E4%BF%A1%E4%B8%8D%E6%94%AF%E6%8C%81%E9%98%BF%E9%87%8C%E4%BA%91OSS%E5%9F%9F%E5%90%8D%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>阿里云OSS的元素（除了图片）是无法通过微信小程序&#x2F;微信聊天直接打开的，会爆“已停止访问该网页”的错误，如图：<br><img data-src="/images/wechat1.jpg" alt="akb48"></p>
<p>但是复制url地址到手机浏览器是可以正常访问的，无疑这样对于用户来说是一个很不好的体验，因为腾讯屏蔽了阿里云的相关元素地址。所以为了解决这个问题，需要登录OSS后台，在对应的bucket里，点击“域名管理”，然后“绑定用户域名”，在里面输入一个域名即可。如果是HTTPS访问，还需要点击“证书托管”，把域名证书上传到阿里云OSS里，如图：<br><img data-src="/images/wechat2.jpg" alt="akb48"></p>
<p>这样就可以用自定义的域名去替代阿里云OSS的基础域名（<a href="http://xxxx.oss-cn-hangzhou.aliyuncs.com/%EF%BC%89%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%BE%AE%E4%BF%A1%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%AD%A3%E5%B8%B8%E6%89%93%E5%BC%80%E4%BA%86%EF%BC%9A">http://XXXX.oss-cn-hangzhou.aliyuncs.com/），这样微信就可以正常打开了：</a><br><img data-src="/images/wechat3.jpg" alt="akb48"></p>
<p><img data-src="/images/%E5%AD%97%E6%AF%8D%E5%93%A5%E8%A2%AB%E5%B8%BD.gif" alt="akb48" title="字母哥惨遭两帽"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>阿里云oss</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次mysql无法启动的解决过程</title>
    <url>/2018/03/12/%E8%AE%B0%E4%B8%80%E6%AC%A1mysql%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>今天开发人员反馈一个问题，就是某一台开发环境机器的mysql无法启动了，但是如果这台服务器重启的话，mysql就好使，而第二天就会出现mysql死掉然后无法启动的情况。我使用<code>service mysqld restart</code>，命令行反馈如下的内容：<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@iZ2373j9xivZ data]# service mysqld restart</span><br><span class="line"><span class="title class_">MySQL</span> server <span class="variable constant_">PID</span> file could not be found!                  [<span class="variable constant_">FAILED</span>]    </span><br><span class="line"><span class="title class_">Starting</span> <span class="title class_">MySQL</span>........<span class="property">The</span> server quit without updating <span class="variable constant_">PID</span> <span class="title function_">file</span> (<span class="regexp">/data/my</span>sql/data/sock/mysql.<span class="property">pid</span>).                                                         [<span class="variable constant_">FAILED</span>]</span><br></pre></td></tr></table></figure></p>
<p>打开错误日志看一下，里面是这么写的：<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">2018</span>-<span class="number">03</span>-<span class="number">10</span> <span class="number">00</span>:<span class="number">26</span>:<span class="number">24</span> <span class="number">25919</span> [<span class="title class_">Note</span>] <span class="title class_">InnoDB</span>: <span class="title class_">Using</span> <span class="variable constant_">CPU</span> crc32 instructions</span><br><span class="line"><span class="number">2018</span>-<span class="number">03</span>-<span class="number">10</span> <span class="number">00</span>:<span class="number">26</span>:<span class="number">24</span> <span class="number">25919</span> [<span class="title class_">Note</span>] <span class="title class_">InnoDB</span>: <span class="title class_">Initializing</span> buffer pool, size = <span class="number">4.</span>0G</span><br><span class="line"><span class="title class_">InnoDB</span>: <span class="title function_">mmap</span>(<span class="number">549453824</span> bytes) failed; errno <span class="number">12</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">03</span>-<span class="number">10</span> <span class="number">00</span>:<span class="number">26</span>:<span class="number">24</span> <span class="number">25919</span> [<span class="variable constant_">ERROR</span>] <span class="title class_">InnoDB</span>: <span class="title class_">Cannot</span> allocate memory <span class="keyword">for</span> the buffer pool</span><br><span class="line"><span class="number">2018</span>-<span class="number">03</span>-<span class="number">10</span> <span class="number">00</span>:<span class="number">26</span>:<span class="number">24</span> <span class="number">25919</span> [<span class="variable constant_">ERROR</span>] <span class="title class_">Plugin</span> <span class="string">&#x27;InnoDB&#x27;</span> init <span class="keyword">function</span> returned error.</span><br><span class="line"><span class="number">2018</span>-<span class="number">03</span>-<span class="number">10</span> <span class="number">00</span>:<span class="number">26</span>:<span class="number">24</span> <span class="number">25919</span> [<span class="variable constant_">ERROR</span>] <span class="title class_">Plugin</span> <span class="string">&#x27;InnoDB&#x27;</span> registration <span class="keyword">as</span> a <span class="variable constant_">STORAGE</span> <span class="variable constant_">ENGINE</span> failed.</span><br><span class="line"><span class="number">2018</span>-<span class="number">03</span>-<span class="number">10</span> <span class="number">00</span>:<span class="number">26</span>:<span class="number">24</span> <span class="number">25919</span> [<span class="variable constant_">ERROR</span>] <span class="title class_">Unknown</span>/unsupported storage <span class="attr">engine</span>: <span class="variable constant_">INNODB</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">03</span>-<span class="number">10</span> <span class="number">00</span>:<span class="number">26</span>:<span class="number">24</span> <span class="number">25919</span> [<span class="variable constant_">ERROR</span>] <span class="title class_">Aborting</span></span><br></pre></td></tr></table></figure></p>
<p>爆<code>InnoDB: mmap(549453824 bytes) failed; errno 12</code>，然后我就<code>free -m</code>查看一下，当前服务器的内存已经不够用了。<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@iZ2373j9xivZ sock]# free -m</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line"><span class="title class_">Mem</span>:          <span class="number">7869</span>       <span class="number">7747</span>        <span class="number">121</span>          <span class="number">0</span>         <span class="number">16</span>         <span class="number">15</span></span><br><span class="line">-<span class="regexp">/+ buffers/</span><span class="attr">cache</span>:       <span class="number">7716</span>        <span class="number">152</span></span><br><span class="line"><span class="title class_">Swap</span>:            <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span> </span><br></pre></td></tr></table></figure></p>
<p>那么是什么在占用这台服务器的内存？使用<code>ps aux | sort -k4nr |head -5</code> 这个命令查找当前占用内存最大的五个进程一看，全是<code>php-fpm</code>，同时也发现服务器里面运行大量的<code>php-fpm</code>，在征得开发人员的同意之后，重启<code>php-fpm</code>进程，内存空出来很多。</p>
<p>此时再次<code>service mysqld restart</code>，发现mysql的错误日志改成如下的样子了：<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">2018</span>-<span class="number">03</span>-<span class="number">12</span> <span class="number">10</span>:<span class="number">53</span>:<span class="number">42</span> <span class="number">28238</span> [<span class="title class_">Note</span>] <span class="title class_">InnoDB</span>: <span class="title class_">Highest</span> supported file format is <span class="title class_">Barracuda</span>.</span><br><span class="line"><span class="number">2018</span>-<span class="number">03</span>-<span class="number">12</span> <span class="number">10</span>:<span class="number">53</span>:<span class="number">42</span> <span class="number">28238</span> [<span class="title class_">Note</span>] <span class="title class_">InnoDB</span>: <span class="title class_">The</span> log sequence numbers <span class="number">16939991440</span> and <span class="number">16939991440</span> <span class="keyword">in</span> ibdata files <span class="keyword">do</span> not match the log sequence number <span class="number">16940121908</span> <span class="keyword">in</span> the ib_logfiles!</span><br><span class="line"><span class="number">2018</span>-<span class="number">03</span>-<span class="number">12</span> <span class="number">10</span>:<span class="number">53</span>:<span class="number">42</span> <span class="number">28238</span> [<span class="title class_">Note</span>] <span class="title class_">InnoDB</span>: <span class="title class_">Database</span> was not shutdown normally!</span><br><span class="line"><span class="number">2018</span>-<span class="number">03</span>-<span class="number">12</span> <span class="number">10</span>:<span class="number">53</span>:<span class="number">42</span> <span class="number">28238</span> [<span class="title class_">Note</span>] <span class="title class_">InnoDB</span>: <span class="title class_">Starting</span> crash recovery.</span><br></pre></td></tr></table></figure></p>
<p>这次变成了<code>The log sequence numbers 16939991440 and 16939991440 in ibdata files do not match the log sequence number 16940121908 in the ib_logfiles!</code>，我打开<code>my.cnf</code>，适当的调小了<code>max_connections</code>和<code>innodb_buffer_pool_size</code>，然后<code>service mysqld restart</code>的时候发现错误又变了：<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">2018</span>-<span class="number">03</span>-<span class="number">12</span> <span class="number">11</span>:<span class="number">03</span>:<span class="number">57</span> <span class="number">29190</span> [<span class="title class_">Note</span>] <span class="title class_">InnoDB</span>: <span class="number">5.6</span><span class="number">.27</span> started; log sequence number <span class="number">16940121918</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">03</span>-<span class="number">12</span> <span class="number">11</span>:<span class="number">03</span>:<span class="number">57</span> <span class="number">29190</span> [<span class="title class_">Note</span>] <span class="title class_">Server</span> <span class="title function_">hostname</span> (bind-address): <span class="string">&#x27;*&#x27;</span>; <span class="attr">port</span>: <span class="number">3306</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">03</span>-<span class="number">12</span> <span class="number">11</span>:<span class="number">03</span>:<span class="number">57</span> <span class="number">29190</span> [<span class="title class_">Note</span>] <span class="title class_">IPv6</span> is not available.</span><br><span class="line"><span class="number">2018</span>-<span class="number">03</span>-<span class="number">12</span> <span class="number">11</span>:<span class="number">03</span>:<span class="number">57</span> <span class="number">29190</span> [<span class="title class_">Note</span>]   - <span class="string">&#x27;0.0.0.0&#x27;</span> resolves to <span class="string">&#x27;0.0.0.0&#x27;</span>;</span><br><span class="line"><span class="number">2018</span>-<span class="number">03</span>-<span class="number">12</span> <span class="number">11</span>:<span class="number">03</span>:<span class="number">57</span> <span class="number">29190</span> [<span class="title class_">Note</span>] <span class="title class_">Server</span> socket created on <span class="attr">IP</span>: <span class="string">&#x27;0.0.0.0&#x27;</span>.</span><br><span class="line"><span class="number">2018</span>-<span class="number">03</span>-<span class="number">12</span> <span class="number">11</span>:<span class="number">03</span>:<span class="number">57</span> <span class="number">29190</span> [<span class="variable constant_">ERROR</span>] <span class="title class_">Can</span><span class="string">&#x27;t start server : Bind on unix socket: Permission denied    </span></span><br><span class="line"><span class="string">2018-03-12 11:03:57 29190 [ERROR] Do you already have another mysqld server running on socket: /data/mysql/data/sock/mysql.sock ?</span></span><br><span class="line"><span class="string">2018-03-12 11:03:57 29190 [ERROR] Aborting</span></span><br></pre></td></tr></table></figure></p>
<p>这就是文件权限问题了，我再次打开<code>my.cnf</code>发现里面的<code>user</code>填写的是<code>mysql</code>，那么把<code>/data/mysql/data/sock/mysql.sock</code>这一系列的文件的所属人都改成了<code>mysql</code>用户，这一次重启mysql就OK了。</p>
<p>为什么这个<code>mysql</code>会好好的突然自动死掉呢？我发现日志里面有这样的字样：<code>InnoDB: Database was not shutdown normally!</code>，于是我猜想很有可能是<code>php-fpm</code>这进程不断地增长，占用的内存太大，导致<code>mysql</code>被<code>linux</code>的内核杀死了。于是查看<code>/var/log/message</code>的文件，结合mysql的错误日志时间找到了如下的字样：<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Mar</span> <span class="number">10</span> <span class="number">00</span>:<span class="number">26</span>:<span class="number">22</span> iZ2373j9xivZ <span class="attr">kernel</span>: <span class="title class_">Out</span> <span class="keyword">of</span> <span class="attr">memory</span>: <span class="title class_">Kill</span> process <span class="number">1883</span> (mysqld) score <span class="number">53</span> or sacrifice child</span><br><span class="line"><span class="title class_">Mar</span> <span class="number">10</span> <span class="number">00</span>:<span class="number">26</span>:<span class="number">22</span> iZ2373j9xivZ <span class="attr">kernel</span>: <span class="title class_">Killed</span> process <span class="number">1883</span>, <span class="variable constant_">UID</span> <span class="number">501</span>, (mysqld) total-<span class="attr">vm</span>:6849508kB, anon-<span class="attr">rss</span>:429368kB, file-<span class="attr">rss</span>:176kB</span><br><span class="line"><span class="title class_">Mar</span> <span class="number">10</span> <span class="number">04</span>:<span class="number">11</span>:<span class="number">38</span> iZ2373j9xivZ <span class="attr">kernel</span>: php-fpm invoked oom-<span class="attr">killer</span>: gfp_mask=<span class="number">0x201da</span>, order=<span class="number">0</span>, oom_adj=<span class="number">0</span>, oom_score_adj=<span class="number">0</span></span><br><span class="line"><span class="title class_">Mar</span> <span class="number">10</span> <span class="number">04</span>:<span class="number">11</span>:<span class="number">38</span> iZ2373j9xivZ <span class="attr">kernel</span>: php-fpm cpuset=/ mems_allowed=<span class="number">0</span></span><br><span class="line"><span class="title class_">Mar</span> <span class="number">10</span> <span class="number">04</span>:<span class="number">11</span>:<span class="number">38</span> iZ2373j9xivZ <span class="attr">kernel</span>: <span class="title class_">Pid</span>: <span class="number">4375</span>, <span class="attr">comm</span>: php-fpm <span class="title class_">Not</span> tainted <span class="number">2.6</span><span class="number">.32</span>-<span class="number">431.23</span><span class="number">.3</span>.<span class="property">el6</span>.<span class="property">x86_64</span> #<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>证据确凿，<code>php-fpm</code>的无休止增长导致服务器的可用内存变小，最后内核把<code>mysql</code>杀死，修改<code>php-fpm</code>的文件之后，暂时好了点…</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://robinchen.me/tech/2016/03/14/tech-aliyun-centos-mysql-shutdown-itself-irregularly.html">http://robinchen.me/tech/2016/03/14/tech-aliyun-centos-mysql-shutdown-itself-irregularly.html</a><br><a href="http://www.wisedream.net/2017/12/20/traps/mysql-corrupt/">http://www.wisedream.net/2017/12/20/traps/mysql-corrupt/</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>运维技术</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次阿里云oss云存储删除失败的问题</title>
    <url>/2018/04/27/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%98%BF%E9%87%8C%E4%BA%91oss%E4%BA%91%E5%AD%98%E5%82%A8%E5%88%A0%E9%99%A4%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>公司每天云存储都要删除过期的内容，工作细节是这样的：每天零点，采集模块开始收集应该删除掉的内容，然后把这个消息传给阿里云MQ，阿里云MQ又把消息传给删除模块，删除模块拿到名单之后，开始调用阿里云OSS的删除API进行删除。架构如图：<br><img data-src="/images/oss6.png" alt="paradin"></p>
<p>但是今天登陆监控平台发现，昨天oss没有删除，上涨了80多个T，如图：<br><img data-src="/images/oss1.png" alt="paradin"></p>
<p>老板一看，卧槽这怎么可以，80多个T的云存储费用可是不容小视的，于是责令追查一下为啥会发生这样的情况。</p>
<p>昨天我的手机又没有收到任何阿里云消息队列告警的信息，可见MQ应该是没问题的，查看一下是否有MQ的产生和消费情况，如下图：<br><img data-src="/images/oss2.png" alt="paradin" title="这个是消息产生情况"></p>
<p><img data-src="/images/oss3.png" alt="paradin" title="这个是消息消费情况"></p>
<p>产生的消息基本都消费掉了，由此推断之前的过程都应该是OK的。再查看一下会不会是删除模块外网带宽到期的问题，此时发现两天的流量有显著的不同：<br><img data-src="/images/oss7.png" alt="paradin" title="这个是正常的流量情况"></p>
<p><img data-src="/images/oss8.png" alt="paradin" title="这个是异常的流量情况"></p>
<p>流量明显减少，可以说是删除模块执行任务少了。于是到执行OSS删除API的模块上去抓了几个包，里面情况如下：<br><img data-src="/images/oss4.png" alt="paradin"></p>
<p>但是跑到阿里云对应的bucket里看一下文件情况，比如<code>https://lechangecloud.oss-cn-hangzhou.aliyuncs.com/lechange/4B01F1FPAGE4E9D_img/Alarm/20180427000913997_0_fa62bec6dee24cc0bee42e1ee3e75743_thumb_qcif.dav</code>这个文件，这个文件明明还在里面躺着好好的。如图：<br><img data-src="/images/oss5.png" alt="paradin"></p>
<p>文件00：27的时候就在了，但是2：53分的时候调用阿里云OSS的API去删除，明明返回了200，但是文件却没有真正的从OSS删除掉。</p>
<p>我觉得这样就拿去跟阿里云撕逼还是有点不太妥当，又回到刚刚的那个包里，我发现里面还有一些返回的内容是这样的：<br><img data-src="/images/oss9.png" alt="paradin"></p>
<p>这个图跟之前的图明显路径上不同，而这些文件在OSS上确认是被成功删除掉的，可见的确是文件路径的问题：失败的文件路径是完全路径，而成功的都是相对路径。于是就告诉开发赶快整改代码，把路径统一…</p>
<p><img data-src="/images/%E6%9C%9D%E9%9F%A9%E4%BC%9A%E9%9D%A2.png" alt="paradin" title="历史性的会面"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次nginx负载均衡配置问题</title>
    <url>/2018/04/28/%E8%AE%B0%E4%B8%80%E6%AC%A1nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="故障背景"><a href="#故障背景" class="headerlink" title="故障背景"></a>故障背景</h2><p>公司有三个实体服务器，内网IP分别是<code>10.1.82.83</code>、<code>10.1.82.84</code>、<code>10.1.82.113</code>，这三个作为源站使用专线连接到了阿里云的一台nginx服务器上，并且通过这个nginx做负载均衡展示这三个服务器里面的网页。负载均衡使用的是<code>nginx 1.12</code>版本，最外面在上一个CDN起到静态页面加速的作用。整个架构如图：<br><img data-src="/images/aliCDN2.png" alt="paradin"></p>
<p>CDN的配置界面如下：<br><img data-src="/images/aliCDN6.png" alt="paradin"></p>
<p>但是现在很奇怪的是，所有节点启动之后，外网用户通过负载后访问均指向了<code>10.1.82.84</code>这一台服务器，<code>nginx.conf</code>配置是<code>最小连接数</code>的配置，如下：<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">upstream eln.<span class="property">dahuatech</span>.<span class="property">com</span> &#123;</span><br><span class="line">      #ip_hash;</span><br><span class="line">      #hash $http_x_forwarded_for;</span><br><span class="line">      #sticky;</span><br><span class="line">      least_conn;</span><br><span class="line">      server  <span class="number">10.1</span><span class="number">.82</span><span class="number">.83</span> max_fails=<span class="number">2</span> fail_timeout=30s;</span><br><span class="line">      server  <span class="number">10.1</span><span class="number">.82</span><span class="number">.84</span> max_fails=<span class="number">2</span> fail_timeout=30s;</span><br><span class="line">      server  <span class="number">10.1</span><span class="number">.82</span><span class="number">.113</span> max_fails=<span class="number">2</span> fail_timeout=30s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        server_name  eln.<span class="property">dahuatech</span>.<span class="property">com</span>;</span><br><span class="line">            listen     <span class="number">80</span>;</span><br><span class="line">            listen     <span class="number">443</span> ssl;</span><br><span class="line"></span><br><span class="line">        access_log logs/eln.<span class="property">dahuatech</span>.<span class="property">com</span>.<span class="property">access</span>.<span class="property">log</span> main;</span><br><span class="line">        error_log  logs/eln.<span class="property">dahuatech</span>.<span class="property">com</span>.<span class="property">error</span>.<span class="property">log</span>;</span><br><span class="line"></span><br><span class="line">        proxy_set_header <span class="title class_">Host</span> <span class="attr">$host</span>:$server_port;</span><br><span class="line">        proxy_set_header X-<span class="title class_">Real</span>-<span class="variable constant_">IP</span> $remote_addr;</span><br><span class="line">        proxy_set_header <span class="variable constant_">REMOTE</span>-<span class="variable constant_">HOST</span> $remote_addr;</span><br><span class="line">        proxy_set_header X-<span class="title class_">Forwarded</span>-<span class="title class_">For</span> $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line">   location / &#123;</span><br><span class="line">            proxy_pass <span class="attr">http</span>:<span class="comment">//eln.dahuatech.com;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试的时候发现，即使绑定美国和香港的节点去<code>curl</code>，是能正常解析到其他机器上的。如下：<br><img data-src="/images/aliCDN3.png" alt="paradin"></p>
<p>然而源站过来的请求IP集中到了只有一个，这太奇怪了。</p>
<h2 id="故障解决"><a href="#故障解决" class="headerlink" title="故障解决"></a>故障解决</h2><p>后来发现<font color=red>ngnix后端会把http1.1转换成1.0变成短连接</font>，这个连接存在的时间非常短，因为后端响应非常快。所以即使配上了<code>least_conn</code>，其实是没有任何效果的。这样负载均衡的nginx看到所有源站其实一直都是没有连接的，所以也就一直在给第一个转。</p>
<p>既然这样，就取消了<code>least_conn</code>改用轮询，nginx.conf也改成如下的样子：<br><img data-src="/images/aliCDN1.png" alt="paradin"></p>
<p>最后终于均衡了，大功告成！<br><img data-src="/images/aliCDN5.png" alt="paradin"></p>
<p>后来琢磨了一下，是用sticky其实也是OK的。</p>
<p>所以说，有些情景使用域名不通的情况下，可以考虑直接使用IP，这样就绕过nginx了，不会破坏原来的长连接。</p>
<h2 id="几个主流负载均衡软件配置cookie的方法"><a href="#几个主流负载均衡软件配置cookie的方法" class="headerlink" title="几个主流负载均衡软件配置cookie的方法"></a>几个主流负载均衡软件配置cookie的方法</h2><p>1.Apache的话首先打开<code>httpd.conf</code>配置文件，确保如下配置没有被注释。<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">LoadModule</span> usertrack_module modules/mod_usertrack.<span class="property">so</span></span><br></pre></td></tr></table></figure></p>
<p>再在<code>virtual host</code>中添加以下配置。<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">CookieName</span> name</span><br><span class="line"><span class="title class_">CookieExpires</span> <span class="string">&quot;1 days&quot;</span></span><br><span class="line"><span class="title class_">CookieStyle</span> <span class="title class_">Cookie</span></span><br><span class="line"><span class="title class_">CookieTracking</span> on</span><br></pre></td></tr></table></figure></p>
<p>2.Nginx参考以下配置，设置Cookie。<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">8080</span>;</span><br><span class="line">    server_name wqwq.<span class="property">example</span>.<span class="property">com</span>;</span><br><span class="line">    location / &#123;</span><br><span class="line">      add_header <span class="title class_">Set</span>-<span class="title class_">Cookie</span> name=xxxx;</span><br><span class="line">        root   html;</span><br><span class="line">        index  index.<span class="property">html</span> index.<span class="property">htm</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.Lighttpd参考以下配置，设置Cookie。<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server.<span class="property">modules</span>  = ( <span class="string">&quot;mod_setenv&quot;</span> )</span><br><span class="line">$HTTP[<span class="string">&quot;host&quot;</span>] == <span class="string">&quot;test.example.com&quot;</span> &#123;</span><br><span class="line">      server.<span class="property">document</span>-root = <span class="string">&quot;/var/www/html/&quot;</span></span><br><span class="line">      setenv.<span class="property">add</span>-response-header = ( <span class="string">&quot;Set-Cookie&quot;</span> =&gt; <span class="string">&quot;name=XXXXXX&quot;</span>      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p><a href="https://cloud.tencent.com/document/product/214/2736">https://cloud.tencent.com/document/product/214/2736</a><br><a href="http://blog.text.wiki/2015/08/01/nginx-sticky-problem.html">http://blog.text.wiki/2015/08/01/nginx-sticky-problem.html</a><br><a href="https://cloud.tencent.com/developer/article/1004547">https://cloud.tencent.com/developer/article/1004547</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>记录Apache Storm的部署始末</title>
    <url>/2018/02/25/%E8%AE%B0%E5%BD%95Apache-Storm%E7%9A%84%E9%83%A8%E7%BD%B2%E5%A7%8B%E6%9C%AB/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Storm</code>是一个流式处理框架（你可以把它当成一种消息队列），开发人员开发出特定的项目，然后通过storm这个渠道下发各种任务，从而达到任务执行的效果。</p>
<p>Storm有两个比较重要的组件：<code>nimbus</code>和<code>supervision</code>，其中<code>nimbus</code>主要是承接任务和分配任务用，而每一个<code>supervision</code>可以有若干<code>worker</code>（视服务器硬件而定），而<code>supervison</code>的主要任务就是监控对应的<code>worker</code>，一旦<code>worker</code>死了，<code>supervision</code>就会把他们唤醒。</p>
<p>本次试验是用的是金山云服务器，storm的版本是<code>1.0.2</code>，配置是<code>1个nimbus，三个supervision</code>，每一个worker上只执行一个任务，总共三个任务。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>安装<code>storm</code>之前需要在<code>storm</code>里新安装一套<code>zookeeper</code>，因为<code>storm</code>是需要一个zk集群的，<code>nimbus</code>和每一个<code>supervisior</code>是通过zk的心跳来传递存活的信息，于是我们就在每一个<code>supervision</code>里面安装一个<code>zookeeper</code>，并且启动<code>zookeeper</code>的<code>server</code>端，安装<code>zookeeper</code>的方法可以移步<a href="http://chenx1242.blog.51cto.com/10430133/1889715">http://chenx1242.blog.51cto.com/10430133/1889715</a> 。</p>
<p>上面这段话用图来说就是这样子：<br><img data-src="/images/storm1.jpg" alt="paradin"></p>
<p>启动<code>zookeeper</code>之后，就需要在<code>nimbus</code>和<code>supervisior</code>里安装<code>storm</code>，上面说过本次安装的<code>storm</code>是<code>1.0.2</code>版本，路径直接是<code>/storm/apache-storm-1.0.2</code>。</p>
<p>将<code>storm</code>安装完之后，需要在<code>nimbus</code>和<code>supervisior</code>里更改<code>/etc/hosts</code>文件，改成如下的格式：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> localhost</span><br><span class="line"> </span><br><span class="line">nimbus的内网<span class="variable constant_">IP</span> online-nimbus-<span class="number">001</span></span><br><span class="line">supervision1的内网<span class="variable constant_">IP</span> supervision-<span class="number">001</span></span><br><span class="line">supervision2的内网<span class="variable constant_">IP</span> supervision-<span class="number">002</span></span><br><span class="line">supervision3的内网<span class="variable constant_">IP</span> supervision-<span class="number">003</span></span><br><span class="line"> </span><br><span class="line">zookeeper的内网<span class="variable constant_">IP</span> zookeeper的名称            #注意，这里的zk是给模块拉取配置的zk</span><br><span class="line">storm的zk1的内网<span class="variable constant_">IP</span> storm的zk1            #这里的zk就是给storm集群用的zk</span><br><span class="line">storm的zk2的内网<span class="variable constant_">IP</span>  storm的zk2                      #如果storm的zk是standalone模式，这里就不要写了。</span><br><span class="line">storm的zk3的内网<span class="variable constant_">IP</span>  storm的zk3                      #如果storm的zk是standalone模式，这里就不要写了。</span><br></pre></td></tr></table></figure></p>
<p>保存完<code>/etc/hosts</code>之后，还有一个比较重要的步骤，就是在<code>/etc/ld.so.conf.d/</code>这个路径里面建立一个<code>ffmped.conf</code>这个文件，文件的内容如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/storm/apache-storm-<span class="number">1.0</span><span class="number">.2</span>/lib</span><br><span class="line">/storm/apache-storm-<span class="number">1.0</span><span class="number">.2</span>/lib/3rd</span><br></pre></td></tr></table></figure></p>
<p>注意，<code>/storm/apache-storm-1.0.2</code>是我的storm路径，在实际情况下需要根据自己的路径进行更改。</p>
<p>把这个<code>ffmped.conf</code>建立成功之后，我们可以测试一下，如果输入<code>ldconfig</code>的话，会出现如下的内容，就证明达到了我们的效果：<br><img data-src="/images/storm2.jpg" alt="paradin"></p>
<p><code>storm</code>本身的<code>bin</code>目录夹里也有很多命令可以直接使用，为了调用<code>storm list</code>方便，我们需要把<code>bin/storm</code>这个可执行文件作一个软连接，方法就是先<code>cd /usr/local/bin/</code>，然后<code>ln -s /storm/apache-storm-1.0.2/bin/storm storm</code>。这样的话，我们就可以直接使用<code>storm list</code>来查看任务列表了。</p>
<h2 id="Storm的具体配置"><a href="#Storm的具体配置" class="headerlink" title="Storm的具体配置"></a>Storm的具体配置</h2><p>安装了<code>storm</code>，调整了命令行，同时也搞定了<code>ffmpeg.conf</code>，下面就是调整<code>storm</code>的配置文件了，<code>nimbus</code>和<code>supervisior</code>都要修改。</p>
<p>storm的配置文件叫<code>storm.yaml</code>，路径位于<code>storm</code>文件夹下的<code>/conf/</code>文件夹，我们需要在这个文件里面输入如下的内容：<br><img data-src="/images/storm3.png" alt="paradin"></p>
<p>下面对配置文件作一个简单的解释：<br>1）storm.zookeeper.port:zk的默认端口2181；<br>2）storm.cluster.mode:storm的集群运行模式，这里我们也是采用默认的distributed（分布式）；<br>3）storm.local.dir:storm使用的本地文件的目录，这个目录必须存在而且storm进程可读写；<br>4）supervisor.slots.ports：这个地方在nimbus里可以不用管，但是在supervisior里是需要改的，如果你只打开6700，那么就只放开了6700端口，即只有一个worker，如果你打开了6700、6701、6702三个端口，那么就意味这个supervisior将有三个worker在工作，由于这次试验里我们每一个supervisor只开启一个任务，所以在supervisior的storm.yaml里这个节点就只保留6700，其他的就全部注释掉；<br>5）nimbus.task.launch.secs:task启动时的一个特殊超时设置.在启动后第一次心跳前会使用该值来临时替代nimbus.task.timeout.secs；<br>6）worker.childopts:设定每个worker (JVM任务)的最小和最大内存；</p>
<p>更改完了<code>storm.yaml</code>之后，就要在<code>nimbus</code>里面安装<code>zkclient</code>。直接复制粘贴过来就好了。</p>
<p>如果你不喜欢<code>storm</code>自带的日志格式，想更改一下日志的内容，那么就要在<code>/storm/apache-storm-1.0.2/log4j2</code>文件夹里面修改<code>worker.xml</code>，不过在这里善意的提醒，最好在修改之前先备份原有的<code>worker.xml</code>。</p>
<h2 id="连接具体任务"><a href="#连接具体任务" class="headerlink" title="连接具体任务"></a>连接具体任务</h2><p>这次的实验包用的是我所在的公司开发内部使用的包，先把这个包的内容复制到<code>/storm/</code>文件夹下，同时<code>mkdir install</code>和<code>makir properties</code>这两个文件夹，在<code>install</code>文件夹里有开发写的任务的<code>jar</code>包和启动程序，如下：<br><img data-src="/images/storm4.png" alt="paradin"></p>
<p>而在<code>properties</code>文件夹里，应该有这个任务的配置文件，如下：<br><img data-src="/images/storm5.png" alt="paradin"></p>
<p>由于我们已经事前在<code>/etc/hosts</code>里指定了zkclient需要访问的zk的ip地址了，那么如果zk项配置正确，zkclient这个时候是可以成功启动的。同时在<code>install</code>文件夹里<code>./update_stormserver_config.sh</code>也应该是反应正确的。</p>
<p>然后我们就可以启动storm了。</p>
<h2 id="启动nimbus和supervision"><a href="#启动nimbus和supervision" class="headerlink" title="启动nimbus和supervision"></a>启动nimbus和supervision</h2><p>启动<code>storm</code>要先启动<code>nimbus</code>，在<code>/storm/apache-storm-1.0.2/bin</code>里面启动<code>run_nimbus.sh</code>，然后等一下会有一大片东西出现，再<code>jps</code>一下就能看到<code>nimbus</code>已经启动了，如图：<br><img data-src="/images/storm6.png" alt="paradin"></p>
<p>从上图我们可以看到，18141的进程就是<code>zkclient</code>，只不过在<code>jps</code>里它名字叫<code>AppServerDaemon</code>，而<code>zkServer</code>在<code>jps</code>里叫<code>QuorumPeerMain</code>。</p>
<p>如果 <code>storm</code>出现<code>Did you specify a valid list of nimbus hosts for config nimbus.seeds?</code>的错误提示，那么就是<code>nimbus</code>没有启动的缘故。</p>
<p>启动了<code>nimbus</code>之后，就可以在<code>supervisor</code>的机器里去效仿着启动<code>supervisor</code>，但是这里要注意，如果你开启了一个<code>supervisior</code>，那么按照我们上面的配置文件，就启动了一个6700端口的<code>worker</code>，这个时候在<code>nimbus</code>执行下派一个任务的命令，<code>nimbus</code>就会下派这个任务给这个<code>worker</code>。</p>
<p>下派命令的例子如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">storm jar storm-starter-<span class="number">0.9</span><span class="number">.2</span>-incubating-jar-<span class="keyword">with</span>-dependencies.<span class="property">jar</span> com.<span class="property">lechange</span>.<span class="property">recordshare</span>.<span class="property">RecordShareTopology</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>这样就启动了一个叫<code>videoshare</code>的任务，这个任务只用1个<code>worker</code>。</p>
<p>如果在命令行里反馈这样的错误：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Error</span>: <span class="title class_">Could</span> not find or load main <span class="keyword">class</span> <span class="title class_">storm</span>.<span class="property">starter</span>.<span class="property">recordshare</span>.<span class="property">RecordShareTopology</span></span><br></pre></td></tr></table></figure></p>
<p>或者<code>exception in thread main java.lang.NoClassDefFoundError</code>这样的错误，那就要检查jar包和路径。</p>
<p>而如果你再打开一个<code>supervisor</code>，在<code>nimbus</code>端又下发了一个任务，那么这个任务就会给刚刚新启动的<code>supervisor</code>。这样，启动一个下发一个，就会对每一个<code>worker</code>具体干的任务情况有一个比较清晰的了解。<br><img data-src="/images/storm7.png" alt="paradin"></p>
<p>在nimbus上执行<code>storm list</code>，就可以获得上图的样子，可以看出，我在nimbus端下发了三个任务，就是<code>topology_name</code>这一栏，他们的状态也是<code>active</code>，而<code>workers</code>数量都是1，也就是说在那三台<code>supervisor</code>里都在工作。而跑到<code>supervisor</code>一看日志，也是对应有各自的任务日志。</p>
<p>至此整个storm和具体的模块工作的搭建就完成了。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>如果你事前一口气把三个<code>supervisor</code>都打开了，即开启了3个<code>worker</code>，然后一口气在<code>nimbus</code>端，一口气输入了三个下发任务的命令，那么这三个命令会随机的到这三个<code>worker</code>里，没有任何顺序而言，你只能通过日志的关键词来判断具体的<code>worker</code>做哪些任务。</p>
<p>而如果你的worker数量少于<code>nimbus</code>下发任务的数量，会有什么反应呢？</p>
<p>答案就是任务根本没有<code>worker</code>去干，在<code>storm list</code>里，多余的任务对应的<code>num_workers</code>的数字是0，而如果这个时候你新增一个<code>supervisor</code>到这个<code>storm</code>集群，那么这个任务就会吭哧吭哧开始工作了。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>大数据分析</tag>
        <tag>storm</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次配置rewrite和return的经历</title>
    <url>/2018/01/09/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%85%8D%E7%BD%AErewrite%E5%92%8Creturn%E7%9A%84%E7%BB%8F%E5%8E%86/</url>
    <content><![CDATA[<h2 id="前言与需求"><a href="#前言与需求" class="headerlink" title="前言与需求"></a>前言与需求</h2><p>自动电商平台归属了大数据研究院之后，我又恢复了那个“把nginx当成爸爸”的日子。开发不断地提出了的要求，我一样一样的疲命应付，并且在应付后记录下来，就怕以后再遇到类似的问题。</p>
<p>这次的需求是一个跳转，满足某个条件之后把<code>“http://dvlshop.lechange.com/index.php/wap/?client_id=lc_mall_m&amp;redirect_uri=https%3A%2F%2Fdvlshop.lechange.com%2Fopenapi%2Ftrustlogin_api%2Fparse%2Fwap_trustlogin_lecheng%2Fcallback&amp;response_type=code&amp;scope=read&amp;state=http%3A%2F%2Fdvlshop.lechange.com%2Findex.php%2Fwap&amp;user=token%2Flcid_9f9lmo2u6i7hkl6t6eaodn2blmg5jbsg&amp;expire=1514191636&amp;source_type=lc_app&amp;nonce=cdizHO6uvSx5JK79Kmtz5RBpSi0ROhpF&amp;signature=VeCceYCWDE6BZjIdni/68YCmhqc=%27 ”</code><br>改成<br><code>“http://dvlshop.lechange.com/index.php/wap/?client_id=lc_mall_m&amp;redirect_uri=https%3A%2F%2Fdvlshop.lechange.com%2Fopenapi%2Ftrustlogin_api%2Fparse%2Fwap_trustlogin_lecheng%2Fcallback&amp;=code&amp;scope=read&amp;state=http%3A%2F%2Fdvlshop.lechange.com%2Findex.php%2Fwap&amp;user=token%2Flcid_9f9lmo2u6i7hkl6t6eaodn2blmg5jbsg&amp;expire=1514191636&amp;source_type=lc_app&amp;nonce=cdizHO6uvSx5JK79Kmtz5RBpSi0ROhpF&amp;signature=VeCceYCWDE6BZjIdni/68YCmhqc=%27”</code></p>
<p>具体条件是: </p>
<ol>
<li><pre><code>  先判断是否有source_type=lc_app；
</code></pre>
</li>
<li><pre><code>  再判断是否有response_type；
</code></pre>
</li>
<li><pre><code>  如果以上两个都满足，将“response_type”改成“+auto+”；
</code></pre>
</li>
</ol>
<p>各位看官，我理解你们此时不想继续看下去的心情，其实我当初看着那么一大坨uri心里也直犯闹，但是没办法，“食君之禄，分君之忧”，我只能耐着性子一个一个的拆开，还别说，拆开的话就清晰许多了，如下：<br><a href="http://dvlshop.lechange.com/index.php/wap/">http://dvlshop.lechange.com/index.php/wap/</a>?<br><em>client_id</em>&#x3D;lc_mall_m&amp;<br><em>redirect_uri</em>&#x3D;https%3A%2F%2Fdvlshop.lechange.com%2Fopenapi%2Ftrustlogin_api%2Fparse%2Fwap_trustlogin_lecheng%2Fcallback&amp;<br><em>response_type</em>&#x3D;code&amp;	<code>#满足条件的话把这个改成+auto+</code><br><em>scope</em>&#x3D;read&amp;<br><em>state</em>&#x3D;http%3A%2F%2Fdvlshop.lechange.com%2Findex.php%2Fwap&amp;<br><em>user</em>&#x3D;token%2Flcid_9f9lmo2u6i7hkl6t6eaodn2blmg5jbsg&amp;<br><em>expire</em>&#x3D;1514191636&amp;<br><em>source_type</em>&#x3D;lc_app&amp;<br><em>nonce</em>&#x3D;cdizHO6uvSx5JK79Kmtz5RBpSi0ROhpF&amp;signature&#x3D;VeCceYCWDE6BZjIdni&#x2F;68YCmhqc&#x3D;%27 </p>
<h2 id="开始操作"><a href="#开始操作" class="headerlink" title="开始操作"></a>开始操作</h2><p>针对这次需求我的计划是这样的：把原地址看成”$1+ response_type +$2”这样的一个样式，确定$1和$2，然后rewrite成”$1+ +auto+ +$2”不就搞定了么？ 于是乎我就凭着我那二把刀的nginx技术开始动手。折腾了大约半个小时，拿出来这样一个配置：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">location ~ .*\.<span class="property">php</span>.*</span><br><span class="line">   &#123;</span><br><span class="line">       include php_fcgi.<span class="property">conf</span>;</span><br><span class="line">       include pathinfo.<span class="property">conf</span>;</span><br><span class="line">       set $flag <span class="string">&quot;0&quot;</span>;</span><br><span class="line">       <span class="keyword">if</span> ( $request_uri ~ <span class="string">&quot;source_type=lc_app&quot;</span> ) &#123;</span><br><span class="line">          set $flag  <span class="string">&quot;1&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> ( $request_uri ~ <span class="string">&quot;(.*)response_type(.*)&quot;</span> )&#123;</span><br><span class="line">          set $Flag  <span class="string">&quot;$flag$flag&quot;</span>;</span><br><span class="line">          set $id $1;</span><br><span class="line">          set $query $2;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> ($Flag = <span class="string">&quot;11&quot;</span>)&#123;	#注意这个地方是<span class="number">11</span></span><br><span class="line">           set $flag <span class="string">&quot;0&quot;</span>;</span><br><span class="line">          rewrite ^.*$ <span class="attr">http</span>:<span class="comment">//dvlshop.lechange.com/index.php/wap/$id$query last;	#前面那一段是写死的</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>但是很不幸，<code>nginx -s reload</code>之后的结果是“$1+$2+$1+ response_type +$2”的格式（地址太长太恶心了，我就不写了）。</p>
<p>然后在arstercz大神的指点下，把那句rewrite改成了<code>return 301 http://dvlshop.lechange.com/index.php/wap/?$id$query;</code>。就达到了效果。</p>
<h2 id="原因确定"><a href="#原因确定" class="headerlink" title="原因确定"></a>原因确定</h2><p>后来追寻原因，原来是： <font color=red>rewrite后面接的$uri不需要$args，因为$args会被自动带过来。而return的则会丢失$args，需要手动补上$args。</font>而我上面的$1,$2恰巧就是$args，所以用rewrite的话就会重复。举个例子，比如请求「<a href="http://localhost/?a=1%E3%80%8D%E6%83%B3%E8%A2%AB">http://localhost/?a=1」想被</a> 301 到「<a href="https://localhost/?a=1?a=1%E3%80%8D%EF%BC%8C%E8%A6%81%E4%B9%88">https://localhost/?a=1?a=1」，要么</a><br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">80</span>;</span><br><span class="line">    rewrite / <span class="attr">https</span>:<span class="comment">//$host$uri permanent;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要么就<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">80</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">301</span> <span class="attr">https</span>:<span class="comment">//$host$request_uri;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p>这里补充一下uri、request_uri、document_uri之间的区别：</p>
<ul>
<li><code>$request_uri</code>: &#x2F;stat.php?id&#x3D;1585378&amp;web_id&#x3D;1585378</li>
<li><code>$uri</code>: &#x2F;stat.php	(不带？后面)</li>
<li><code>$document_uri</code>: &#x2F;stat.php	（与uri完全相同）</li>
</ul>
<p><font color=red>注意！<code>$uri</code>和<code>$document_uri</code>同是不带参数的，但是是解码之后请求的路径，而<code>$request_uri</code>是没有解码的完整uri。这样就有一个问题，就是<code>$uri</code>是解码的，这样就可能包含换行符，CRLF就会注入漏洞。</font>详情可见 <a href="https://www.leavesongs.com/PENETRATION/nginx-insecure-configuration.html">https://www.leavesongs.com/PENETRATION/nginx-insecure-configuration.html</a> 。</p>
<p>所以说，不要偷懒少打几个字母，最好都要用<code>$request_uri</code>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/bigberg/p/7715020.html">https://www.cnblogs.com/bigberg/p/7715020.html</a><br><a href="https://blog.csdn.net/yxl0011/article/details/72818409">https://blog.csdn.net/yxl0011/article/details/72818409</a><br><a href="https://blog.csdn.net/aliencsdn/article/details/54668552">https://blog.csdn.net/aliencsdn/article/details/54668552</a></p>
<p><img data-src="/images/hugguangmei.gif" alt="抱光妹" title="《四重奏》"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>记录Uwsgi与Django成功勾搭的始末</title>
    <url>/2018/02/07/%E8%AE%B0%E5%BD%95Uwsgi%E4%B8%8EDjango%E6%88%90%E5%8A%9F%E5%8B%BE%E6%90%AD%E7%9A%84%E5%A7%8B%E6%9C%AB/</url>
    <content><![CDATA[<h2 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h2><p>Uwsgi版本：<code>2.0.14</code>(yum install安装）<br>django版本：<code>1.10.6</code>（pip install安装）<br>python版本：<code>2.7.5</code>(阿里云 centos 7自带）<br>nginx版本：<code>1.10.2</code>（yum install安装）</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在<code>https://rorschachchan.github.io/2018/02/02/Uwsgi的安装和简单使用/</code>里面，我们已经实现了网页打开出现”good bye,logan”的效果，可见<code>Web Client &lt;===&gt; uWSGI &lt;===&gt; Python</code>是通畅的，现在我们要调整看看django与uwsgi是否是通畅的。</p>
<p>首先，我们在&#x2F;django这个目录下，<code>django-admin.py startproject logan</code>，建立了一个叫logan的project，然后在&#x2F;django&#x2F;logan&#x2F;logan里会有一个自动生成的<code>wsgi.py</code>，打开一看，里面的内容如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">WSGI config for logan project.</span></span><br><span class="line"><span class="string">It exposes the WSGI callable as a module-level variable named ``application``.</span></span><br><span class="line"><span class="string">For more information on this file, see</span></span><br><span class="line"><span class="string">https://docs.djangoproject.com/en/1.10/howto/deployment/wsgi/</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> django.<span class="property">core</span>.<span class="property">wsgi</span> <span class="keyword">import</span> get_wsgi_application</span><br><span class="line">os.<span class="property">environ</span>.<span class="title function_">setdefault</span>(<span class="string">&quot;DJANGO_SETTINGS_MODULE&quot;</span>, <span class="string">&quot;logan.settings&quot;</span>)</span><br><span class="line">application = <span class="title function_">get_wsgi_application</span>()</span><br></pre></td></tr></table></figure></p>
<p>我们原来的目标就是测试django跟uwsgi的链接是否正常，那么返回到&#x2F;django&#x2F;logan，使用<code>python manage.py runserver 0.0.0.0:8000</code>启动django，然后打开浏览器，在地址栏里输入<code>外网ip:8000</code>，看到了如下的界面：<br><img data-src="/images/ud1.png" alt="paradin"></p>
<p>可见django已经启动成功，但是前面说过了，这种方法只能测试环境里小规模的玩玩，完全不推荐拿去生产化境里。所以现在我们用uwsgi在8000来启动一下django。</p>
<p>首先，先停止了原来我们启动的django。</p>
<p>然后，使用命令<code>uwsgi --http :8000 --wsgi-file logan.py</code>,反馈错误信息如下：<br><img data-src="/images/ud2.png" alt="paradin"></p>
<p>出现这个错误，那就<code>yum install uwsgi-plugin-python</code>，同时使用<code>uwsgi --plugin python --http-socket :8001 --wsgi-file /django/logan/logan/wsgi.py</code>，这样却又出了一个新错误：<br><img data-src="/images/ud3.png" alt="paradin"></p>
<p>提示说：<code>ImportError: No module named logan.settings</code>。可是当我使用python客户端单独测试的时候，这个语句是可以使用的，如图：<br><img data-src="/images/ud4.png" alt="paradin"></p>
<p>很多人都卡在了这种情况，这个时候我们需要换一个命令：<code>uwsgi --plugin python --http-socket :8001 --chdir /django/logan/ --wsgi-file /django/logan/logan/wsgi.py</code>。然后我们在浏览器地址栏里输入<code>外网地址：8001</code>就可以看到如下网页：<br><img data-src="/images/ud5.png" alt="paradin"></p>
<p>可见，我们已经通过uwsgi启动了原本已经关闭了的django，这样就达到了<code>Web Client &lt;===&gt; uWSGI &lt;===&gt; Django</code>的目的。</p>
<p>如果过程中出现了端口被占用的情况，比如8002端口已经被使用了：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">probably another instance <span class="keyword">of</span> uWSGI is running on the same <span class="title function_">address</span> (:<span class="number">8002</span>).</span><br><span class="line"><span class="title function_">bind</span>(): <span class="title class_">Address</span> already <span class="keyword">in</span> use [core/socket.<span class="property">c</span> line <span class="number">764</span>]</span><br></pre></td></tr></table></figure></p>
<p>那么就可以使用<code>lsof -i:8002</code>，然后把对应的进程干掉就好了。</p>
<p>最后附赠python脚本一个，这个脚本可以显示python的path，内容如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">print <span class="string">&#x27;===== sys.path / PYTHONPATH =====&#x27;</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="title function_">sorted</span>(os.<span class="property">environ</span>.<span class="title function_">keys</span>()):</span><br><span class="line">    v = os.<span class="property">environ</span>[k]</span><br><span class="line">    <span class="title function_">print</span> (<span class="string">&#x27;%-30s %s&#x27;</span> % (k,v[:<span class="number">70</span>]))</span><br></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.python88.com/topic/101/">http://www.python88.com/topic/101/</a><br><a href="http://www.nowamagic.net/academy/detail/1330334">http://www.nowamagic.net/academy/detail/1330334</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>uwsgi</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次优化前端docker的过程</title>
    <url>/2019/06/12/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E4%BC%98%E5%8C%96%E5%89%8D%E7%AB%AFdocker%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="最初优化"><a href="#最初优化" class="headerlink" title="最初优化"></a>最初优化</h2><p>前端node项目一直以来虽然是容器部署，但是是很粗糙的形式—每次更新的过程给各位感受一下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">先在宿主机里去项目文件夹里执行`git pull`，然后 docker <span class="built_in">exec</span> -it 容器名 /<span class="built_in">bin</span>/bash 进入到对应容器里，然后执行`pm2 flush`、`npm run build`和`pm2 reload <span class="number">0</span>`。</span><br></pre></td></tr></table></figure></p>
<p>这种拿docker做虚拟机的行为实在是让人“叔可忍婶不可忍”。于是就要改变一下这个思路，重写一个dockerfile，内容如下：<br>	<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">FROM keymetrics/pm2:latest-alpine</span><br><span class="line">MAINTAINER ChrisChan &lt;chen_shuo@dahuatech.com&gt;</span><br><span class="line"></span><br><span class="line">WORKDIR /<span class="keyword">var</span>/www/node/shopFront</span><br><span class="line">COPY shopFront/ .		#由于上面已经指定了WORKDIR的地址，所以COPY/ADD/RUN等命令的相对路径都是WORKDIR的路径，所以这里是.</span><br><span class="line">RUN git pull &amp;&amp; npm run build</span><br><span class="line">EXPOSE <span class="number">3000</span>		#暴露<span class="number">3000</span>端口</span><br><span class="line">CMD [ <span class="string">&quot;pm2&quot;</span>, <span class="string">&quot;start&quot;</span>, <span class="string">&quot;npm&quot;</span>]</span><br></pre></td></tr></table></figure></p>
<p>然后<code>docker build -t=&quot;ecnode：0.1&quot; .</code>生成镜像，<code>docker run --name ECNODE -it -p 33664:3000 ecnode:0.1</code>启动叫ECNODE的容器，发现服务站不住，启动完了后就死了。其实这里不能用<code>pm2 start npm</code>这种启动方法，应该用<code>pm2-docker start XXX.js</code>作为CMD，这样才能在后台站住。效果如图：<br><img data-src="/images/v2ray4.png" alt="akb48" title="因为有部分静态文件是存储在阿里云OSS上的，没有开放白名单就不会正常显示"></p>
<h2 id="继续折腾"><a href="#继续折腾" class="headerlink" title="继续折腾"></a>继续折腾</h2><p>上面这个dockerfile打成镜像的时间总共是165秒，如图：<br><img data-src="/images/v2ray2.png" alt="akb48"></p>
<p>分析一下发现时间大量的消耗在<code>npm run build</code>和<code>COPY</code>这两个步骤上了，因为dockerfile所在的文件夹shopFront&#x2F;(项目文件夹）里包括<code>node_modules</code>，这个文件夹大小是220M左右，复制肯定比较消耗时间。于是我尝试换了一个Dockerfile写法：<br>	<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">FROM keymetrics/pm2:latest-alpine</span><br><span class="line">MAINTAINER ChrisChan &lt;<span class="number">33664</span>@dahuatech.com&gt;</span><br><span class="line"></span><br><span class="line">RUN mkdir -p /<span class="keyword">var</span>/www/node/shopFront</span><br><span class="line">WORKDIR /<span class="keyword">var</span>/www/node/shopFront		#设定工作目录</span><br><span class="line">COPY <span class="keyword">package</span>.json .	#<span class="keyword">package</span>.json要跟dockerfile在同一个文件夹下</span><br><span class="line">RUN  npm install	</span><br><span class="line">COPY shopFront/ .	#再将其他的内容拷贝过去</span><br><span class="line">RUN git pull</span><br><span class="line">EXPOSE <span class="number">3000</span></span><br><span class="line">CMD [ <span class="string">&quot;pm2-docker&quot;</span>, <span class="string">&quot;start&quot;</span>, <span class="string">&quot;server.js&quot;</span>]</span><br></pre></td></tr></table></figure></p>
<p>执行之后效果如图：<br><img data-src="/images/v2ray3.png" alt="akb48"></p>
<p>妈的，时间反而多了20秒。不过这样文件夹里就不用带着<code>node_modules</code>，因为<code>npm install</code>会生成一个<code>node_modules</code>。不过这个0.2镜像比之前的多不到100M。所以看来看去还是0.1更划算。</p>
<p>补充一下：<code>docker ps -a --no-trunc</code>是查看<code>docker ps</code>完全命令，有的时候COMMAND显示不全就用它。 </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://pm2.io/doc/zh/runtime/integration/docker/#%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%B8%AAdocker%E6%96%87%E4%BB%B6">https://pm2.io/doc/zh/runtime/integration/docker/#%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%B8%AAdocker%E6%96%87%E4%BB%B6</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA5OTAyNzQ2OA==&mid=2649700687&idx=1&sn=a656b7c7fdacc1b3df97c1d2630e50d9&scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzA5OTAyNzQ2OA==&amp;mid=2649700687&amp;idx=1&amp;sn=a656b7c7fdacc1b3df97c1d2630e50d9&amp;scene=21#wechat_redirect</a><br><a href="https://stackoverflow.com/questions/35774714/how-to-cache-the-run-npm-install-instruction-when-docker-build-a-dockerfile">https://stackoverflow.com/questions/35774714/how-to-cache-the-run-npm-install-instruction-when-docker-build-a-dockerfile</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>前端node</tag>
        <tag>前端pm2</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次nginx出现了502的问题</title>
    <url>/2018/03/26/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1nginx%E5%87%BA%E7%8E%B0%E4%BA%86502%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="背景交待"><a href="#背景交待" class="headerlink" title="背景交待"></a>背景交待</h2><p>市场运营在手机APP端推送了一个“家装节，部分商品优惠打折”消息，用户可以通过点击这个消息，在APP进入到商城界面，如果是已经登录的用户将通过免登陆直接跳转，如果是没有登录的用户会登陆到登陆界面。但是刚推送就发现，通过这个推送点击，没有正常登陆到商城界面，而是返回了502。</p>
<p>nginx 502的错误，一般来说就是<code>php-fpm</code>的问题，我登陆到电商服务器发现，<code>php-fpm</code>运行正常而且<code>php-fpm</code>的进程数也很正常。但是查看到mysql，发现mysql的CPU飙升，如图：<br><img data-src="/images/nginx5021.png" alt="paradin"></p>
<p>于是登陆到数据库里，使用<code>show processlist</code>一看，数据库里有大量的语句处于<code>sending data</code>状态，而且执行时间令人发指（<code>command</code>项处于<code>Sleep</code>状态的进程表示其正在等待接受查询，因此它并没有消耗任何资源，是无害的）：<br><img data-src="/images/nginx5022.png" alt="paradin"></p>
<p>先赶快通知运营先把推送的消息界面停用掉，不要让更多的用户登陆失败。然后写了一个脚本批量的kill掉这些进程，看看能不能让数据库恢复正常，过程如下。</p>
<p>首先先得到<code>show processlist</code>展现的所有的情况:<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p密码 -h数据库地址 -e <span class="string">&quot;show processlist&quot;</span> | grep -i <span class="string">&#x27;Locked&#x27;</span> &gt; locked_log.<span class="property">txt</span></span><br></pre></td></tr></table></figure></p>
<p>然后获得前面的进程号，并且加上kill的指令:<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#/bin/bash</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="string">`cat locked_log.txt | awk &#x27;&#123;print $1&#125;&#x27;`</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">   echo <span class="string">&quot;kill $line;&quot;</span> &gt;&gt; kill_thread_id.<span class="property">sql</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>在登陆到数据库，然后执行上面生成的<code>kill_thread_id.sql</code>：:<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mysql&gt;source kill_thread_id.<span class="property">sql</span></span><br></pre></td></tr></table></figure></p>
<p>但是发现，kill掉一批之后，又有了新的慢sql出现，CPU依旧高居不下，于是只能跟产品经理说明情况，在征得了产品经理无奈的同意之后，重启了数据库，幸好时间没有很长，就耽误二三分钟而已。重启了之后，CPU就降下去了。赶快叫开发童鞋在线补充一个索引给用户登录的表来解决这个慢sql问题，没有了慢sql就没有了502。</p>
<h2 id="补充nginx499"><a href="#补充nginx499" class="headerlink" title="补充nginx499"></a>补充nginx499</h2><p>nginx如果爆错499的话，代表<code>客户端主动关闭连接</code>，原因就是后端脚本执行的时间太长了or数据库有慢mysql，调用方超出了<code>timeout</code>的时间，关闭了连接。</p>
<p>这个时候需要更改一下<code>nginx.conf</code>:<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">proxy_read_timeout 10s;</span><br><span class="line">proxy_send_timeout 10s;</span><br></pre></td></tr></table></figure></p>
<p>把上面两个值适度调大然后重启nginx即可。或者就是<code>proxy_ignore_client_abort  on;</code>，这话就是让代理服务端不要主动关闭客户端的连接。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/zhuxineli/article/details/14455029">https://blog.csdn.net/zhuxineli/article/details/14455029</a><br><a href="https://segmentfault.com/a/1190000012326158">https://segmentfault.com/a/1190000012326158</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次处理https监听不正确的过程</title>
    <url>/2018/01/12/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%A4%84%E7%90%86https%E7%9B%91%E5%90%AC%E4%B8%8D%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>今天开发反馈在测试金山云设备的时候遇到了这样的一个现象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wget <span class="attr">https</span>:<span class="comment">//funchlscdn.lechange.cn/LCLR/2K02135PAK01979/0/0/20170726085033/dev_20170726085033_lpxh73ezzb92xxa8.m3u8 </span></span><br><span class="line">--<span class="number">2017</span>-<span class="number">07</span>-<span class="number">26</span> <span class="number">11</span>:<span class="number">49</span>:<span class="number">26</span>--  <span class="attr">https</span>:<span class="comment">//funchlscdn.lechange.cn/LCLR/2K02135PAK01979/0/0/20170726085033/dev_20170726085033_lpxh73ezzb92xxa8.m3u8  </span></span><br><span class="line"><span class="title class_">Resolving</span> funchlscdn.<span class="property">lechange</span>.<span class="property">cn</span>... <span class="number">120.92</span><span class="number">.158</span><span class="number">.134</span> </span><br><span class="line"><span class="title class_">Connecting</span> to funchlscdn.<span class="property">lechange</span>.<span class="property">cn</span>|<span class="number">120.92</span><span class="number">.158</span><span class="number">.134</span>|:<span class="number">443.</span>.. connected. </span><br><span class="line"><span class="title class_">OpenSSL</span>: <span class="attr">error</span>:140770<span class="attr">FC</span>:<span class="variable constant_">SSL</span> <span class="attr">routines</span>:<span class="title class_">SSL23</span><span class="attr">_GET_SERVER_HELLO</span>:unknown protocol </span><br><span class="line"><span class="title class_">Unable</span> to establish <span class="variable constant_">SSL</span> connection.</span><br></pre></td></tr></table></figure>
<p>爆<code>error:140770FC:SSL routines:SSL23_GET_SERVER_HELLO:unknown protocol</code>的错误，有两种可能，1）SSL证书没有配对；2）当向只提供http的服务发送https请求。</p>
<p><code>ping funchlscdn.lechange.cn</code>，获得了这个域名对应的IP之后，返回到金山云的控制台查询这个IP，发现这个IP是一个负载均衡，但是这个负载均衡配置的时候对80端口是http协议，而对443端口还是http协议，于是更改成https，重新测试之后，发现错误变成了这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@js-develop ~]# wget <span class="attr">https</span>:<span class="comment">//funchlscdn.lechange.cn/LCLR/2K02135PAK01979/0/0/20170726085033/dev_20170726085033_lpxh73ezzb92xxa8.m3u8 </span></span><br><span class="line">--<span class="number">2017</span>-<span class="number">07</span>-<span class="number">26</span> <span class="number">16</span>:<span class="number">08</span>:<span class="number">15</span>--  <span class="attr">https</span>:<span class="comment">//funchlscdn.lechange.cn/LCLR/2K02135PAK01979/0/0/20170726085033/dev_20170726085033_lpxh73ezzb92xxa8.m3u8</span></span><br><span class="line"><span class="title class_">Resolving</span> funchlscdn.<span class="property">lechange</span>.<span class="property">cn</span>... <span class="number">120.92</span><span class="number">.158</span><span class="number">.134</span></span><br><span class="line"><span class="title class_">Connecting</span> to funchlscdn.<span class="property">lechange</span>.<span class="property">cn</span>|<span class="number">120.92</span><span class="number">.158</span><span class="number">.134</span>|:<span class="number">443.</span>.. connected.</span><br><span class="line"><span class="variable constant_">HTTP</span> request sent, awaiting response... <span class="number">502</span> <span class="title class_">Bad</span> <span class="title class_">Gateway</span></span><br><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">26</span> <span class="number">16</span>:<span class="number">08</span>:<span class="number">15</span> <span class="variable constant_">ERROR</span> <span class="number">502</span>: <span class="title class_">Bad</span> <span class="title class_">Gateway</span>.</span><br></pre></td></tr></table></figure>
<p>在浏览器打开效果如图：</p>
<p>502 Bad Gateway<br>The proxy server received an invalid response from an upstream server. </p>
<hr>
<p>KSYUN ELB 1.0.0 </p>
<p>同时发现金山云负载均衡里对nginx的8000健康检查是“异常”。但是使用http访问却是可以的，效果如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@js-develop ~]# wget <span class="attr">http</span>:<span class="comment">//funchlscdn.lechange.cn/LCLR/2K02135PAK01979/0/0/20170726085033/dev_20170726085033_lpxh73ezzb92xxa8.m3u8 </span></span><br><span class="line">--<span class="number">2017</span>-<span class="number">07</span>-<span class="number">26</span> <span class="number">15</span>:<span class="number">31</span>:<span class="number">55</span>--  <span class="attr">http</span>:<span class="comment">//funchlscdn.lechange.cn/LCLR/2K02135PAK01979/0/0/20170726085033/dev_20170726085033_lpxh73ezzb92xxa8.m3u8</span></span><br><span class="line"><span class="title class_">Resolving</span> funchlscdn.<span class="property">lechange</span>.<span class="property">cn</span>... <span class="number">120.92</span><span class="number">.158</span><span class="number">.134</span></span><br><span class="line"><span class="title class_">Connecting</span> to funchlscdn.<span class="property">lechange</span>.<span class="property">cn</span>|<span class="number">120.92</span><span class="number">.158</span><span class="number">.134</span>|:<span class="number">80.</span>.. connected.</span><br><span class="line"><span class="variable constant_">HTTP</span> request sent, awaiting response... <span class="number">302</span> <span class="title class_">Found</span></span><br><span class="line"><span class="title class_">Location</span>: <span class="attr">http</span>:<span class="comment">//120.92.133.76:8090/LCLR/2K02135PAK01979/0/0/20170726085033/dev_20170726085033_lpxh73ezzb92xxa8.m3u8 [following]</span></span><br><span class="line">--<span class="number">2017</span>-<span class="number">07</span>-<span class="number">26</span> <span class="number">15</span>:<span class="number">31</span>:<span class="number">55</span>--  <span class="attr">http</span>:<span class="comment">//120.92.133.76:8090/LCLR/2K02135PAK01979/0/0/20170726085033/dev_20170726085033_lpxh73ezzb92xxa8.m3u8</span></span><br><span class="line"><span class="title class_">Connecting</span> to <span class="number">120.92</span><span class="number">.133</span><span class="number">.76</span>:<span class="number">8090.</span>.. connected.</span><br><span class="line"><span class="variable constant_">HTTP</span> request sent, awaiting response... <span class="number">200</span> <span class="variable constant_">OK</span></span><br><span class="line"><span class="title class_">Length</span>: <span class="number">66</span> [application/x-mpegURL]</span><br><span class="line"><span class="title class_">Saving</span> <span class="attr">to</span>: “dev_20170726085033_lpxh73ezzb92xxa8.<span class="property">m3u8</span>”</span><br><span class="line"><span class="number">100</span>%[========================================================================================================================================================&gt;] <span class="number">66</span>          --.-K/s   <span class="keyword">in</span> 0s      </span><br><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">26</span> <span class="number">15</span>:<span class="number">31</span>:<span class="number">55</span> (<span class="number">3.02</span> <span class="variable constant_">MB</span>/s) - “dev_20170726085033_lpxh73ezzb92xxa8.<span class="property">m3u8</span>” saved [<span class="number">66</span>/<span class="number">66</span>]</span><br></pre></td></tr></table></figure>
<p>于是就叫来开发问一下http和https详细的流程，开发说在http里，设计路线如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">http</span>(<span class="number">80</span>)-&gt;开发模块(<span class="number">9001</span>)</span><br></pre></td></tr></table></figure>

<p>而在https里，设计路线如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">https</span>(<span class="number">443</span>)-&gt;<span class="title function_">nginx</span>(<span class="number">8000</span>)-&gt;开发模块(<span class="number">9001</span>)</span><br></pre></td></tr></table></figure>

<p>这时候就发现了问题，原来最早的时候金山云是没有配置https证书的，于是开发们就用nginx的8000端口去监听ssl这样达到https证书的效果，但是后来金山云控制台添加了https证书，就不再需要nginx去配置ssl证书了，再去https监听8000这一步也就是错误的了，于是在负载均衡那里改成了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">https</span>(<span class="number">443</span>)-&gt;开发模块(<span class="number">9001</span>)</span><br></pre></td></tr></table></figure>

<p>同时关闭了nginx，这时候再来测试一下https请求，就成功了！<br><img data-src="/images/ksslb.png" alt="7牛云存储" title="https返回OK"></p>
<p>其实如果非要用nginx的ssl证书的话，那么的套路就是：开启nginx，但是在负载均衡那里使用tcp协议去监听nginx的8000端口，这样一样能达到效果。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次性能优化过程</title>
    <url>/2021/06/16/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h2><p>数据中心的核心功能是提供数据聚合的服务，什么叫数据聚合，简而言之就是把业务想要的数据从具体的数据提供方应用里面去取出来，封装好之后统一返回给业务方。为了方便理解，我用一次最简单的调用过程来进行说明：<br><img data-src="/images/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.png" alt="paradin" title="业务方来请求，我这里就是一个找各数据的角色"></p>
<p>以上例子中，伙拼作为1个业务方，想要获取商品列表，并且补充商品中的基本信息和一些标签、营销等信息，那么这个时候，伙拼会根据约定携带参数向数据中心发起一个RPC请求。数据中心接收到请求之后，第一次发起RPC调用，从主数据源（数据源：是具体数据提供方的统称）获取到伙拼需要的商品，然后再并发的再向各个其他数据源发起请求去取商品的属性信息，最后把各个数据源的返回结果合并返回给伙拼业务方。</p>
<p>纵观整个过程，“数据中心”并不自己产生数据，数据都是从其他的应用通过网络请求去取的，数据中心充当的是一个代理和搬运工的角色，去帮业务方把数据拿到并组装好。通过这种方式，制定一套数据中心自己的数据接入和取数规范，以此来减少业务方的硬编码，大大提升数据扩展能力和业务快速迭代的能力。</p>
<h2 id="明确性能问题"><a href="#明确性能问题" class="headerlink" title="明确性能问题"></a>明确性能问题</h2><p>数据中心是一个中心化的应用，需要扛各个业务方的调用，而中心化的应用性能瓶颈很明显：能提供的最大QPS依赖于应用本身集群机器数量的大小。在服务器资源有限的情况下，数据中心出现了服务器集群load高的问题，而服务器load一旦偏高，就会导致机器的rt抖动，从而影响前台业务的稳定性。在优化前日常load峰值已经飙高到3.1+，对于普通配置的4核机器，这个load算是比较高的了：<br><img data-src="/images/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%962.png" alt="paradin"></p>
<p>而load高可能是流量过高导致服务器负载高，也有可能是自身有性能瓶颈，这里我们抱着优化自身性能的初心，从自身的机器着手尝试去解决问题。</p>
<h2 id="使用arthas进行初步分析"><a href="#使用arthas进行初步分析" class="headerlink" title="使用arthas进行初步分析"></a>使用arthas进行初步分析</h2><p>要分析应用的热点代码，可以根据方法调用栈采样的方式来分析，而“火焰图”恰好就是干这个的，这里可以直接使用集团现成的工具：arthas。于是，我在线上找了运行了好几天的几台load高的机器，通过arthas的火焰图采样，发现这几台load高机器的火焰图有一些共性，大致都长如下的样子：<br><img data-src="/images/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%963.png" alt="paradin"></p>
<p>根据得到的火焰图结果，去找比较宽的函数，可以简单理解函数越宽，其占的CPU越高，具体怎么看火焰图我在文章后面会附链接。通过以上的火焰图可以比较明显的看到两个问题，我在图中已经圈出：<br>1、C2Compiler::compile_method xxx 占了48.33%的采样结果，C2是一个JIT编译器<br>2、ClassLoader.loadClass 占了9.2%的采样结果<br>基于这两个问题，脑子里应该有两个疑问：1、JIT对性能的影响应该是在机器刚启动时影响较大，为什么机器运行了这么久，jit还这么活跃以致于占了这么多的采样？2、为什么ClassLoader也这么活跃，采样占比这么高？</p>
<h2 id="疑问排查"><a href="#疑问排查" class="headerlink" title="疑问排查"></a>疑问排查</h2><p>我先看的第一个问题，由于JIT编译会使用到CodeCache，怀疑是不是CodeCache的空间不够？查看Sunfire监控，发现CodeCache利用率还算处于正常水位：<br><img data-src="/images/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%964.png" alt="paradin"></p>
<p>暂时排除了CodeCache空间不足的原因。而且由于我们应用使用的是Java8，默认会开启分层编译，JVM会自适应的去调整使用的编译器，但现在线上jit还这么活跃，真有点让人摸不着头脑。于是我接下来在预发去尝试了修改编译器线程数量、增大CodeCache、甚至关闭分层编译等一系列操作，但最后都没发现有太多的性能提升，甚至在关闭分层编译之后机器启动后的几分钟内load飙到好几十：<br><img data-src="/images/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%965.png" alt="paradin"></p>
<p>其实JIT这块对于应用开发的工程师来说，是相对黑盒的，在没经过大量验证的情况下，也不敢轻易修改默认的JIT配置，所以关于JIT影响性能这块，没有得到太多的有效结论。</p>
<p>只能马上转头看第二个问题，为什么ClassLoader这么活跃？点击火焰图的函数，可以看到详情：<br><img data-src="/images/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%966.png" alt="paradin"></p>
<p>ClassLoader#loadClass往下找是具体的调用来源，可以发现ClassLoader的调用其实是来自于com.alibaba.dubbo.common.utils.PojoUtils#realize这个方法，这个方法是干嘛的？我截取了该方法唯一在数据中心的调用代码，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bean = Proxy.newProxyInstance(type.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;type&#125;, <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">            String[] parameterTypeStrs = <span class="keyword">new</span> <span class="title class_">String</span>[parameterTypes.length];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">                parameterTypeStrs[i] = parameterTypes[i].getName();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">            <span class="comment">// 获取泛化调用对象</span></span><br><span class="line">            <span class="type">GenericService</span> <span class="variable">genericService</span> <span class="operator">=</span> service != <span class="literal">null</span> ? service : genericServiceInstanceCache.get(key);</span><br><span class="line">            <span class="comment">// 发起泛化调用</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> service.$invoke(method.getName(), parameterTypeStrs, args);</span><br><span class="line">			<span class="comment">// 把泛化调用返回的HashMap转化成Java Bean</span></span><br><span class="line">            <span class="keyword">return</span> PojoUtils.realize(result, returnType, method.getGenericReturnType());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里简单介绍一下，由于数据中心制定了一个RPC接口规范，数据源接入需要在自己的应用里面实现我们的规范接口，而在数据中心发起调用的时候是通过泛化调用的方式来进行调用的，以此来实现扩展性。数据中心定制的核心规范接口如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.china.idc.common.model.Context;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.china.idc.common.model.Result;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EnhancedDataSourcePlus</span> <span class="keyword">extends</span> <span class="title class_">DataSource</span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取单个ID的其他扩展信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Map&gt; <span class="title function_">getData</span><span class="params">(String ID, List&lt;String&gt; selectFields, Context context)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同时获取多个ID的其他扩展信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Map&gt; <span class="title function_">batchGetData</span><span class="params">(List&lt;String&gt; IDs, List&lt;String&gt; selectFields, Context context)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>其中com.alibaba.china.idc.common.model.Result是数据中心定义的一个Model，Map用来存放数据源返回的数据。泛化调用返回的结果都会被处理成HashMap类型的数据，如下是我模拟的一个泛化调用返回对象toJSONString的结果，value结果里面如果是一个自定义的Java对象，则会添加一个class字段来标示当前的类型：<br><img data-src="/images/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%967.png" alt="paradin"></p>
<p>关键点就在这里，这个PojoUtils#realize实际上是将泛化调用的返回结果Map类型转化为数据中心自定义的Java类型，里面会递归的读取class字段里面的内容，并尝试通过反射把HashMap通过转化为对应的类型，如下是这个工具类的核心源码部分：<br><img data-src="/images/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%968.png" alt="paradin"></p>
<p>在以上的case中，PojoUtils会首先通过读取到com.alibaba.china.idc.model.Result这个字符串，并通过反射生成一个对象，这没问题，因为这个Model是数据中心定义的。然后会去读到wfx.service.TestEchoPromaryDataSourcre$TagResult这个字符串，并尝试通过反射创建一个对应的对象，这里问题就来了，数据中心并没有这个类的定义。</p>
<p>所以，现在问题大概就清楚了：业务方在数据中心规范的接口返回Map中，塞了自己的定义的Model，而数据中心并没有导入他们的二方包！因此会陷入ClassLoader一直去加载这个类，但是每次都加载不到的这种死循环中。而且需要注意的是，ClassLoader加载类的方法块里面，有一段同步代码块：<br><img data-src="/images/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%969.png" alt="paradin"></p>
<p>所以，当这个数据源的qps高的时候，会出现锁竞争的情况，线程dump证明了这一点：<br><img data-src="/images/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9610.png" alt="paradin"></p>
<p>现在问题找到了，如何修复呢？正常来说，PojoUtils里面如果能将找不到的类缓存起来，那就不用每次都去执行类加载了。我去查了一下HSF官方文档，其实官方文档也提供了一个同名的PojoUtils类：com.taobao.hsf.util.PojoUtils 。这个类就实现了对无法加载的类的缓存：<br><img data-src="/images/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9611.png" alt="paradin"></p>
<p>至于为什么数据中心代码里面不用HSF官方推荐的类，可能是历史原因，不去管他了。一顿疯狂操作后，其实就改了一行代码：替换com.alibaba.dubbo.common.utils.PojoUtils为com.taobao.hsf.util.PojoUtils 。</p>
<h2 id="优化效果"><a href="#优化效果" class="headerlink" title="优化效果"></a>优化效果</h2><p>发布代码上线后，果然有了立竿见影的效果，通过sunfire监控可以看到，数据中心机器的平均CPU利用率降低了40%左右，峰值从28.4%降到了16.7%；load降低了35%左右，峰值从3.1降低到2.0；YGC次数降低了67%左右；最终数据中心提供的hsf服务rt降低了10%，这些提升将直接加快APP中许多页面的打开速度。<br><img data-src="/images/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9612.png" alt="paradin"></p>
<p>我找了很多台load偏高的机器，结果意外的发现不仅ClassLoader的问题没了，jit的问题也没了，意外之喜，原因是啥还没找到。</p>
<p>除了以上的几个优化尝试外，我还有一些其他比较通用的优化操作，这里我简单例举一下：<br>● 优化日志量，减少日志打印。这个优化在我这个应用里面十分重要，我精简了大量日志，剪裁了不必要的日志，上线后，有5%的load提升<br>● 日志异步打印。logback和log4j都支持异步打印日志，但都是需要手动配置的，具体配置方式就不细说了，这个优化主要是考虑到，当一个方法执行过程中如果执行了太多次同步的日志打印，对性能是有影响的（蚊子再小也是肉对吧）</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实性能优化也真的是一个很大的命题，特别是当这个问题不具体的时候，因为它不像是我们平常遇到的空指针、包冲突那样有章可循，它往往没法很好的切入，甚至很多时候你可能不知道你的应用有性能问题。所以我们可以尝试利用一些工具，将一个比较泛的问题，分解成一个个具体的问题，将一个较为黑盒的操作系统问题，具象化的进入到我们熟悉的Java领域上再逐个击破，拿到好的优化效果。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>SRE</tag>
        <tag>java</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次阿里云负载均衡端口监听不正确的过程</title>
    <url>/2018/05/31/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E9%98%BF%E9%87%8C%E4%BA%91%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AB%AF%E5%8F%A3%E7%9B%91%E5%90%AC%E4%B8%8D%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>在阿里云上新配置了一个负载均衡，后面挂载的服务器上安装了一个nginx，分别开启了80端口和8080端口，其中80端口是给http访问的，8080端口是给https访问的，同时在8080端口上做了http跳转https的配置。</p>
<p>但是在负载均衡配置完毕之后，发现tcp的80转8080是OK的，但是https的443转80却始终不OK，网页也自然打不开，但是在nginx上看80端口的确是在stand by：<br><img data-src="/images/alislb1.png" alt="paradin"></p>
<p>而且安全组都做了配置，telnet端口也是完全没有问题的，如图：<br><img data-src="/images/alislb2.png" alt="paradin"></p>
<p>执行了一下<code>time curl -I -X HEAD SLB的域名  -x http://本机IP地址:80</code>看一下效果，如图：<br><img data-src="/images/alislb3.png" alt="paradin"></p>
<p>可见命令执行OK，但是耗时需要7秒，而默认的阿里云SLB在https监听的超时时间设定是5秒，怀疑是后端ECS上对head头响应慢导致的健康检查失败。然后在网页上使用“检查”功能，发现有几个js、css文件耗时很长，于是就叫前端的码农们配合查一下，在几位前端吭哧吭哧解决了这个问题之后，https访问恢复正常。</p>
<p><img data-src="/images/jpbook3.jpg" alt="paradin" title="霓虹书店一角，我表示只能看得懂图"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次配置http跳转https的过程</title>
    <url>/2018/01/18/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E9%85%8D%E7%BD%AEhttp%E8%B7%B3%E8%BD%AChttps%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>公司最近搞了一个数据运营平台，这个平台会以web界面的形式把各个数据展示出来，这个项目是我们一个经理的重点关照项目。把平台模块部署完毕并且启动之后，又把这个平台服务器的外网IP绑定到<code>alkaid.lechange.com</code>这个域名上，在浏览器里输入<code>https://alkaid.lechange.com</code>,就看到了前端同行们写的网页。</p>
<p>但是我们的霸气经理说这样不行，说要更多要求更高标准更好体验，于是乎提出一个需求就是：<font color=blue>在输入<code>alkaid.lechange.com</code>的时候会自动跳转到<code>https://alkaid.lechange.com</code>。</font></p>
<p>既然如此，我们就在nginx上原有的<code>nginx.conf</code>里补充几个配置文件：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include upstream</span><br><span class="line">include upstream.<span class="property">conf</span>;</span><br><span class="line"># include servers</span><br><span class="line">include alkaid.<span class="property">conf</span>;</span><br><span class="line">include alkaid-https.<span class="property">conf</span>;</span><br></pre></td></tr></table></figure></p>
<p>这样在执行<code>nginx.conf</code>的时候，就会调用<code>upstream.conf</code>、<code>alkaid.conf</code>和<code>alkaid-https.conf</code>，我们主要看一下这三个文件。</p>
<p><code>alkaid.conf</code>文件如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">       listen <span class="number">80</span>;</span><br><span class="line">       server_name *.<span class="property">lechange</span>.<span class="property">com</span>;</span><br><span class="line">       proxy_buffering off;</span><br><span class="line">       location / &#123;</span><br><span class="line">               rewrite ^<span class="regexp">/ https:/</span>/alkaid.<span class="property">lechange</span>.<span class="property">com</span> permanent;</span><br><span class="line">               client_max_body_size 100m;</span><br><span class="line">   	    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们监听了80端口，下面那个<code>client_max_body_size 100m</code>是用来设定<code>nginx+php</code>上传文件的大小，这里规定是100m，这个可以写进<code>nginx.conf</code>里，如果有对上传文件方面感兴趣，可以看<a href="http://www.cnblogs.com/zhwl/archive/2012/09/18/2690714.html">http://www.cnblogs.com/zhwl/archive/2012/09/18/2690714.html</a> 。</p>
<p>再来看看<code>alkaid-https.conf</code>，如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">       listen <span class="number">10000</span>;</span><br><span class="line">       server_name *.<span class="property">lechange</span>.<span class="property">com</span>;</span><br><span class="line">       proxy_buffering off;</span><br><span class="line">       location / &#123;</span><br><span class="line">               proxy_pass <span class="attr">http</span>:<span class="comment">//alkaid_backend;</span></span><br><span class="line">               proxy_set_header   X-<span class="title class_">Real</span>-<span class="variable constant_">IP</span>        $remote_addr;</span><br><span class="line">               proxy_set_header   X-<span class="title class_">Forwarded</span>-<span class="title class_">For</span>  $proxy_add_x_forwarded_for;</span><br><span class="line">               proxy_redirect     off;</span><br><span class="line">   	    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里监听了10000端口，<code>location</code>写的是<code>http://alkaid_backend</code>,这个<code>alkaid_backend</code>是啥东西?</p>
<p>这个时候我们就需要看一下<code>upstream.conf</code>，里面内容是:<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">upstream alkaid_backend &#123;</span><br><span class="line">       server   X.<span class="property">X</span>.<span class="property">X</span>.<span class="property">X</span>:<span class="variable constant_">JQK</span>;</span><br><span class="line">       check interval=<span class="number">5000</span> rise=<span class="number">2</span> fall=<span class="number">5</span> timeout=<span class="number">1000</span> type=tcp default_down=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>X.X.X.X是模块服务器的内网IP地址，而JQK是模块服务器的模块端口，这里要根据实际的情况来写。可见<code>alkaid_backend</code>对应的就是模块服务器和它的端口，下面是检查间隔等等数值。</p>
<p>现在我们启动<code>nginx</code>，然后把nginx的外网地址绑定去<code>alkaid.lechange.com</code>这个域名，在浏览器里输入<code>alkaid.lechange.com</code>，就会达到自动跳转的目的了！</p>
<p>这里要额外多说一下，我们这里设定了80的配置文件也设置了443的文件，但是这俩文件的转发过程却不同：<code>alkaid-https.conf</code>文件把443的请求转向了平台模块服务器的服务，而<code>alkaid.conf</code>文件把凡是从80端口进来的请求直接全部永久重定向到<code>https://alkaid.lechange.com</code> ，但是这个<code>alkaid.lechange.com</code>还是会去访问平台模块服务器的服务，也就是说<code>alkaid.conf</code>文件多了一步重定向。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>记录部署ProxySql的过程</title>
    <url>/2019/05/31/%E8%AE%B0%E5%BD%95%E9%83%A8%E7%BD%B2ProxySql%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="安装与启动"><a href="#安装与启动" class="headerlink" title="安装与启动"></a>安装与启动</h2><p>先去<code>https://github.com/sysown/proxysql/releases</code> 下载稳定版本 ，我是下载的<code>proxysql-2.0.4-1-centos7.x86_64.rpm</code>，然后<code>rpm -ivh proxysql-2.0.4-1-centos7.x86_64.rpm</code>，如果出现了如下错误：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[root@dvlshop-proxysql-001 ~]<span class="comment"># rpm -ivh proxysql-2.0.4-1-centos7.x86_64.rpm </span></span><br><span class="line">error: Failed dependencies:</span><br><span class="line">	perl(DBD::mysql) <span class="keyword">is</span> needed by proxysql-<span class="number">2.0</span><span class="number">.4</span>-<span class="number">1.</span>x86_64</span><br><span class="line">	perl(DBI) <span class="keyword">is</span> needed by proxysql-<span class="number">2.0</span><span class="number">.4</span>-<span class="number">1.</span>x86_64</span><br></pre></td></tr></table></figure><br>就执行一下<code>yum install -y perl-IO-Socket-SSL perl-DBD-MySQL</code>就可以了。</p>
<p>安装成功之后，启动的命令是<code>service proxysql start</code>：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[root@dvlshop-proxysql-001 ~]<span class="comment"># service proxysql start</span></span><br><span class="line">Starting ProxySQL: <span class="number">2019</span>-05-<span class="number">31</span> <span class="number">11</span>:<span class="number">23</span>:<span class="number">10</span> [INFO] Using config file /etc/proxysql.cnf</span><br><span class="line"><span class="number">2019</span>-05-<span class="number">31</span> <span class="number">11</span>:<span class="number">23</span>:<span class="number">10</span> [INFO] No SSL keys/certificates found <span class="keyword">in</span> datadir (/var/lib/proxysql). Generating new keys/certificates.</span><br><span class="line">DONE!</span><br><span class="line">[root@dvlshop-proxysql-001 ~]<span class="comment"># </span></span><br></pre></td></tr></table></figure></p>
<p>启动完毕就可以使用初始命令<code>mysql -uadmin -padmin -h 127.0.0.1 -P 6032</code>来登录proxysql了，如图：<br><img data-src="/images/proxy16.png" alt="akb48"></p>
<p>补充一下：proxysql的默认管理端口是<code>6032</code>，客户端服务端口是<code>6033</code>。默认的用户名密码都是<code>admin</code>，可以在配置文件里看到。<br><img data-src="/images/proxy18.png" alt="akb48"></p>
<p>再说一下各个重要文件的位置：proxysql的静态配置文件是<code>/etc/proxysql.cnf</code>(只在第一次启动的时候有用，后续所有的配置修改都是对SQLite数据库操作，并且不会更新到<code>proxysql.cnf</code>文件中。)，日志文件是<code>/var/lib/proxysql/proxysql.log</code>，SQLITE的数据文件是<code>/var/lib/proxysql/proxysql.db</code>。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>与之前的中间件atlas不同，配置ProxySQL是基于sql命令的方式完成的，而且配置完成之后直接应用无需重启。怎么做到这个的呢？是因为ProxySQL的三层管理配置设计：</p>
<ol>
<li>runtime：运行中使用的配置文件，这些表的数据库无法直接修改，只能从其他层级load加载。这一份配置会直接影响到生产环境的，所以要将配置加载进RUNTIME层时需要三思而行；</li>
<li>memory：提供用户动态修改配置文件，它是我们修改proxysql的唯一正常入口。一般来说在修改一个配置时，首先修改Memory层，确认无误后再接入RUNTIME层，最后持久化到DISK和CONFIG FILE层。也就是说memeory层里面的配置随便改，不影响生产，也不影响磁盘中保存的数据。</li>
<li>disk：将修改的配置保存到磁盘SQLit表中（即：proxysql.db），DISK&#x2F;CONFIG FILE层表示持久存储的那份配置，持久层对应的磁盘文件是$(DATADIR)&#x2F;proxysql.db，在重启ProxySQL的时候，会从proxysql.db文件中加载信息。即如果不持久化下来，重启后，配置都将丢失。</li>
<li>config：一般不使用它（即：proxysql.cnf）</li>
</ol>
<p>再重复一遍：proxysql分为三个级别，RUNTIME是即时生效的，MEMORY是保存在内存中但并不立即生效的，DISK|CONFIG FILE是持久化或写在配置文件中的。修改的配置都是在memory层。可以load到runtime，使配置在不用重启proxysql的情况下也可以生效，也可以save到disk，将对配置的修改持久化！如图：<br><img data-src="/images/proxy17.png" alt="akb48"></p>
<p>这三个级别的配置文件互不干扰，在某个层级修改了配置文件，想要加载或保存到另一个层级，需要额外的LOAD或SAVE操作：”LOAD xx_config FROM xx_level | LOAD xx_config TO xx_level | SAVE xx_config TO xx_level | SAVE xx_config FROM xx_level”等等。</p>
<p>由此可见，如果想要更改proxysql的初始账号密码以及端口，改了<code>/etc/proxysql.cnf</code>是没用的，应该通过sql命令行进入到proxysql里，先查看<code>global_variables</code>这个表：<br><img data-src="/images/proxy19.png" alt="akb48"></p>
<p>要修改表里的内容才算是真正的修改了配置文件！于是想要在admin:admin的基础上添加一个lcshop:lcshop2019这个用户同时把登录端口改成127.0.0.1:6969，那么语句如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">update global_variables <span class="built_in">set</span> variable_value = <span class="string">&#x27;admin:admin;lcshop:lcshop2019&#x27;</span> where variable_name = <span class="string">&#x27;admin-admin_credentials&#x27;</span>;</span><br><span class="line">update global_variables <span class="built_in">set</span> variable_value = <span class="string">&#x27;127.0.0.1:6969&#x27;</span> where variable_name = <span class="string">&#x27;admin-mysql_ifaces&#x27;</span>;	<span class="comment">#登录proxysql的管理端口是6969了</span></span><br><span class="line">LOAD MYSQL SERVERS TO RUNTIME;  <span class="comment">#常用，让修改的配置生效</span></span><br><span class="line">SAVE MYSQL SERVERS TO DISK;     <span class="comment">#常用，将修改的配置持久化</span></span><br></pre></td></tr></table></figure></p>
<p>此时就是使用新账号和新端口访问proxysql管理界面了！如图：<br><img data-src="/images/proxy20.png" alt="akb48"></p>
<p>跟mysql一样，如果你想查看历史命令记录，<code>cat ~/mysql_history</code>即可。</p>
<h2 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h2><p>假设我有一组阿里云RDS数据库，主库的内网地址是rm-bp1el471x0ltbg402.mysql.rds.aliyuncs.com，从库的内网地址是rr-bp10ki29n7n8z0ex0.mysql.rds.aliyuncs.com，端口皆3306，并且将这台proxysql的IP地址添加到双方的白名单里。</p>
<p>首先先把两个mysql信息插入到<code>mysql_servers</code>，如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MySQL [(none)]&gt; insert into mysql_servers(hostgroup_id,hostname,port) values(<span class="number">10</span>,<span class="string">&#x27;rm-bp1el471x0ltbg402.mysql.rds.aliyuncs.com&#x27;</span>,<span class="number">3306</span>);	<span class="comment">#10表示写组，为20表示读组。</span></span><br><span class="line">Query OK, <span class="number">1</span> row affected (<span class="number">0.01</span> sec)</span><br><span class="line">MySQL [(none)]&gt; insert into mysql_servers(hostgroup_id,hostname,port) values(<span class="number">20</span>,<span class="string">&#x27;rr-bp10ki29n7n8z0ex0.mysql.rds.aliyuncs.com&#x27;</span>,<span class="number">3306</span>);</span><br><span class="line">Query OK, <span class="number">1</span> row affected (<span class="number">0.00</span> sec)</span><br><span class="line">MySQL [(none)]&gt; select * <span class="keyword">from</span> mysql_servers;</span><br><span class="line">+--------------+---------------------------------------------+------+-----------+--------+--------+-------------+-----------------+---------------------+---------+----------------+---------+</span><br><span class="line">| hostgroup_id | hostname                                    | port | gtid_port | status | weight | compression | max_connections | max_replication_lag | use_ssl | max_latency_ms | comment |</span><br><span class="line">+--------------+---------------------------------------------+------+-----------+--------+--------+-------------+-----------------+---------------------+---------+----------------+---------+</span><br><span class="line">| <span class="number">10</span>           | rm-bp1el471x0ltbg402.mysql.rds.aliyuncs.com | <span class="number">3306</span> | <span class="number">0</span>         | ONLINE | <span class="number">1</span>      | <span class="number">0</span>           | <span class="number">1000</span>            | <span class="number">0</span>                   | <span class="number">0</span>       | <span class="number">0</span>              |         |</span><br><span class="line">| <span class="number">20</span>           | rr-bp10ki29n7n8z0ex0.mysql.rds.aliyuncs.com | <span class="number">3306</span> | <span class="number">0</span>         | ONLINE | <span class="number">1</span>      | <span class="number">0</span>           | <span class="number">1000</span>            | <span class="number">0</span>                   | <span class="number">0</span>       | <span class="number">0</span>              |         |</span><br><span class="line">+--------------+---------------------------------------------+------+-----------+--------+--------+-------------+-----------------+---------------------+---------+----------------+---------+</span><br><span class="line"><span class="number">2</span> rows <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>然后还要在阿里云的RDS控制台上创建两个用户，一个是监控用户<code>sqlmonitor</code>，一个是普通的进程用户<code>proxysql</code>。先将进程用户proxysql添加到<code>mysql_users</code>这个表里<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MySQL [(none)]&gt;	INSERT INTO mysql_users(username,password,default_hostgroup) VALUES (<span class="string">&#x27;proxysql&#x27;</span>,<span class="string">&#x27;这里是账号对应的密码&#x27;</span>,<span class="number">10</span>);</span><br><span class="line">MySQL [(none)]&gt; select * <span class="keyword">from</span> mysql_users;</span><br><span class="line">+----------+--------------------+--------+---------+-------------------+----------------+---------------+------------------------+--------------+---------+----------+-----------------+---------+</span><br><span class="line">| username | password           | active | use_ssl | default_hostgroup | default_schema | schema_locked | transaction_persistent | fast_forward | backend | frontend | max_connections | comment |</span><br><span class="line">+----------+--------------------+--------+---------+-------------------+----------------+---------------+------------------------+--------------+---------+----------+-----------------+---------+</span><br><span class="line">| proxysql | 这里是账号对应的密码| <span class="number">1</span>      | <span class="number">0</span>       | <span class="number">10</span>                | NULL           | <span class="number">0</span>             | <span class="number">1</span>                      | <span class="number">0</span>            | <span class="number">1</span>       | <span class="number">1</span>        | <span class="number">10000</span>           |         |</span><br><span class="line">+----------+--------------------+--------+---------+-------------------+----------------+---------------+------------------------+--------------+---------+----------+-----------------+---------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">   LOAD MYSQL USERS TO RUNTIME;</span><br><span class="line">SAVE MYSQL USERS TO DISK;</span><br></pre></td></tr></table></figure></p>
<p>这里说一下<code>default_hostgroup</code>，它的意思是“这个用户的请求没有匹配到规则时，默认发到这个<code>hostgroup</code>，默认0”，由于我们上面设定10是写组，所以这里写成10。</p>
<p>这里默认保存的密码是明文的，如果想保存加密后的密码，可以先去mysql的界面里进行加密，比如：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MySQL [(none)]&gt; select PASSWORD(<span class="string">&#x27;114514&#x27;</span>);</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">| PASSWORD(<span class="string">&#x27;114514&#x27;</span>)                        |</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">| *D9050F2D99C3DDD8138912B7BDF8F4BACBE3A8E7 |</span><br><span class="line">+-------------------------------------------+</span><br></pre></td></tr></table></figure></p>
<p>然后用这个密码输入，比如：<code>insert into mysql_users(username,password,active,default_hostgroup) values (&#39;proxysql2&#39;,&#39;*D9050F2D99C3DDD8138912B7BDF8F4BACBE3A8E7&#39;,1,20);</code>。注意！mysql_users的username是不能重复的。</p>
<p>确认一下账号已经正确连接：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MySQL [(none)]&gt; select * <span class="keyword">from</span> mysql_server_connect_log;</span><br><span class="line">+---------------------------------------------+------+------------------+-------------------------+---------------+</span><br><span class="line">| hostname                                    | port | time_start_us    | connect_success_time_us | connect_error |</span><br><span class="line">+---------------------------------------------+------+------------------+-------------------------+---------------+</span><br><span class="line">| rm-bp1el471x0ltbg402.mysql.rds.aliyuncs.com | <span class="number">3306</span> | <span class="number">1559649241943118</span> | <span class="number">8607</span>                    | NULL          |</span><br><span class="line">| rr-bp10ki29n7n8z0ex0.mysql.rds.aliyuncs.com | <span class="number">3306</span> | <span class="number">1559649242748088</span> | <span class="number">1291</span>                    | NULL          |</span><br><span class="line">| rr-bp10ki29n7n8z0ex0.mysql.rds.aliyuncs.com | <span class="number">3306</span> | <span class="number">1559649301943192</span> | <span class="number">1396</span>                    | NULL          |</span><br><span class="line">| rm-bp1el471x0ltbg402.mysql.rds.aliyuncs.com | <span class="number">3306</span> | <span class="number">1559649302760022</span> | <span class="number">7218</span>                    | NULL          |</span><br><span class="line">+---------------------------------------------+------+------------------+-------------------------+---------------+</span><br><span class="line"><span class="number">4</span> rows <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>发现<code>connect_error</code>为空，而且<code>connect_success_time_us</code>有值可见已经成功连接了。如果<code>connect_error</code>有具体的错误，那么就可以根据错误来修改。<br>	<br>然后添加<code>sqlmonitor</code>用户，它主要是用来健康监测：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> mysql-monitor_username=<span class="string">&#x27;sqlmonitor&#x27;</span>;</span><br><span class="line"><span class="built_in">set</span> mysql-monitor_password=<span class="string">&#x27;对应的密码&#x27;</span>;</span><br><span class="line"><span class="comment">#或者是UPDATE global_variables SET variable_value=&#x27;monitor&#x27; WHERE variable_name=&#x27;sqlmonitor&#x27;;</span></span><br><span class="line"><span class="comment">#UPDATE global_variables SET variable_value=&#x27;unixfbi&#x27; WHERE variable_name=&#x27;对应的密码&#x27;; </span></span><br><span class="line">LOAD MYSQL VARIABLES TO RUNTIME;  <span class="comment">#别忘了让修改的配置生效</span></span><br><span class="line">SAVE MYSQL VARIABLES TO DISK;     <span class="comment">#将修改的配置持久化</span></span><br></pre></td></tr></table></figure></p>
<p>此时在另外一个xshell对话框窗口尝试一下使用proxysql连接数据库，使用<code>mysql -h127.0.0.1 -P6033 -uproxysql -p</code>效果如图：<br><img data-src="/images/proxy21.png" alt="akb48"></p>
<p>已经成功的通过proxysql来访问到数据库了！</p>
<h2 id="验证读写分离"><a href="#验证读写分离" class="headerlink" title="验证读写分离"></a>验证读写分离</h2><p>首先在proxysql账号下创建一个tables：<br><img data-src="/images/proxy22.png" alt="akb48"></p>
<p>然后往里面随机插入三条数据：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INSERT INTO players ( name, team, num ) VALUES ( <span class="string">&quot;Jordan&quot;</span>, <span class="string">&quot;Bulls&quot;</span> , <span class="number">23</span>);</span><br><span class="line">INSERT INTO players ( name, team, num ) VALUES ( <span class="string">&quot;Kobe&quot;</span>, <span class="string">&quot;Lakers&quot;</span> , <span class="number">24</span>);</span><br><span class="line">INSERT INTO players ( name, team, num ) VALUES ( <span class="string">&quot;Duncan&quot;</span>, <span class="string">&quot;Spurs&quot;</span> , <span class="number">21</span>);</span><br></pre></td></tr></table></figure></p>
<p>查看数据如下：<br><img data-src="/images/proxy23.png" alt="akb48"></p>
<p>此时新开一个xshell窗口登录proxysql的管理端，<code>select * from stats_mysql_query_digest;</code>查看语句细节如下：<br><img data-src="/images/proxy24.png" alt="akb48"></p>
<p>发现所有的语句的hostgroup都是10，也就是我们上面设定的写库，即读库并没有承担起读的作用。这是为什么呢？因为proxysql还需要设定路由。于是我们添加两个路由：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">insert into mysql_query_rules(rule_id,active,match_digest,destination_hostgroup,apply)values(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;^SELECT.*FOR UPDATE$&#x27;</span>,<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line">insert into mysql_query_rules(rule_id,active,match_digest,destination_hostgroup,apply)values(<span class="number">2</span>,<span class="number">1</span>,<span class="string">&#x27;^SELECT&#x27;</span>,<span class="number">20</span>,<span class="number">1</span>);</span><br><span class="line">load mysql query rules to runtime;	<span class="comment">#生效</span></span><br><span class="line">save mysql query rules to disk;		<span class="comment">#持久化</span></span><br></pre></td></tr></table></figure><br>如图：<br><img data-src="/images/proxy25.png" alt="akb48"></p>
<p>加上这几句话的含义是：1.将select语句全部路由至hostgroup_id&#x3D;20的组(也就是读组)； 2.但是<code>select * from tb for update</code>这样的语句是修改数据的，所以需要单独定义，将它路由至hostgroup_id&#x3D;10的组(也就是写组)； 3.其他没有被规则匹配到的组将会被路由至用户默认的组(mysql_users表中的<code>default_hostgroup</code>)</p>
<p>然后我们返回到mysql，再插入几句数据，再重新打开<code>select * from stats_mysql_query_digest;</code>，发现符合标准的select都落到了hostgroup是20的mysql上了，测试读写分离成功，如图：<br><img data-src="/images/proxy26.png" alt="akb48"></p>
<p>最后补充几个常用的语句：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">select hostgroup_id, hostname, status <span class="keyword">from</span> runtime_mysql_servers;	<span class="comment">#查看在用的mysql状态</span></span><br><span class="line">select * <span class="keyword">from</span> mysql_server_ping_log;	<span class="comment">#查看mysql的连接情况</span></span><br><span class="line">select * <span class="keyword">from</span> stats_mysql_query_rules;	<span class="comment">#查看路由规则命中情况</span></span><br><span class="line">load mysql users to runtime;</span><br><span class="line">load mysql servers to runtime;</span><br><span class="line">load mysql query rules to runtime;</span><br><span class="line">load mysql variables to runtime;</span><br><span class="line">load admin variables to runtime;</span><br><span class="line"><span class="comment">#load进runtime，是配置生效</span></span><br><span class="line"></span><br><span class="line">save mysql users to disk;</span><br><span class="line">save mysql servers to disk;</span><br><span class="line">save mysql query rules to disk;</span><br><span class="line">save mysql variables to disk;</span><br><span class="line">save admin variables to disk;</span><br><span class="line"><span class="comment">#save到磁盘(/var/lib/proxysql/proxysql.db)中，永久保存配置</span></span><br></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/sysown/ProxySQL">https://github.com/sysown/ProxySQL</a><br><a href="https://arstercz.com/proxysql-%E4%BB%8B%E7%BB%8D%E5%8F%8A%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8/">https://arstercz.com/proxysql-%E4%BB%8B%E7%BB%8D%E5%8F%8A%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8/</a><br><a href="http://seanlook.com/2017/04/10/mysql-proxysql-install-config/">http://seanlook.com/2017/04/10/mysql-proxysql-install-config/</a> （具体各表的信息可以看这个）<br><a href="https://www.cnblogs.com/kevingrace/p/10329714.html">https://www.cnblogs.com/kevingrace/p/10329714.html</a>	（墙裂推荐！mysql 5.7的主从同步也有）</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>读写分离</tag>
        <tag>proxysql</tag>
      </tags>
  </entry>
  <entry>
    <title>调整Django使其可以上传大文件和多文件</title>
    <url>/2019/06/06/%E8%B0%83%E6%95%B4Django%E4%BD%BF%E5%85%B6%E5%8F%AF%E4%BB%A5%E4%B8%8A%E4%BC%A0%E5%A4%A7%E6%96%87%E4%BB%B6%E5%92%8C%E5%A4%9A%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="更改上传文件大小限制"><a href="#更改上传文件大小限制" class="headerlink" title="更改上传文件大小限制"></a>更改上传文件大小限制</h2><p>我的django上传文件工具代码是<a href="https://rorschachchan.github.io/2018/12/19/Django%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/">https://rorschachchan.github.io/2018/12/19/Django实现图片上传/</a> 这么写的，但是发现再上传大的图片（7M左右的GIF图片）时，出现了413的错误提示：<br><img data-src="/images/django51.png" alt="akb48"></p>
<p>我上传的方法<code>request.FILES.getlist</code>，但是文件的体积太大了，所有就有这样的错误。去django的官方文档<a href="https://docs.djangoproject.com/en/2.2/ref/settings/#file-upload-max-memory-size">https://docs.djangoproject.com/en/2.2/ref/settings/#file-upload-max-memory-size</a> 查了一下：<br><img data-src="/images/django52.png" alt="akb48"><br><img data-src="/images/django53.png" alt="akb48"></p>
<p>原来django默认的上传文件大小是2.5M，小于2.5M时，会放在InMemoryFileUploadFile（内存里面）对象里面；大于2.5M时，会放在TemporaryFileUploadFile（磁盘文件）里面。于是我们就要更改一下这个大小，改成25M。这个要谨慎使用，小心内存溢出。</p>
<p>打开<code>settings.py</code>，增加一句<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FILE_UPLOAD_MAX_MEMORY_SIZE = <span class="number">26214400</span>  <span class="comment">#上传文件大小，改成25M</span></span><br><span class="line">DATA_UPLOAD_MAX_MEMORY_SIZE = <span class="number">26214400</span>	<span class="comment">#上传数据大小，也改成了25M</span></span><br></pre></td></tr></table></figure></p>
<p>保存之后，django会自动重启，再次尝试传输单个大文件，应该就会成功了。</p>
<p>其实这个改动不仅仅是单个文件小于25M，假如是批量上传，所选的文件加起来总量小于25M都可以一并传上去了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://stackoverflow.com/questions/55190498/413-payload-too-large-on-django-server">https://stackoverflow.com/questions/55190498/413-payload-too-large-on-django-server</a><br><a href="https://github.com/django/django/blob/master/django/conf/global_settings.py#L297">https://github.com/django/django/blob/master/django/conf/global_settings.py#L297</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>记录日志系统ELKB 5.6.4的搭建过程</title>
    <url>/2018/01/16/%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9FELKB-5-6-4%E7%9A%84%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ELK是最近比较流行的免费的日志系统解决方案，注意，ELK不是一个软件名，而是一个解决方案的缩写，即<code>Elasticsearch+Logstash+Kibana（ELK Stack）</code>。这哥几个都是java系的产品，但是众所周知，java的东西很吃内存和CPU，Logstash在当作为收集日志的Agent时，就显得太过臃肿了。听说直播平台“斗鱼”团队很为logstash占用资源的情况很而苦恼，后来为了解决这个问题，他们自己写了一个agent。不过后来官方在logstash-forwarder的基础上推出了beat系列，里面包括四个兄弟，分别是：Packetbeat（搜集网络流量数据）；Topbeat（搜集系统、进程和文件系统级别的 CPU 和内存使用情况等数据）；Filebeat（搜集文件数据）；Winlogbeat（搜集 Windows 事件日志数据）。而Filebeat也就这样加入了“日志收集分析”的团队里，所以虽然大家还是习惯性的叫ELK，其实准确的说法已经是ELKB了。</p>
<p>ELKB这几个哥们的分工如下：</p>
<ol>
<li>Elasticsearch：分布式搜索和分析引擎，具有高可伸缩、高可靠和易管理等特点。基于 Apache Lucene 构建，能对大容量的数据进行接近实时的存储、搜索和分析操作。通常被用作某些应用的基础搜索引擎，使其具有复杂的搜索功能；</li>
<li>Logstash：数据收集额外处理和数据引擎。它支持动态的从各种数据源搜集数据，并对数据进行过滤、分析、丰富、统一格式等操作，然后存储到用户指定的位置；</li>
<li>Kibana：数据分析和可视化平台。通常与 Elasticsearch 配合使用，对其中数据进行搜索、分析和以统计图表的方式展示；</li>
<li>Filebeat：ELK 协议栈的新成员，在需要采集日志数据的 server 上安装 Filebeat，并指定日志目录或日志文件后，Filebeat 就能读取数据，迅速发送到 Logstash 进行解析，亦或直接发送到 Elasticsearch 进行集中式存储和分析。</li>
</ol>
<h2 id="设计架构"><a href="#设计架构" class="headerlink" title="设计架构"></a>设计架构</h2><p><img data-src="/images/elk1.png" alt="办公室"></p>
<p>本文的设计结构就是这样，其中红色的redis&#x2F;RebbitMQ部分可以省略（我这个例子里暂省略），让日志直接传递到logstash，如果日志量较大，最好还是添加上redis，同时再横向扩容Elasticsearch，搞成一个集群。</p>
<p>对于这几个模块服务器多说几句：<br>1）Logstash要选择计算能力强的，CPU和内存比较丰满的；<br>2）Elasticsearch要选择磁盘容量大的，同时CPU和内存也比较丰满的；</p>
<h2 id="实验软件版本"><a href="#实验软件版本" class="headerlink" title="实验软件版本"></a>实验软件版本</h2><p>Elasticsearch 5.6.4<br>Logstash 5.6.4<br>Kibana 5.6.4<br>Filebeat 5.6.4<br>Java 1.8+，安装方法：<code>http://blog.51cto.com/chenx1242/2043924</code><br>由于ELKB这几个东西都是墙外的，墙内的下载可能会比较费劲。所以我稍后会把所有ELKB的5.6.4程序都放在51CTO的存储空间里，需要的朋友可以去下载，还是那话，虽然ELK升级频率很快，但是5.6.4已经足够稳定了。</p>
<h2 id="实验服务器情况"><a href="#实验服务器情况" class="headerlink" title="实验服务器情况"></a>实验服务器情况</h2><p><img data-src="/images/elk2.png" alt="办公室"></p>
<h2 id="安装Elasticsearch-5-6-4"><a href="#安装Elasticsearch-5-6-4" class="headerlink" title="安装Elasticsearch 5.6.4"></a>安装Elasticsearch 5.6.4</h2><p>以下所有操作都是root下进行的:<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">curl -L -O <span class="attr">https</span>:<span class="comment">//artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.6.4.rpm</span></span><br><span class="line">rpm -ivh elasticsearch-<span class="number">5.6</span><span class="number">.4</span>.<span class="property">rpm</span></span><br></pre></td></tr></table></figure></p>
<p>然后编辑<code>/etc/elasticsearch/elasticsearch.yml</code>，不然的话logstash无法与之相连：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cluster.<span class="property">name</span>: my-application  #如果是集群的es就把这个打开，<span class="title class_">Elasticsearch</span> 启动时会根据配置文件中设置的集群名字（cluster.<span class="property">name</span>）自动查找并加入集群，端口是<span class="number">9300</span></span><br><span class="line">network.<span class="property">host</span>: <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>    #取消注释，并且改成<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">http.<span class="property">port</span>: <span class="number">9200</span>    #取消注释</span><br></pre></td></tr></table></figure></p>
<p>保存之后，启动并且添加开机启动：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">systemctl start elasticsearch     </span><br><span class="line">systemctl enable elasticsearch</span><br></pre></td></tr></table></figure></p>
<p>使用<code>curl localhost:9200</code>能看到这样的情景就证明已经成功启动了：<br><img data-src="/images/elk3.png" alt="办公室"></p>
<h2 id="安装kibana-5-6-4"><a href="#安装kibana-5-6-4" class="headerlink" title="安装kibana 5.6.4"></a>安装kibana 5.6.4</h2><p>以下所有操作都是root下进行的:<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">curl -L -O <span class="attr">https</span>:<span class="comment">//artifacts.elastic.co/downloads/kibana/kibana-5.6.4-linux-x86_64.tar.gz</span></span><br><span class="line">tar xzvf kibana-<span class="number">5.6</span><span class="number">.4</span>-linux-x86_64.<span class="property">tar</span>.<span class="property">gz</span></span><br><span class="line">cd kibana-<span class="number">5.6</span><span class="number">.4</span>-linux-x86_64/</span><br><span class="line">vim config/kibana.<span class="property">yml</span></span><br></pre></td></tr></table></figure></p>
<p>把kibana.yml里的<code>server.host: localhost</code>改成<code>server.host: 0.0.0.0</code>，然后保存退出，在kibana的bin文件夹里执行<code>./kibana</code>即可。如果要后台启动就是<code>nohup /kibana安装路径/bin/kibana &amp;</code>。</p>
<p>启动之后，如图：<br><img data-src="/images/elk4.png" alt="办公室"></p>
<h2 id="安装Logstash-5-6-4"><a href="#安装Logstash-5-6-4" class="headerlink" title="安装Logstash 5.6.4"></a>安装Logstash 5.6.4</h2><p>以下所有操作都是root下进行的:<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">curl -L -O <span class="attr">https</span>:<span class="comment">//artifacts.elastic.co/downloads/logstash/logstash-5.6.4.rpm </span></span><br><span class="line">rpm -ivh logstash-<span class="number">5.6</span><span class="number">.4</span>.<span class="property">rpm</span></span><br></pre></td></tr></table></figure></p>
<p>如果安装的时候爆错：<code>/usr/share/logstash/vendor/jruby/bin/jruby: line 388: /usr/bin/java: No such file or directory</code>。那么就先<code>which java</code>查看一下java的文件，然后做一个软连接过去，然后重装logstash即可，如图：<br><img data-src="/images/elk5.png" alt="办公室"></p>
<p><img data-src="/images/elk6.png" alt="办公室"></p>
<p>用户可以使用TLS双向认证加密Filebeat和Logstash的连接，保证Filebeat只向可信的Logstash发送加密的数据（如果你的logstash和filebeat是内网通信，而且你认可当前内网的安全度，这一步可以省略）。同样的，Logstash也只接收可信的Filebeat发送的数据。这个功能默认是关闭的，要开启的话需要先<code>vim /etc/pki/tls/openssl.cnf</code>，如图：<br><img data-src="/images/elk7.png" alt="办公室"></p>
<p>找到<code>[ v3_ca ]</code>的字段，在底下添加<code>subjectAltName = IP:logstash的内网IP</code>字段，保存退出来到&#x2F;etc&#x2F;pki&#x2F;tls&#x2F;，执行下面命令：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">openssl req -x509 -days <span class="number">365</span> -batch -nodes -newkey <span class="attr">rsa</span>:<span class="number">2048</span> -keyout private/logstash-forwarder.<span class="property">key</span> -out certs/logstash-forwarder.<span class="property">crt</span></span><br></pre></td></tr></table></figure></p>
<p>来生成一个期限为365天的IP SAN证书对，如果想生成一个十年的证书，就把365改成3650即可，如图：</p>
<p>安装完毕之后，<code>vim /etc/logstash/logstash.yml</code>，编辑成如下的样子：<br><img data-src="/images/elk8.png" alt="办公室"></p>
<p>然后在<code>/etc/logstash/</code>下手动建立一个目录conf.d，在conf.d里新建一个<code>logstash.conf</code>的文件，如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ cat /usr/local/logstash/config/conf.<span class="property">d</span>/logstash.<span class="property">conf</span></span><br><span class="line">#在输入部分，配置<span class="title class_">Logstash</span>通信端口以及添加<span class="variable constant_">SSL</span>证书，从而进行安全通信。</span><br><span class="line">input &#123;</span><br><span class="line"> beats &#123;</span><br><span class="line">   <span class="function"><span class="params">port</span> =&gt;</span> <span class="number">5044</span></span><br><span class="line">   ssl =&gt; <span class="literal">true</span></span><br><span class="line">   ssl_certificate =&gt; <span class="string">&quot;/etc/pki/tls/certs/logstash-forwarder.crt&quot;</span></span><br><span class="line">   ssl_key =&gt; <span class="string">&quot;/etc/pki/tls/private/logstash-forwarder.key&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#在过滤器部分，我们将使用<span class="title class_">Grok</span>来解析这些日志，然后将其发送到<span class="title class_">Elasticsearch</span>。以下grok过滤器将查找“syslog”标记的日志，并尝试解析它们，以生成结构化索引。</span><br><span class="line">filter &#123;</span><br><span class="line"> 	<span class="keyword">if</span> [type] == <span class="string">&quot;syslog&quot;</span> &#123;</span><br><span class="line">    grok &#123;</span><br><span class="line">      <span class="function"><span class="params">match</span> =&gt;</span> &#123; <span class="string">&quot;message&quot;</span> =&gt; <span class="string">&quot;%&#123;SYSLOGTIMESTAMP:syslog_timestamp&#125; %&#123;SYSLOGHOST:syslog_hostname&#125; %&#123;DATA:syslog_program&#125;(?:\[%&#123;POSINT:syslog_pid&#125;\])?: %&#123;GREEDYDATA:syslog_message&#125;&quot;</span> &#125;</span><br><span class="line">      add_field =&gt; [ <span class="string">&quot;received_at&quot;</span>, <span class="string">&quot;%&#123;@timestamp&#125;&quot;</span> ]</span><br><span class="line">      add_field =&gt; [ <span class="string">&quot;received_from&quot;</span>, <span class="string">&quot;%&#123;host&#125;&quot;</span> ]</span><br><span class="line">    &#125;</span><br><span class="line">    syslog_pri &#123; &#125;</span><br><span class="line">    date &#123;</span><br><span class="line">      <span class="function"><span class="params">match</span> =&gt;</span> [ <span class="string">&quot;syslog_timestamp&quot;</span>, <span class="string">&quot;MMM  d HH:mm:ss&quot;</span>, <span class="string">&quot;MMM dd HH:mm:ss&quot;</span> ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#输出部分，我们将定义要存储的日志位置</span><br><span class="line">output &#123;</span><br><span class="line">	elasticsearch &#123;</span><br><span class="line"> 	<span class="function"><span class="params">hosts</span> =&gt;</span> [ <span class="string">&quot;10.162.80.192:9200&quot;</span> ]                #这个地址是elasticsearch的内网地址</span><br><span class="line">	index =&gt; <span class="string">&quot;filebeat-%&#123;+YYYY.MM.dd&#125;&quot;</span>			#设定这个是索引</span><br><span class="line">   	#index =&gt; <span class="string">&quot;auclogstash-%&#123;+YYYY.MM.dd&#125;&quot;</span>    	#这行是后来作实验的，可以忽视            </span><br><span class="line">	user =&gt; elastic                    #这个是为了将来装x-pack准备的</span><br><span class="line">	password =&gt; changeme                #同上</span><br><span class="line">   	   &#125;</span><br><span class="line">stdout &#123;</span><br><span class="line">   	<span class="function"><span class="params">codec</span> =&gt;</span> rubydebug</span><br><span class="line">   	   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后就是启动并且添加开机自启动:<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">systemctl start logstash        </span><br><span class="line">systemctl enable logstash</span><br></pre></td></tr></table></figure></p>
<h2 id="安装filebeat"><a href="#安装filebeat" class="headerlink" title="安装filebeat"></a>安装filebeat</h2><p>以下所有操作都是root下进行的,在模块服务器上安装filebeat的方法如下:<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">curl -L -O <span class="attr">https</span>:<span class="comment">//artifacts.elastic.co/downloads/beats/filebeat/filebeat-5.6.4-x86_64.rpm </span></span><br><span class="line">rpm -ivh filebeat-<span class="number">5.6</span><span class="number">.4</span>-x86_64.<span class="property">rpm</span></span><br></pre></td></tr></table></figure></p>
<p>之前在logstash上生成了一个IP SAN证书，现在需要把这个证书传递给filebeat的机器里，使用scp语句如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">scp -pr root@<span class="number">10.162</span><span class="number">.80</span><span class="number">.171</span>:<span class="regexp">/etc/</span>pki/tls/certs/logstash-forwarder.<span class="property">crt</span> /etc/ssl/certs/        #<span class="number">10.162</span><span class="number">.80</span><span class="number">.171</span>就是logstash的内网<span class="variable constant_">IP</span></span><br></pre></td></tr></table></figure></p>
<p>输入logstash的密码，并且密钥文件复制完毕之后，需要修改filebeat.yml，于是#vim &#x2F;etc&#x2F;filebeat&#x2F;filebeat.yml：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@func-auc-<span class="number">001</span> log]# grep -iv <span class="string">&#x27;#&#x27;</span> /etc/filebeat/filebeat.<span class="property">yml</span> | grep -iv <span class="string">&#x27;^$&#x27;</span></span><br><span class="line">filebeat.<span class="property">prospectors</span>:</span><br><span class="line">- <span class="attr">input_type</span>: log</span><br><span class="line">  <span class="attr">paths</span>:</span><br><span class="line">    -  <span class="regexp">/mnt/</span>hswx/auc/logs<span class="comment">/*.log        #这个是那个auc模块的路径</span></span><br><span class="line"><span class="comment">    -    /第二个日志路径/*.log                   #如果有第二个文件路径的话</span></span><br><span class="line"><span class="comment">  tail_files: true                                 #从文件末尾开始读取</span></span><br><span class="line"><span class="comment">  document_type: &quot;newnginx-api&quot;                    #logstash那里已经设定了index，如果要使用了document_type，那么在logstash的index就要这么写：&quot;%&#123;type&#125;-%&#123;+YYYY.MM.dd&#125;&quot;</span></span><br><span class="line"><span class="comment">  # 以下是规避数据热点的优化参数：</span></span><br><span class="line"><span class="comment">    spool_size: 1024         # 积累1024条消息才上报</span></span><br><span class="line"><span class="comment">    idle_timeout: &quot;5s&quot;        # 空闲5s上报</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">output.logstash:</span></span><br><span class="line"><span class="comment">  hosts: [&quot;10.162.80.171:5044&quot;]            #这个地方要写logstash的内网地址</span></span><br><span class="line"><span class="comment">  ssl.certificate_authorities: [&quot;/etc/ssl/certs/logstash-forwarder.crt&quot;]    #这里就是刚刚复制的那个密钥文件路径</span></span><br><span class="line"><span class="comment">  #注意上面是ssl而不是tls，1.0版本才是tls，如果这个写错了，启动的时候会出现“read: connection reset by peer”的错误</span></span><br></pre></td></tr></table></figure></p>
<p>注意！Filebeat的配置文件采用YAML格式，这意味着缩进非常重要！请务必使用与这些说明相同数量的空格。</p>
<p>保存之后，使用<code>/etc/init.d/filebeat start</code>启动filebeat，如图：<br><img data-src="/images/elk10.png" alt="办公室"></p>
<h2 id="故障解决"><a href="#故障解决" class="headerlink" title="故障解决"></a>故障解决</h2><p>ELK几个部件现在都已经启动了，并且互相telnet端口都是通的，在elasticsearch的服务器上使用<code>curl -XGET &#39;http://elasticsearch内网IP:9200/filebeat-*/_search?pretty&#39;</code>却出现这样的情况：<br><img data-src="/images/elk9.png" alt="办公室"></p>
<p>而使用<code>tailf /var/log/filebeat/filebeat</code>去查看filebeat的日志是这样的：<br><img data-src="/images/elk11.png" alt="办公室"></p>
<p>再看看logstash-plain.log，里面的情况是这样的：<br><img data-src="/images/elk12.png" alt="办公室"></p>
<p>从此可见，filebeat与logstash的联系是error状态，那么停止filebeat的进程，改用<code>/etc/init.d/filebeat start -c /etc/filebeat/filebeat.yml</code>，重新在elasticsearch的服务器上使用<code>curl -XGET &#39;http://elasticsearch内网IP:9200/filebeat-*/_search?pretty&#39;</code>发现已经成功读到了我们之前配置的目录“&#x2F;mng&#x2F;hswx&#x2F;auc&#x2F;log”，如图：<br><img data-src="/images/elk13.png" alt="办公室"></p>
<h2 id="配置kibana"><a href="#配置kibana" class="headerlink" title="配置kibana"></a>配置kibana</h2><p>在浏览器输入<code>kibana服务器外网IP：5601</code>打开kibana的web界面，把<code>idenx pattern</code>的地方改成<code>filebeat-*</code>(同之前配置的index索引一致)，然后点击<code>create</code>，如图：<br><img data-src="/images/elk14.png" alt="办公室"></p>
<p>然后就得到了细节的web界面，如图：<br><img data-src="/images/elk15.png" alt="办公室"></p>
<p>点击左侧框的<code>Discover</code>，就会看到梦寐以求的日志web界面，如图：<br><img data-src="/images/elk16.png" alt="办公室"></p>
<p>看一下红色框的内容里面有时间，有host主机，有source来源，还有具体的日志信息，我们再去func-auc-001这个日志源主机上查询一下日志：<br><img data-src="/images/elk17.png" alt="办公室"></p>
<p>两个日志是一样的，可见实现了预期的日志展示的目标！</p>
<p>最后一步，就是把kibana与nginx联系起来（也可以把kibana做阿里云负载均衡的后端服务器），这样通过nginx&#x2F;负载均衡来访问kibana的界面，对kibana来说更安全。配置端口监听如图，再把kibana服务器挂在负载均衡后面即可。<br><img data-src="/images/elk18.png" alt="办公室"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-elk-filebeat/index.html">https://www.ibm.com/developerworks/cn/opensource/os-cn-elk-filebeat/index.html</a><br><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-elk/">https://www.ibm.com/developerworks/cn/opensource/os-cn-elk/</a><br><a href="http://www.jinsk.vip/2017/05/24/elksetup/">http://www.jinsk.vip/2017/05/24/elksetup/</a><br><a href="https://renwole.com/archives/661">https://renwole.com/archives/661</a><br><a href="https://www.zybuluo.com/dume2007/note/665868">https://www.zybuluo.com/dume2007/note/665868</a><br><a href="https://www.elastic.co/guide/en/beats/libbeat/5.6/getting-started.html">https://www.elastic.co/guide/en/beats/libbeat/5.6/getting-started.html</a><br><a href="https://discuss.elastic.co/search?q=ERR%20Failed%20to%20publish%20events%20caused%20by:%20read%20tcp">https://discuss.elastic.co/search?q=ERR%20Failed%20to%20publish%20events%20caused%20by%3A%20read%20tcp</a><br><a href="http://jaminzhang.github.io/elk/ELK-config-and-use-Filebeat/">http://jaminzhang.github.io/elk/ELK-config-and-use-Filebeat/</a> （这个博主很好，但是就是博客无法留言，这点比较坑）</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>大数据分析</tag>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈中国短道速滑队</title>
    <url>/2022/02/20/%E8%B0%88%E8%B0%88%E4%B8%AD%E5%9B%BD%E7%9F%AD%E9%81%93%E9%80%9F%E6%BB%91%E9%98%9F/</url>
    <content><![CDATA[<p>以我来说，冬奥项目最喜欢的就是短道速滑，首先是短道速滑的运动员身材也比较健美，胸平腿粗屁股翘。而且它是一个速度为主又不缺身体对抗的项目，相比较大道速滑，短道速滑更频繁的弯道超车让比赛多出了很多悬念，策略、胆识、技巧和刺激并存。最最重要的是，这个项目是一个赛后严重互相撕逼的节目，带来的口水战数不胜数。</p>
<h2 id="中国队的囧境"><a href="#中国队的囧境" class="headerlink" title="中国队的囧境"></a>中国队的囧境</h2><p>今天冬奥会随着双人花滑隋文静&#x2F;韩聪也拿到了金牌，大概率中国代表队就会以9块金牌结束东奥之旅，但是相比较于在主场作战各方夺金的声势，曾经的金牌大户—“短道速滑”相对来说，表现是差强人意。尤其是短道项目的最后一天，让韩国一金一银反超了该项目的奖牌总数，这样高开低走的表现更是让无数中国网友憋气。</p>
<p>先看一下2金1银1铜的分布：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2金：混合接力、男子1000米（任子威）</span><br><span class="line">1银：男子1000米（武大靖）</span><br><span class="line">1铜：女子3000米接力</span><br></pre></td></tr></table></figure></p>
<p>可以说这几些奖牌来的很不容易（判罚或者“我的眼睛就是尺”），但是输掉的基本都稀里哗啦：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">女子500：张玉婷进了A组决赛第四，倒数第二；</span><br><span class="line">女子1000：无人进A\B组决赛；</span><br><span class="line">女子1500：韩雨桐进了A组决赛，开头爆发结果成绩倒数第一；</span><br><span class="line">男子500：武大靖B组决赛第一；</span><br><span class="line">男子1500：无人进A\B组决赛</span><br><span class="line">男子3000接力：孙龙摔倒，A组倒数第一；</span><br></pre></td></tr></table></figure></p>
<p>中国代表队在本届北京冬奥会之前一共有13枚金牌40枚奖牌，其中有12枚金牌来自冰上项目，12枚里10枚来自短道速滑，而这10枚里9枚来自女子速滑队。可以说中国女子短道速滑队是中国冬奥会的奖牌大户，但是这只队伍从2018年平昌到现在，登上领奖台的女子单项只有李靳宇（2018平昌女子1500米），这次还因为腰伤没来。</p>
<p>上面这个成绩单直接反映了短道速滑队自2018年开始整体实力的一个下降，而且比较严重的是，现在中国短道速滑队属于一个人才青黄不接的断档期。武大靖下一届意大利米兰冬奥会有多少油不好说，规划来的林孝俊到时候是不是匈牙利刘氏兄弟的对手？女子方面，范可新大概率不会参加下一届了，李靳宇恢复成啥样不好说，还要依靠韩雨桐他们么？韩雨桐都27了，而且她的实力目前看都不如韩国的李有彬，更别提崔敏静这种历史级别的人物了。</p>
<p>其实在咪咕解说的短道速滑队的比赛里，曾经的国家队总教练长（短道+大道都归她管）王濛也提出过几个质疑：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 张楚桐虽然半决赛是第一组出场，在恢复体能上吃亏了，但是赛前王濛说“我们训练的时候，休息一分钟再上是训练的家常便饭”，但是在半决赛里，张楚桐明显没有力气了。平时的训练量不足么？</span><br><span class="line">2. 韩雨桐为什么决赛采取兔子战术？</span><br><span class="line">3. 男子接力选人为什么会选孙龙？</span><br></pre></td></tr></table></figure></p>
<p>以上这些质疑可以隐约的看出王濛对现如今的国家速滑队的一些情况是“看不懂”的，这里面的内幕我们不得而知，但是交出这样的一份答卷我想短道速滑队肯定至少是要低调一下的。而且随着孙龙被王濛怒骂等事情，安凯等人没有入选冬奥会大名单的“选拔机制”也被网友翻出，直言这机制够奇葩的：<br><img data-src="/images/%E7%9F%AD%E9%81%93%E9%80%89%E6%8B%94.PNG"></p>
<p>中国网民经常嘲笑韩国内斗，他们也经常在B站和论坛反复提及崔敏静跟沈石溪的“塑料姐妹情”，或者挖掘“崔敏静银牌周边队友笑”的片段，甚至郭润起在更衣室受伤，李浩锡撞到队友盛锡贝导致韩国队到手的金银铜只剩一块金牌等等事情被中国网友幸灾乐祸。但是要知道中国队的“黑吉”内斗也是家常便饭，队员身后也有各地方媒体撑腰，只不过压盖的比较好而已。<br><img data-src="/images/%E6%B2%88%E7%9F%B3%E6%BA%AA%E5%B4%94%E6%95%8F%E9%9D%99.gif" title="平昌冬奥会1000米决赛，沈石溪在外线试图超越丰塔纳时发生了碰撞，失去平衡之后，带倒了崔敏静"><br><img data-src="/images/%E6%9D%8E%E6%B5%A9%E9%94%A1%E7%9B%9B%E9%94%A1%E8%B4%9D.gif" title="温哥华冬奥会男子1500米决赛最后时刻，李浩锡自杀式超越，将盛锡贝绊倒"></p>
<p>看完了内还有外，现在中国南北经济反差太大，大量北方人外流，在南方安家落户（比如我），孩子在南方出生接受教育，肯定也接触的是南方的运动，导致短道速滑的选材分母越来越少，这也是速滑队后补力量可能会匮乏的一个隐患。</p>
<h2 id="中韩之争"><a href="#中韩之争" class="headerlink" title="中韩之争"></a>中韩之争</h2><p>中国与韩国在很多体育项目上有直接竞争关系，除了经常撕逼的短道速滑，还有篮球、足球、游泳（朴泰桓VS孙阳）、射击、射箭。由于中韩在历史文化和领土上的一些纠纷（2007年在长春的亚冬会，因为之前比赛的争议，导致韩国女子在获得3000米接力银牌后，五个姑娘在领奖台上打出了“白头山是韩国领土”的政治标语），所以每次这种竞争关系都会被网民们指责对方缺乏体育精神，进而带上民族主义色彩。今年比较出名的就是安贤洙被韩国网民网暴。<br><img data-src="/images/%E9%9F%A9%E5%9B%BD%E6%A0%87%E8%AF%AD.JPG"></p>
<p>而在短道这种速度快的项目里，中韩身体碰撞频繁镜头频频发生，赛后双方媒体队员互相指责，网民撕逼的情况数不胜数。其实在“恶意伤人”里双方都不是赢家：郑恩珠把周洋推了颈椎错位（周洋之前被申新春推过，那场是郑恩珠夺冠），孟晓雪也废了陈善有（这事发生在前），黄大宪抬刀过高影响武大靖，范可新在500米决赛手搂了沈石溪的膝盖（抛开民族立场而言，范可新的犯规的确很多，她是16-18两个赛季的国际赛事里的犯规王）。</p>
<p>【孟晓雪对陈善有犯规，从此陈善有基本远离赛场，孟晓雪被网友成为民族英雄】 <a href="https://b23.tv/X97ebuM">https://b23.tv/X97ebuM</a><br>【范可新冲刺阶段搂沈石溪膝盖】<a href="https://v.qq.com/x/page/k0848pil3d5.html">https://v.qq.com/x/page/k0848pil3d5.html</a><br>【索契1000米决赛，范可新冲刺拉人，这届1000米范可新可以说从小组赛就犯规，半决赛也犯规，决赛还拉人】<a href="https://www.bilibili.com/video/av927130401/">https://www.bilibili.com/video/av927130401/</a></p>
<p>不过说实话，这种肢体冲突，感觉还是中国队员吃亏比较多。韩国队主动挑衅的镜头也比较多一点，不过相对奇怪的是，除了中韩之间火星撞地球，但是他们各自对其他国家选手相对来说犯规也有但是没有那么集中，可以说是“有针对性的积怨”了。<br><img data-src="/images/%E9%87%91%E7%82%B3%E4%BF%8A%E4%BC%A4%E5%AE%B3%E9%9F%A9%E4%BD%B3%E8%89%AF.gif" title="金炳俊这个动作非常的恶劣！韩佳良当时送去抢救，从此远离赛场"></p>
<p>韩国是速滑强国，那里产生过很多速滑名将，不过也是一个故事很多的国家，比如2006年都灵冬奥会5000米接力成员吴世钟在2016年车祸去世、1500米记录和3000米记录保持者卢珍奎骨癌去世、“体大”与“非体大”的内斗、安贤洙和林孝俊转国籍、崔敏静VS沈石溪等等赛场内外的新闻也是屡屡不穷，我觉得以netflix和韩国喜欢“自揭黑暗面”的尿性，把他们都拍成电影也不是不可能。</p>
<h2 id="一些其他"><a href="#一些其他" class="headerlink" title="一些其他"></a>一些其他</h2><p>温哥华冬奥会的辉煌，让中国的短道成绩一时无两，这期间中国国家队培养出来很多人才，而这些人才也在退役后做了其他国家的教练，比如李佳军做了哈萨克斯坦的教练，张晶做了匈牙利教练，跟王濛闹过矛盾又和好的李琰曾经更是在斯洛伐克、奥地利、美国等地担任过教练（她有美国绿卡），但是细心的老冰迷可以发现一个问题，就是中国教练基本不会在韩国任职，但是韩国教练很多在中国任职。</p>
<p>且不说本次冬奥会频频上热搜的金善台（他在长春队带过周洋，而且是少数的带过中日韩三个国家队的人）和安贤洙，宋在根和赵载范（他是沈石溪从小的教练，平昌奥运会因为训练中打了沈石溪被停职）在2018年就来中国国家短道速滑队了，只不过待了一年，他俩的领导李琰就换成了王濛，然后王濛2020年5月份下课。</p>
<p>这个原因可能就是韩国觉得自己无需聘用他国教练，哪怕现在短道速滑的霸主地位已经不复存在也要维持住自己内心的那一份骄傲。但是说实话，韩国也到了换血的阵痛期，虽然他们的崔敏静是历史级别的选手，她要是下届前不生孩子不受伤，很有可能1500米三连霸，成为历史TOP 1。但是女子除了崔敏静之外，李有彬和金雅朗个人能力并不突出，更多担任战术旗子的角色。韩国男队也有类似这样的情况。</p>
<p>短道速滑运动员在韩国地位很高，有很多福利待遇（崔敏静近期拿下了欧米伽的代言），这可能导致他们短道文化的“奖牌至上”。当然其实中国冠军运动员的待遇也不低，比如武大靖，虽然他不如今年突然铺天盖地宣传的谷爱凌有2亿的代言费，但是他也代言了类似肯德基、宝洁、康师傅等数十家一线品牌。<br><img data-src="/images/%E6%AD%A6%E5%A4%A7%E9%9D%96%E6%96%87%E6%A1%88%E4%B9%8C%E9%BE%99.jpg" title="武大靖微博文案闹乌龙"></p>
<p>但是毕竟武大靖是金字塔尖的运动员，像东京奥运会一跳出名的全红婵一样被资本看中。那么其他的腰部运动员呢？我们可能要面临东北孩子越来越少玩冰上项目的事实，我们要如何改变这样的局面？</p>
<p>中国冬季项目最成功的运动员王濛其实在采访里都说过：“韩国速滑有很多地方值得我们学习，首先他们基层教练工资很高，甚至比国家队教练还高”，“像方塔娜这样的老运动员可以自己选择赛事参加，同时选中她的资本会想方延长她的运动寿命，所以她们是越老越吃香”等等看法，可见我们国家的速滑管理和运动员商业价值保护上还有很长的路要走。</p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>体育</tag>
        <tag>奥运会</tag>
      </tags>
  </entry>
  <entry>
    <title>调用阿里云api去修改域名对应IP</title>
    <url>/2018/09/17/%E8%B0%83%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91api%E5%8E%BB%E4%BF%AE%E6%94%B9%E5%9F%9F%E5%90%8D/</url>
    <content><![CDATA[<h2 id="问题简述"><a href="#问题简述" class="headerlink" title="问题简述"></a>问题简述</h2><p>以阿里云厂家为例，假设我们有一个网站，它的服务器、数据库、负载均衡都部署在杭州区可用区B,将IP A绑定到某个域名上，启动了系统之后为客户提供服务。那么如果现在要对这套系统进行灾备，应该怎么做？</p>
<p>第一个方法：在可用区D复制一模一样的环境，然后以“主备服务器组”的方式配置一下负载均衡：如果端口监听不正常就会切换到备用服务器上，监听正常了再切回来。但是这个方式有一个问题，就是当前模式<strong>阿里云的主备切换是不支持HTTPS&#x2F;HTTP的</strong>，如图：<br><img data-src="/images/aliyundns2.png" alt="akb48"></p>
<p>可见，这种方式是有很大的局限性的。</p>
<p>那既然同是花钱，干脆就做一个异地容灾，整套系统在其他的地理区域比如上海区也复制一遍，把上海区的B IP也绑定到这个网站域名上，阿里云的域名解析是支持多IP绑定同一个域名的。平时的时候，上海区的IP被域名解析的权重是0，一旦杭州区出现了某些线路方面的硬件问题，那么就将杭州区的权重降成0，同时提高上海区的权重，这样用户就会直接访问到上海区的系统。</p>
<p>理想是丰满的，但是现实是骨感的，因为阿里云的权重配置区域是1<del>100，而不是0</del>100，如下图：<br><img data-src="/images/aliyundns1.png" alt="akb48"></p>
<p>也就是说这个云解析的负载均衡是不能当做主备切换使用的，如果想要通过阿里云解析来达到主备切换的目的，方法只能是<code>升级VIP DNS，配置网站监控</code>，具体操作是<a href="https://help.aliyun.com/document_detail/59372.html?spm=5176.215331.1147916.23.65de614dac85Sw">https://help.aliyun.com/document_detail/59372.html?spm=5176.215331.1147916.23.65de614dac85Sw</a> 。但是这个VIP升级是需要钱的，如果监控的网站越多，花费越大，如果老板不肯掏这份钱，那就只能换条路走。</p>
<h2 id="脚本内容"><a href="#脚本内容" class="headerlink" title="脚本内容"></a>脚本内容</h2><p>想来想去，还是老办法—-调用阿里云API修改云解析记录达到切换IP的目的。脚本如下，这里我采取了命令行交互的形式，实际上都是将域名IP写死的：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/usr/</span>bin/env python</span><br><span class="line">#coding=utf-<span class="number">8</span></span><br><span class="line">#此脚本版本是<span class="number">2.7</span>，用来修改阿里云云解析<span class="variable constant_">IP</span>地址，使用之前请先安装<span class="attr">sdk</span>:pip install aliyun-python-sdk-domain</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.<span class="property">client</span> <span class="keyword">import</span> <span class="title class_">AcsClient</span></span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.<span class="property">request</span> <span class="keyword">import</span> <span class="title class_">CommonRequest</span></span><br><span class="line">print <span class="string">&quot;请注意！本脚本只会修改lechange.com域名下的A记录！！！&quot;</span></span><br><span class="line"><span class="title class_">RRKeyWord</span> = <span class="title function_">raw_input</span>(<span class="string">&quot;请输入您要修改的域名：&quot;</span>)</span><br><span class="line"><span class="title class_">Value</span> = <span class="title function_">raw_input</span>(<span class="string">&quot;请输入新的IP：&quot;</span>)</span><br><span class="line">client = <span class="title class_">AcsClient</span>(<span class="string">&#x27;这里是AK&#x27;</span>, <span class="string">&#x27;这里是SK&#x27;</span>,<span class="string">&#x27;cn-hangzhou&#x27;</span>)</span><br><span class="line">request = <span class="title class_">CommonRequest</span>()</span><br><span class="line">request.<span class="title function_">set_accept_format</span>(<span class="string">&#x27;json&#x27;</span>)</span><br><span class="line">request.<span class="title function_">set_domain</span>(<span class="string">&#x27;alidns.aliyuncs.com&#x27;</span>)</span><br><span class="line">request.<span class="title function_">set_method</span>(<span class="string">&#x27;POST&#x27;</span>)</span><br><span class="line">request.<span class="title function_">set_version</span>(<span class="string">&#x27;2015-01-09&#x27;</span>)</span><br><span class="line"></span><br><span class="line">def <span class="title function_">getRecordId</span>(<span class="title class_">RRKeyWord</span>):</span><br><span class="line">        <span class="variable language_">global</span> <span class="title class_">RecordId</span></span><br><span class="line">        request.<span class="title function_">set_action_name</span>(<span class="string">&#x27;DescribeDomainRecords&#x27;</span>)</span><br><span class="line">        request.<span class="title function_">add_query_param</span>(<span class="string">&#x27;DomainName&#x27;</span>, <span class="string">&#x27;lechange.com&#x27;</span>)	#这里写死了lechange.<span class="property">com</span>域名</span><br><span class="line">        request.<span class="title function_">add_query_param</span>(<span class="string">&#x27;RRKeyWord&#x27;</span>, <span class="title class_">RRKeyWord</span>)</span><br><span class="line">        request.<span class="title function_">add_query_param</span>(<span class="string">&#x27;TypeKeyWord&#x27;</span>, <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">        response = client.<span class="title function_">do_action_with_exception</span>(request)</span><br><span class="line">        encode_json = json.<span class="title function_">loads</span>(response)</span><br><span class="line">        <span class="title class_">RecordId</span> = encode_json[<span class="string">&#x27;DomainRecords&#x27;</span>][<span class="string">&#x27;Record&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;RecordId&#x27;</span>]	#需要获取这个<span class="title class_">RecordId</span></span><br><span class="line">                </span><br><span class="line">def <span class="title class_">UpdateDomainRecord</span>(<span class="title class_">RRKeyWord</span>,<span class="title class_">Value</span>):</span><br><span class="line">        request.<span class="title function_">set_action_name</span>(<span class="string">&#x27;UpdateDomainRecord&#x27;</span>)</span><br><span class="line">        request.<span class="title function_">add_query_param</span>(<span class="string">&#x27;RecordId&#x27;</span>, <span class="title class_">RecordId</span>)</span><br><span class="line">        request.<span class="title function_">add_query_param</span>(<span class="string">&#x27;RR&#x27;</span>, <span class="title class_">RRKeyWord</span>)</span><br><span class="line">        request.<span class="title function_">add_query_param</span>(<span class="string">&#x27;Type&#x27;</span>, <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">        request.<span class="title function_">add_query_param</span>(<span class="string">&#x27;Value&#x27;</span>, <span class="title class_">Value</span>)</span><br><span class="line">        response = client.<span class="title function_">do_action_with_exception</span>(request)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">        <span class="title function_">getRecordId</span>(<span class="title class_">RRKeyWord</span>)</span><br><span class="line">        <span class="title class_">UpdateDomainRecord</span>(<span class="title class_">RRKeyWord</span>,<span class="title class_">Value</span>)</span><br></pre></td></tr></table></figure></p>
<p>这个脚本比较粗糙，可以改进的地方如下：</p>
<ol>
<li>判断输入的域名和IP是否符合格式的规范；</li>
<li>判断输入的域名是否存在；</li>
<li>如果添加错误，对应的报错；</li>
<li>搭配爬虫页面脚本使用，如果爬虫页面脚本出现了异常，那么直接启动这个脚本，并且发送微信&#x2F;邮件通知！</li>
</ol>
<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>整个脚本启动后效果如下：<br><img data-src="/images/aliyundns3.gif" alt="akb48"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://help.aliyun.com/document_detail/29776.html?spm=a2c4g.11186623.2.37.d31b31dfNqojPT">https://help.aliyun.com/document_detail/29776.html?spm=a2c4g.11186623.2.37.d31b31dfNqojPT</a><br><a href="https://help.aliyun.com/document_detail/44657.html?spm=a2c4g.11186623.6.579.4d1d7cd208aSgl">https://help.aliyun.com/document_detail/44657.html?spm=a2c4g.11186623.6.579.4d1d7cd208aSgl</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title>调用阿里云api获取阿里云数据同步服务（DTS）并且作图发送邮件的整个流程</title>
    <url>/2018/02/28/%E8%B0%83%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91api%E8%8E%B7%E5%8F%96%E9%98%BF%E9%87%8C%E4%BA%91%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1%EF%BC%88DTS%EF%BC%89%E5%B9%B6%E4%B8%94%E4%BD%9C%E5%9B%BE%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E7%9A%84%E6%95%B4%E4%B8%AA%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在<a href="https://rorschachchan.github.io/2018/02/24/%E9%98%BF%E9%87%8C%E4%BA%91%E8%8E%B7%E5%8F%96DTS%E6%9C%8D%E5%8A%A1%E5%BB%B6%E8%BF%9F%E7%9A%84%E8%84%9A%E6%9C%AC/">https://rorschachchan.github.io/2018/02/24/阿里云获取DTS服务延迟的脚本/</a> 文章里已经说了“领导要求每天查看阿里云dts同步的延迟情况和同步速率情况”，并且在<a href="https://rorschachchan.github.io/2018/02/27/%E4%BD%BF%E7%94%A8matplotlib%E7%94%BB%E5%9B%BE%E7%9A%84%E4%B8%80%E4%B8%AA%E8%84%9A%E6%9C%AC/">https://rorschachchan.github.io/2018/02/27/使用matplotlib画图的一个脚本/</a> 里面也放了一个使用<code>python matplotlib</code>画图的demo，这篇文章的目的就是把整个过程实现，并且把dts图形以每日邮件的形式发送给领导的效果！</p>
<h2 id="实现需求的思路"><a href="#实现需求的思路" class="headerlink" title="实现需求的思路"></a>实现需求的思路</h2><p>本次需求有四个动作，分别是<code>获取一天以内的DTS延迟和同步速率</code>、<code>将获取到的DTS值做成PNG图像</code>、<code>将生成的PNG图像上传到阿里云云存储OSS</code>、<code>把图片展示到邮件里并发送给相关领导</code>。由于第一步<code>获取一天以内的DTS延迟和同步速率</code>需要将这个脚本每小时执行一次，执行24次，才可以执行<code>生成png图像</code>这一步，所以后三个其实可以写成一个大脚本。不过在本文为了表述的清楚，就把各自不同用途写成了不同的脚本。</p>
<h2 id="获取阿里云DTS延迟和同步速率的脚本"><a href="#获取阿里云DTS延迟和同步速率的脚本" class="headerlink" title="获取阿里云DTS延迟和同步速率的脚本"></a>获取阿里云DTS延迟和同步速率的脚本</h2><p>这个脚本之前写过了，这里再拿出来晒一遍：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/usr/</span>bin/env python</span><br><span class="line">#coding=utf-<span class="number">8</span></span><br><span class="line">#这个脚本是用来获取dts延迟数字的</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore <span class="keyword">import</span> client</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.<span class="property">acs_exception</span>.<span class="property">exceptions</span> <span class="keyword">import</span> <span class="title class_">ClientException</span></span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.<span class="property">acs_exception</span>.<span class="property">exceptions</span> <span class="keyword">import</span> <span class="title class_">ServerException</span></span><br><span class="line"><span class="keyword">import</span> time,json,sys</span><br><span class="line">sys.<span class="property">path</span>.<span class="title function_">append</span>(<span class="string">&#x27;/解压缩路径/aliyunsdkdts/request/v20160801/&#x27;</span>)		#这里看不懂去看<span class="attr">https</span>:<span class="comment">//rorschachchan.github.io/2018/02/24/阿里云获取DTS服务延迟的脚本/</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">DescribeSynchronizationJobStatusRequest</span></span><br><span class="line"></span><br><span class="line"># 创建 <span class="title class_">Client</span> 实例</span><br><span class="line">clt = client.<span class="title class_">AcsClient</span>(<span class="string">&#x27;这里填写ak&#x27;</span>,<span class="string">&#x27;这里填写sk&#x27;</span>,<span class="string">&#x27;cn-shenzhen&#x27;</span>)</span><br><span class="line"></span><br><span class="line"># 创建 request，并设置参数</span><br><span class="line">request = <span class="title class_">DescribeSynchronizationJobStatusRequest</span>.<span class="title class_">DescribeSynchronizationJobStatusRequest</span>()</span><br><span class="line">request.<span class="title function_">set_SynchronizationJobId</span>(<span class="string">&quot;这里填写DTS的ID号&quot;</span>)</span><br><span class="line"></span><br><span class="line">response = clt.<span class="title function_">do_action_with_exception</span>(request)</span><br><span class="line"></span><br><span class="line">delay = json.<span class="title function_">loads</span>(response)</span><br><span class="line">rate = <span class="title function_">str</span>(delay[<span class="string">&quot;Performance&quot;</span>][<span class="string">&quot;FLOW&quot;</span>])[<span class="number">0</span>:<span class="number">4</span>]	#由于同步速率默认是带单位的，这里就取前四位</span><br><span class="line"></span><br><span class="line">#用A.<span class="property">txt</span>来存储延迟时长</span><br><span class="line">fd = <span class="title function_">open</span>(<span class="string">&quot;/存储路径/A.txt&quot;</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line">fd.<span class="title function_">write</span>(<span class="title function_">str</span>(delay[<span class="string">&quot;DataSynchronizationStatus&quot;</span>][<span class="string">&quot;Delay&quot;</span>]))</span><br><span class="line">fd.<span class="title function_">write</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">fd.<span class="title function_">close</span>()</span><br><span class="line"></span><br><span class="line">#用B.<span class="property">txt</span>来存储同步速率	</span><br><span class="line">fr = <span class="title function_">open</span>(<span class="string">&quot;/存储路径/rate.txt&quot;</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line">fr.<span class="title function_">write</span>(rate)</span><br><span class="line">fr.<span class="title function_">write</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">fr.<span class="title function_">close</span>()</span><br></pre></td></tr></table></figure></p>
<h2 id="将获取到的值做成图片的脚本"><a href="#将获取到的值做成图片的脚本" class="headerlink" title="将获取到的值做成图片的脚本"></a>将获取到的值做成图片的脚本</h2><p>由于脚本执行环境是无图像的阿里云服务器，系统是<code>centos 7</code>，<code>ps.slow</code>这一步会爆错<code>RuntimeError: could not open display</code>，所以只能采取把生成的PNG图像文件保存到本地路径里的方法。脚本内容如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/usr/</span>bin/env python</span><br><span class="line"># -*- <span class="attr">coding</span>: utf-<span class="number">8</span> -*-</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line">mpl.<span class="title function_">use</span>(<span class="string">&#x27;Agg&#x27;</span>)		#在无法生成图像的环境下要添加了上面两句话</span><br><span class="line"><span class="keyword">import</span> matplotlib.<span class="property">pyplot</span> <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pylab <span class="keyword">as</span> pl</span><br><span class="line"></span><br><span class="line">x=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>]</span><br><span class="line">#横坐标的内容</span><br><span class="line">labels=[<span class="string">&#x27;10&#x27;</span>,<span class="string">&#x27;11&#x27;</span>,<span class="string">&#x27;12&#x27;</span>,<span class="string">&#x27;13&#x27;</span>,<span class="string">&#x27;14&#x27;</span>,<span class="string">&#x27;15&#x27;</span>,<span class="string">&#x27;16&#x27;</span>,<span class="string">&#x27;17&#x27;</span>,<span class="string">&#x27;18&#x27;</span>,<span class="string">&#x27;19&#x27;</span>,<span class="string">&#x27;20&#x27;</span>,<span class="string">&#x27;21&#x27;</span>,<span class="string">&#x27;22&#x27;</span>,<span class="string">&#x27;23&#x27;</span>,<span class="string">&#x27;24&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;9&#x27;</span>]</span><br><span class="line"></span><br><span class="line">#y1是delay延迟时长</span><br><span class="line"><span class="keyword">with</span> <span class="title function_">open</span>(<span class="string">&#x27;/存储路径/A.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> <span class="attr">f</span>:</span><br><span class="line">    y1 = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> <span class="attr">f</span>:</span><br><span class="line">        lst = line.<span class="title function_">split</span>(<span class="string">&#x27;\n&#x27;</span>)		#增加一个换行符，不然数字是不换行的</span><br><span class="line">        y1.<span class="title function_">append</span>(<span class="title function_">float</span>(lst[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">#y2是rate同步速率</span><br><span class="line"><span class="keyword">with</span> <span class="title function_">open</span>(<span class="string">&#x27;/存储路径/B.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> <span class="attr">f</span>:</span><br><span class="line">    y2 = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> <span class="attr">f</span>:</span><br><span class="line">        lst = line.<span class="title function_">split</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        y2.<span class="title function_">append</span>(<span class="title function_">float</span>(lst[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">#输入对应的坐标，后面是颜色</span><br><span class="line">plot1,=pl.<span class="title function_">plot</span>(x,y1,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">plot2,=pl.<span class="title function_">plot</span>(x,y2,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pl.<span class="title function_">xticks</span>(x,labels)</span><br><span class="line"></span><br><span class="line">pl.<span class="title function_">title</span>(<span class="string">&#x27;这里写标题&#x27;</span>,size=<span class="number">20</span>)	#中文会显示乱码，推荐还是英文</span><br><span class="line">pl.<span class="title function_">xlabel</span>(<span class="string">&#x27;这里是X轴标题&#x27;</span>, size=<span class="number">14</span>)</span><br><span class="line">pl.<span class="title function_">ylabel</span>(<span class="string">&#x27;这里写Y轴标题&#x27;</span>, size=<span class="number">14</span>)</span><br><span class="line">pl.<span class="title function_">ylim</span>(<span class="number">0.0</span>,<span class="number">5.0</span>)</span><br><span class="line"></span><br><span class="line">#曲线对应注释</span><br><span class="line">pl.<span class="title function_">legend</span>([plot1,plot2],(<span class="string">&#x27;Delay&#x27;</span>,<span class="string">&#x27;Sync rate&#x27;</span>),<span class="string">&#x27;best&#x27;</span>,numpoints=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">#开启网格</span><br><span class="line">pl.<span class="title function_">grid</span>()</span><br><span class="line"></span><br><span class="line">#图片保存路径</span><br><span class="line">plt.<span class="title function_">savefig</span>(<span class="string">&#x27;/保存路径/图片名称.png&#x27;</span>, format=<span class="string">&#x27;png&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="将生成的图片上传到阿里云OSS的脚本"><a href="#将生成的图片上传到阿里云OSS的脚本" class="headerlink" title="将生成的图片上传到阿里云OSS的脚本"></a>将生成的图片上传到阿里云OSS的脚本</h2><p>由于不想让“领导去手动点开附件查看图像”，所以我们干脆把图片作为邮件的正文展示出来，那么就在html里就需要<code>img src=图片的网络地址</code>的方法。于是就把刚刚生成的图片上传到阿里云OSS里，这样就可以获得图片的网络地址。而且阿里云OSS是“相同文件名会覆盖”，所以不用再去删除。整个脚本内容如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># -*- <span class="attr">coding</span>: utf-<span class="number">8</span> -*-</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> oss2</span><br><span class="line"></span><br><span class="line">access_key_id = os.<span class="title function_">getenv</span>(<span class="string">&#x27;OSS_TEST_ACCESS_KEY_ID&#x27;</span>, <span class="string">&#x27;这里填写ak&#x27;</span>)</span><br><span class="line">access_key_secret = os.<span class="title function_">getenv</span>(<span class="string">&#x27;OSS_TEST_ACCESS_KEY_SECRET&#x27;</span>, <span class="string">&#x27;这里填写sk&#x27;</span>)</span><br><span class="line">bucket_name = os.<span class="title function_">getenv</span>(<span class="string">&#x27;OSS_TEST_BUCKET&#x27;</span>, <span class="string">&#x27;这里填写bucket名称&#x27;</span>)</span><br><span class="line">endpoint = os.<span class="title function_">getenv</span>(<span class="string">&#x27;OSS_TEST_ENDPOINT&#x27;</span>, <span class="string">&#x27;这里填写内网end-point&#x27;</span>)</span><br><span class="line"></span><br><span class="line"># 确认上面的参数都填写正确了</span><br><span class="line"><span class="keyword">for</span> param <span class="title function_">in</span> (access_key_id, access_key_secret, bucket_name, endpoint):</span><br><span class="line">    assert <span class="string">&#x27;&lt;&#x27;</span> not <span class="keyword">in</span> param, <span class="string">&#x27;请设置参数：&#x27;</span> + param</span><br><span class="line"></span><br><span class="line"># 创建<span class="title class_">Bucket</span>对象，所有<span class="title class_">Object</span>相关的接口都可以通过<span class="title class_">Bucket</span>对象来进行</span><br><span class="line">bucket = oss2.<span class="title class_">Bucket</span>(oss2.<span class="title class_">Auth</span>(access_key_id, access_key_secret), endpoint, bucket_name)</span><br><span class="line">bucket.<span class="title function_">put_object_from_file</span>(<span class="string">&#x27;上传到OSS的图片名称.png&#x27;</span>, <span class="string">&#x27;/服务器保存路径/图片名称.png&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="将图片作为内容发邮件的脚本"><a href="#将图片作为内容发邮件的脚本" class="headerlink" title="将图片作为内容发邮件的脚本"></a>将图片作为内容发邮件的脚本</h2><p>整个脚本内容如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/usr/</span>bin/env python</span><br><span class="line"># -*- <span class="attr">coding</span>: <span class="variable constant_">UTF</span>-<span class="number">8</span> -*-</span><br><span class="line"><span class="keyword">import</span> os,time,re,smtplib,logging</span><br><span class="line"><span class="keyword">from</span> email.<span class="property">mime</span>.<span class="property">text</span> <span class="keyword">import</span> <span class="title class_">MIMEText</span></span><br><span class="line"><span class="keyword">from</span> email.<span class="property">header</span> <span class="keyword">import</span> <span class="title class_">Header</span></span><br><span class="line"></span><br><span class="line">def <span class="title function_">send_mail</span>(to_list, cc_list, html, sub):</span><br><span class="line">    me = mail_user</span><br><span class="line">    msg = <span class="title class_">MIMEText</span>(html, _subtype=<span class="string">&#x27;html&#x27;</span>, _charset=<span class="string">&#x27;utf-8&#x27;</span>)  # 格式化邮件内容为html，编码为utf-<span class="number">8</span></span><br><span class="line">    msg[<span class="string">&#x27;Subject&#x27;</span>] = sub    # 邮件主题</span><br><span class="line">    msg[<span class="string">&#x27;From&#x27;</span>] = me    # 发件人</span><br><span class="line">    msg[<span class="string">&#x27;To&#x27;</span>] = <span class="string">&quot;;&quot;</span>.<span class="title function_">join</span>(to_list)  # 收件人，将列表转换为字符串</span><br><span class="line">    msg[<span class="string">&#x27;Cc&#x27;</span>] = <span class="string">&quot;;&quot;</span>.<span class="title function_">join</span>(cc_list)  # 抄送人，将列表转换为字符串</span><br><span class="line"></span><br><span class="line">    <span class="attr">try</span>:</span><br><span class="line">        send_smtp = smtplib.<span class="title function_">SMTP</span>()    # 实例化</span><br><span class="line">        send_smtp.<span class="title function_">connect</span>(mail_host)    # 连接smtp服务器</span><br><span class="line">        send_smtp.<span class="title function_">login</span>(mail_user, mail_pass)    # 使用定义的账号密码进行登录</span><br><span class="line">        send_smtp.<span class="title function_">sendmail</span>(me, to_list+cc_list, msg.<span class="title function_">as_string</span>())    # 发送邮件</span><br><span class="line">        send_smtp.<span class="title function_">close</span>()    # 关闭连接</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">True</span></span><br><span class="line">    except <span class="title class_">Exception</span>, <span class="attr">e</span>:</span><br><span class="line">        logging.<span class="title function_">basicConfig</span>(filename=<span class="string">&#x27;logger.log&#x27;</span>, level=logging.<span class="property">DEBUG</span>)</span><br><span class="line">        logging.<span class="title function_">debug</span>(e)</span><br><span class="line">        <span class="title function_">print</span> (<span class="string">&quot;ERROR!!!!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   	mail_host = <span class="string">&#x27;mail.dahuatech.com&#x27;</span></span><br><span class="line">   	mail_user = <span class="string">&#x27;这里填写发件人地址&#x27;</span></span><br><span class="line">   	mail_pass = <span class="string">&#x27;填写对应的密码&#x27;</span></span><br><span class="line">   	mailto_list = [<span class="string">&#x27;收件人邮箱地址&#x27;</span>]</span><br><span class="line">   	mailcc_list = [<span class="string">&#x27;抄送人1的邮箱地址&#x27;</span>，<span class="string">&#x27;抄送人2的邮箱地址&#x27;</span>]</span><br><span class="line">   	html = <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">               &lt;body&gt; </span></span><br><span class="line"><span class="string">                &lt;br&gt;&lt;img src=&quot;</span>这里填写的是图片的http地址<span class="string">&quot;&gt;&lt;/br&gt;</span></span><br><span class="line"><span class="string">               &lt;table color=&quot;</span><span class="title class_">CCCC33</span><span class="string">&quot; width=&quot;</span><span class="number">800</span><span class="string">&quot; border=&quot;</span><span class="number">1</span><span class="string">&quot; cellspacing=&quot;</span><span class="number">0</span><span class="string">&quot; cellpadding=&quot;</span><span class="number">5</span><span class="string">&quot; text-align=&quot;</span>center<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">                       &lt;tr&gt;</span></span><br><span class="line"><span class="string">                     &lt;td test-align=&quot;</span>center<span class="string">&quot;&gt;上图是阿里云深圳VPC区数据同步过去24小时的情况。&lt;br /&gt;</span></span><br><span class="line"><span class="string">                     注意事项 1:dts的延迟时间是5秒计算一次，api请求会取到最新的延迟时间，而控制台是每隔20秒才刷新一次；</span></span><br><span class="line"><span class="string">                     注意事项 2:api在延迟时间取值为整数，即1.x显示为2，请知悉; </span></span><br><span class="line"><span class="string">                     注意事项 3:此邮件是系统自动发出，如果有任何疑问请联系运维人员；</span></span><br><span class="line"><span class="string">                       &lt;/tr&gt;&lt;/br&gt;</span></span><br><span class="line"><span class="string">               &lt;/table&gt;</span></span><br><span class="line"><span class="string">               &lt;/body&gt; &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    sub = <span class="string">&quot;阿里云深圳VPC数据同步情况&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="title function_">send_mail</span>(mailto_list,mailcc_list,html,sub):</span><br><span class="line">        logging.<span class="title function_">debug</span>(<span class="string">&quot;Send mail succed!&quot;</span>)</span><br><span class="line">    <span class="attr">else</span>:</span><br><span class="line">        logging.<span class="title function_">debug</span>(<span class="string">&quot;Send mail failed&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>上面四个脚本整个执行下来，效果如下，至此大功告成！<br><img data-src="/images/dts3.png" alt="paradin"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/aliyun/aliyun-oss-python-sdk/blob/master/examples/object_basic.py">https://github.com/aliyun/aliyun-oss-python-sdk/blob/master/examples/object_basic.py</a><br><a href="https://hk.saowen.com/a/fe355cb5cc3ab17dbc84e9489621d2ab31da72b511092839832bc9e89d63bf71">https://hk.saowen.com/a/fe355cb5cc3ab17dbc84e9489621d2ab31da72b511092839832bc9e89d63bf71</a><br><a href="http://blog.csdn.net/baoli1008/article/details/47980779">http://blog.csdn.net/baoli1008/article/details/47980779</a><br><a href="https://www.digglife.net/articles/html-mail-with-inline-images-python-perl.html">https://www.digglife.net/articles/html-mail-with-inline-images-python-perl.html</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>踩了K8s Pod内部PID限制的一个坑</title>
    <url>/2023/04/07/%E8%B8%A9%E4%BA%86K8s-Pod%E5%86%85%E9%83%A8PID%E9%99%90%E5%88%B6%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9D%91/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>某个环境，产品在使用过程频繁出现异常，获取日志发现报错提示：<code>unable to create new native thread.</code><br><img data-src="/images/k8s%E8%B8%A9%E5%9D%91.png" title="内存报错，说无法创建新的线程"></p>
<p>连 Pod 都无法进入。<br><img data-src="/images/k8s%E8%B8%A9%E5%9D%911.png"></p>
<h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><p>根据经验，先登录机器查看 ulimit，发现只有 1024。于是乎修改 ulimit 大小，再观察。<br><img data-src="/images/k8s%E8%B8%A9%E5%9D%912.png"></p>
<p>观察发现仍然在报同样的错误，重启 Pod 也无效。容器内部的 Java 进程使用的是 admin 用户启动，考虑到容器内部的用户 UID 本身是映射到宿主机用户 UID。此前就因为只修改了 root 用户的 ulimit 限制，没有修改宿主机对应用户 UID 的 ulimit 限制，导致类似无法创建线程的问题，切换到宿主机同样 UID 的用户，发现 ulimit 是正确的。</p>
<p>因为 Linux 系统里，PID 的限制对进程和线程本身是一样的。于是，拉起一个空的容器来测试，写一个测试脚本来创建 1024 个进程。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;<span class="number">1.</span><span class="number">.1024</span>&#125;</span><br><span class="line">do</span><br><span class="line">    echo <span class="string">&quot;Process: $&#123;i&#125;&quot;</span></span><br><span class="line">    ( sleep <span class="number">600</span> &amp; )</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">wait</span><br></pre></td></tr></table></figure>
<p>运行测试脚本，发现确实会报错，提示无法继续创建进程。<br><img data-src="/images/k8s%E8%B8%A9%E5%9D%913.png"></p>
<p>怀疑是 K8s 对 Pod 内部的 PID 使用做了什么限制。查看<code>kubelet</code>进程，未看到有类似 <code>--pod-max-pids</code>的限制。</p>
<p>后来查看<code>kubelet config</code>，发现有个<code>SuuportPodPidsLimit</code>的<code>FeatureGate</code>。<br><img data-src="/images/k8s%E8%B8%A9%E5%9D%914.png"></p>
<p>这个集群使用的 K8s 是<code>OpenShift</code>，查找 OpenShift 相关的资料（<a href="https://skybert.net/linux/openshift-container-running-out-of-pids-all-the-time/%EF%BC%89%E3%80%82">https://skybert.net/linux/openshift-container-running-out-of-pids-all-the-time/）。</a></p>
<p>发现<code>SupportPodPidsLimit</code>这个就是用来限制 Pod 内部的 PID 数量。在普通的 K8s 集群里，<code>SupportPodPidsLimit</code> 这个是默认关闭，而在 OpenShift 里，<code>SupportPodPidsLimit</code> 这个参数确实默认开启的。联系这个 <code>Openshift</code> 的集群运维，修改参数关闭 <code>SupportPodPidsLimit</code>，再次运行测试脚本，发现就可以正常运行了。</p>
<p>最后补充一下，宿主机的 ulimit 设置可以通过以下命令查看：<code>cat /proc/sys/kernel/pid_max</code>。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>容器</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>贵州四日游</title>
    <url>/2022/08/09/%E8%B4%B5%E5%B7%9E%E5%9B%9B%E6%97%A5%E6%B8%B8/</url>
    <content><![CDATA[<p>本次贵州行是团队的outing，第一天晚上8点半我们一行人抵达贵阳龙洞堡机场，最后一天晚上23点返回萧山机场，一共玩了5天。本次我们一共去了这几个景点：黄果树瀑布、大小七孔、西江千户苗寨。<br><img data-src="/images/%E8%B4%B5%E5%B7%9E%E5%9C%B0%E5%9B%BE.png" title="可见我们在贵州画了个四边形"></p>
<p>从中国地图来看，贵州北方是重庆&#x2F;四川，西方是云南，南方是广西，东边是湖南。也正是与重庆相连的原因吧，整个贵州的山也是超级多，在高速上开车不是在穿隧道就是在拐大弯，后来查了数据，贵州90%以上的面积都是山。山多，山谷之间的那点平原就是难得适合种粮食的地儿，自然人聚集，人多吊脚楼也多，十几个吊脚楼、小砖楼就形成了一个小镇子，在高速上一眼望过去倒也是一副宁静的画面。贵州跟重庆都是“自然风光更好看，出名景点在周边”的类型，我们这次选择的那几个景点都在南边，贵州北边比较有名的是遵义，看红色革命的地方，那里还有鼎鼎大名的茅台镇。再往西北方跟四川接壤的地方就是赤水，毛主席当年带兵打仗的地方。</p>
<p>不过很巧的是，我去的那段时间贵阳机场的抽茅台活动临时取消了，我走了后就会重新开放，这真的让人心痛不已。</p>
<h2 id="贵州的玩"><a href="#贵州的玩" class="headerlink" title="贵州的玩"></a>贵州的玩</h2><p>如果是玩上面三个景点，我其实个人推荐顺序是：大小七孔–&gt;黄果树瀑布–&gt;苗寨。原因很简单，看过了黄果树瀑布的人再看大小七孔内心是完全毫无波澜的，而把苗寨放最后，就是因为苗寨属于“大理”、“凤凰”那种夜市型城市，比较适合放到最后一站，在时间充裕的情况下放松使用。不过这个路线是最绕的，并不科学。</p>
<p>黄果树瀑布是贵州旅游的最大的名片了，从贵阳龙洞堡机场开车大约需要2个小时，票要提前一天购买，那里需要大约2天的时间来玩。同样的，不要第一天就去看大瀑布—当你看过了大瀑布再看其他小瀑布就没感觉了。所以建议先看陡坡塘瀑布（86版西游记里师徒四人走过这条瀑布，而且还是流沙河、通天河的取景地）、天星洞、银链坠潭瀑布，然后回去休息，第二天早上，吃饱喝足，穿上雨披和拖鞋，去感受一下黄果树大瀑布和水帘洞（没错，86版西游记在这里取了很多景）。<br><img data-src="/images/%E9%BB%84%E6%9E%9C%E6%A0%91%E7%80%91%E5%B8%83.JPG" title="为了手机、相机等数码产品，请带着防水袋前往"></p>
<p>当近距离接触瀑布的时候，真的是能感受的到水的力量和美。漫天的水雾，由远及近就像经历了毛毛雨-小雨-中雨-大雨的感觉，没有雨衣的话不到一分钟必定湿身。看着水川流不息，听着瀑声，内心那种激动和波澜，明白了那“飞流直下三千尺，疑是银河落九天”的浪漫与壮美。此时就不禁的懂了为啥老庄他们会花那么多文字来描述水，纯净的“水”就是“道”最贴切的描述—温柔同时也兼并着力量，既滋养了万物又低调，同时又具备巨大的威力。</p>
<p>黄果树瀑布不远有一个坝陵河大桥，桥长2000多米，在这里可以玩吉尼斯第一高度的370米蹦极，3000块一次，挑战成功之后会给一个金牌作为勇敢者奖励，又穷又恐高的我当然不会去玩。桥面用于正常的运输，中间有一个夹层可以高空观景，观景票100元一张，每当有大货车从桥上经过，整个夹层也会轰隆轰隆的感受到震动。大桥旁边还有一个小博物馆，可以熟悉这座桥的历史以及买到这个桥的周边纪念品还能用于共青团入团。<br><img data-src="/images/%E5%9D%9D%E9%99%B5%E6%B2%B3%E5%A4%A7%E6%A1%A5.JPG" title="这里蹦极3000，降落伞2000"><br><img data-src="/images/%E5%9D%9D%E9%99%B5%E6%B2%B3%E5%A4%A7%E6%A1%A52.JPG" title="这个角度看过去非常帅"></p>
<p>坝陵河大桥两边是山下面是河水，不晓得什么原理，山谷之间会间歇性的起雾，或许是当天雨水比较多，有明显的温差导致。肉眼可见的超级大雾从地表升起，然后白白的一片把桥淹没，给这茫茫大山一种仙境的朦胧感，觉得山谷间应该有龙有妖，不禁想起来那句“若有人兮山之阿”。</p>
<p>贵州的周边城市也还是比较自然化的，各种景色和建筑都很“大”—-大山、大桥、大瀑布、大朵云，甚至下雨也是突然的大雨，然后大太阳放晴。想要找寻“雄伟壮观”在这里可以说是毫不费力。跟江南不同，江南很多地方体现的是“小而精致”，这里更加粗放不加修饰，自然之美特别豪爽。</p>
<p>大七孔和小七孔是我们第二个景点，这里虽然小七孔名字带“小”，但是游玩起来却是最长，光走一圈下来基本需要3~4个小时，运动20000步轻松达成。这里可以打水仗，可以游船、可以看溶洞。这里的水是绿色的，清澈见底，甚至还能看到水蛇一摇一摇的在水面游动。<br><img data-src="/images/%E5%A4%A7%E4%B8%83%E5%AD%94.JPG"><br><img data-src="/images/%E5%A4%A7%E4%B8%83%E5%AD%941.JPG"><br><img data-src="/images/%E5%A4%A7%E4%B8%83%E5%AD%942.JPG"><br><img data-src="/images/%E5%A4%A7%E4%B8%83%E5%AD%943.JPG"></p>
<p>大小七孔不像黄果树那么壮美，它主打的是安静清澈原生态氧吧，不过里面的游客也是众多，所以我一直心心念念的那种冰凉纯净的空气并没有感受到。<br>	<br>苗寨作为最后一个景点，是让我又爱又恨的。因为我们在游览的时候，三亚爆出了大面积疫情，导致贵州也紧张了起来。贵州的核酸是收费的，而且做起来很麻烦：需要注册小程序，然后上传行程码，做核酸一般都是在高速路口，人多网络很差，导致上传行程码特别费劲。上传成功后给志愿者看，他给你一个贴纸，带着贴纸到小房子窗口面前做核酸，一个房子里只有一个窗口里面只有一个大白，所以进度是非常的慢，等的人无比心焦。</p>
<p>好不容易做完了核酸，晚饭的时候抵达了苗寨的东停车场，发现那里早就满了，只能再开3公里左右去一个临时停车场。在临时停车场里会有苗寨景区的接驳车来把人运到苗寨景区大门，但是接驳车基本没有什么秩序，大家提着箱子开始抢座。好容易到了景区大门，又见到了不比做核酸短多少的队，原来是要扫场所码然后再给你一个贴纸，有了贴纸才可以扫身份证入园。真实费了九牛二虎之力，我拖着箱子带着一身的臭汗以及一肚子的烦躁终于来到了我们住的酒店。</p>
<p>确切地说这除了价格之外，根本就不是酒店，充其量就是一个招待所：没有电梯，厕所的门不敢使劲儿，而且马桶间跟洗浴相隔的门竟然还不能关，墙上的瓷砖也脱落了，隔音什么的就更别说了，只是一个有空调睡觉的地儿，仅此而已。打开电视，贵州当地的1到7台，全是在播抗日神剧，而且还不重样。</p>
<p>不过苗寨里面还不错的，占地很大，上坡下坡，还有艺术演出。可以刷身份证坐车或者干脆走着去瞭望台看夜景，苗寨的吊脚楼很多，夜景跟重庆的洪崖洞相似，在瞭望台看到对面山上那一面的灯光，与天上星星相连。</p>
<p>苗寨里最大的产业就是“苗装拍照”，感谢抖音和朋友圈让他们火了起来。几乎这里每座桥、每个河边都是这样的一个组合：摄影师一手抓着单反一手拎着补光灯，后面的女孩子头上顶着苗族头饰，挂着长命锁样子的银胸牌，穿着已经改良过的鲜艳苗服，哗啦啦的摆着造型，旁边她的男朋友拎着包拿着水和小电扇伺候着。整个从“选衣服–选头饰–化妆–拍3个点–卸妆–退衣服”几乎就要3个小时左右。苗寨晚上的景色要比白天的好看，所以很多女菩萨们都避开白天的嘈杂，从晚上10点多开始拍，一直拍到凌晨，所以这里的摄影师是高薪职业但是也是夜猫子。<br><img data-src="/images/%E8%8B%97%E5%AF%A8%E7%BE%8E%E5%A5%B32.JPG" title="拍照一条街"><br><img data-src="/images/%E8%8B%97%E5%AF%A8%E7%BE%8E%E5%A5%B3.JPG" title="甜美~"></p>
<p>西江苗寨里据说还有6000个本地苗人，他们彼此交流还用苗语。本地人在这里开店做生意、打篮球、下棋、买菜、办电话卡，毫不在意大街上游客们的叽叽喳喳。夜半的西江苗寨就是大理和凤凰的模样，成桌的外地人喝酒撸串，听着酒吧伴唱的歌摇着色子。入夜后的欲望男女毫不隐晦的玩起打擦边球的皮肉游戏。旁边烤串的小哥一边麻利的处理黑猪肉串一边油嘴滑舌的跟同行嬉笑。路边的垃圾摊儿里，年迈的苗族老太把头发挽起来，头上的大花只能看出是一个脏脏的红，翻着垃圾，逐个寻找易拉罐和塑料瓶，然后收进那破麻袋里，弓着腰再走到下一个垃圾摊。形形色色的人组成了这条街的“烟火气”。<br><img data-src="/images/%E5%87%8C%E6%99%A8%E4%B8%89%E7%82%B9%E7%9A%84%E8%8B%97%E5%AF%A8.JPG" title="这是凌晨三点的烧烤摊路边"></p>
<h2 id="贵州的吃"><a href="#贵州的吃" class="headerlink" title="贵州的吃"></a>贵州的吃</h2><p>首先，在“黄果树瀑布、大小七孔和西江千户苗寨”这三个景点里，我这一路竟然都没有看到过一家tims、瑞幸和星巴克（最后在机场里终于发现了星巴克续命），找了半天最后才发现了两家蜜雪冰城，小七孔一个，苗寨一个，而且基本都是爆满。除了没有手冲的咖啡，我也没有看到一家KFC、汉堡王、麦当劳，所以说这几天基本没有接触到什么垃圾食物。</p>
<p>贵州的吃真的很惨淡，酸辣为主，因为他们的菜翻来覆去就是那么几种：酸汤鱼+丝娃娃+各种辣椒炒肉+炒青菜+折耳根+木姜子+其他野菜。其中辣椒炒肉就分为：青辣椒炒牛肉、青辣椒炒腊肉，圆辣椒炒牛肉、圆辣椒炒腊肉…所以吃来吃去除了辣和酸没什么新意，不过丝娃娃，也就是春卷，里面竟然还能卷折耳根我也是开了眼界。景区里没有火锅店，没有烤肉，没有日料，各个饭店打开菜单基本就是这么些东西。当地人喜欢吃面和粉，吃炒饭的地方很少，基本都是白饭或者糯米饭，不过他们的辣椒酱真的很是下饭，毕竟老干妈陶华碧就是贵州人。<br><img data-src="/images/%E5%86%9C%E5%AE%B6%E4%B9%90.JPG" title="找到一个农家乐，消费也不便宜"></p>
<p>因为是团队outing，负责攻略的同学为了方便，就把我们的酒店全都订在了景区内，但是贵州的景区都很大，但是吃的东西却不多，这样就导致一个后果，就是只能酒店里有啥就吃啥，打开“饿了么”、“美团”，发现方圆5公里根本没有外卖店。我们当时在小七孔附近的酒店住下，酒店很高档，但是周围5公里一家店没有，而且从小七孔开车出去找也很费功夫，所以那一宿只能看电视和跟同事55开黑中度过，早早就睡了等着第二天猛吃自助早餐，结果第二天发现自助早餐人暴多，原来全酒店都是跟我一个想法。</p>
<p>贵州本地招牌的水果是刺梨和杨梅，刺梨果冻深得我意，在机场有卖，比景区还便宜。</p>
<h2 id="贵州的穷"><a href="#贵州的穷" class="headerlink" title="贵州的穷"></a>贵州的穷</h2><p>贵州的穷是国人对它的第一印象。的确，贵州外出打工人口占全省人口的22%，可以说是劳务输出大省，父母出门打工，家里只有小孩和老人。贵州的教育不甚发达，全省就一个211大学贵州大学。前面也说了贵州的山多导致交通非常不便利，运输成本很高，修各种大桥、隧道和景区的设施很是花钱，现在贵州政府也是欠钱大户。贵州目前的主要发展方向一个是旅游业一个是大数据，大数据的原因就是这里相对比较凉快，可以建很多机房用来存储各种数据，省电。旅游业就是靠山吃山靠水吃水的选择，不过贵州虽然4A\5A很多，但是他们旅游业基本都是“建立在自然风光上的人工景色”，商业化很严重，矿泉水卖5块，奶茶卖四五十很常见，而且这里的服务意识和基础设施其实有点差的，比如我刚刚说到的苗寨，他们的口号就是“冲击5A”，然而他们很多酒店超级破旧，这无疑是冲击5A最大的阻碍。</p>
<p>2020年贵州有一个可怜的小姑娘吴花燕，每天只有2块钱的伙食，24岁因为营养不良，导致身高不足1米4，体重只有20多公斤，最后她抢救无效逝世，这无疑是贫困摘帽的大耻辱。其实横向对比全国的几个城市，在交通工具人均拥有数上，贵州的不少城镇都是全国倒数。可见交通已经够烂了，但是很多人依旧要靠自己的血肉之躯翻山越岭。现在“清零”的政策不放松，同样是趁学生暑假赚旅游钱的三亚因为疫情而GG，贵州无疑也是疫情封城的潜在重灾区，商家每天都担心疫情反复。我在苗寨足疗的时候，那个按脚的小妹就说“疫情封城的时候，一条街上真的是连个人都没有”。以前贵州的政府也有管理混乱的旧闻：<a href="http://news.sohu.com/51/15/news212301551.shtml">http://news.sohu.com/51/15/news212301551.shtml</a> ，还有西气东输把能源几年就抽光的历史。<br><img data-src="/images/%E8%B4%B5%E5%B7%9E%E7%A9%B7.JPG"></p>
<p>贵州是一个好地方，它美丽又低调。虽然在古代这里是流放罪人的地方，但也无碍它有着辉煌的人文历史，王阳明、徐霞客、张之洞等很多古人都在这里留下了自己的足迹。孔子说过“仁者乐山，智者乐水”，贵州有山有水，理应是一个人杰地灵有福的好地方。希望贵州可以能打好服务+大数据牌，让它富裕起来，好上加好，同时也想疫情早日过去，贵州不要被这种忧患所打扰。</p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>旅游</tag>
        <tag>贵州</tag>
      </tags>
  </entry>
  <entry>
    <title>资损防控的感悟</title>
    <url>/2020/07/02/%E8%B5%84%E6%8D%9F%E9%98%B2%E6%8E%A7%E7%9A%84%E6%84%9F%E6%82%9F/</url>
    <content><![CDATA[<p>资损是电商平台永远绕不开的话题，如果是平台（X宝、X东、X多多）的资损那会给平台减少收益，如果是店铺或者买家的资损（买家因为红包等权益失败导致多掏钱），那么这样会带来大量的舆情，甚至是合同上的纠纷，最后靠公关团队来安抚和赔付收场。所以说搞资损防控虽然是一个高收益的方向（目前国内关于资损的专家并不多），但是也是一个高风险的任务。简而言之，搞资损防控第一要对业务流程十分的理解，同时对玩法术语要明白，同时对技术（重试机制、锁机制、幂等性等等）也要有足够的沉淀。</p>
<p>本文主要就是我个人作为资损小白的一点关于资损防控的感悟，偏方法论，这里面并没有什么平台的介绍。</p>
<h2 id="什么是资损"><a href="#什么是资损" class="headerlink" title="什么是资损"></a>什么是资损</h2><p>资损事件指的是导致“平台多出钱和少收钱”的事件。但是引起这个事件的原因有很多种，我粗略统计了一下，主要分为如下几个类型：<br><img data-src="/images/%E8%B5%84%E6%8D%9F%E9%98%B2%E6%8E%A71.png" alt="akb48" title="除了商家人为过错，其他基本都要平台方解决"></p>
<p>从上面可以看出，作为一个技术人员主要面对的资损场景有很多，但是可以解决的主要就四大类，不要小看这四大类。比如最后一个“商家人为差错”，曾经有真实的案例：平台的产品在策略的说明比较复杂（写代码的人还能写明白文档的一定要好好对待），商家因为理解错误，原本的机票88折设成了减88%，遭到客户疯抢刷单，损失惨重。自己有可能会彻底葬送了维持生计的成本…</p>
<p>说到这里，想起来其实有些商家宣传语也是很模糊的。比如“XXX活动，不花一分钱买云服务器建平台”，但是没说截止日期，也不主动让客户指定额度告警。一个月下来，客户收到账单一看数字吓死人！</p>
<h2 id="如何梳理资损"><a href="#如何梳理资损" class="headerlink" title="如何梳理资损"></a>如何梳理资损</h2><p>一般来说如果是平台代销场景，商家跟平台在合约里是会有一个容忍buffer的条款，举个例子：某批货如果完美出售，可以卖1000万，那么设定buffer是10万，即990万以上就算平台成功完成任务。如果超出这个buffer，那么多出来的那部分就是商家资损了,可以去找平台赔偿。当然也有平台资损，比如平台多分钱给商家，或者优惠券红包设置成无门槛等等导致自己少收钱的行为。资损有两个数值，一个是<code>理论资损</code>一个是<code>实际资损</code>:理论资损指的是故障导致理论上的损失，比如X东去年的空调和烤箱被人薅羊毛事件，新闻标题是损失了几千万，其实这“几千万”是理论资损。实际资损是远远不会这么大的，因为会有售后介入，统一话术来安抚“薅羊毛”的用户，让他们放弃该订单，最后赔付红包了事。如果是ToB，那么也会有结算的同事去向多打款的商家追款，那么实际资损就是无法追回的那部分了。</p>
<p>虽然实际资损才是真实的损失，但是这绝不是代表“理论资损”不重要！相反理论资损非常重要，它才是衡量漏洞严重性的标准。</p>
<p>资损的防控主要还是“事前查—监控盯—快回血”这几part，这几个part的价值也是递减的。“事前查”这一块主要考验项目立项的时候，业务在prd文档里是否考虑周全。我曾经看过一个业务场景：“平台跟商家结算的时候会取单据的最新合同，但是这期间商家的合同是会发生变化的。原来可能是货入仓了就直接结算，但是后来变成了时销时算（可能商家资金比较紧张，不能接受每月结算，而是卖出后马上就跟平台分钱）。这样就会有的货物在入仓的时候平台就已经给商家结算过一次钱了，但是随着合同的变化，在商品卖出去的时候又重复结算一次。”这种产品问题其实是可以避免的，但是这种问题由于产品人员更迭，经常漏洞发现的时候已经漏水许久了，无论是找商家追债和内部追责都很不方便。</p>
<p>“快回血”这部分主要考验的是开发同学预案覆盖度和兜底逻辑是否合理，当发现了对账出现了异常，可以迅速止血，甚至不惜熔断的手法。“快回血”和“事前查”这个不是本文重点讨论的范围，因为这两个场景涉及到很多的“具体事情具体分析”。这里主要是说一下“监控盯”。</p>
<p>资损故障如果技术型问题，除了产品BUG之外那就是数据核对不一致。举个例子，某些产品由于仓覆盖的关系只能是在特定的某些区域可售的，比如说某些奢侈品只能在北上广深等一线城市才有货，那么这种货品肯定有一个商品标来体现它的特别性。在链路中，如果这个标丢失了，就成了“全国可售”，这样非可售区域的用户下了单，却拿不到货，就会出现超卖的问题。那么就会产生舆情，最后靠售后安抚了事，赔付不少的红包。</p>
<p>那么如何能比较全面的梳理全资损点呢？我觉得分两个方法，一个是通过以往的资损事故，让产品、开发和测试的同学枚举资损场景。还有一种方法，就是反推。</p>
<p>反推是什么意思？就是从结算的角度出发，因为结算才是钱出去的最后一环，为了钱不出差错，那么一切到结算这块的数字一定要是准确无误的。一般来说，结算都是自己有一套公式的，可以根据公式来逐级的拆解，这样落实到具体的各个部门。让对应的接口人来把监控补齐。如图：</p>
<p><img data-src="/images/%E8%B5%84%E6%8D%9F%E9%98%B2%E6%8E%A72.png" alt="akb48" title="通过结算因子来反推到上游"></p>
<p>这样是不是看起来清晰多了，也方便让各部门快速定位到自己负责的一part有哪些因素是下游强感知的，这样上游在修改他们的时候也要考虑到他们。</p>
<p>最后注意一种情况，那就是隐藏的资损，这种主要体现在“时效表达”上。比如“仓定位错误”，即顾客是杭州的，但是仓关系错误，定位商品需要在北京发货，到杭州是2天之后了。那么对于急需该产品的客户来说，他的心智就会去转投另外的电商APP购买同款商品了。这种情况虽然没有造成实际的金额往来，但是也要列入到整治的范围里。</p>
<p>至于如何整治，其实除了监控之外还需要一个强力的核对平台。通过两两核对或者什么手段，保证上游的数据在流到下游的时候不会发生丢失甚至是变化。</p>
<p>不过目前业界在监控的时候只能应对传入“值”类型错误、为空或者上下幅度较大这几个场景。而由于电商玩法很多，具体一些配置，比如优惠券或者加价购场景，可能就需要一些极低的价格。那么这种情况还是要人工去double-check，这一部分一直都没有一个好的解法。</p>
<h2 id="工作安排的几条军规"><a href="#工作安排的几条军规" class="headerlink" title="工作安排的几条军规"></a>工作安排的几条军规</h2><p>这一part跟资损没直接关系，但是有些公司比较喜欢搞运动、搞集中战役。那么面对这种情况，恰巧老板又抓你来当战役的leader，你应该做到如下几点：<br>1.第一时间明确战役目标，制定战役的里程碑，将目标拆解到周维度。拿着这个目标和里程碑去找各位老板说明战役的重要性（公司高层非要搞，我也没办法），再要具体干活的人力。同时让老板对参与战役的同事减少当前的任务，让这些同事可以更充足的精力投入到战役里；<br>2.让具体干活的同事认同战役里程碑，同时让他们自己拿出来一份自己分内任务的具体可行性计划，大家一起评估；<br>3.制定一个日报&#x2F;周报的模板，要求同事按期汇报工作进展。同时一定要注明有无风险，因为战役的第一负责人是你，如果战役没有达到预期效果，那么被问责的人也是你。所以一定要对风险了如指掌，出现了delay的风险要第一时间出面解决；<br>4.切忌中途改变目标和加入新目标！这必然会引起同事的反弹，不过难免会遇到“官大一级压死人”的场面，负责战役的领导突然脑抽风，要加XXX任务或者改变XXX的验收标准。那就要你顶住，哪怕是标准与现在实际情况偏离不多，实在顶不住就只能靠话术或者干脆升级到高一层，继续调人力过来支持了；<br>5.要对战役中的目标过程有一个比较清晰的认识，能合并的地方尽量合并。各部门在战役里有交集的地方需要拉齐时间线，统一确定产出的形式，同时这个形式也是领导所认可的；<br>6.如果有的team leader比较难搞怎么办？那你就拉一个跟他比较熟的人进入你的战役队伍，让他去搞定这个team leader…</p>
]]></content>
      <categories>
        <category>大牛之路</category>
      </categories>
      <tags>
        <tag>电商</tag>
        <tag>安全生产</tag>
        <tag>资损</tag>
      </tags>
  </entry>
  <entry>
    <title>较深入的理解Pod下的&quot;多个容器&quot;定义</title>
    <url>/2019/03/19/%E8%BE%83%E6%B7%B1%E5%85%A5%E7%9A%84%E7%90%86%E8%A7%A3Pod%E4%B8%8B%E7%9A%84%E5%A4%9A%E4%B8%AA%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p>众所周知，k8s能调度的最小单元就是pod，但是pod里面是可以有多个docker容器的。但是pod和docker之间到底一种什么关系？还是需要实际的操作来更加直白的理解。</p>
<p>首先，先写了一个<code>test.yaml</code>用来启动Pod：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">apiVersion: v1	<span class="comment">#这里注意版本号</span></span><br><span class="line">kind: Pod	<span class="comment">#注意这里的大小写</span></span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-greenbook</span><br><span class="line">  labels:</span><br><span class="line">	app: test</span><br><span class="line">spec:</span><br><span class="line">      volumes:</span><br><span class="line">      - name: test</span><br><span class="line">        emptyDir: &#123;&#125;</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: <span class="number">80</span></span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: test	<span class="comment">#这里必须要跟Volumes的名称一致，都是test</span></span><br><span class="line">          mountPath: /usr/share/nginx/html</span><br><span class="line">      - name: debian1</span><br><span class="line">        image: debian</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: test</span><br><span class="line">          mountPath: /html</span><br><span class="line">        command: [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>]</span><br><span class="line">        args:</span><br><span class="line">          - <span class="keyword">while</span> true; do</span><br><span class="line">              date &gt;&gt; /html/index.html;</span><br><span class="line">              sleep <span class="number">1</span>;</span><br><span class="line">            done</span><br><span class="line">      - name: debian2	<span class="comment">#每一个容器的名称不能一样</span></span><br><span class="line">        image: debian</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: test	</span><br><span class="line">          mountPath: /html</span><br><span class="line">        command: [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>]</span><br><span class="line">        args:</span><br><span class="line">          - <span class="keyword">while</span> true; do</span><br><span class="line">              echo <span class="string">&quot;woxcwy&quot;</span> &gt;&gt; /html/index.html;</span><br><span class="line">              sleep <span class="number">2</span>;</span><br><span class="line">            done</span><br><span class="line">	   restartPolicy: Never		<span class="comment">#死了就死了</span></span><br></pre></td></tr></table></figure></p>
<p>这个yaml主要是建立了一个存储卷叫html，它默认类型是<code>emptyDir</code>。这意味着当一个POD被分配到一个节点时，卷先被创建，并只要Pod在节点上运行时，这个卷仍存在（node重启的话，卷内容丢失，所以它只能做一个临时行的存储，如果想要持久化存储请使用<code>hostPath</code>）。第一容器运行nginx的服务器并将共享卷挂载到目录<code>/usr/share/Nginx/html</code>。第二容器使用Debian的镜像，并将共享卷挂载到目录<code>/html</code>，每一秒输入当前时间。第三个容器同理，每两秒输入一些字符串。</p>
<p>然后<code>kubectl create -f test.yaml --record </code>创建这个pod，然后使用<code>docker ps -a</code>就能看到生成了四个docker—分别是pod的三个容器和一个pause容器。使用<code>kubectl exec -it pod名 -c 容器名 /bin/bash</code>进入nginx的容器，会发现里面的<code>/usr/share/nginx/html/index.html</code>果然按照我们的要求在不断的输出日期和字符串。可见这三个容器已经挂载了同一个卷，如图：<br><img data-src="/images/k8s32.png" alt="akb48"></p>
<p>可见挂载volume到Pod，本质上是将volume挂载到Pod中的每一个容器。如果在这三个容器<code>ps -ef</code>一下，会发现他们的<code>pid=1</code>的进程是各自的进程而不是pause容器的<code>/pause</code>进程，如图：<br><img data-src="/images/k8s33.png" alt="akb48"><br><img data-src="/images/k8s34.png" alt="akb48"></p>
<p>所以很多人说pod里每个容器的init进程其实是<code>/pause</code>，而pause容器的作用，可以担任init的角色（默认都<code>docker run -ipc:container:pause</code>），及时的清理僵尸进程。但是在我这里的实验结果看来并不是真的。不知道是不是我某个姿势不对…</p>
<p>话说回来，这个例子很明显的体现了“一个pod里可以有多个容器”这句话，每个pod是一个namespace，即这些容器都可以通过localhost来彼此访问，但是不能重复使用同一个端口而且所有的pod都是同时启动的。</p>
<p>k8s的容器编排这里有一个比较不错的例子：<a href="https://cloud.tencent.com/developer/ask/180938">https://cloud.tencent.com/developer/ask/180938</a> ，个人觉得说的很形象。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>容器</tag>
        <tag>k8s</tag>
        <tag>云原生</tag>
      </tags>
  </entry>
  <entry>
    <title>运维常见问题解决方案</title>
    <url>/2024/03/10/%E8%BF%90%E7%BB%B4%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>我所在的团队主要的稳定性工作，一部分是“大促稳定性”，一部分是“日常稳定性”。其中“日常稳定性”我们是通过一个叫“技术健康度”的评分机制来通晒的，这个“技术健康度”目前包括“应用、变更、数据库、搜索引擎”这四个治理维度，通过已经识别的风险提炼出来的规则，进行日常的扫描，同时再搭配上“技术工单准时完结率”，客观评价各团队的稳定性和质量的水位。最后每个团队可以看到一个总分数和以上四个治理维度各自的分数，看到自己的长短板，辅助一线开发阶段性的对某几个方面进行提升。</p>
<p>这里列举一些“应用”视角下的常见运维问题定位和解决的方案。</p>
<h2 id="CPU消耗过高"><a href="#CPU消耗过高" class="headerlink" title="CPU消耗过高"></a>CPU消耗过高</h2><p>【人工排查手段】</p>
<ol>
<li>部分机器问题，还是全局问题，如果是全局问题需要考虑是否是上有流量变大、消息量变多等原因导致，依赖限流保护自己（sentinel 系统保护限流）。</li>
<li>top查看CPU占用较高的进程情况，CPU占用高的进程的线程情况，jstack、pstack分析线程的合理性。</li>
<li>arthas、perf抓取火焰图分析。</li>
</ol>
<p>【可能的原因以及人工解决方案】<br>Q1：全局问题。<br>A1：报警、限流、扩容。<br>Q2：不合理的流量已经代码逻辑造成开销比较大。<br>A2：代码性能优化【场景比较复杂，分支多】。</p>
<p>【辅助定位以及变更托管可能性】<br>● 执行相关的命令，并分析对应的结果：top 、top -H -p、perf、asyncprofile。<br>● 分析堆栈数据、perf产出数据，找出不合理的代码逻辑。<br>● 根据分析建议，产出修复代码，并完成代码变更上线。</p>
<h2 id="磁盘利用率高"><a href="#磁盘利用率高" class="headerlink" title="磁盘利用率高"></a>磁盘利用率高</h2><p>【人工排查手段】</p>
<ol>
<li>命令查看结果：du -h * 、df -h、lsof 。</li>
<li>查看是否存在句柄未正常释放的场景，du、df 数值不匹配，lsof 持有未释放句柄。</li>
<li>大日志文件（不同分片聚合）。</li>
</ol>
<p>【可能的原因以及人工解决方案】<br>Q1：句柄未正常释放导致的磁盘利用率过高。<br>A1：重启机器可以临时恢复；根治方案需要排查未正常释放的原因，多见于logagent bug、日志清理配置不合理、人为操作。</p>
<p>Q2：大文件导致的磁盘利用率过高。<br>A1：业务日志类文件，截取一段日志，分析占比较高的日志打印，评估是否合理，如果不合理关闭对应的日志打印；非业务日志类文件，多见于Core dump文件，这类上传分析，或者距离比较久的直接删除；历史比较久的大量文件，属于日志清理策略配置不合理导致的问题，需要调整日志清理策略。</p>
<p>【辅助定位以及变更托管可能性】<br>● 执行相应的命令，并分析结果；du -h、df -h、lsof；日志分析以及提取。<br>● 在应用水位合理的条件下，执行单机的应用重启操作，临时释放磁盘利用率。<br>● 根据分析，优化日志的打印方式：不打印、抽样打印、仅打印必要的内容。</p>
<h2 id="RT类问题"><a href="#RT类问题" class="headerlink" title="RT类问题"></a>RT类问题</h2><p>【人工排查手段】</p>
<ol>
<li>利用鹰眼采集RT超过一定阈值的数据。</li>
<li>分析鹰眼trace，找到耗时消耗比较大的调用，分析耗时高的合理性。</li>
</ol>
<p>【可能的原因以及人工解决方案】<br>Q1：下游资源达到瓶颈，影响自身；比如数据库、下游应用负载过高。<br>A1：可能是自身的调用量大，导致下游异常，也可能是下游异常，导致自身受影响。这两类需要单独分析。<br>Q1：自身GC、线程池、负载等问题，导致RT升高。<br>A1：结合Sunfire监控指标（CPU、HSF线程数、GC耗时）辅助确认原因。深度分析鹰眼日志，以及堆栈信息，判断是否存在锁争抢、内部线程资源竞争等问题。产出优化建议</p>
<p>【辅助定位以及变更托管可能性】<br>● 通过系统监控平台分析相关资源的利用率情况。<br>● 通过链路平台分析耗时的调用上下游。<br>● 分析堆栈锁情况和多资源争抢的场景，并产出优化建议。<br>● 产出代码优化建议，并协助功能验证。</p>
<h2 id="HSF错误率"><a href="#HSF错误率" class="headerlink" title="HSF错误率"></a>HSF错误率</h2><p>【人工排查手段】</p>
<ol>
<li>通过链路平台看全局的问题，明确具体失败率上涨的接口、错误码、调用trace等信息。</li>
<li>查看hsf的日志，内部会有错误相关的堆栈信息。</li>
</ol>
<p>【可能的原因以及人工解决方案】<br>Q1：限流导致的部分接口问题。<br>A1：为了保护自身的合理限流，此时需要推动上游优化调用方式；调用量增加导致的非预期限流，拉群联系上游owner明确调用是否合理。<br>Q1：超时导致的限流问题。<br>A1：同RT类问题相同的排查治理思路。</p>
<p>【辅助定位以及变更托管可能性】<br>● 识别应用的报错是由于限流导致，还是由于其他原因导致。可以通过hsf日志、sentinel日志、noha日志辅助分析。</p>
<h2 id="HSF线程池满"><a href="#HSF线程池满" class="headerlink" title="HSF线程池满"></a>HSF线程池满</h2><p>【人工排查手段】</p>
<ol>
<li>登录线程池满的机器。</li>
<li>分析hsf线程池满的堆栈日志。</li>
<li>主动做jstack操作，同时关注线程数。</li>
<li>分析jstack日志。</li>
</ol>
<p>【可能的原因以及人工解决方案】<br>Q1：内部存在锁等待（多个线程等待同一个锁，常见于日志打印相关）。<br>A1： 解决锁等待的问题，常见的方式日志异步化，日志升级等，实际处理的方式依据原因会有变化。</p>
<p>Q2：线程依赖的下游RT升高，造成内部多线程等待。<br>A2：多为下游服务的问题，但下游服务引起本身的线程池满，一方面可能是业务本身的RT设置不合理导致；另一种可能是业务自身超过承接水位的上限；【可以根据是单机问题，还是全局问题来判断】。</p>
<p>【辅助定位以及变更托管可能性】<br>● 使用jstack的辅助分析工具，分析jstack的格式，识别锁等待，以及工作线程的情况。<br>● 使用日志配置标准化工具，主要解决日志异步化配置改造、日志版本升级、日志配置转换（log4j-&gt;log4j2, log4j -&gt; logback ）。<br>● 代码变更工具：调整HSF consumer的超时时间、调整Tair的超时时间、调整Http的超时时间。</p>
<h2 id="CodeCache使用率、Metaspace利用率、堆外内存利用率"><a href="#CodeCache使用率、Metaspace利用率、堆外内存利用率" class="headerlink" title="CodeCache使用率、Metaspace利用率、堆外内存利用率"></a>CodeCache使用率、Metaspace利用率、堆外内存利用率</h2><p>【人工排查手段】</p>
<ol>
<li>分析sunfire的监控数据，观察利用率是否会存在下降的趋势。</li>
<li>CodeCache的利用率、CodeCache的使用量、CodeCache的最大值、Metaspace的配置值。</li>
<li>比较相关配置值的合理性。</li>
<li>codecache、metaspace dump 分析。</li>
</ol>
<p>【可能的原因以及人工解决方案】<br>Q1：JVM参数不合理导致的利用率报警。<br>A1：调整JVM的参数，适当配置Metaspace、CodeCache、堆利用率。</p>
<p>Q2：应用代码不合理，导致大量的类加载问题，比如Groovy、Json、反射等。<br>A2：分析Dump内容，识别占比较大的类的合理性、利用堆栈、代码增强等手段抓到运行过程中新增类加载的堆栈；分析对应堆栈的合理性以及优化方案。</p>
<p>Q3：类加载均是合理的诉求，单纯空间配置不合理。<br>A3：人工分析、根据应用的历史分析、占比分析确认合理诉求，调整JVM参数配置；提升规格；应用包治理。</p>
<p>【辅助定位以及变更托管可能性】<br>● 使用系统监控分析工具，分析Codecache、Metaspace、堆外内存利用率的数据。<br>● 使用JVM参数建议工具，如何提供一个合理准确的建议参数是一个比较大的挑战（根据应用的历史运行情况进行分析确定的值，根据类似应用的参数配置情况，参数缺失的场景）。<br>● 使用代码临时增强工具，可以利用arthas抓取相应的数据classloader、stack、jad；并对结果进行分析。<br>● 使用dump分析工具，比如Metaspace、CodeCache 这类工具需要有历史记录的对比，同应用不同机器的对比功能。<br>● 以及使用其他规格升级、包治理相关的配套工具。</p>
<h2 id="GC类问题"><a href="#GC类问题" class="headerlink" title="GC类问题"></a>GC类问题</h2><p>【人工排查手段】</p>
<ol>
<li>分析GC日志，观察GC频率、GC的原因、GC前后的堆空间变化。</li>
<li>分析监控数据，观察GC频率、JVM相关指标数据。</li>
<li>Dump堆，并上传到Grace上进行分析。</li>
</ol>
<p>【可能的原因以及人工解决方案】<br>Q1：堆外内存、Metaspace、CodeCache等导致的GC产生。<br>A1：参考对应利用率的应对办法。GC日志里会有相关的提示（Metaspace、System.gc等）。</p>
<p>Q2：常驻对象过多，导致的GC频率增加；对应的现象是GC前后堆存活兑现差异不大。<br>A2：根据常见的二三方包堆空间占用大小的数据可以判断是否具备治理条件，如果具备治理条件，推动治理；如果确认为内部缓存需要，则需要调整参数，甚至升级规格。</p>
<p>【辅助定位以及变更托管可能性】<br>● 通过分析常见二三方包堆空间占用大小数据，在分析Grace的结果时，可以沉淀起来。<br>● 使用系统监控分析工具，分析JVM相关的指标，以及报警前后的数据。<br>● 使用Dump分析工具，可以调用Grace的接口，拿到泄露建议、支配树分析、OQL表达式。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>SRE</tag>
      </tags>
  </entry>
  <entry>
    <title>超赞的京都大阪五日游</title>
    <url>/2018/05/25/%E8%B6%85%E8%B5%9E%E7%9A%84%E4%BA%AC%E9%83%BD%E5%A4%A7%E9%98%AA%E4%BA%94%E6%97%A5%E6%B8%B8/</url>
    <content><![CDATA[<p>说来惭愧，活了30年了这是我第一次出国旅行，借着公司有一次旅游的机会就跟女朋友一起到京都和大阪玩5天。</p>
<p>搞定了签证，在网上买好了USJ的快速通行票，又预定了随身WIFI，简单在穷游、知乎和马蜂窝上做了做自由行的攻略，18号晚上6点半从杭州萧山机场出发，两个小时后到达关西机场。之前在《miss pilot》里看到过ANA的航空，这一次亲自乘坐感觉还是不错，飞机场有吃有玩还有葡萄酒喝。</p>
<p>到关西机场之后，又按指纹又照相的通过了一连串的海关检查，就跟公司其他小伙伴兵分两路，他们去奈良看鹿，我跟女票直接去京都。凭借女票的三脚猫日语功力和她以前来过大阪的经验，我俩先办理了地铁卡，又购买了一日游行卡，最后坐上了从大阪出发到京都的新干线。</p>
<p>从大阪到京都大约花了一个半小时左右，抵达京都已经是晚上11点了。路上下着细细小雨，再加上两人拖着箱子有点肚饿，就在路边的seven-eleven里简单买了一点水和东西，买东西之余发现在超市里有成人书籍出售。从便利店出来顺着google地图找之前在爱彼迎上预订的民宿，那是一个公寓型民宿，凭借店主之前在邮件里写的密码，我们从信箱里拿到房间钥匙，顺利入住。</p>
<h2 id="日本的庙"><a href="#日本的庙" class="headerlink" title="日本的庙"></a>日本的庙</h2><p>京都是一个充满寺庙和神社的地方，京都的旅行也就是“从这个庙出来，到下一个庙去”，而清水寺正是京都众多庙里人气很旺的景点之一，日本的庙和神社有一个习惯，入寺前先用竹勺洗手，如果要入室参拜的话还要脱鞋。在京都穿和服是一个很常见的事情，而且我觉得一群人穿和服是一个蛮cool的风景，不过女票没有租，但是在寺里买了很多的御守。</p>
<p>昨晚到京都太晚，无法注意天空，到了白天才发现京都的天真的很蓝，看见远方的山轻而易举。从清水寺出来下一站是八坂神社，巧的是遇到了一对新婚夫妇在这里结婚拍照，不得不说日本新郎传统的黑和服加扇子的形象还是很帅的。</p>
<h2 id="日本的玩"><a href="#日本的玩" class="headerlink" title="日本的玩"></a>日本的玩</h2><p>水族馆是我非常喜欢的地方，而大阪海游馆也是这次游玩里安排的重要环节之一，但是比较让我失望的是它的海底隧道很短，大约也就杭州水族馆的一半长度。我俩没有看到喂食节目，而且海游馆也没有海豹顶球，海豚跳舞这样的节目。不过海游馆的鱼种类还是很多的，有些品种还可以亲手去摸一摸它们。出了海游馆就是一个蛮大的摩天轮，用一日通票的话可以免费上去坐一圈。</p>
<p>大阪的USJ是我们这次日本之行的最后一站也是最高潮的部分，去年圣诞节我跟女票在上海的迪士尼度过的。从迪士尼回来她就一直碎碎念大阪的环球影城，我俩还特意挑选了一个工作日去玩就是为了尽可能的少排队，但是那天依旧很多很多人，真的超火爆。</p>
<p>环球影城的运营模式跟迪士尼差不多，通过IP分主题区，可以购物也有花车游行。但是整个乐园的玩法相对单一—-都是过山车：哈利波特是过山车、蜘蛛侠是过山车、小黄人是原地晃晃过山车、侏罗纪公园是水上过山车，至于翼龙飞行和好莱坞美梦更是超刺激的过山车…</p>
<p>这一次环球影城的特殊项目有四个：怪物猎人、美少女战士（看动画片）、柯南（密室逃脱）和最终幻想。我跟女票还有公司同事都选择了柯南，虽然通篇日语对白，不过还是能猜出来一个大概剧情，所以一个半小时玩下来感觉就像看了一遍柯南的剧场版，里面的解密就不剧透了，机关真的很难，想要在一个小时内完全逃脱几乎是一个不可能的任务。</p>
<p>上面把正经的娱乐说完了，下面来说一点不正经的娱乐。我和女票在大阪住在日本桥地铁站附近，那里距离道顿堀走路也就10分钟的路程，而道顿堀附近有一个街叫宗右卫门町，那里就是大阪有名的牛郎街，一路走过去各种牛郎宣传大海报和在路边搭讪的小哥，甚至那附近的小吃店里还有牛郎哥的宣传单。除了铺天盖地的牛郎哥哥外还有站街的妹妹，大多数都是黄发浓妆，但是仔细看脸都不算太好看的。这些人会跟过往的单身男女搭讪，邀请他们去店里坐坐喝点酒说说话，至于有没有更进一步的皮肉关系，那就不好说了。而且据说他们是不做不懂日语人的生意的，所以如果他们真的纠缠你了，就直接说我是外国人就好。</p>
<h2 id="日本的购物"><a href="#日本的购物" class="headerlink" title="日本的购物"></a>日本的购物</h2><p>到了日本，买东西是必然的。不过当地的大商场关门很早，基本晚上八点半左右就开始关门。在伏见稻荷大社甚至有的商铺五点半就打烊了，我很好奇，商场这么早关门，那日本人晚上的娱乐是什么呢？他们除了去居酒屋喝酒和广场溜达再加上回家看电视难道就没有其他的娱乐了吗？</p>
<p>不过，各大药妆店的营业时间很晚，甚至唐吉坷德是24小时营业。这种地方里充满了大陆人、香港人、台湾人、韩国人还有泰国人，在人群和背包中穿梭，拎着篮子买买买，买到5000就可以退税。我女票这次买了很多的卸妆水乳液面膜眼霜口红还有零食，作为一个在旁边无事可做的男人，深深地觉得陪女人逛街是一个很遭罪的事情。</p>
<h2 id="日本的吃"><a href="#日本的吃" class="headerlink" title="日本的吃"></a>日本的吃</h2><p>我是看过《深夜食堂》和《孤独的美食家》的，所以对日本的食物有一点好感，而且在杭州吃到日本料理也不是一个难事。不过这次到了日本，连续吃了五天当地的饭，发现日本的菜其实很单一。</p>
<p>日本普通的餐就是“米饭+猪肉\牛肉\鸡肉+沙拉+味增汤”，日本的米饭是很好吃的，但是他们的肉做法基本就是炸，炒是很少的。如果不是米饭的话就是炒面、拉面、寿司或者是煎饺。期间我跟女票吃了一次烤肉，里面有“最强牛里脊和牛肠”给我留下了很深的印象。此外在海游馆还吃到了我梦寐已久的大阪烧，插播一句话，吃大阪烧的时候还看到足球运动员郑大世，我女票一眼就认出他来了…</p>
<p>日本的消费能力不低，五天下来，基本上每一顿饭都大约花费了3000多日元，在吉野家吃算比较便宜的，2000不到就能搞定。在烤肉店要了套餐，每人是5000日元。这次在日本，觉得最好吃的是牛里脊，然后就是烤蟹壳。</p>
<p>说完了吃再说说喝，大阪和京都随处可见自动售卖机，售卖机里面基本就是五样饮品—水、绿茶、优酸乳、可乐和咖啡，价钱还都差不多。日本的水果很贵，一个不到6斤重的西瓜就要2200日元左右，橘子大约五块钱一个，但是他们的酒却相比较便宜。在日本我可没少喝梅子酒、气泡果酒和啤酒。</p>
<h2 id="日本的电视"><a href="#日本的电视" class="headerlink" title="日本的电视"></a>日本的电视</h2><p>我俩住的民宿有一个小电视，里面有12个频道，其中三个是购物频道…我想可能日本的免费电视就这么点，大多数都是收费频道。这九个电视台白天有新闻，有韩剧，有街头采访；晚上有芭蕾舞片段、有综艺节目、还有打着圣光的肉番！说到综艺节目，里面有一个片段就是把秃头用毛巾擦的锃亮，然后用遥控板去对着秃头摁键，结果信号经过秃头的折射，竟然能顺利的操纵电视。再后来叫来两个秃头，尝试多次折射，依旧可以准确遥控电视…就这么一个环节把我之前从来不看日本综艺节目的同事笑翻了，回国后就开始恶补这种日本综艺。</p>
<h2 id="游玩的tips"><a href="#游玩的tips" class="headerlink" title="游玩的tips"></a>游玩的tips</h2><p>1.日本路边的垃圾箱很少，据说是因为他们没有边走路边吃喝东西的习惯，所以随处带一个塑料袋来装垃圾；<br>2.USJ的快速通行证只有日语区的页面才有，请准备好visa和master卡；<br>3.办理的地铁充值卡不要扔，下一次再来日本，直接储值依旧可以使用；<br>4.到了USJ别上来先买东西，要先排队玩，东西可以放到最后出院的时候再买；<br>5.不会日语在一般情况下没问题，但是如果看不懂车站的话，就难免要问路了，这样会比较头疼，准备一个google翻译。<br>6.champion在日本的地摊也有卖，人民币大约100多，所以淘宝上那些200左右的champion完全不需要考虑…</p>
<h2 id="这次的遗憾"><a href="#这次的遗憾" class="headerlink" title="这次的遗憾"></a>这次的遗憾</h2><p>这次玩的蛮爽的，但是大阪仅仅只有三天只能玩一个皮毛，比如本次出游的遗憾如下：</p>
<p>1.据说大阪有一个棒球场，20日元一个球，然后通过发球机器发射，游客可以轮棒尝试一下本垒打的快感，但是由于时间太紧没有打上棒球…<br>2.没有去游戏机厅，以前常在漫画里看到日本有那种弹子机，如果赢的多，可以用塑料筐装满小弹子去换钱，这种游戏机厅在大阪的商场很常见，而且门口都有大广告，上面写“新品到店，欢迎畅玩”；<br>3.在龟梨和也和山下智久主演的《我命中注定的人》里，龟梨和也手工雕刻了一个王将的木牌，这次到了大阪逛了很多店，都没有发现这款木雕，不仅没有这个木雕，连战国时期各大将的头盔纺织品也没有看到，这一点很遗憾；<br>4.USJ里的变形金刚和终结者2都暂时停业，不过我后来在B战上看了视频，还是过山车…</p>
<p>等下一次如果有机会能去东京的话，就尝试把上面几个弥补上，再顺便去一趟秋叶原。</p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>旅游</tag>
        <tag>日本</tag>
      </tags>
  </entry>
  <entry>
    <title>较深入解析filebeat.yml各字段功能</title>
    <url>/2019/01/21/%E8%BE%83%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90filebeat-yml%E5%90%84%E5%AD%97%E6%AE%B5%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>首先，6.0之后的版本的<code>filebeat</code>，已经不再支持<code>document_type</code>这个选项了。因为ES6不再支持自己在同一个index下定义多个type。 </p>
<h2 id="常见的几个参数"><a href="#常见的几个参数" class="headerlink" title="常见的几个参数"></a>常见的几个参数</h2><p>以下面这个<code>filebeat.yml</code>为例：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">filebeat.<span class="property">prospectors</span>:</span><br><span class="line">- <span class="attr">type</span>: log	#这个值可以是<span class="title function_">stdin</span>(读入标准)、udp（通过udp读取事件）</span><br><span class="line">  <span class="attr">enabled</span>: <span class="literal">true</span></span><br><span class="line">  <span class="attr">paths</span>:</span><br><span class="line">    - <span class="regexp">/var/</span>log/messages	#指定文件，可以使用通配符</span><br><span class="line">  <span class="attr">tags</span>: [<span class="string">&quot;logmessages&quot;</span>]		#lostash能区分不同目录发过来的日志，用tag区分</span><br><span class="line">  <span class="attr">encoding</span>: utf-<span class="number">8</span>	#设置字符编码</span><br><span class="line">  <span class="attr">scan_frequency</span>: 10s	#每 <span class="number">10</span> 秒钟扫描一次</span><br><span class="line">  <span class="attr">harvester_buffer_size</span>: <span class="number">15000</span>		#实际读取文件时，每次读取<span class="number">15000</span>字节</span><br><span class="line">  <span class="attr">tail_files</span>: <span class="literal">true</span>		#是否从文件末尾开始读取</span><br><span class="line">  <span class="attr">fields</span>:  </span><br><span class="line">    <span class="attr">alilogtype</span>: usercenter_serverlog</span><br><span class="line">    <span class="attr">serverip</span>: <span class="number">172.16</span><span class="number">.0</span><span class="number">.207</span></span><br><span class="line">  <span class="attr">fields_under_root</span>: <span class="literal">true</span> 	#field 字段会放在根索引下，否则会放在 fields 字段下</span><br><span class="line"></span><br><span class="line">#这里添加第二个日志路径</span><br><span class="line">  - <span class="attr">type</span>: log		</span><br><span class="line">  <span class="attr">enabled</span>: <span class="literal">true</span></span><br><span class="line">  <span class="attr">paths</span>:</span><br><span class="line">    - <span class="regexp">/tmp/</span>test.<span class="property">log</span></span><br><span class="line">  <span class="attr">tags</span>: [<span class="string">&quot;test&quot;</span>]</span><br><span class="line"></span><br><span class="line">output.<span class="property">kafka</span>:</span><br><span class="line">  <span class="attr">enabled</span>: <span class="literal">true</span></span><br><span class="line">  <span class="attr">hosts</span>: [<span class="string">&quot;172.31.0.84:9092&quot;</span>]</span><br><span class="line">  <span class="attr">topic</span>: <span class="string">&#x27;system-secure&#x27;</span>			#支持 <span class="attr">topic</span>: <span class="string">&#x27;%&#123;[fields][alilogtype]&#125;&#x27;</span> 这种写法</span><br></pre></td></tr></table></figure></p>
<p>在kibana上看到的效果如图：<br><img data-src="/images/filebeat1.png" alt="akb48"></p>
<h2 id="exclude和include"><a href="#exclude和include" class="headerlink" title="exclude和include"></a>exclude和include</h2><p>而如果是这样：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">- <span class="attr">type</span>: log</span><br><span class="line">  <span class="attr">enabled</span>: <span class="literal">true</span></span><br><span class="line">  <span class="attr">paths</span>:</span><br><span class="line">    - <span class="regexp">/tmp/</span>test.<span class="property">log</span></span><br><span class="line">  <span class="attr">exclude_lines</span>: [<span class="string">&#x27;^JAMES&#x27;</span>]		#排除掉<span class="variable constant_">JAMES</span>开头的行</span><br><span class="line">  <span class="attr">include_lines</span>: [<span class="string">&#x27;^HARDEN&#x27;</span>, <span class="string">&#x27;^CURRY&#x27;</span>]      #保留<span class="variable constant_">HARDEN</span>或者<span class="variable constant_">CURRY</span>开头的行        </span><br><span class="line">  <span class="attr">tags</span>: [<span class="string">&quot;test&quot;</span>]</span><br><span class="line"></span><br><span class="line">output.<span class="property">kafka</span>:</span><br><span class="line">  <span class="attr">enabled</span>: <span class="literal">true</span></span><br><span class="line">  <span class="attr">hosts</span>: [<span class="string">&quot;172.31.0.84:9092&quot;</span>]</span><br><span class="line">  <span class="attr">topic</span>: <span class="string">&#x27;system-secure&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>效果如图：<br><img data-src="/images/filebeat2.png" alt="akb48"></p>
<p>注意！如果同时定义了<code>include_lines</code>和<code>exclude_lines</code>，则<code>Filebeat</code>首先执行<code>include_lines</code>，然后执行<code>exclude_lines</code>。 这两个选项的定义顺序无关紧要。 即使<code>exclude_lines</code>出现在配置文件中的<code>include_lines</code>之前，<code>include_lines</code>选项也会始终在<code>exclude_lines</code>选项之前执行。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.xiaot123.com/post/elk_filebeat1">http://www.xiaot123.com/post/elk_filebeat1</a><br><a href="https://blog.csdn.net/u013613428/article/details/78665081">https://blog.csdn.net/u013613428/article/details/78665081</a><br><a href="http://www.51niux.com/?id=204">http://www.51niux.com/?id=204</a><br><a href="https://github.com/wangriyu/docker-elk/wiki/Filebeat-Kafka-ELK">https://github.com/wangriyu/docker-elk/wiki/Filebeat-Kafka-ELK</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>elk</tag>
        <tag>filebeat</tag>
      </tags>
  </entry>
  <entry>
    <title>这里记录的不只有代码，还有生活和思想！</title>
    <url>/2017/12/13/%E8%BF%99%E9%87%8C%E8%AE%B0%E5%BD%95%E7%9A%84%E4%B8%8D%E5%8F%AA%E6%9C%89%E4%BB%A3%E7%A0%81%EF%BC%8C%E8%BF%98%E6%9C%89%E7%94%9F%E6%B4%BB%E5%92%8C%E6%80%9D%E6%83%B3%EF%BC%81/</url>
    <content><![CDATA[<p><img data-src="/images/%E7%9F%B3%E9%94%A4%E6%B7%A1%E5%95%A4%E9%85%92.png" alt="beer" title="那些在阳光下挥洒青春的日子啊！"></p>
<p>你说要一个人去旅行　但是归期却没有约定　亚得里亚海边风中的吉他声<br>你说你带着苍白的回忆　却谢谢能与我相逢　我怕你在异乡夜里孤独醒来<br>要拒绝两人单调的生活　想寻找自由　迷信了爱情　就迷失了我自己<br>你就这样　离开吧　抛弃吧　他乡的旅人<br>你就那样　离开吧　抛弃吧　一个人生活</p>
<p>你说要一个人去旅行　眼里藏着一朵乌云　知道你藏不住秘密　天空就会飘着雨<br>你说你带着一本日记　却不想再拥有回忆　我怕你在异乡孤独的醒来<br>要拒绝两人单调的生活　不想再随波逐流　迷信了孤独　就软弱的抛弃了我的等待</p>
<p>你就这样　离开吧　抛弃吧　他乡的旅人<br>你就那样　离开吧　抛弃吧　让我孤独生活</p>
<p>你就这样　离开吧　抛弃我　孤独的旅人<br>你就这样　离开我　抛弃我　让我孤独生活</p>
<p>我想要一个人去旅行　但愿归期会有约定　每个人都在问我　是否可以找到自由的你<br>亚得里亚海边他乡的人和风中的吉他声　我怕你一个人在异乡孤独醒来<br>我会带着你回来</p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>音乐</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>过去十年安全事件</title>
    <url>/2022/10/30/%E8%BF%87%E5%8E%BB%E5%8D%81%E5%B9%B4%E5%85%AC%E4%BC%97%E5%AE%89%E5%85%A8%E6%96%B0%E9%97%BB/</url>
    <content><![CDATA[<p>中共二十大结束了，明年二会就会是新的党政府班子的正式开端。这里总结了一下过去十年的公共安全新闻，分别是几大类：安全生产事故、民生相关、自然天灾和严重刑事案件。</p>
<h2 id="安全生产事故"><a href="#安全生产事故" class="headerlink" title="安全生产事故"></a>安全生产事故</h2><p>这里总结了有标志性的安全生产案件，安全生产，警钟长鸣： </p>
<ol>
<li>2022年3月21日，东方航空5735号班机空难</li>
<li>2015年6月1日，东方之星号客船在长江沉没</li>
<li>2014年12月31日，上海黄埔发生跨年夜踩踏事件</li>
<li>2015年8月12日，天津港危化品仓库爆炸</li>
<li>2018年10月28日，重庆万州公交车坠江</li>
<li>2021年6月13日，湖北省十堰市集贸市场燃气爆炸</li>
<li>2021年7月12日，苏州四季酒店倒塌</li>
<li>2018年11月4日，福建泉港碳九泄露</li>
<li>2013年11月22日，青岛输油管道爆炸</li>
<li>2014年7月28日，新疆维吾尔自治区喀什地区莎车县暴恐袭击案，新疆还有很多类似的案件，影响恶劣，死伤群众很多，这里不一一列举了</li>
<li>2019年3月21日，江苏响水天佳宜化工厂爆炸</li>
<li>2021年5月22日，黄河石林百公里越野跑组织事故</li>
<li>2022年4月29日，长沙自建房倒塌</li>
</ol>
<h2 id="民生"><a href="#民生" class="headerlink" title="民生"></a>民生</h2><p>影响大量普通人正常生活的社会性问题：</p>
<ol>
<li>2020年1月初，武汉爆发不明肺炎，后命名为新冠病毒，影响全球。这场病毒后续有很多衍生悲剧，比如2022年9月18日贵州涉疫人员隔离转运车辆侧翻事故等等</li>
<li>2021年7月，黑龙江、四川、吉林、辽宁多次出现拉闸限电现象。2022年7月，四川等地也出现限电现象</li>
<li>2018年8月9日，陕西商洛发现多例儿童接种过期疫苗</li>
<li>2018年7月15日，长春长生冻干人用狂犬病疫苗存在记录造假行为</li>
<li>2016年3月，山东警方破获价值5.7亿非法疫苗案</li>
<li>2022年4月18日，河南多家村镇银行被曝无法取款</li>
<li>2018年，P2P借贷平台集体倒闭，大量群众财产受损失</li>
<li>2020年12月，蛋壳租房暴雷，多地租房合同出现纠纷</li>
<li>2022年7月初，上海公安数据库遭到入侵，泄露十亿居民的个人资料，此案件非经官方正式回应</li>
<li>2013年12月初，多地严重雾霾污染，PM2.5严重超标</li>
</ol>
<h2 id="自然天灾"><a href="#自然天灾" class="headerlink" title="自然天灾"></a>自然天灾</h2><p>自然导致的灾难是悲惨的：</p>
<ol>
<li>2022年9月5日，四川泸定县6.8级地震</li>
<li>2013年4月20日，四川庐山7.0级地震（原雅安地震），四川是地震的高频率地带，很多类似的天灾也不一一列举了</li>
<li>2021年7月20日，河南郑州特大暴雨造成严重洪水</li>
<li>2020年5月下旬，长江中下游、淮河、西南华南东南沿海严重水灾</li>
<li>2020年3月30日，四川凉山州西昌市森林大火</li>
<li>2020年3月20日，因降水京广线部分行区间导致塌方，T179列车发生侧翻，导致列车脱轨</li>
</ol>
<h2 id="严重刑事案件"><a href="#严重刑事案件" class="headerlink" title="严重刑事案件"></a>严重刑事案件</h2><p>希望这个社会不再有戾气，不要恶意伤害无辜的人。愿正义审判早日惩罚犯罪的人：</p>
<ol>
<li>2014年7月5日，杭州7路公交车人为纵火</li>
<li>2013年6月7日，厦门BRT快1线公交车人为纵火</li>
<li>2021年11月2日，大连某投资失败者恶意驾车撞人</li>
<li>2020年6月4日，广西梧州市苍梧县旺甫镇中心小学，一保安恶意伤人</li>
<li>2022年6月10日，唐山某烧烤店性骚扰暴力打人事件</li>
<li>2018年，河南开封人民法院公审赵志勇性侵多名幼女或系强迫卖淫</li>
<li>2022年1月，徐州丰县铁链女事件</li>
<li>2020年7月7日，贵州安顺市公交坠湖，官方调查是公交司机由于被强拆和疫情减薪导致对社会不满</li>
</ol>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>安全生产</tag>
        <tag>公共事件</tag>
      </tags>
  </entry>
  <entry>
    <title>通过nginx配置修改网页cookie属性</title>
    <url>/2018/01/10/%E9%80%9A%E8%BF%87nginx%E9%85%8D%E7%BD%AE%E4%BF%AE%E6%94%B9%E7%BD%91%E9%A1%B5cookie%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h2 id="需求与具体配置"><a href="#需求与具体配置" class="headerlink" title="需求与具体配置"></a>需求与具体配置</h2><p>公司的电子商城在十九大等保安检时期被折腾出去，结果这几天又折腾回来了，据说还会是明年大数据研究院的主要开发项目。结果回来没几天被测试中心的人在cookie方面发现了几个问题，如下：</p>
<ol>
<li>cookie没有使用http-only；</li>
<li>cookie没有携带secure属性；</li>
<li>http头中需要配置“X-Frame-Options：SAMEORIGIN”；</li>
</ol>
<p>以上这几点可以通过nginx的配置来轻松实现，具体方法就是在需要更改的网页server的配置里面添加下面几句话。如图：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">add_header                  <span class="title class_">Set</span>-<span class="title class_">Cookie</span> <span class="string">&quot;HttpOnly&quot;</span>;</span><br><span class="line">add_header                  <span class="title class_">Set</span>-<span class="title class_">Cookie</span> <span class="string">&quot;Secure&quot;</span>;</span><br><span class="line">add_header                  X-<span class="title class_">Frame</span>-<span class="title class_">Options</span> <span class="string">&quot;SAMEORIGIN&quot;</span>;</span><br></pre></td></tr></table></figure></p>
<p><img data-src="/images/addheader.png" alt="好车" title="修改配置文件如图"></p>
<p>然后保存配置文件，<code>nginx -s reload</code>平滑重启即可，通过chrome在目标网页里按下<code>ctrl+shift+c</code>，先选择好<code>network</code>，然后重新刷新一下界面，选择域名，对应域名下点击<code>headers</code>，就会看到<code>cookie</code>的配置情况，如图：<br><img data-src="/images/seecookie.png" alt="好车" title="cookie生效"></p>
<h2 id="扩展内容"><a href="#扩展内容" class="headerlink" title="扩展内容"></a>扩展内容</h2><p>看到配置已经生效。那么这几个配置主要是干什么的呢？其实主要都是防范XSS攻击（跨域脚本攻击）的。</p>
<p>Cookie的Secure属性，意味着保持Cookie通信只限于加密传输，指示浏览器仅仅在通过安全&#x2F;加密连接才能使用该Cookie。如果一个Web服务器从一个非安全连接里设置了一个带有secure属性的Cookie，当Cookie被发送到客户端时，它仍然能通过中间人攻击来拦截。 </p>
<p>Cookie的HttpOnly属性，指示浏览器不要在除HTTP（和HTTPS)请求之外暴露Cookie。一个有HttpOnly属性的Cookie，是不可以通过例如调用JavaScript(引用document.cookie)这种非HTTP方式来访问。因此，也不可能通过跨域脚本（一种非常普通的攻击技术）来偷走这种Cookie。</p>
<p>X-Frame-Options HTTP 响应头是用来给浏览器指示允许一个页面可否在<code>frame</code>, <code>iframe</code>或者<code>object</code>中展现的标记。网站可以使用此功能，来确保自己网站的内容没有被嵌到别人的网站中去，也从而避免了点击劫持 (clickjacking) 的攻击。它有三个可选择项：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">DENY</span>：表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许；</span><br><span class="line"><span class="variable constant_">SAMEORIGIN</span>：表示该页面可以在相同域名页面的 frame 中展示；</span><br><span class="line"><span class="variable constant_">ALLOW</span>-<span class="variable constant_">FROM</span> uri地址：表示该页面可以在指定来源的 frame 中展示；</span><br></pre></td></tr></table></figure><br>如果设置为 DENY，不光在别人的网站 frame 嵌入时会无法加载，在同域名页面中同样会无法加载。另一方面，如果设置为 SAMEORIGIN，那么页面就可以在同域名页面的 frame 中嵌套。</p>
<p>这里还要额外注意一下！<font color=red>配置了Cookie的HttpOnly属性和Secure属性之后，如果测试中心的人使用的协议是http而不是https的话，会有“浏览器请求后端服务时header不会带上cookie参数”的现象，那是因为“由于secure属性的存在，导致浏览器在与服务器通信时不会使用该cookie”。这个时候就需要把secure&#x3D;”true”这个配置去掉才可以达到正确测试的目的。</font></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://imququ.com/post/my-nginx-conf-for-security.html">https://imququ.com/post/my-nginx-conf-for-security.html</a> </p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>运维技术</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>通过调整Css让界面美观一点</title>
    <url>/2018/11/05/%E9%80%9A%E8%BF%87%E8%B0%83%E6%95%B4Css%E8%AE%A9%E7%95%8C%E9%9D%A2%E7%BE%8E%E8%A7%82%E4%B8%80%E7%82%B9/</url>
    <content><![CDATA[<p>数据可视化肯定需要前端知识，同时也要美化前端，让用户的体验更好，这时候就需要接触到css技术。</p>
<p>css简单来说就是先给你需要修饰的部分设定变量，然后针对不同的变量做不同的声明，达到修改界面的目的。css规则由两个主要的部分构成：选择器，以及一条或多条声明，格式是：<code>selector {declaration1; declaration2; ... declarationN }</code>。</p>
<p>在html文本里添加一个style标签，比如：<code>&lt;style type=&quot;test/css&quot;&gt; &lt;/style&gt;</code>。这个标签可以放到<code>&lt;body&gt;</code>最尾处也可以放到<code>&lt;head&gt;</code>最尾处。不过一般来说都是放到<code>&lt;body&gt;</code>里。</p>
<p>在调整css的时候，可以搭配chrome的F12键直接修改，然后将修改的内容拷贝粘贴到html文件里。</p>
<p>比如我现在的页面是如下这个样子的：<br><img data-src="/images/css3.png" alt="akb48"></p>
<p>这个结构可以看出使用最直白的html语言编写，为了美观大方，我们需要把它改成如下的样子：<br><img data-src="/images/css4.png" alt="akb48"></p>
<p>原来的代码如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% url &#x27;home&#x27; %&#125;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Homepage<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% url &#x27;blog_list&#x27; %&#125;&quot;</span>&gt;</span>List<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span>&gt;</span>跳往百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.lechange.com&quot;</span>&gt;</span>跳往乐橙<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        &lt;hr&gt;</span><br><span class="line">        &#123;% block content %&#125; &#123;% endblock %&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>更改后的代码如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>  <span class="attr">class</span>=<span class="string">&quot;nav&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		<span class="comment">&lt;!-- 给这个div标签添加一个class叫nav --&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;logo&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% url &#x27;home&#x27; %&#125;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">				<span class="comment">&lt;!-- 给这个div下的这个a标签添加一个class叫logo --&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Homepage<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% url &#x27;blog_list&#x27; %&#125;&quot;</span>&gt;</span>List<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span>&gt;</span>跳往百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.lechange.com&quot;</span>&gt;</span>跳往乐橙<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        &lt;hr&gt;</span><br><span class="line">        &#123;% block content %&#125; &#123;% endblock %&#125;</span><br><span class="line">        &lt;style type=<span class="string">&#x27;text/css&#x27;</span>&gt;</span><br><span class="line">				body&#123;</span><br><span class="line">                       <span class="attr">margin</span>: <span class="number">0</span>;</span><br><span class="line">                       <span class="attr">padding</span>: <span class="number">0</span>;</span><br><span class="line">					&lt;!-- 这是对整个body标签进行声明，外边距和内边距都是<span class="number">0</span> --&gt;</span><br><span class="line">                &#125;</span><br><span class="line">                div.<span class="property">nav</span>&#123;</span><br><span class="line">                       background-<span class="attr">color</span>: #eee;</span><br><span class="line">					border-<span class="attr">bottom</span>: 2px solid blue;</span><br><span class="line">					<span class="attr">padding</span>: 5px 10px;</span><br><span class="line">					&lt;!-- 这是对整个nav的div标签进行声明：颜色灰色 --&gt;</span><br><span class="line">					&lt;!-- 增加一条底线取代&lt;hr&gt;，设定宽是2px，实线，颜色是蓝色 --&gt;</span><br><span class="line">					&lt;!-- 设定上下边距5px,左右边距10px --&gt;</span><br><span class="line">               	&#125;</span><br><span class="line">				div.<span class="property">nav</span> a&#123;</span><br><span class="line">					text-<span class="attr">decoration</span>: none;</span><br><span class="line">					<span class="attr">color</span>: #<span class="number">000</span>;</span><br><span class="line">					&lt;!-- 这是对整个nav的div标签里的所有a标签说明：取消下划线，并且规定为黑色 --&gt;</span><br><span class="line">				&#125;</span><br><span class="line">                div.<span class="property">nav</span> a.<span class="property">logo</span> &#123;</span><br><span class="line">					<span class="attr">display</span>: inline-block;</span><br><span class="line">					<span class="attr">color</span>: green;</span><br><span class="line">					font-<span class="attr">size</span>:<span class="number">120</span>%;</span><br><span class="line">					&lt;!-- 在这里对nav的div标签里那个叫logo的a标签进行单独的说明：缩进，并且规定为绿色 --&gt;</span><br><span class="line">					&lt;!-- 字体大小是原来的<span class="number">120</span>% --&gt;</span><br><span class="line">                &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>调整css是一个很繁琐很麻烦的事情，需要耐心。至于如何整合css样式到一个文件然后统一配置的内容，请去看：<a href="https://rorschachchan.github.io/2018/05/12/%E5%8A%A0%E8%BD%BDcss%E6%A0%B7%E5%BC%8F%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%B3%95/">https://rorschachchan.github.io/2018/05/12/%E5%8A%A0%E8%BD%BDcss%E6%A0%B7%E5%BC%8F%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%B3%95/</a> 。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>通过调整jmv参数，有效提升系统可用率</title>
    <url>/2025/07/25/%E9%80%9A%E8%BF%87%E8%B0%83%E6%95%B4jmv%E5%8F%82%E6%95%B0%EF%BC%8C%E6%9C%89%E6%95%88%E6%8F%90%E5%8D%87%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E7%8E%87/</url>
    <content><![CDATA[<h2 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h2><p>组内有一个业务系统 A，日常能达到十万级QPS（大促峰值超40WQPS），且上游系统基于同步调用，对RT非常敏感（毫秒级返回）。因此系统A不能轻易抖动，需要在超高流量下保持极致的服务稳定性：<br><img data-src="/images/jvm1.png" alt="paradin" title="调用关系很简单，但是对抖动的要求很高"></p>
<p>某天发现上游系统有一些报错，找过来需要我们排查解决：<br><img data-src="/images/jvm2.png" alt="paradin" title="RT跟qps的曲线几乎相同，可见就是抖动导致的"></p>
<h2 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2><h3 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h3><p>查看上游系统报错日志，发现全都是同步调用请求超时，报错<code>TimeoutException</code>。因此需要重点分析系统A是否有异常。<br>首先，在报错时间段业务流量并没有明显上涨，系统 A 的CPU水位、机器load也没有明显异常，因此可初步排除由于流量激增、超出系统最大负载所致。<br>其次，系统 A 执行请求的过程全都是一些内存计算逻辑，不需要远程调用数据库、中间件、外部系统，因此也可排除是外部依赖服务抖动&#x2F;有瓶颈导致。<br>其次，虽然系统 A 的并发流量很高（单机高达数千 QPS），但每条请求之间不涉及同步&#x2F;互斥的单机&#x2F;分布式锁逻辑，因此也可排除由于锁导致请求等待超时所致。<br>经过以上初步分析，已排除流量激增、外部服务有瓶颈、并发锁等可能影响因素，但并未定位到根因，需要进一步深入分析。</p>
<h3 id="定位根因"><a href="#定位根因" class="headerlink" title="定位根因"></a>定位根因</h3><p>查看系统日志，发现服务抖动期间，该系统曾发生过一次热数据发布（系统索引切换）：<br><img data-src="/images/jvm3.png" alt="paradin" title="系统 A 在内存中加载了一份索引（可简单理解为一个比较复杂的大对象&#x2F;数据结构），且系统 A 会不定期（最快每 15 分钟）更换旧索引、加载最新版本索引"></p>
<p>已知本系统的索引较大（约 0.5G），由于索引切换过程会产生大量新对象和内存垃圾，因此高度怀疑服务抖动与 GC 强相关。查看 <code>gc.log</code>，在系统抖动期间果然发现了长耗时的 YGC：<br><img data-src="/images/jvm4.png" alt="paradin" title="Object Copy：GC 时不再使用的对象会被清理释放，并整理剩余存活对象，整理过程存活对象会被复制到内存中新的位置"></p>
<p>观察日志可发现<code>Object Copy</code>环节耗时明显异常，高达200ms，且本过程会<code>STW（Stop The World）</code>。因此服务抖动的根本原因已锁定：<code>系统A加载的索引非常大，导致 YGC 时索引在堆内存的复制过程耗时久，复制期间业务线程被长时间暂停，导致上游请求大量超时报错</code>。</p>
<h2 id="优化过程"><a href="#优化过程" class="headerlink" title="优化过程"></a>优化过程</h2><h3 id="常规思路"><a href="#常规思路" class="headerlink" title="常规思路"></a>常规思路</h3><p>针对 GC 暂停久这类常见问题，有如下一些常规优化思路：<br><img data-src="/images/jvm5.png" alt="paradin" title="这些思路都是面试时候可以拿来装逼的材料"></p>
<p>然而，以上方法在本次场景中大多不适用。首先经排查代码并不存在Bug，且索引体积已无更多压缩空间，且索引算法层面并不支持增量式更新只能全量更替。其次，加机器虽然能通过稀释单机请求量，让 STW 长暂停影响到的请求量更少，但并未从根本解决问题，且会导致机器资源大量浪费。另外使用堆外内存虽然可不受 GC 管理，但高频访问下序列化&#x2F;反序列化开销无法容忍。</p>
<p>因此，综合来看只能考虑在 JVM 参数方面做优化：通过修改参数调整 JVM 的行为模式，让索引复制带来的负面影响尽可能小，保障服务高可用。</p>
<h3 id="详细分析GC日志"><a href="#详细分析GC日志" class="headerlink" title="详细分析GC日志"></a>详细分析GC日志</h3><p>根据 “定位根因” 那一段的分析，问题已归因为<code>YGC Object Copy</code>阶段复制索引时耗时太久，导致上游请求超时报错。本节进一步详细分析 GC 日志，更细粒度还原整个 GC 过程，探索有无潜在优化点。<br>已知当前 JVM 核心参数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Xms12g</span><br><span class="line">-Xmx12g</span><br><span class="line">-XX:MetaspaceSize=512m</span><br><span class="line">-XX:MaxMetaspaceSize=512m</span><br><span class="line">-XX:+UseG1GC</span><br><span class="line">-XX:G1HeapRegionSize=16M</span><br><span class="line">-XX:MaxGCPauseMillis=100</span><br></pre></td></tr></table></figure>

<p>通过集团 ATP 工具对原始 GC 日志进行可视化分析，下图中标出了各 GC 事件的时间点和变化曲线：<br><img data-src="/images/jvm6.png" alt="paradin" title="grace-parser 对于分析堆和线程栈是一个好东西"></p>
<p>从图中可以分析出如下信息：<br>① 蓝色圆点：一个点代表一次 YGC，横轴上堆满了密密麻麻的蓝点，说明 YGC 发生非常频繁且耗时短，毫秒级即可完成清理，这是理想中的情况。符合预期<br>② 粉色折线：代表堆内存占用量的变化情况，可以看到整体呈锯齿形，不断快速上升和下降。由于系统流量较大且请求执行过程会不断产生一些朝生夕灭的临时对象，因此可看到粉色折线快速上升。当 Eden 区不足时触发 YGC 清理，内存释放完成即可看到粉色折线下降到低点。符合预期<br>③ 异常蓝点：远离横轴说明耗时久，它们就是刚刚在日志中手动找到的长耗时 YGC 记录。需重点关注<br>④ 紫色折线：代表老年代堆内存占用量的变化情况。相比之下老年代占用率上涨缓慢，因为大多数临时对象都在年轻代被清理掉了，不会进入老年代。然而观察发现每次长耗时 YGC 蓝点附近，都会伴随着紫色折线阶梯式上升。需重点关注</p>
<p>其次，还可发现长耗时YGC往往是成对出现的，有如下规律：<code>成对出现、时间接近、耗时都长、第一次晋升量少、第二次晋升量多</code>，如下图所示：<br><img data-src="/images/jvm7.png" alt="paradin" title="可见每次切换索引就超时抖动"></p>
<p>综上，整合目前所有已知线索：系统在每次切换索引时，都会超时抖动，且在抖动时间点会发现连续的两次长耗时 YGC（第二次 YGC 晋升量大）。</p>
<p>经分析以上现象符合预期，详细过程推演还原如下：<br><img data-src="/images/jvm8.png" alt="paradin" title="gc原理"></p>
<p>● 阶段一：系统创建新索引，相关对象默认被分配至 Eden 区<br>● 阶段二：Eden 区空间不足，触发第一次 YGC，此时新索引被复制（Object Copy）到 Survivor 区，耗时久<br>● 阶段三：新索引构造完成，并被 GcRoot 引用上，旧索引与 GcRoot 引用被断开<br>● 阶段四：系统持续处理外部请求，Eden 区空间再次不足，触发第二次 YGC，此时旧索引被清理。新索引又被复制（Object Copy）到 Old 区（晋升），耗时久<br>● 阶段五：后续即使外部流量再次把 Eden 区打满，YGC 也能毫秒级快速完成。因为只需快速清理临时对象即可，新索引已稳定在老年代不会再被腾挪复制</p>
<h3 id="一些尝试"><a href="#一些尝试" class="headerlink" title="一些尝试"></a>一些尝试</h3><p>至此，问题原因已非常清晰：每次新生成的索引会随着YGC连续复制多次，复制过程暂停久导致系统抖动。因此可考虑基于如下一些思路来针对性优化本问题，后文会逐个详细解释：<br><img data-src="/images/jvm9.png" alt="paradin" title="这几个参数又是给你面试装逼的资源"></p>
<h4 id="让索引尽早晋升到老年代"><a href="#让索引尽早晋升到老年代" class="headerlink" title="让索引尽早晋升到老年代"></a>让索引尽早晋升到老年代</h4><p>通常情况下，一个对象最初会被分配在 Eden 区，第一次 YGC 后进入 Survivor 区。此后每次 YGC 对象会在 S0 和 S1 之间反复腾挪，且每次腾挪后对象 age+1，当 age 大于默认阈值时会晋升到 Old 区。因此对象在堆内存中的流转路径是：<code>Eden =&gt; S0 =&gt; S1 =&gt; S0 =&gt; S1 =&gt; ... =&gt; Old</code>。</p>
<p>由于本例中索引对象复制开销太大，因此可考虑让索引尽早晋升到老年代，避免在年轻代反复腾挪影响系统稳定性。有如下 JVM 参数可以达到此目的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MaxTenuringThreshold参数作用：表示对象在晋升到老年代之前，在年轻代中最多能够承受的 GC 周期次数</span><br></pre></td></tr></table></figure>

<p>然而，结合上面 GC 日志截图可知，G1GC 对大对象做了动态优化——直接晋升（Direct Tenuring），并没有让索引在 Survivor 内反复腾挪。索引实际流转路径是：<code>Eden =&gt; S0 =&gt; Old</code>，总共只涉及 2 次复制而非默认值 15 次。此时相当于已经默认设置了 <code>MaxTenuringThreshold=1</code>，流程如下：<br>● 阶段一：新索引分配至 Eden 区，此时 age&#x3D;0<br>● 阶段二：触发第一次 YGC，索引存活，由于 age &lt; MaxTenuringThreshold &#x3D; 1，此时索引从 Eden 复制到 S0，随后 age 增长为1<br>● 阶段三：触发第二次 YGC，索引仍存活，此时由于 age &#x3D; MaxTenuringThreshold &#x3D; 1，则直接晋升并复制到 Old</p>
<p>于是手动设置 <code>MaxTenuringThreshold=1</code> 重新实验。如下图所示，经实测索引流转路径仍然是 Eden &#x3D;&gt; S0 &#x3D;&gt; Old，证明以上猜想成立：<br><img data-src="/images/jvm10.png" alt="paradin" title="直接晋升"></p>
<p>那能否更极端一点呢？让索引直接从 Eden 复制到 Old 而完全不经过 Survivor 区？因为<code>Eden =&gt; Old</code>相比<code>Eden =&gt; S0 =&gt; Old</code>，复制次数从 2 次进一步压缩为 1 次，总暂停时间直接减半，系统稳定性预期将提升明显。因此考虑进一步设置 <code>MaxTenuringThreshold=0</code>，预期流程如下：</p>
<p>●阶段一：新索引分配至 Eden 区，此时 age&#x3D;0<br>●阶段二：触发第一次 YGC，此时由于 age &#x3D; MaxTenuringThreshold &#x3D; 0，则索引直接晋升并复制到 Old</p>
<p>实验结果如下图，可知索引的确在第一次 YGC 时从 Eden 被直接复制到了 Old（因为清理后年轻代占用变为 0，否则年轻代清理后仍然会占用 400MB 左右）<br><img data-src="/images/jvm11.png" alt="paradin" title="直接晋升"></p>
<p>总结：本次优化前，每次索引切换后会出现2次连续的长耗时YGC，在不改任何一行业务代码、不加一台机器的前提下，仅通过设置 <code>MaxTenuringThreshold=0</code>，GC 长暂停时间直接减半。体现在系统监控上就是索引切换时报错量明显变少，服务抖动时成功率从 95% 提高至 98%：<br><img data-src="/images/jvm12.png" alt="paradin" title="不走s区，直接去old"></p>
<h4 id="InitialTenuringThreshold"><a href="#InitialTenuringThreshold" class="headerlink" title="InitialTenuringThreshold"></a>InitialTenuringThreshold</h4><p>经实测，设置 <code>InitialTenuringThreshold=1</code> 也能达到类似上面的效果，也能将索引复制次数从 2 次减少为 1 次，提高系统稳定性：<br><img data-src="/images/jvm12.png" alt="paradin" title="InitialTenuringThreshold和MaxTenuringThreshold的作用类似，都是用于调整对象晋升到老年代的年龄阈值"></p>
<h4 id="AlwaysTenure"><a href="#AlwaysTenure" class="headerlink" title="AlwaysTenure"></a>AlwaysTenure</h4><p>AlwaysTenure参数作用如字面含义：让对象总是晋升。经实测，设置 AlwaysTenure 后，也能将索引复制次数从 2 次减少为 1 次，提高系统稳定性：<br><img data-src="/images/jvm14.png" alt="paradin" title="AlwaysTenure 参数也能达到该目的"></p>
<p>这里多说明一下：<br>● 由于索引较大，Eden 区剩余空间可能无法容纳整个索引，因此上图总共经历了 3 次 YGC 清理释放，才让索引全部创建完成。其中每次 YGC 会把已构造好的索引局部晋升到老年代，前后总共 3 次 YGC 才把索引完整搬到了老年代。这与“AlwaysTenure 将索引复制次数从 2 次减少为 1 次”结论并不冲突。</p>
<p>● AlwaysTenure 相当于只使用 Eden 和 Old，而 Survivor 闲置。与之作用相反的参数是 NeverTenure，会让对象在年轻代中反复辗转而永远不晋升，意味着只使用了 Eden 和 Survivor 区，而 Old 区闲置。两个参数都比较极端，【只有在特殊业务场景才考虑使用】。</p>
<p>● 降低晋升年龄阈值会让对象更容易进入老年代，但是会加重老年代 FGC 负担。而本业务场景比较特殊，对象的存活时间两极分化明显：一种是由 RPC 请求产生的朝生夕灭的对象，存活时间毫秒级；另一种则是巨型索引对象，存活时间最短都有数十分钟。因此就算把晋升年龄阈值改为1，这些临时对象大概率已失活（被清理）而非存活（被晋升），故修改以上 JVM 参数不会加重本系统FGC负担。</p>
<h4 id="让索引直接分配到老年代"><a href="#让索引直接分配到老年代" class="headerlink" title="让索引直接分配到老年代"></a>让索引直接分配到老年代</h4><p>上节内容已将索引流转路径已从<code>Eden =&gt; Survivor =&gt; Old（2 次复制）</code>优化为 <code>Eden =&gt; Old（1 次复制）</code>。能否更极端一点，让新索引在最初创建时，就一步到位直接分配到老年代（0 次复制）？思路如下：<br><img data-src="/images/jvm15.png" alt="paradin" title="这样索引复制导致服务抖动的问题将得到根治"></p>
<p>围绕此思路，继续做了如下尝试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PretenureSizeThreshold 参数作用：当对象的大小超过 PretenureSizeThreshold 时，该对象会直接分配到老年代</span><br></pre></td></tr></table></figure>

<p>然而 PretenureSizeThreshold 参数对 G1GC 并不生效，实测也发现调整该参数后没有稳定性增益。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">G1HeapRegionSize 参数作用：G1GC 将堆内存划分为多个大小相等的区域，这些区域被称为 Region，旨在提高垃圾收集的效率和灵活性。当待分配对象大小 &gt; G1HeapRegionSize / 2 时，会被直接分配到老年代</span><br></pre></td></tr></table></figure>

<p>修改 G1HeapRegionSize 参数后继续观察，索引切换时系统仍然抖动，看 GC 日志索引流转路径仍然是 <code>Eden =&gt; Survivor =&gt; Old</code>，并没有达到预期效果。</p>
<p>原因分析：业务上索引虽然整体很大（约500MB），但实际是由上百万个小对象组成的。索引的创建过程实际就是内部海量小对象逐个创建的过程，这些小对象被分配至 Eden（而非 Old）是合理的、符合预期的，因此从结果来看整个索引实际仍然被分配在 Eden 区。除非是 int[] arr &#x3D; new int[1000000000] 这类情况，JVM 能在最初明确知道 arr 需要多少空间，才可直接分配到老年代。</p>
<h4 id="加速索引复制过程"><a href="#加速索引复制过程" class="headerlink" title="加速索引复制过程"></a>加速索引复制过程</h4><p>在不改变索引固有大小、索引复制次数的情况下，也可以考虑调节如下参数来提高复制速度、降低暂停时长：<br><img data-src="/images/jvm16.png" alt="paradin" title="这几个参数也都挨个试过"></p>
<p>实测调整以上参数无明显改善：MaxGCPauseMillis 只是一个目标值，然而复制索引固有耗时始终有那么久，作用不大。其次，经实测 GC 默认并发线程数已接近 CPU 核数，也无更多优化空间。</p>
<h4 id="升级JDK11-ZGC"><a href="#升级JDK11-ZGC" class="headerlink" title="升级JDK11 - ZGC"></a>升级JDK11 - ZGC</h4><p>传统的CMS和G1都存在各自的理论局限（例如CMS的内存碎片化，G1只能在STW时移动对象，两者STW时长会随着活跃对象的增加而增加），这正是我们大索引复制所遇到的问题。</p>
<p>JDK11 中新增 ZGC，核心变化是引入了着色指针（Colored Pointers）和读屏障（Load Barriers）机制，解决对象复制过程中准确访问对象的问题，从 STW 优化为并发转移。核心原理如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ZGC中业务线程访问对象将触发“读屏障”，如果发现对象被复制移动了（通过“着色指针”实现），则“读屏障”会把读出来的指针更新到对象的新地址上，让业务线程始终访问到对象更新后、移动后的正确地址。对比之下G1只能先暂停并复制对象、更新指针地址，随后再解除暂停让业务线程访问对象</span><br></pre></td></tr></table></figure>

<p>以上机制让 ZGC 可以有更高的并发度、更低的 STW 时长。对比 G1 如下：<br><img data-src="/images/jvm17.png" alt="paradin" title="ZGC vs G1"></p>
<p>经实测使用 ZGC 后稳定性有提升，但索引切换期间仍然会有轻微抖动。诊断分析 GC 日志发现此期间有 Allocation Stall（导致应用程序在尝试分配内存时暂时停止，直到有足够的内存可用）：<br><img data-src="/images/jvm18.png" alt="paradin" title="ZGC还是有点效果的"></p>
<p>本系统每次分配新索引都需要约 500MB 内存，这是 JVM 无法预知的。对比监控可发现每次索引切换时，每个服务端 RT 尖刺均对应了一次堆内存占用尖刺，如下图：<br><img data-src="/images/jvm19.png" alt="paradin" title="时间轴都对得上"></p>
<p>由于 ZGC 在内存整理阶段是无锁复制，因此 GC 日志中没再发现耗时异常的记录，经实测服务成功率进一步提高到了 99.5%。但美中不足的是由于 Allocation Stall 问题，系统时常还是会有些小抖动。</p>
<h2 id="问题复盘"><a href="#问题复盘" class="headerlink" title="问题复盘"></a>问题复盘</h2><p>回顾本问题，复盘为什么YGC的负面影响这么大，让本系统在索引切换时成功率跌至95%？核心问题是本系统挑战本身就非常大，需要同时满足以下三个条件，缺一不可：<br>● 对延迟非常敏感：同步调用且毫秒级返回，不能长时间暂停，否则每次长暂停都会直接体现为业务监控上的报错<br>● 极高的内存压力：每次索引切换会带来 GB 级的内存消耗、清理和复制开销，这是导致 YGC 耗时久的根源<br>● 极高的并发量：总流量十万级 QPS，单机数千 QPS。GC 暂停时所有请求都将暂停处理，导致大量超时<br><img data-src="/images/jvm20.png" alt="paradin" title="维护这么难得的系统也是一个挺有挑战的事儿"></p>
<p>由此可见，针对组内某个高并发（10W+ QPS）、低延迟（毫秒级返回）、高内存压力（最快每 15 分钟一次 GB 级索引切换）系统的不稳定问题，可以尝试基于 JVM 调参做了一系列探索尝试，最终彻底实现了索引无感切换，让服务可用率稳定在 99.995%。经测试有效的优化手段如下：<br><img data-src="/images/jvm21.png" alt="paradin" title="最后总结一下"></p>
<p>至此，未来无论系统 QPS 涨到多高、索引体积膨胀到多大、索引切换多么频繁，系统都能无感切换索引，稳定性不再受到任何影响。完结撒花~</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>gc</tag>
        <tag>系统调优</tag>
      </tags>
  </entry>
  <entry>
    <title>這些年被Ainge拆毀的塞爾提克</title>
    <url>/2019/07/11/%E9%80%99%E4%BA%9B%E5%B9%B4%E8%A2%ABAinge%E6%8B%86%E6%AF%80%E7%9A%84%E5%A1%9E%E7%88%BE%E6%8F%90%E5%85%8B/</url>
    <content><![CDATA[<p><strong>原作者：老溫隨筆</strong></p>
<p>2019年選秀會上塞爾提克將替補中鋒Aron Baynes打包送往太陽隊，如果加上成為自由球員且可能一去不回頭的Kyrie Irving、Al Horford、Terry Rozier，以及成為自由球員但完全沒有續約消息的Daniel Theis，塞爾提克頓時成了沒有控衛、沒有中鋒，加上本來就沒有大前鋒的詭異陣容。這支一年前還誓言爭奪總冠軍的球隊，在幾天之內就變得連自家球迷都不認識的模樣。</p>
<p>自從2013年7月12日總管Danny Ainge正式將Kevin Garnett、Paul Pierce與Jason Terry打包送往籃網隊交換包含數個首輪選秀權的包裹後，短短六年裡塞爾提克在Ainge不斷的交易洗資產與總教練Brad Stevens的堅持不擺爛的兩極風格下意外地兩度打入東區冠軍賽，一年前甚至僅一場之差就足以重返總冠軍賽，讓塞爾提克成為聯盟裡最炙手可熱的球隊。</p>
<p>但是就在短短的一年裡，塞爾提克問鼎準後勇士時期王座的希望破滅。隨著球季中一波波的脫序演出，無論是場後Irving、Marcus Morris在媒體前的狂飆或是場上直接發洩不滿的舉動，連過去十幾年來幾乎沒有異音的波士頓媒體都逐漸脫離過往照著球隊餵養訊息過日子的生態，不斷的向這些球員發出怒火。當塞爾提克在東區第二輪以近乎毫無抵抗力的方式慘敗給公鹿隊，宛如1983年的悲劇重演的情節似乎也注定了這支完全不符內外期望的塞爾提克即將面對的悲慘未來。</p>
<h2 id="歷史的借鏡"><a href="#歷史的借鏡" class="headerlink" title="歷史的借鏡"></a>歷史的借鏡</h2><p>1983年球季結束後的第22天，原本以為自己地位依然穩固的總教練Bill Fitch意外得知一向力挺自己的老闆Harry Mangurian即將出售持股，三天後，在鬥爭中贏得勝利的總裁Red Auerbach正式重新掌握球隊，在眾叛親離下，Fitch只能黯然宣布下台。除了失去老闆Mangurian的力挺外，另一個壓垮Fitch的原因是成為自由球員的明星前鋒Kevin McHale表明不願意再替Fitch打球，而陣中除了Larry Bird以外的球員無論老少也都投下反對票。</p>
<p>故事的最後在老闆Mangurian用智力退試圖搶親的尼克隊讓McHale續留下獲得圓滿的結局。塞爾提克重新成為Auerbach的大家庭，孚眾望的助理教練K.C. Jones扶正成為總教練，McHale如願逼走了Fitch並重返球隊，Mangurian也成功地在八月將球隊賣給Dan Gaston。</p>
<p>重新站起的塞爾提克很快地在1984年東區冠軍賽裡以4：1淘汰了公鹿隊，報了一箭之仇，並在總冠軍賽裡擊敗了湖人隊拿下總冠軍。</p>
<p>也許，可以說當1983年Red Auerbach剷除球隊內部不安的因子Fitch後，這支球隊就獲得初步的止血，並在交易Dennis Johnson完成對湖人與公鹿部屬後重新回到正軌。</p>
<p>跟1983年相近的是2019年的塞爾提克也有一個最後近乎公認的麻煩人物Kyrie Irving，而球季結束後這個麻煩人物也近乎確定離隊。問題在於當你的麻煩人物是個總教練或是行政人員時，下手清除膿包並不會對球隊實力傷筋動骨，但當你的問題人物是個球員時，除非能夠以對等交易的方式進行，否則終將註定會折損球隊的實力。</p>
<p>而現在的塞爾提克問題更加複雜，因為Irving不僅是位球員，還是這支球隊最好的球員，也注定了這將會是一個難捱的暑假，即使，這個結果在兩年前其實就已經可以預知。</p>
<p>從Irving幾乎確定轉隊開始，對塞爾提克不利的消息就接踵而來。原本球團即使沒有Irving都想促成的Anthony Davis交易在經紀人Rich Paul出面喝止，湖人隊一口氣比照籃網隊加碼數個首輪選秀權下成了泡影。眼看著死敵日漸茁壯，當家中鋒Al Hoford宣布跳脫合約後因為換約談判觸礁而可能他去的消息傳出，不僅成了壓垮塞爾提克球迷希望的最後一根稻草，也意味著從2013年開始的重建畫下句點。</p>
<p>不要懷疑，無論是對波士頓這座體育城市，或是對塞爾提克而言，重建成功的標準只有一個：總冠軍。</p>
<p>有趣的是Horford離隊消息傳出後，塞爾提克向上交易第四順位、交易Bradley Beal或是Mike Conley等謠言開始大舉出籠，過去一年完全沒有動作的總裁Ainge也開始再度活躍。更在選秀會上送出了剛執行合約的Baynes，一瞬間，反手大力清除薪資的塞爾提克從原本沒有薪資空間變成了有開出頂薪的能力。</p>
<p>一年前還是眾人捧的塞爾提克在一年後不但牆倒眾人推，而且很有可能成為一支完全不同的球隊。</p>
<h2 id="塞爾提克的東區冠軍賽魔咒"><a href="#塞爾提克的東區冠軍賽魔咒" class="headerlink" title="塞爾提克的東區冠軍賽魔咒"></a>塞爾提克的東區冠軍賽魔咒</h2><p>如果檢視Danny Ainge的掌舵紀錄，會發現打入東區冠軍賽往往不是美好未來的起點，反而可能是旅程的終點。更可以發現當Ainge與背後的老闆們覺得球隊無法跨越高牆時做出的選擇幾乎都是整組拆掉重建，只是過去三次都是Ainge主動按下重建鈕，只有這一次是Ainge首度因為球員背離而被迫重建。<br><img data-src="/images/nba5.png" alt="抱光妹"></p>
<p>塞爾提克的未來尚在未定之天，過去一年的安定終究只是這十七年來的意外，但如果回顧過去三次的解體，除了第二回因為Garnett與Pierce逐漸衰老外，另外兩次主力都正當盛年，解體後的結果都讓球隊跌入更深的深淵，特別是剛打出生涯最佳成績的Isaiah Thomas與Jae Crowder被打包送往騎士交換Irving更是導致當前的大挫敗。</p>
<h2 id="被拆毀的2002年塞爾提克"><a href="#被拆毀的2002年塞爾提克" class="headerlink" title="被拆毀的2002年塞爾提克"></a>被拆毀的2002年塞爾提克</h2><p>只是當年Ainge接手後如何一手拆掉2002年打入東區冠軍賽的塞爾提克，已經沒有太多人記憶，如果經歷過那一段歷史，也許對現在塞爾提克的一片混亂就不會那麼意外，因為這曾經是身為塞爾提克球迷的日常。</p>
<p>當時塞爾提克的老闆傳承到Gaston家族的第二代Paul Gaston，跟熱愛籃球的老爸不同，Paul Gaston只是因為繼承了老爸的遺產而成為球隊的老闆，儘管球隊戰績跌落谷底，但因為NBA持續成長讓塞爾提克的價值也持續成長，於是覺得這是門好生意的Paul Gaston願意繼續經營下去。雖然Auerbach依然在球團裡擔任精神領袖的總裁一職保持門面，但Paul Gaston卻對剛退役的八零年代明星球員有諸多提防，例如一直被認為總有一天會回到波士頓承繼Auerbach衣缽的Larry Bird就始終被以顧問之名給晾在一旁，1993年就開始擔任助理教練的Dennis Johnson也始終無緣扶正。</p>
<p>當接掌國王的王子始終避免被有人望的王子所取代下，其他八零年代的球星如Ainge、McHale就更沒有插手機會，而先後轉戰太陽隊與灰狼隊。這層緊張關係終於在1997年塞爾提克手握兩張樂透籤，有高達19.9%的機率抽到Tim Duncan而爆開。</p>
<p>當規劃NBA史上第一個公然輸球拚選秀的總管M.L. Carr功成身退後，能夠指導Duncan的總管兼總教練空缺成了聯盟最搶手的工作，當時最熱門的人選除了老字號的名帥Larry Brown外，就屬Larry Bird的呼聲最高。</p>
<p>但最後，Paul Gaston宣布由畢業自麻州大，帶領Providence College打入NCAA四強賽，與波士頓有強烈地緣關係的Kentucky大學總教練Rick Pitino接手總教練，並明升暗降Auerbach到副董事長。雖然記者會上Pitino表示會考慮接手塞爾提克是在接到Bird的詢問電話之後，並表示希望Bird能夠考慮留在球團內協助，但此時的Bird也已經接到家鄉印第安那溜馬隊的總教練職缺探詢，只是基於禮貌不便在老東家宣布新任總教練時確定接任。</p>
<p>Pitino的塞爾提克總教練任期最後證明是場災難，但他帶來的首席助理教練Jim O’Brien擔任代理總教練時卻成功帶領以Antoine Walker與Paul Pierce為首的年輕球員在剩餘球季打出剛好五成勝率，第一個完整球季更寫下49勝33敗成績，不但重返季後賽並就此一路打到東區冠軍賽，距離上回Bird帶領球隊打入東冠已經間隔了十四年之久。</p>
<p>這個球季也是Walker成功洗白的一年。</p>
<p>Walker是M.L. Carr在1996年所選，隔年在大學恩師Pitino的全力支持下刷出了22.4分、10.2籃板與3.3助攻的成績，加上球隊從聯盟底部回升到36勝46敗，讓Walker成功入選了明星賽替補。只是少年得志加上教練團沒有強加約束，其實Pitino也約束不住已經在NBA混了一季，跟許多老將廝混養出一堆壞毛病的Walker。他囂張的態度惹惱了波士頓記者，不但給了他Employee #8的綽號，也成了媒體發洩不滿的稻草人，讓Walker在波士頓的名聲始終欠佳。</p>
<p>這局勢在O’Brien接手後開始轉變。Pitino在塞爾提克失敗最大的原因與Fitch相當接近，同為大學教練出身的兩人在球隊裡人緣極差，Pitino更刻意維持大學籃壇以總教練為首的金字塔結構，讓自己與球員之間的隔閡頗深，即使是大學子弟兵如Walker、Ron Mercer、Walter McCarty也難以直接與總教練接觸，所有的事情都靠居間扮演傳達與協調者的O’Brien傳遞，因此當O’Brien接手後很快地就讓球員團結一致的以季後賽為目標，雖然最後無緣，但O’Brien代理時帶隊打出24勝24敗已經是McHale退休後最佳的教練成績，也讓他獲得真除成為正式的塞爾提克總教練。</p>
<p>O’Brien除了改變總教練高高在上的姿態外，最重要的轉變是讓Walker、Pierce成為球隊決策的一環，無形中也讓球員與教練團間的隔閡消失。被賦予重任的Walker改變過去被媒體貼上的標籤，在暑假裡邀請隊友一起練球，到西岸跟Pierce練球，更把場上表現的機會讓給Pierce，自己扮演助攻的配角，這些都讓Walker的好感度快速累積。</p>
<p>最關鍵的還是Walker在2002年東區冠軍賽第三戰回到波士頓主場時展現的領導力。在前三節結束時塞爾提克大幅落後21分，鏡頭前只見到Walker在板凳上激動地對Pierce比手畫腳，第四節裡Pierce用單節獨得19分的表現幫助塞爾提克演出大逆轉，這也是塞爾提克脫離黑暗時期的象徵。</p>
<p>但沒人想到這也是塞爾提克的轉捩點。</p>
<p>將塞爾提克當作是一門生意的Paul Gaston在球隊重返季後賽價值快速上升後終於開啟了交易模式，並成功地在2002年9月將球隊易手給目前以Wyc Grousbeck家族為首的團隊。雖然新老闆沒有立刻撤換球團制服組，但懸而未決的總管人選卻在季後賽時傳出了可能人選，因此當2002-03季後賽塞爾提克在第二輪再次遭遇籃網隊時，所有媒體的焦點都落在可能接手籃球事務的Ainge身上。離開太陽隊教職後的Ainge轉任電視球評，他對於塞爾提克的過度依賴三分投射的打球方式多所評論，特別是對Walker的投籃選擇更是不假辭色，當傳出他可能接掌球隊時，預期他可能將全隊拆解的傳聞也開始在市場上流傳，讓原本就無力防守Jason Kidd的塞爾提克更加無助。球團最後確認人選消息傳出的時間剛好在第三戰前，在人心浮動下，整個第三戰完全失焦，塞爾提克也以76：94慘敗收場，最後慘遭橫掃。</p>
<p>只是諷刺的是Ainge在1988-89球季之所以被賣走，除了年輕最有交易價值外，他與新任總教練Jimmy Rogers交惡也是原因之一，而交惡的原因就是因為Ainge糟糕的三分投籃選擇。</p>
<h2 id="O’Brien跨越時代的戰術思維"><a href="#O’Brien跨越時代的戰術思維" class="headerlink" title="O’Brien跨越時代的戰術思維"></a>O’Brien跨越時代的戰術思維</h2><p><img data-src="/images/nba1.png" alt="抱光妹" title="2002-2003绿凯的三分出手点"><br>如果回顧當時的塞爾提克打法，O’Brien有許多跨越時代的想法。最知名的是2002-03球季塞爾提克以2155次三分球出手成為NBA史上第一支單季三分球出手次數突破2000次球隊，而且要到兩年後NBA才開始穩定有球隊單季出手突破2000次，可說是當前三分熱潮的真正開端。更重要的是O’Brien不僅僅是讓球員多投三分球，他也要求球隊減少在中距離的出手，同時大幅增加球隊在兩側底角的三分球出手次數。</p>
<p><img data-src="/images/nba2.png" alt="抱光妹" title="2002-2003国王的三分出手点"><br>對比另一個底角出手次數較多的國王隊，兩隊的投籃分布截然不同，這說明了O’Brien的塞爾提克在整個投籃的思維領先當代甚多，以致於無法讓當時的媒體所理解。</p>
<p>雖然塞爾提克本身角落三分球出手只占全隊三分球出手的23%在聯盟裡屬於後段，但總出手逼近500次，僅略低於剛好突破500次的馬刺隊（註），這數字比次高球隊多出超過30次。如果認為這數字只是單純因為O’Brien增加三分投射而來，那就大錯特錯，因為這是本季新任湖人隊總教練Frank Vogel在塞爾提克擔任數據影像分析師時所得出來的結論，讓O’Brien有了理論基礎，設計出這套以三分球取代命中率低的中距離，同時利用兩側底角距離較短的特性來增加威脅力的基本打法，而這正是現在NBA的主流思維。</p>
<p>最明顯的例子是小前鋒Eric Williams。1995年入隊的他常跟Walker一起在禁區內攪和，但被Pitino賣往金塊隊後卻因為受傷導致爆發力與敏捷性大幅衰退，重新被賣回塞爾提克後轉型成了防守大鎖，原本不出手三分球的他也開始嘗試在外圍接應。從2001-02球季開始Williams的角落三分球比重就在七成以上，2002-03球季的數據雖然稍降，但也有65.5%的出手比重是在兩側底角。同樣的情況也發生在Walter McCarty身上，2002-03球季有50.4%的出手在兩側底角，這個策略讓塞爾提克能夠利用雙槍的切入破壞力製造外圍空檔，也能夠讓進攻能力較弱的防守組球員在場上能利用較短三分距離有了牽制效果，讓對手不能肆意的內縮防線包夾雙槍。</p>
<p><img data-src="/images/nba3.png" alt="抱光妹" title="2002-2003马刺的三分出手点"><br>（註）馬刺隊的數字是因為Bruce Bowen有79.3%的三分球出手都在角落，一個人就出手超過一百八十次。</p>
<p>因此，帳面上看塞爾提克的天份在雙槍之後有明顯的落差，但這支球隊卻能夠很有效率的贏球。2002-03球季戰績之所以不進反退，一個極大的原因是Paul Gaston為了規避豪華稅且讓球隊賣相好看而刻意控制薪資，因此讓成為自由球員的Rodney Rogers以微幅增加的三年九百萬美金合約轉投死敵籃網隊。這筆薪水如果加上豪華稅將讓Gaston付出接近兩千萬美金，使得他堅持不肯放行。</p>
<p>Rodney Rogers的重要性在於他是塞爾提克攻守兩端所缺乏的關鍵人物。雖然資料上名列前鋒，但六呎七吋有235磅重的他能夠在防守時對抗對手的大前鋒甚至中鋒，進攻端更因為他每場出手3.5次命中率高達41.1%的三分球，讓對手不得不將長人拉至外圍防守Rogers，因此成了O’Brien調度上的活棋。</p>
<p>換言之，在2001-02球季O’Brien在交易大限換入Rogers後，O’Brien就已經當現今最熱門的衍生四號甚至外線中鋒的概念運用在Rogers身上，Walker、Pierce、Williams搭配Rogers，或是將Williams換成McCarty的四小前鋒是O’Brien即常使用的陣容，這也是當年O’Brien跨越時代的戰術思維。</p>
<p>換入Rogers後，塞爾提克的勝率從原本的56.3%攀升至66.7%，只差一勝就跨入五十勝俱樂部，少了Rogers讓O’Brien的攻守體系缺了一角，而在當年，這樣能夠投三分又能夠扛住對手中鋒的替代品幾乎沒有。</p>
<p>當Ainge確定接手，拆解陣容就成了時間早晚的問題。除了原本就對塞爾提克的打法與組隊方式非常有意見外，球隊薪資已經因為雙槍的兩張頂薪合約而捉襟見肘也是另一個因素。</p>
<p>交易1：<strong>送出Daris Songaila从国王得到Bandon Hunter和Orien Greene</strong></p>
<p>Ainge在五月九日第三戰時上任，很快的就在一個多月後的選秀會上大展身手。Ainge用2002年第50順位的Darius Songalia為籌碼向國王隊換來2003年與2005年的兩個二輪選秀。這筆交易據稱是Songalia的經紀人Mark Bartelstein拜託Ainge把自己客戶交易到有較多上場機會的球隊，只是當時的國王隊正當盛年，特別是前場的深度與高度俱佳，實在很難讓人信服Songalia能有更好的機會。</p>
<p>Songalia獲選後在夏季聯盟登場時展現了相當好的球賽解讀能力，以及非常靈巧的雙手，因此儘管體能遠遠不及NBA水準，接下來幾年一直都是堪用替補。</p>
<p>幾天後的選秀會上，Ainge用剛交易來的第二輪第56順位選了他選秀生涯最愛的類型：六呎七吋260磅重的矮胖型長人Brandon Hunter，但Hunter也跟大多數他選的矮胖型長人一樣沒有太多作用。而2005年的二輪成了第53順位，Ainge挑選了六呎四吋的得分後衛Orien Greene，只打了一年就被揮棄。</p>
<p>Ainge用生涯出賽495場平均6.9分、3.4籃板的堪用替補，換了兩個福袋。</p>
<p>交易2：<strong>送出Troy Bell和Dahntay Jones从灰熊得到Marcus Banks和Kendrick Perkins</strong></p>
<p>這筆交易只是Ainge瘋狂交易的開端，選秀會上他又用第16順位的Troy Bell與第20順位的Dahntay Jones跟前灰熊隊交換了第13順位的Marcus Banks與第27順位的Kendrick Perkins。這筆交易引起不少反彈，因為Bell是本地Boston College出品的後衛，是BC隊史上的得分王，不過只出賽六場就從聯盟中消失。Jones雖然沒有太突出表現，但至少在聯盟裡打滾了十三個球季，2015-16在騎士隊拿到了一枚戒指。</p>
<p>Banks是Ainge非常喜愛的控衛類型，六呎二吋高的小後衛，沒有外線可言，速度飛快，往後每幾年他就會在選秀會上挑上一個或交易來一個，近期的代表人物是Demetrius Jackson。</p>
<p>選秀後Banks參加了暑假在UMass Boston舉行的Shaw’s夏季聯盟。UMass Boston的校區在波士頓南邊，突出在大西洋中的小半島，校園裡的甘迺迪總統圖書館襯映著大西洋在炎夏下極美。當時UMass Boston的體育館是一般小型學校的規模，座椅是從兩側拉出來的活動式座椅，兩年的經驗累積下來習慣坐在第二或第三層的位置，這位置大致就是球員眼睛高度左右，可以清楚看到球員切入後眼光的移動，是判斷球員場上閱讀能力最好的角度。第一場只見場上的Banks速度飛快但運球不甚靈光，因此快速推進時得要聚精會神地盯住球瘋狂地往前快跑，也導致當他快速移動時的視角極窄，幾乎只有正前方的傳球視角，看完一場之後就知道這個第13順位打注定要打水漂。</p>
<p>Banks從來沒有成為Ainge口中的控球後衛，在2006年成為交易中的配菜，只在隊史留下5.3分、2.0助攻完全不及格的成績。</p>
<p>Perkins應該是交易裡知名度最高的球員，在今年的諸多紛擾裡是對Irving最不假辭色的退休球員，他是2014-15球季Irving在騎士隊的隊友。雖然是末代高中棄學生，Perkins是少數近乎沒有進攻技巧的高中棄學生，生涯前兩個球季幾乎沒有上場機會。身體十分鈍重，直到第三個球季才逐漸開竅，最後在Garnett入隊後成為禁區的防守核心。</p>
<p>也許，可以說Perkins救了這筆交易，但這筆交易最可悲的地方也在於Perkins救了這筆交易。</p>
<p>交易3：<strong>送出JR Bremer、Bruno Sundov和Ryan Gomes从骑士队得到了Jumaine Jones</strong></p>
<p>一個月後，Ainge又做出了另一筆交易，將六月底剛轉換為保證約的第二年控衛J.R. Bremer與六月底選擇執行球員選擇權的替補中鋒Bruno Sundov以及2005年第二輪打包送往騎士隊，用先簽後換的方式換回了小前鋒Jumaine Jones。Jones在騎士的兩個球季有9.0分、5.6籃板，被認為能升級塞爾提克在鋒線的深度，但在入隊後Jones卻沒有辦法獲得出場時間，只上場42場，留下2.2分、1.6籃板就在隔年被送往湖人隊。</p>
<p>Bremer是總管Chris Wallace在沙裡掏金的結果。出身St. Bonaventure University，大四有24.6分與3.1助攻，雖然在2002年選秀會上未受青睞，但在Shaw’s裡以大膽投射與防守贏得球隊青睞，成功入隊。開季後從替補打起，由於塞爾提克此時的控衛工作相對單純，運過半場後就交由雙槍處理，主要工作是擔任外圍接應的狙擊手，勇於出手的Bremer因此有許多發揮空間，更在一月取代老將Tony Delk成為球隊的先發控球，直到季末為了準備季後賽才再度由Delk先發。擔任先發的41場比賽裡Bremer有平均11.2分、3.5助攻的成績，同時有37.2%的三分球命中率。</p>
<p>Sundov是小牛隊1998年選秀會第二輪第35順位，七呎二吋的瘦長型克羅埃西亞中鋒。高中在麻州就讀，一直被認為是有潛力的攻擊型長人，但生涯前四年沒有太多表現機會，因此2002年暑假被Wallace以底薪簽下，但在26場比賽裡也只交出1.2分、1.1籃板的成績。</p>
<p>交易4：<strong>送出Antoine Walker和Tony Delk从小牛队得到Raef LaFrentz、Chris Mills、Jiri Welsch和Delonte West</strong></p>
<p>Ainge接掌球隊後所有媒體最關注的就是主將Walker的去留，接手一周Ainge就約談Walker討論未來合作。結束後Ainge對媒體說著：「我跟Walker談過，並告訴他我對他在這個暑假的期望，以及對新球季訓練營前的準備，這就是我們的計劃，繼續邁步向前。」</p>
<p>只是這個保證並沒有持續太久，10月20日，塞爾提克突然宣布將Walker、Delk打包送往小牛隊交換Pierce的大學隊友Raef LaFrentz，一對搖擺人Chris Mills與Jiri Welsch以及2004年的首輪選秀權。這筆交易幾乎毫無預警，因為前一天環球報隨隊記者Shira Springer還煞有其事地認真討論著塞爾提克開季的球員陣容，而Walker是她筆下的篤定人選。</p>
<p>交易一出，波士頓環球報的神級專欄作家傾巢而出。由最資深也是知名Walker厭惡者Bob Ryan寫體育版刊頭，包括現在還在執筆的Jackie MacMullan、長年隨隊記者Peter May與現役隨隊記者Springer都寫了文章討論。帳面上Ainge的理由是不久後即將成為自由球員的Walker在延長合約談判上堅不讓步，高達一千六百萬美金的頂薪年薪讓球團無力負擔，又擔心會在未來失去他而一無所有，於是做出了交易的抉擇。</p>
<p>看過這個，應該就不會意外Ainge如何處理Isaiah Thomas。</p>
<p>Delk是Walker的肯大隊友，也是聯盟有名的板凳好手，在前主控Kenny Anderson離隊後就是塞爾提克實際上的控球後衛。在塞爾提克兩季裡Delk練出了一手穩定的三分球，成為重要的外線射手，有39.5%的三分準度，同時一雙長臂也是球隊重要的後場防守者。</p>
<p>小牛隊提出的包裹裡，Mills曾經在1997年暑假與Pitino簽下合約，但球季還沒開打就被打包送往尼克隊交換包含McCarty在內的包裹。這次再度重返波士頓沒想到歷史又再度重演，因為受傷一直無法上場的Mills在隔年交易大限時又被放上交易桌上，數據上連一場替塞爾提克出賽的紀錄都未曾留下。Ainge利用Mills的六百六十萬美金合約做為幫助其他球隊平衡薪資的重要籌碼，終於在與老鷹、活塞的三方交易中扮演重要角色，讓活塞順利從老鷹處換得Rasheed Wallace，幫助活塞拿下2004年總冠軍。交易中塞爾提克另外送出控衛Mike James，換回另一個近似的控衛Chucky Atkins以及老將Lindsey Hunter與2004年首輪選秀權，James與Atkins這對戰力毫無幫助的互換也讓人開了眼界。</p>
<p>Welsch是相當有靈性的搖擺人，入隊後第一年有9.2分、3.7籃板與2.3助攻的成績，同時有38.1%的三分球命中率。不過2005年的交易大限Welsch又被打包送往騎士隊交換2007年的首輪選秀權。</p>
<p>這筆交易裡的主角LaFrentz是1998年選秀會的第三順位，但生涯卻一直為膝蓋傷勢所苦，始終沒能有所表現。小牛隊在2002年的交易大限換入了LaFrentz，並在球季結束後與他簽下一紙七年七千萬美金的肥約。儘管LaFrentz在小牛隊的一年多裡只有9.7分、5.5籃板的不及格成績，為了賣掉Walker的Ainge還是毅然決然地接手他剩下來六年長約，成了許多人批評的把柄。交易後LaFrentz依然因為膝傷所苦，表現並不穩定，最後終於在12月12日接受膝蓋手術而宣告球季提前結束，生涯在塞爾提克三季只有9.2分、5.8籃板。</p>
<p>面對媒體不斷的詢問Walker的私人恩怨說，Ainge只能不斷的否認，強調時間將會證明一切。不管是真心還是推託之詞，Ainge倒是不能說完全在說謊，因為2005年交易Welsch的同一天，他又將一年多前說毫無續約希望的Walker從老鷹隊給換了回來，目的是替塞爾提克爭取季後賽的機會。就這樣，Walker與LaFrentz一起在季後賽裡出戰，但塞爾提克打滿七場後敗在溜馬隊的手下。</p>
<p>球季結束後，Ainge又再一次將Walker打包以先簽後換的方式送往熱火隊，讓Walker成為第一個拿下冠軍的球員。</p>
<p>看到Walker這樣賣出去又買回來又賣出去，以及LaFrentz的數據，Ainge急於做出這筆交易是不是有個人恩怨也許見仁見智，但賠上了塞爾提克兩個球季這點卻是毫無爭議的事情。</p>
<p>交易5：<strong>送出Tony Battie、Kedrick Brown、Kedrick Brown从骑士队得到Ricky Davis、Chris Mihm、Michael Stewart和Ryan Gomes</strong></p>
<p>送走了Walker讓塞爾提克全隊士氣低迷，也讓全隊更加人心惶惶，誰也不知道自己的明天在哪裡。就在LaFrentz倒下的幾天後，Ainge又再一次做出交易，這次把中鋒Tony Battie、前鋒Williams與體能絕佳的搖擺人Kedrick Brown給送往騎士隊，交換中鋒Chris Mihm、Michael Stewart、搖擺人Ricky Davis與2005年的第二輪選秀權。</p>
<p>這一筆交易等於將塞爾提克上季除了Pierce、McCarty之外的主力正式全部出清，也把在球隊資歷最久的Williams再次推出球隊。</p>
<p>雖然是2000年的第七順位，但Chris Mihm始終只有替補中鋒的資質，球隊的先發中鋒依然是1997年第57順位由超音速所選，但在小聯盟裡浮沉三年，直到2000年才被塞爾提克看上帶入NBA的Mark Blount擔綱。</p>
<p>Michael Stewart綽號Yogi (Bear)，是六呎十吋的火鍋中鋒，但菜鳥球季在國王繳出4.6分、2.4阻攻之後就因為毫無節制的犯規而被各隊冷凍。在塞爾提克的一季裡只有平均0.3分、0.1阻攻的成績，0.8次的犯規換算成36分鐘將高達6.6次，一年後就從聯盟中消失。</p>
<p>這次交易中的主角Davis可說是Ainge早期交易史裡少數成功的球員，三個球季中留下16.2分、3.7籃板與3.4助攻，成為這幾個球季裡Pierce最主要的助拳者。2002-03球季Davis在幾乎無人的騎士隊裡成為第一主將，在有大量出手機會下繳出平均20.6分、4.9籃板與5.5助攻的全方位成績（Jones也是在這季打出成績）。只是在LeBron James入隊後，Davis就成了礙眼的存在，最後成了騎士隊出清的對象。Davis有得分能力也有外線準度，防守的態度也比在騎士隊時好上許多，但他始終不是一個能夠幫助球隊更上層樓的球員，各方面雜而不精，也因為功能與Pierce重疊性遠高於Walker，讓他的發揮空間受到壓縮。</p>
<p>2006年一月底Davis又跟Blount、Banks一起被打包送往灰狼隊，交換1998年狀元Michael Olowokandi、Wally Szczerbiak、Dwayne Jones與2009首輪選秀權。</p>
<p>1998年選秀會上的兩大長人Olowokandi與LaFrentz都在Ainge主政下來到了塞爾提克，但結果卻與選秀會上同樣悲慘。</p>
<p>塞爾提克送出的Williams是1995年首輪第14順位的新秀，跟1996年第六順位的Walker是一起度過黑暗歲月的夥伴，也是Walker在球隊裡最好的朋友。年輕時是宛如豺狼般的蠻幹型小前鋒，受傷後失去爆發力導致進攻能力大幅衰退，但原本不在意防守的他卻專注在防守上，負責防守對手最難纏的搖擺人，讓雙槍能夠減輕防守負擔，是個工作態度與團隊精神俱佳的自家球員。</p>
<p>經過這幾年，也該知道Ainge最不在乎的就是這些非關天賦的正面特質。</p>
<p>Williams是Walker最好的朋友，而Battie則是Pierce最好的朋友。當Pierce在2001年開季前於Buzz Club遇刺時，緊急抱著Pierce穿過Stuart Street到對街的新英格蘭醫療中心求助，保住Pierce一命的隊友正是Battie。</p>
<p>Buzz Club的位置在中國城與劇院區之間，雖然出事後沒多久Buzz Club就已經歇業，但原址一直都在經營夜店或是酒吧，並不是外界想像的是非之地。十多年前習慣將車停在Buzz Club旁大空地開設的停車場，每天那裏就不斷的玩著大型移車遊戲，現在停車場已經杳無蹤跡成了高樓大廈，但夜店依舊在。</p>
<p>Battie是1997年第五順位，1998-99球季開始前被賣到塞爾提克交換被Pitino打入冷宮的中鋒Travis Knight。Battie有六呎十一吋高230磅重，瘦長的體型讓他的防守能力一直被外界所忽略，但他在塞爾提克的生涯裡有平均1.1次的阻攻，是塞爾提克賴以為生的防守核心。O’Brien接手後特別替Battie設計一套在前防守的系統，利用他的一雙長手臂來騷擾對手後衛將球送往禁區的路徑。如果對手將球轉移到側翼，Battie可以利用自身敏捷性繼續保持在前防守，或是立刻轉換成傳統的防守位置。這一套防守有效的箝制對手將球送到中鋒的機會，再搭配Walker在後方的包夾，就曾經成功地限制住湖人隊當家中鋒Shaq O’Neal在禁區的威脅力。</p>
<p>跟受傷後的Williams或是沒有驚人天賦的Battie不同，2001年第11順位的Kedrick Brown則有讓人過目不忘的驚人天賦，那兩年在Shaw’s裡Brown幾乎快超過籃框的實戰扣籃動作至今依然震撼。但Brown始終沒有辦法把自己的天賦幻化成實際數據，二年制學院出身而成為樂透新秀的他缺少如Pierce一般苦練而來的下球技巧，這讓他無法利用切入來發揮自己的體能天賦，也沒有發展出足夠穩定的三分投射能力，加上個性缺少在NBA成功所必需的強大企圖心，讓他一直都沒能達到天賦體能所該有的表現，這也讓他在離隊後不久就從NBA消失。</p>
<p>Ainge主政下最糟糕的一點是2003年暑假剛開始，塞爾提克就製作了Tony Delk、Tony Battie的非正式版球衣，然後某些通路還買得到Kendrick Brown的球衣，買了之後，這些球員就通通被賣掉，於是通路賣不掉的球衣就瘋狂大拍賣。</p>
<p>連這都要坑殺球迷。</p>
<h2 id="交易後的塞爾提克真的有不平庸？"><a href="#交易後的塞爾提克真的有不平庸？" class="headerlink" title="交易後的塞爾提克真的有不平庸？"></a>交易後的塞爾提克真的有不平庸？</h2><p>Ainger接手後改變了這個球隊的諸多面向，這一季塞爾提克的三分球出手數陡降至1599次，總教練O’Brien在季中終於難以忍受而宣布辭職，塞爾提克在代理總教練John Carroll努力團結球員下勉強以東區第八打入季後賽，但被Larry Bird擔任總管，Rick Carlisle擔任總教練的溜馬隊輕鬆橫掃出局。</p>
<p>那幾年的塞爾提克除了大量的三分球外，最著名的就是瘋狂不要命的防守態度，Williams、Battie、McCarty、Delk等防守組球員正是執行這套防守的核心人物，也是塞爾提克能夠逆勢獲勝的關鍵。</p>
<p>經過這幾年，也該知道Ainge對這些與天賦無關的事情一點也不在乎。</p>
<p>從五月九日上任到十二月十五日，Ainge花了七個多月的時間就送走了上一季名單中的七名球員，讓這隻曾經打入2002年東區冠軍賽的塞爾提克完全崩解，留在名單中的Vin Baker因為酗酒問題而在2004年二月被球隊解約，Tommy Heinsohn的愛將McCarty則在2005年交易大限前被送往太陽隊交換2007年的第二輪選秀權，被好友形容是被遺忘在孤島上的Pierce則熬過了地獄般的重建歲月拿下2008年總冠軍，但也在2013年被賣往籃網隊。</p>
<p>這七個月的跳樓大拍賣裡包含選秀會共有五筆交易，Ainge送出了十位球員與一枚二輪選秀權，收進了十一位球員、兩枚首輪與三枚二輪選秀權，已經展露出他喜歡收集選秀權的習性。在Ainge送出的十位球員裡有入選明星賽的Walker與球隊主力Delk、Williams、Battie以及年輕的Bremer，換進來的球員除了Davis外只有Welsch勉強對球隊有些助益。</p>
<p>這五筆交易後，Ainge在接下來到2007年選秀會交易Ray Allen前又發動了十二筆交易，不斷的將手上的球員洗成另一批球員，雖然因此累積了許多爛合約作為交易的資產，也累積了許多選秀權幻化為新秀，也讓這些年輕球員累積了許多壞習慣，導致塞爾提克的戰績不斷下滑，2006-07球季僅有24勝58敗，讓好不容易走出九零年代中黑暗時期的球迷又墜入無底深淵之中，也讓Pierce終於決定向球隊發出最後通牒，也才在2007年暑假有GAP的誕生。</p>
<p>這七個月的時間裡，展現了Ainge的許多特質，例如不計代價地送走自家球員，這在2013年拍賣GAP之後也有相同的舉動，只是這次Ainge很幸運地在大拍賣中分別與2014與2015年換到了Jae Crowder與Isaiah Thomas，並用他們帶領著一批浪人打入季後賽，再吸引Al Horford加盟終於再次打入東區冠軍賽。</p>
<p>但就像2002年的塞爾提克，奮戰不懈的態度與打死不退的防守在Ainge與老闆群的眼裡完全無法與天賦相提並論，最後終於參與許多人口中「就算再一百次也會選擇交易」的捨Thomas、Crowder就Irving的交易。</p>
<p>另一個不同處是Ainge對於自己挑選的球員有相當偏好，因此2003年的重建中毫無顧忌地拍賣除了Pierce之外的球員，而2017年則送走了自己在交易中挖掘的Thomas與Crowder，而留下自己挑選的Jaylen Brown、Jayson Tatum等年輕球員。</p>
<p>2003與2017的塞爾提克如果沒有拆散是否能拿下總冠軍？這問題誰也沒有答案，只能說如果留下核心繼續努力，也許有一拚的機會。當時絕大多數人都覺得這兩支球隊完全沒有機會，但這些人中又有一部分覺得有了Irving之後就有機會至少打入總冠軍賽。歷史打了這些人兩次巴掌，第一次是Irving、Gordon Hayward受傷後反而再次打入東區冠軍賽直到第七戰才落敗。第二次則是有了健康的Irving反而讓球隊分崩離析，不但離總冠軍更為遙遠，還成為眾人的笑柄。</p>
<p>也許關鍵就在對核心的認知，2017年與2018年兩度打入東區冠軍的原因不是因為Tatum或是Brown或是Horford，而是Thomas與Crowder入隊後帶給這支球隊的態度，打死不退的防守與永遠不放棄的精神，讓所有球員緊緊的團結在一起。而Ainge與背後的老闆們則認為關鍵因素在自己的眼光挑選了Tatum、Brown等人，因此一貫認為更高的天分與更多的明星就能打造出真正的冠軍球隊，而放任Irving恣意而為，最後摧毀了球隊。</p>
<p>兩年過去了，牆倒眾人推，Irving已經成了媒體棄兒，大多數人都已經忘了自己當時對這筆交易的喜悅以及本能覺得身高、天賦就是一切的迷思，當然，更沒有多少人記得十七年前那一連串交易所造成的夢靨。</p>
<h2 id="Ainge與Auerbach的差異"><a href="#Ainge與Auerbach的差異" class="headerlink" title="Ainge與Auerbach的差異"></a>Ainge與Auerbach的差異</h2><p><img data-src="/images/nba4.png" alt="抱光妹"><br>Hoop雜誌最後的2019年六月號裡，紀念John Havlicek的文章最後引用了Hondo自傳裡對1976年冠軍隊的描述，這不僅說明了為何Auerbach執政時期的塞爾提克即使又老又傷還是能夠笑傲江湖，也說明了為何有數位頂薪球員又有滿滿天賦的2019塞爾提克最後會落得樹倒猢猻散的下場。</p>
<p>「塞爾提克又再次拿下冠軍，我很確信聯盟裡很多球員不懂為何我們能屢屢奪冠，1975-76球季的塞爾提克是隊史上最脆弱的一隊，也是那四年裡最不強勢的一隊，卻拿下最後勝利。我們的紙上陣容不是聯盟最佳，而是由一群角色球員所組成的球隊，然而，在季後賽裡我們每個人都非常有效的扮演自己的角色。」</p>
<p>謹以此文，替這些年劃下一個句點。</p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>nba</tag>
      </tags>
  </entry>
  <entry>
    <title>通过阿里云服务器ID添加服务器资料到django的脚本</title>
    <url>/2018/05/07/%E9%80%9A%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8ID%E6%B7%BB%E5%8A%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B5%84%E6%96%99%E5%88%B0django%E7%9A%84%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>本文的环境是：<code>centos 7</code> + <code>django 2.0</code> + <code>python 3.6</code></p>
<p>先给django里的project创建了<code>models.py</code>，里面内容如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.<span class="property">db</span> <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"># <span class="title class_">Create</span> your models here.</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ecs</span>(models.<span class="property">Model</span>):</span><br><span class="line">    name = models.<span class="title class_">CharField</span>(verbose_name=<span class="string">&#x27;云服务器名称&#x27;</span>,max_length=<span class="number">30</span>)</span><br><span class="line">    ecsid = models.<span class="title class_">CharField</span>(verbose_name=<span class="string">&#x27;云服务器ID&#x27;</span>,max_length=<span class="number">30</span>,<span class="keyword">default</span>=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    inIP = models.<span class="title class_">GenericIPAddressField</span>(verbose_name=<span class="string">&#x27;云服务器内网地址&#x27;</span>)</span><br><span class="line">    outIP = models.<span class="title class_">GenericIPAddressField</span>(verbose_name=<span class="string">&#x27;云服务器外网地址&#x27;</span>)</span><br><span class="line">    osname = models.<span class="title class_">CharField</span>(verbose_name=<span class="string">&#x27;操作系统&#x27;</span>,max_length=<span class="number">50</span>,<span class="keyword">default</span>=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    networktype = models.<span class="title class_">CharField</span>(verbose_name=<span class="string">&#x27;网络类型&#x27;</span>,max_length=<span class="number">20</span>)</span><br><span class="line">    <span class="variable constant_">CPU</span> = models.<span class="title class_">IntegerField</span>(verbose_name=<span class="string">&#x27;云服务器CPU&#x27;</span>,<span class="keyword">default</span>=<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    memory = models.<span class="title class_">IntegerField</span>(verbose_name=<span class="string">&#x27;云服务器内存&#x27;</span>,<span class="keyword">default</span>=<span class="string">&#x27;2048&#x27;</span>)</span><br><span class="line">    netwidth = models.<span class="title class_">IntegerField</span>(verbose_name=<span class="string">&#x27;云服务器外网带宽&#x27;</span>,<span class="keyword">default</span>=<span class="string">&#x27;0M&#x27;</span>)</span><br><span class="line">    signtime = models.<span class="title class_">DateField</span>(auto_now_add=<span class="title class_">True</span>)</span><br><span class="line">    remark = models.<span class="title class_">CharField</span>(verbose_name=<span class="string">&#x27;备注&#x27;</span>,max_length=<span class="number">255</span>,blank=<span class="title class_">True</span>)</span><br></pre></td></tr></table></figure></p>
<p>可以看出这个就是一个很简单的云服务器的配置统计，但是要录入的阿里云服务器很多，一个一个手动输入实在太累，于是就要写一个脚本来达到django同步的效果！</p>
<p>脚本内容如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/usr/</span>bin/env python</span><br><span class="line">#coding=utf-<span class="number">8</span></span><br><span class="line">#这个脚本通过查询阿里云服务器<span class="variable constant_">ID</span>来达到同步django的目的</span><br><span class="line"><span class="keyword">import</span> json,pymysql</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore <span class="keyword">import</span> client</span><br><span class="line"><span class="keyword">from</span> aliyunsdkecs.<span class="property">request</span>.<span class="property">v20140526</span> <span class="keyword">import</span> <span class="title class_">DescribeInstancesRequest</span></span><br><span class="line"></span><br><span class="line">clt = client.<span class="title class_">AcsClient</span>(<span class="string">&#x27;这里是ak&#x27;</span>,<span class="string">&#x27;这里是sk&#x27;</span>,<span class="string">&#x27;这里是地域名&#x27;</span>)</span><br><span class="line"></span><br><span class="line"># 设置参数</span><br><span class="line">request = <span class="title class_">DescribeInstancesRequest</span>.<span class="title class_">DescribeInstancesRequest</span>()</span><br><span class="line">request.<span class="title function_">set_accept_format</span>(<span class="string">&#x27;json&#x27;</span>)</span><br><span class="line"></span><br><span class="line">request.<span class="title function_">add_query_param</span>(<span class="string">&#x27;RegionId&#x27;</span>, <span class="string">&#x27;cn-hangzhou&#x27;</span>)</span><br><span class="line">request.<span class="title function_">add_query_param</span>(<span class="string">&#x27;InstanceIds&#x27;</span>, [<span class="string">&#x27;这里是服务器ID&#x27;</span>])	#如果是多个服务器<span class="variable constant_">ID</span>，可以继续往下写</span><br><span class="line"></span><br><span class="line"># 发起请求</span><br><span class="line">response = clt.<span class="title function_">do_action</span>(request)</span><br><span class="line"></span><br><span class="line">#<span class="title function_">print</span>(response)	#这里可以看一下返回的response，但是它是byte格式的</span><br><span class="line">data=<span class="title function_">str</span>(response, encoding = <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">ecs = json.<span class="title function_">loads</span>(data)	#转换成str格式</span><br><span class="line">name = <span class="title function_">str</span>(ecs[<span class="string">&#x27;Instances&#x27;</span>][<span class="string">&#x27;Instance&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;InstanceName&#x27;</span>])</span><br><span class="line">ecsid = <span class="title function_">str</span>(ecs[<span class="string">&#x27;Instances&#x27;</span>][<span class="string">&#x27;Instance&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;InstanceId&#x27;</span>])</span><br><span class="line">inIP = <span class="title function_">str</span>(ecs[<span class="string">&#x27;Instances&#x27;</span>][<span class="string">&#x27;Instance&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;VpcAttributes&#x27;</span>][<span class="string">&#x27;PrivateIpAddress&#x27;</span>][<span class="string">&#x27;IpAddress&#x27;</span>])[<span class="number">1</span>:-<span class="number">1</span>]	#如果不加[<span class="number">1</span>:-<span class="number">1</span>]的话，得到的是一个<span class="variable constant_">IP</span>外面还有中括号</span><br><span class="line">outIP = <span class="title function_">str</span>(ecs[<span class="string">&#x27;Instances&#x27;</span>][<span class="string">&#x27;Instance&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;PublicIpAddress&#x27;</span>][<span class="string">&#x27;IpAddress&#x27;</span>])[<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line">networktype = <span class="title function_">str</span>(ecs[<span class="string">&#x27;Instances&#x27;</span>][<span class="string">&#x27;Instance&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;InstanceNetworkType&#x27;</span>])</span><br><span class="line"><span class="variable constant_">CPU</span> = <span class="title function_">int</span>(ecs[<span class="string">&#x27;Instances&#x27;</span>][<span class="string">&#x27;Instance&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;Cpu&#x27;</span>])</span><br><span class="line">memory = <span class="title function_">int</span>(ecs[<span class="string">&#x27;Instances&#x27;</span>][<span class="string">&#x27;Instance&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;Memory&#x27;</span>])</span><br><span class="line">osname = <span class="title function_">str</span>(ecs[<span class="string">&#x27;Instances&#x27;</span>][<span class="string">&#x27;Instance&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;OSName&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#创建数据库连接，注意这里我加入了charset和cursorclass参数</span><br><span class="line">conn = pymysql.<span class="title function_">connect</span>(</span><br><span class="line">    host = <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">    user = <span class="string">&quot;数据库账号&quot;</span>,</span><br><span class="line">    password = <span class="string">&quot;数据库密码&quot;</span>,</span><br><span class="line">    database = <span class="string">&quot;数据库名称&quot;</span>,</span><br><span class="line">    charset = <span class="string">&#x27;utf8&#x27;</span>,</span><br><span class="line">    cursorclass = pymysql.<span class="property">cursors</span>.<span class="property">DictCursor</span>)</span><br><span class="line">#获取游标</span><br><span class="line">cursor = conn.<span class="title function_">cursor</span>()</span><br><span class="line"></span><br><span class="line">#三个引号里如何加入变量</span><br><span class="line">sql = <span class="string">&quot;&quot;</span><span class="string">&quot;INSERT INTO ecs_ecs (name,ecsid,inIP,outIP,networktype,CPU,memory,netwidth,signtime,osname) VALUES (%(name)s,%(ecsid)s,%(inIP)s,%(outIP)s,%(networktype)s,%(CPU)d,%(memory)d,%(netwidth)d,NOW(),%(osname)s);&quot;</span><span class="string">&quot;&quot;</span> % <span class="title function_">dict</span>(name=<span class="string">&#x27;\&#x27;&#x27;</span>+name+<span class="string">&#x27;\&#x27;&#x27;</span>,ecsid= <span class="string">&#x27;\&#x27;&#x27;</span>+ecsid+<span class="string">&#x27;\&#x27;&#x27;</span>,inIP=inIP,outIP=outIP,networktype=<span class="string">&#x27;\&#x27;&#x27;</span>+networktype+<span class="string">&#x27;\&#x27;&#x27;</span>,<span class="variable constant_">CPU</span>=<span class="variable constant_">CPU</span>,memory=memory,netwidth=<span class="number">1</span>,osname=<span class="string">&#x27;\&#x27;&#x27;</span>+osname+<span class="string">&#x27;\&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">#<span class="title function_">print</span> (sql)	#在这里可以先看看sql输出的是否正确</span><br><span class="line">cursor.<span class="title function_">execute</span>(sql)</span><br><span class="line"></span><br><span class="line"># 关闭数据库连接</span><br><span class="line">conn.<span class="title function_">close</span>()</span><br></pre></td></tr></table></figure></p>
<p>正常来说应该是先建立一个def来获取阿里云服务器配置，再来一个def来将各配置录入到数据库里，同时让阿里云服务器的id作为变量，而且还要加上如果sql执行失败就回滚的语句。而我由于是临时使用，所以这个脚本按照流水式写下来的，不过不影响阅读。</p>
<p>ps.进化之后的脚本在我的github里，地址是： <a href="https://github.com/RorschachChan/chenWORK/blob/master/%E9%80%9A%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91ID%E5%8F%B7%E5%B0%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BF%A1%E6%81%AF%E5%90%8C%E6%AD%A5%E5%88%B0django.py">https://github.com/RorschachChan/chenWORK/blob/master/通过阿里云ID号将服务器信息同步到django.py</a></p>
<p>比如现在要添加一个服务器，这个服务器的id是：<code>i-bp12ego6x9srzsytxeqo</code>，如图：<br><img data-src="/images/django3.png" alt="akb48"></p>
<p>那么对应填写好脚本里的ak&#x2F;sk之后，就把<code>i-bp12ego6x9srzsytxeqo</code>填写到“服务器ID”的位置 ，执行这个脚本，结果如下：<br><img data-src="/images/django5.png" alt="akb48"></p>
<p>不过这个脚本有两个缺点：<br>第一：如果阿里云服务器是中文名称，那么使用api查询出现的是十六进制的符号；<br>第二：如果服务器里没有外网IP或者是后开的临时带宽，那么在outIP的地方得到的值是空，sql语句会因为少一项而报错；<br>第三：这个api没有查询服务器带宽值的功能，还需要另外写一个脚本搭配。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>python3</tag>
        <tag>django2</tag>
      </tags>
  </entry>
  <entry>
    <title>镜像打包Dockerfile文件常见规范问题</title>
    <url>/2023/06/25/%E9%95%9C%E5%83%8F%E6%89%93%E5%8C%85Dockerfile%E6%96%87%E4%BB%B6%E5%B8%B8%E8%A7%81%E8%A7%84%E8%8C%83%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>修改dockerfile主要影响镜像的打包方式，一般并不会影响应用的实际运行（调整后例如使用mini镜像导致组件依赖缺失等环境问题除外，这部分可以通过添加组件依赖解决）。</p>
<p>本文的目的就是展示在工作中遇到的dockerfile经常出现的一些不规范的地方以及具体的可优化点。</p>
<p>优化调整不规范dockerfile文件的主要好处：<br>       a. 减少应用构建时的镜像打包耗时（减少镜像的更新层数）<br>       b. 缩小应用镜像的包大小，提升应用部署时的镜像拉取速度（减少镜像层数以及清理无用的安装包缓存）</p>
<h2 id="分类问题总结"><a href="#分类问题总结" class="headerlink" title="分类问题总结"></a>分类问题总结</h2><h3 id="RUN-yum指令后应以yum-clean-all收尾"><a href="#RUN-yum指令后应以yum-clean-all收尾" class="headerlink" title="RUN yum指令后应以yum clean all收尾"></a>RUN yum指令后应以yum clean all收尾</h3><p>【原因】一些应用需要通过yum指令安装依赖的组件，在使用yum指令之后没有在最后使用<code>yum clean all</code>进行安装包缓存的清理，这会使最终的镜像包包含无用的安装包文件增加了镜像包的大小</p>
<p>【解决方案】在所有yum指令的最后增加一条<code>yum clean all</code></p>
<p>【收益】根据实际安装包的大小获得相应的容量缩减收益</p>
<p>例如：<br><img data-src="/images/dockerfile1.png" alt="paradin" title="平常时候不增加惯了"><br>调整后：<br><img data-src="/images/dockerfile2.png" alt="paradin" title="增加clean all，清理安装包缓存"></p>
<h3 id="RUN-yum或RUN-rpm指令应在COPY指令之前"><a href="#RUN-yum或RUN-rpm指令应在COPY指令之前" class="headerlink" title="RUN yum或RUN rpm指令应在COPY指令之前"></a>RUN yum或RUN rpm指令应在COPY指令之前</h3><p>【原因】目前大部分应用镜像出现该规范问题主要是在copy应用主包之后，使用RUN指令进行应用包的解包操作，以及部分应用将新增的组件安装等指令直接在copy应用主包之后添加</p>
<p>【解决方案】对于新增的组件安装等指令迁移至前面统一的RUN指令里，通过&amp;&amp;实现同类型或类似变化频率的指令在同一个RUN层。对于对应用包解包操作需要根据应用自身需求确定是否可以移除（可以检查应用启动文件是否存在检查应用包并解包的脚本，如果存在则可以放心的在dockerfile移除主包解压指令，同时当前各应用的主包压缩模式小文件存在情况很少，所以对应用的首次启动耗时不会带来影响。从目前收集的几个应用看均可移除该指令）。</p>
<p>【收益】a. 减少镜像分层，获得分层聚合带来的容量缩减收益<br>     b. 应用解压后占用的容量缩减收益<br>     c. 降低镜像构建耗时，特别当使用yum指令用于安装依赖组件时，可以得到较高的耗时优化收益</p>
<h3 id="不应该超过3条连续RUN命令-Dockerfile指令不应超过20条"><a href="#不应该超过3条连续RUN命令-Dockerfile指令不应超过20条" class="headerlink" title="不应该超过3条连续RUN命令&#x2F;Dockerfile指令不应超过20条"></a>不应该超过3条连续RUN命令&#x2F;Dockerfile指令不应超过20条</h3><p>【原因】一些应用为了添加应用的依赖组件或环境配置，并没有把相同类型或变化频率的指令集中在一个RUN层，而是为每一个sh指令配置RUN指令。一条RUN指令会对应一个镜像分层，过多的RUN指令会导致最终的镜像容量变大。</p>
<p>【解决方案】以动静分离原则，采用不变更指令、偶尔变更指令、频繁变更指令设计尽量将少RUN指令，根据依赖关系和变化频率将各sh指令分配至对应的RUN层，以&amp;&amp;分割符实现批量指令配置</p>
<p>【收益】降低镜像层变更同步的影响，提升镜像构建的push同步速度，同时因镜像层数减少带来部分容量缩减的收益</p>
<h3 id="base镜像体积不应超过2G，能用最小的基础镜像就用最小的，这个不多说了"><a href="#base镜像体积不应超过2G，能用最小的基础镜像就用最小的，这个不多说了" class="headerlink" title="base镜像体积不应超过2G，能用最小的基础镜像就用最小的，这个不多说了"></a>base镜像体积不应超过2G，能用最小的基础镜像就用最小的，这个不多说了</h3><h3 id="CMD-ENTRYPOINT-EXPOSE-LABEL指令位置应在COPY-RUN之前"><a href="#CMD-ENTRYPOINT-EXPOSE-LABEL指令位置应在COPY-RUN之前" class="headerlink" title="CMD&#x2F;ENTRYPOINT&#x2F;EXPOSE&#x2F;LABEL指令位置应在COPY&#x2F;RUN之前"></a>CMD&#x2F;ENTRYPOINT&#x2F;EXPOSE&#x2F;LABEL指令位置应在COPY&#x2F;RUN之前</h3><p>【原因】一般ENTRYPOINT基本上是固定不变的，所以放在COPY&#x2F;RUN之前可以减少因COPY&#x2F;RUN层变动导致分层缓存失效而被动重新构建分层<br>【解决方案】将ENTRYPOINT指令放在所有的COPY&#x2F;RUN之前即可<br>【收益】目前ENTRYPOINT指令用于指定应用启动目录，因此实际对镜像影响很小，所以调整后对当前镜像大小和构建时长没有什么影响，仅用于满足集团dockerfile的执行规范</p>
<h3 id="存在部分重复的配置指令"><a href="#存在部分重复的配置指令" class="headerlink" title="存在部分重复的配置指令"></a>存在部分重复的配置指令</h3><p>【解决方案】部分dockerfile配置存在重复指令的情况，特别是ENV配置，需要将ENV配置集中在一条ENV指令中减少镜像层数，同时去除不必要的重复配置<br>【收益】减少镜像层数，获得镜像层数减少带来小量的缩减的收益<br><img data-src="/images/dockerfile3.png" alt="paradin" title="上面一个path，下面又对path进行配置，重复了"></p>
<p><img data-src="/images/dockerfile4.png" alt="paradin" title="调整后删除多余的java环境配置，将ali_start_timeout指令集中到同一个ENV指令中"></p>
<h3 id="构建时发生变化的层不应该超过3层"><a href="#构建时发生变化的层不应该超过3层" class="headerlink" title="构建时发生变化的层不应该超过3层"></a>构建时发生变化的层不应该超过3层</h3><p>【原因】一般采用动静分离原则进行指令分层优化后，大部分情况下构建变化不会超过3层。出现这个可能原因有如下两个：<br>   1、Dockerfile指令进行了较大的调整后首次进行编译，导致之前的分层缓存失效需要对变化的层重新构建<br>   2、Dockerfile指令未按动静分离原则进行分层，将需要经常变化的分层内容对应的指令写在了前面，导致后面的分层被动进行重新构建（docker构建逻辑：当前分层如果需要重新构建，则后续的分层不论是否变化都需要强制重新构建）<br>【解决方案】<br>     1、对于第一种情况，只要再重新构建一次即可消除该问题，即在每次对dockerfile做较大指令调整后可连续进行2次编译来查看是否存在该问题<br>     2、对于第二种情况，检查Dockerfile指令是否存在每次编译都需要变化的内容写在了前面，分析确认各个指令对应的内容的变化频率，采用不变化、偶尔变化、频繁变化从上至下的方式整理编写到Dockerfile，典型是主应用包拷贝指令，因为应用包每次构建一定会发生变化，所以在拷贝主应用包指令后面的其他指令一定会被强制重新构建。<br>【收益】减少镜像变化层数，降低镜像构建耗时<br>例如：<br><img data-src="/images/dockerfile5.png" alt="paradin" title="这里把经常变化的一个又一个文件的copy后，最后才拷贝一个不怎么会变化的setenv.sh文件"></p>
<p><img data-src="/images/dockerfile6.png" alt="paradin" title="将内容不会变化的setenv.sh文件的拷贝和权限设置指令迁移至主应用文件拷贝指令之前，同时将多个相同的主包文件拷贝指令合并成一个Copy指令，去除多余的变化层"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>镜像</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>通道信息加密工具--Qtunnel</title>
    <url>/2018/01/10/%E9%80%9A%E9%81%93%E4%BF%A1%E6%81%AF%E5%8A%A0%E5%AF%86%E5%B7%A5%E5%85%B7-Qtunnel/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>数据库做异地容灾是一个很常见的现象，既然信息要跨地域传递，要么就很土豪的打通机房之间的链路或者动用VPN，要不然就不可避免的走公网网络传输信息。既然选择了公网，那么数据库的语句就很容易被人监听到，所以把那些明文加密是必不可少的环节。</p>
<p>mysql支持<code>tls/ssl</code>加密方法对信息进行加密，这个方法的配置也很简单，就是两边各加上一个nginx，一个是正向代理一个是反向代理，配上ssl证书，然后就像配置网站https协议那样，在nginx.conf里开启ssl监听即可。</p>
<p>但是这种方法有一点小问题，就是在进行SSL握手之前，mysql会发送Server Greeting和Login Request数据包，然后才有可能使用SSL握手。这样步骤就多了一步鉴权，对访问性能有所影响。所以这个时候，我选择了另一个用于加密client和server之间链路通信的工具—-Qtunnel，因为它直接加密，速度更快。</p>
<p>Git的地址在这里：<a href="https://github.com/arstercz/qtunnel">https://github.com/arstercz/qtunnel</a> ，<strong>感谢arstercz大神的再加工！</strong></p>
<p>上面说过了Qtunnel是不需要认证的，默认加密方法是RC4，以字节流的方式加密明文的每一个字节，而且密钥长度最长支持256位，可以很好的抵御暴力搜索密钥的攻击，总而言之，Qtunnel是一个轻量且快速的加解密工具，而且还可以搭配atlas等数据库中间件使用。</p>
<h2 id="下载与准备"><a href="#下载与准备" class="headerlink" title="下载与准备"></a>下载与准备</h2><p>由于Qtunnel是用go语言写的，所以需要先安装golang，centos服务器的yum安装方法如下:<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rpm -<span class="title class_">Uvh</span> <span class="attr">http</span>:<span class="comment">//dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm</span></span><br><span class="line">yum install -y golang</span><br></pre></td></tr></table></figure></p>
<p>go语言安装完毕之后，我们就<code>git clone https://github.com/arstercz/qtunnel.git</code> ，获得qtunnel文件夹，文件夹内容如下：<br><img data-src="/images/downqtunnel.png" alt="抱光妹" title="qtunnel下载包内容"></p>
<p><code>make</code>，如果没有任何报错，那么就是安装成功了，使用<code>./bin/qtunnel -h</code>语句验证一番：<br><img data-src="/images/installqtunnel.png" alt="抱光妹" title="验证qtunnel"></p>
<p>本次实验的计划是这样的：用A机器访问B机器的mysql，并且插入数据，在B机器上的3306端口抓包，查看数据是否是明文；然后再在A机器和B机器上都安装qtunnel并且启动，然后重新插入数据，在B机器上的端口抓包，查看数据是否被加密。流程图如下：<br><img data-src="/images/%E6%9E%B6%E6%9E%84.png" alt="抱光妹" title="架构图"></p>
<h2 id="实验开始"><a href="#实验开始" class="headerlink" title="实验开始"></a>实验开始</h2><p>A机器和B机器都是使用阿里云虚拟服务器，版本都是centos 6.4，现在我们的加密实验正式开始。</p>
<p>首先A和B机器上都不启动qtunnel，然后我们在A机器上登陆B机器的数据库，如果之前没有授权，那么授权语句是：<br>    <code>GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;A机器的IP地址&#39; IDENTIFIED BY &#39;密码&#39; WITH GRANT OPTION;</code></p>
<p>登陆mysql之后，我们随意的插一个语句，然后通过抓包发现无论这个语句还是数据库的反馈都是以明文的形式呈现，如图：<br><img data-src="/images/shujuluoben.png" alt="抱光妹" title="数据在明文裸奔"></p>
<p>这种让数据裸奔的行为无疑于找死，那么这个时候我们就要配置一下qtunnel，来看一下它的加密效果。</p>
<p>在A服务器上，我们设定qtunnel是客户端，手动建立一个conf文件，比如<code>vim /etc/conn.conf</code>，内容如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[client1]</span><br><span class="line">faddr = <span class="number">10.252</span><span class="number">.215</span><span class="number">.108</span>:<span class="number">3309</span>    #这里是qtunnel客户端的<span class="variable constant_">IP</span></span><br><span class="line">baddr = <span class="number">10.175</span><span class="number">.193</span><span class="number">.239</span>:<span class="number">3310</span>    #这里是qtunnel服务端的<span class="variable constant_">IP</span></span><br><span class="line">cryptoMethod = rc4             #这里选用rc4的方式加密</span><br><span class="line">secret = 3301_test%<span class="title class_">Iad</span>      #rc4密钥，服务端的密码必须跟这个一致！</span><br><span class="line">clientmode = <span class="literal">true</span>              #表示这端是客户端</span><br></pre></td></tr></table></figure></p>
<p>然后使用<code>./bin/qtunnel -conf=/etc/conn.conf -daemon -logto=syslog</code>启动qtunnel，看一下进程和端口情况，如图：<br><img data-src="/images/aqidong.png" alt="抱光妹" title="看一下A进程和端口情况"></p>
<p>在B服务器上，同样手动建立一个配置文件，假设也叫conn.conf，内容如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[server1]</span><br><span class="line">faddr = <span class="number">10.175</span><span class="number">.193</span><span class="number">.239</span>:<span class="number">3310</span>    #这里是qtunnel服务端的<span class="variable constant_">IP</span></span><br><span class="line">baddr = <span class="number">10.175</span><span class="number">.193</span><span class="number">.239</span>:<span class="number">3306</span>    #这里是数据库的地址，由于在同一台机器上，所以地址一样</span><br><span class="line">cryptoMethod = rc4    </span><br><span class="line">secret = 3301_test%<span class="title class_">Iad</span>      #rc4密钥，跟client密钥一致</span><br><span class="line">clientmode = <span class="literal">false</span>             #表示这是服务器端</span><br></pre></td></tr></table></figure></p>
<p>也用同样的语句启动qtunnel，查看3310这个端口已经被监听了：<br><img data-src="/images/bqidong.png" alt="抱光妹" title="看一下B进程和端口情况"></p>
<p>现在，我们在A服务器上来重新连接B数据库，但是要注意！<font color=red>这个时候mysql里的-h不能再是B的IP地址了，而是A的地址！因为qtunnel现在已经打通了一个通道，访问qtunnel的3310端口就等于是访问B数据库的3306端口（有点类似atlas的意思）。</font></p>
<p>连上之后，我们随意插入一些语句，看一下qtunnel的能力:<br><img data-src="/images/shujubuluoben.png" alt="抱光妹" title="数据已经被加密了"></p>
<p>可见这个时候，抓包显示都是加密的文字了，实验成功！</p>
<h2 id="总结与参考资料"><a href="#总结与参考资料" class="headerlink" title="总结与参考资料"></a>总结与参考资料</h2><p>总结一下：qtunnel采用rc4加密，在算法强度和速度方面是很好的选择，不会引起slave太大的延迟，对管理员或开发而言数据都是透明的（如果在上面的实验启动了qtunnel之后，不监听3310端口，而是监听3306端口，得到的依旧是明文），只是在两端传输的过程中增加了加解密处理。核心的业务(比如用户和充值)在做异地架构的时候可以考虑该方式增强数据的安全性。</p>
<p>《mysql使用ssl简析》：<a href="https://hsulei.com/2017/10/19/mysql%E4%BD%BF%E7%94%A8ssl%E7%AE%80%E6%9E%90/">https://hsulei.com/2017/10/19/mysql%E4%BD%BF%E7%94%A8ssl%E7%AE%80%E6%9E%90/</a><br>《使用ssl加密mysql 5.6的官方文档》：<a href="https://dev.mysql.com/doc/refman/5.6/en/encrypted-connections.html">https://dev.mysql.com/doc/refman/5.6/en/encrypted-connections.html</a> </p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>加密技术</tag>
        <tag>Qtunnel</tag>
      </tags>
  </entry>
  <entry>
    <title>配置Intellij IDEA进行高效率运维开发</title>
    <url>/2019/05/14/%E9%85%8D%E7%BD%AEintellij-IDEA%E8%AE%A9%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91%E6%9B%B4%E9%AB%98%E6%95%88%E7%8E%87/</url>
    <content><![CDATA[<p>以前我写python用的是pycharm2018，但是发现我的pycharm里没有go插件，脱机安装也报错，于是乎我就干脆下载了一个interllij IDEA2019，打算把python、go、yaml文件都用它来编辑和管理。</p>
<h2 id="配置python开发环境"><a href="#配置python开发环境" class="headerlink" title="配置python开发环境"></a>配置python开发环境</h2><p>首先先去File–Settings–Plugins搜索python，下载对应插件，下载完毕之后需要重启IDE，重启完毕之后，<code>File--New--Module--Python</code>，选择对应的SDK即可。</p>
<p>若需要添加样式，还是在File–Settings–Editer–File and Code Templates里找到python script，增添文件的通用版面即可，如图：<br><img data-src="/images/intellij9.png" alt="akb48"></p>
<p>输出结果换行也很简单，在File–Settings–Editer–Console里，勾选<code>Use soft wraps in console</code>即可，如图：<br><img data-src="/images/intellij10.png" alt="akb48"></p>
<p>如果控制每行的长度，修改<code>Console commands history size</code>即可。</p>
<h2 id="配置go开发环境"><a href="#配置go开发环境" class="headerlink" title="配置go开发环境"></a>配置go开发环境</h2><p>首先安装go语言，配置好GOROOT和GOPATH，然后去File–Settings–Plugins搜索go，下载对应插件，下载完毕之后需要重启IDE，重启完毕之后，在<code>File--Settings--Languages &amp; Frameworks</code>里选择Go，配置好GOROOT和GOPATH。注意，GOPATH填的是Go的src文件地址。保存之后，就可以正常启动go文件了。</p>
<h2 id="配置k8s-yaml开发环境"><a href="#配置k8s-yaml开发环境" class="headerlink" title="配置k8s yaml开发环境"></a>配置k8s yaml开发环境</h2><p>首先先去File–Settings–Plugins搜索yaml和kubernetes，下载对应的插件之后，直接创建新的project，就会自动补齐，如图：<br><img data-src="/images/intellij7.png" alt="akb48"></p>
<h2 id="调节字体大小"><a href="#调节字体大小" class="headerlink" title="调节字体大小"></a>调节字体大小</h2><p>调节菜单等字体大小：<code>File--Settings--Appearance &amp; Behavior--Appearance--Use custom font(Size)</code>，如图：<br><img data-src="/images/intellij6.png" alt="akb48"></p>
<p>调节代码的字体大小：<code>File--Settings--Font--Size</code>，如图：<br><img data-src="/images/intellij5.png" alt="akb48"></p>
<h2 id="配置与远程服务器同步"><a href="#配置与远程服务器同步" class="headerlink" title="配置与远程服务器同步"></a>配置与远程服务器同步</h2><p>写完了代码，总不能lrzsz的去上传到服务器里，我们要用一个优雅的方式去达到这个目的，首先在顶级菜单里选择<code>Tools--Deployment--Configuration</code>，点击+创建一个新的链接：<br><img data-src="/images/intellij3.png" alt="akb48"></p>
<p>检查可以成功连接到远程服务器之后，保存此链接。右键点击文件，选择<code>Deployment---Upload to XXX</code>，然后就可以看到上传成功。<br><img data-src="/images/intellij4.png" alt="akb48"></p>
<p>最后，分享两个比较柔和的xshell配色方案：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[Solarized Dark]</span><br><span class="line">text(bold)=<span class="number">839496</span></span><br><span class="line">magenta(bold)=6c71c4</span><br><span class="line">text=<span class="number">839496</span></span><br><span class="line">white(bold)=fdf6e3</span><br><span class="line">green=<span class="number">859900</span></span><br><span class="line">red(bold)=cb4b16</span><br><span class="line">green(bold)=<span class="number">586e75</span></span><br><span class="line">black(bold)=073642</span><br><span class="line">red=dc322f</span><br><span class="line">blue=268bd2</span><br><span class="line">black=002b36</span><br><span class="line">blue(bold)=<span class="number">839496</span></span><br><span class="line">yellow(bold)=657b83</span><br><span class="line">cyan(bold)=93a1a1</span><br><span class="line">yellow=b58900</span><br><span class="line">magenta=dd3682</span><br><span class="line">background=042028</span><br><span class="line">white=eee8d5</span><br><span class="line">cyan=2aa198</span><br><span class="line">[Names]</span><br><span class="line">count=<span class="number">1</span></span><br><span class="line">name0=Solarized Dark</span><br></pre></td></tr></table></figure></p>
<p>将文件命名为solarized-dark.xcs文件，在xshell配色方案中导入该文件即可。颜色对比如下：<br><img data-src="/images/intellij8.png" alt="akb48" title="左边是柔和的，右边是默认的"></p>
<p>第二个方案如下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mycolor]</span><br><span class="line">text(bold)=e9e9e9</span><br><span class="line">magenta(bold)=ff00ff</span><br><span class="line">text=00ff80</span><br><span class="line">white(bold)=fdf6e3</span><br><span class="line">green=80ff00</span><br><span class="line">red(bold)=ff0000</span><br><span class="line">green(bold)=3c5a38</span><br><span class="line">black(bold)=808080</span><br><span class="line">red=ff4500</span><br><span class="line">blue=00bfff</span><br><span class="line">black=000000</span><br><span class="line">blue(bold)=1e90ff</span><br><span class="line">yellow(bold)=ffff00</span><br><span class="line">cyan(bold)=00ffff</span><br><span class="line">yellow=c0c000</span><br><span class="line">magenta=c000c0</span><br><span class="line">background=042028</span><br><span class="line">white=c0c0c0</span><br><span class="line">cyan=00c0c0</span><br><span class="line">[Names]</span><br><span class="line">count=1</span><br><span class="line">name0=mycolor</span><br></pre></td></tr></table></figure></p>
<p>将此文件保存较mycolor.xcs，然后同上面一样导入即可。如果想要xshell自动加载此配色，需要将上面里所有mycolor改名叫Xterm，并且删除掉原有的Xterm配色方案，重启Xshell即看到效果。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>intellij idea</tag>
      </tags>
  </entry>
  <entry>
    <title>长白山延吉6日行</title>
    <url>/2023/10/05/%E9%95%BF%E7%99%BD%E5%B1%B1%E5%BB%B6%E5%90%896%E6%97%A5%E8%A1%8C/</url>
    <content><![CDATA[<p>一直想带着老爸老妈出去玩玩，这次国庆假期研究了很多地方，最后我选择了长白山和延吉，第一我没去过，想亲眼看看天池感受一下朝鲜族的生活，第二就是老爸老妈还在东北住，选择长白山他俩用在旅途上的时间比较短。</p>
<p>整体的安排如下：<br>	day1:萧山机场出发去长白山机场，然后机场大巴去二道白河镇，现在二道白河镇附近溜达溜达。<br>	day2:长白山北坡<br>	day3:睡到自然醒，二道白河再走走，火车出发去珲春，珲春找一个海鲜店<br>	day4:从珲春去图们，图们看看国境线，然后返回珲春，再吃珲春美食<br>	day5:珲春出发去延吉西站，在恐龙乐园看《花开永不败》演出，看看朝鲜民族园，再去延吉大学网红墙夜市走走<br>	day6:延吉大学内部溜达一下，西市场走走<br>	day7:延吉机场坐飞机返杭</p>
<p>可以看出来我这次安排很简单，每天就1～2个景点，用时3~4小时。主要是我爹腰不好，长时间走路会腰疼，所以不搞特种兵旅游了。而且最近晚上还有亚运会的赛事直播，东北小城晚上毕竟夜生活有限，可以回酒店看亚运会比赛。</p>
<p>国庆很多商家是等待游客们来报复性消费的，所以机票和住宿都涨了一波价格。我算了一下，本次7日游我们4个人一共花费了18000元左右，其中飞机票占据了1&#x2F;3，住宿占据了1&#x2F;4，剩下一半是玩和买的费用，另一半是吃的费用。可以说如果是淡季，那么至少能节省5000元左右。</p>
<h2 id="本次的玩"><a href="#本次的玩" class="headerlink" title="本次的玩"></a>本次的玩</h2><p>本次的重头戏是长白山天池，我们是选择了29号登北坡，主要是考虑到届时游客会很多，哪怕抢到最早的7点票也会被卷的死去活来，所以我们花了3600包了一个车。这个车只需要在“长白山景区”微信小程序上提前一天0点预订即可，淡季3200，旺季3600。花了这3600就不需要买长白山其他的任何门票了，而且包车师傅会全程陪同，管接管送不管饭。可以说花了3600就是免去了不排队之苦，我们是早上7点半上车，直接就走VIP路线到天池旁边。<br><img data-src="/images/%E4%BA%9A%E8%BF%90%E5%80%BC%E6%9C%BA%E6%9F%9C%E5%8F%B0.jpg" title="值机的时候就看到很多运动员也在值机，估计比赛项目结束了回家了"><br><img data-src="/images/%E4%BA%8C%E9%81%93%E7%99%BD%E6%B2%B3%E6%9E%97%E5%8C%BA.jpg" title="林区这时候正是五颜六色的"></p>
<p>我们一行人的运气还是很好的，那天秋高气爽，阳光明媚，山上甚至还有一些前几天的残雪。天池平静的躺在那里，虽然有点风，但是它就像一面干净的镜子。蓝天下覆盖了一层吹的薄薄的流云再搭配上长白山火山的山壁，蓝白黑黄的颜色搭配让整个场景非常的出片。我在上面足足待了2个小时，充分的感受到了天池带给我的peace，下天池的时候大约是10点，人群已经开始排了很长的队了，景区开始限流，一点一点的放人进来看天池。至于长白山其他的景点就没有什么特色了，基本就是门票里面凑数的，温泉鸡蛋看了但是没吃。<br><img data-src="/images/%E5%A4%A9%E6%B1%A03.jpg"><br><img data-src="/images/%E5%A4%A9%E6%B1%A04.jpg" title="这里的白头峰，朝鲜叫将军峰"><br><img data-src="/images/%E5%A4%A9%E6%B1%A05.jpg" title="流云"><br><img data-src="/images/%E5%A4%A9%E6%B1%A06.jpg"><br><img data-src="/images/%E7%99%BB%E4%B8%8A%E5%A4%A9%E6%96%87%E5%B3%B0.jpg"><br><img data-src="/images/%E7%BB%BF%E6%B8%8A%E6%BD%AD.jpg" title="绿渊潭"></p>
<p>二道白河镇是国家的一个林区，各种树木很笔直也很多种，森林深处据说甚至还有野猪狍子。小镇的空气非常新鲜，早上凉凉的空气吸进肺里很舒服，我们坐包车上山的时候还看到国家一些竞走队的队员在山路上训练，运动员后面跟一辆小轿车。二道白河镇整个镇的绿化做的特别好，镇子里有很多的公园，每个公园的小河都会有流动，河里有小鸭子和鸳鸯游来游去，十分的惬意，可以说这里的秋天是一个疗养放松的好去处。缺点就是不太繁华，它的网红街并不太网红，百货大楼只有三层，而且20点多上面2层就关门了。<br><img data-src="/images/%E4%BA%8C%E9%81%93%E7%99%BD%E6%B2%B3%E9%9F%A9%E5%9B%BD%E9%A3%9F%E5%93%81.jpg" title="二道白河的小超市里能买到进口食品"><br><img data-src="/images/%E8%A1%97%E8%BE%B9%E6%97%B6%E5%85%89%E9%9A%A7%E9%81%93.jpg" title="二道白河也有一些网红小心思"><br><img data-src="/images/%E9%B8%B3%E9%B8%AF.jpg" title="二道白河镇里美人松公园里的鸳鸯"></p>
<p>图们是我们跟朝鲜的边境线，那是一个小城，主打的也是边境旅游生意，玩的是复古风格。到了景点基本也就是换了好几个角度看江对面的朝鲜南阳村，现在虽然我们疫情恢复了，但是以前拿身份证可以去南阳村半日游的业务还没恢复。拿望远镜看朝鲜人种田割草开拖拉机还挺有新意和优越感的，但是图们公路国境线附近的厕所实在太破了，那简直不叫厕所，就是一个茅坑，光味道就让人很下头。<br><img data-src="/images/%E5%9B%BE%E4%BB%AC2.jpg" title="这里目前还是楼梯单侧上下，很不方便，据说要改造成电梯了"><br><img data-src="/images/%E5%A4%A7%E8%83%96%E5%92%8C%E4%BA%8C%E8%83%96.jpg" title="父与子"></p>
<p>图们的那个老虎商品店还是挺有意思的，里面二楼有很多古早品，能看到红宝书、老扑克、朝鲜老货币等各种各样充满年代感的小东西。<br><img data-src="/images/%E4%B8%AD%E5%85%B1%E5%8D%81%E5%A4%A7%E5%B0%8F%E5%86%8C%E5%AD%90.jpg"><br><img data-src="/images/%E4%BA%8C%E6%89%8B%E5%BA%97.jpg"><br><img data-src="/images/%E7%BA%A2%E5%AE%9D%E4%B9%A61.jpg"></p>
<p>珲春的一眼望三国我就没去了，因为那里离珲春其实不近，70多公里，花了70多元上去看个景色觉得没啥意思就放弃了。<br><img data-src="/images/%E7%8F%B2%E6%98%A5%E5%B0%8F%E6%95%99%E5%A0%82.jpg" title="意外的发现一个小教堂！"><br><img data-src="/images/%E7%8F%B2%E6%98%A5%E7%9A%84%E5%9C%86%E6%9C%88.jpg" title="十五的月亮十六圆！"></p>
<p>作为一个东北人，延吉这种风格的城市给了我一个全新的感觉，它可以说是整个东三省里面最网红的城市了，主打一波“延吉美食+朝鲜族服装旅拍”，满大街的在逃公主倒也挺养眼的。延吉大学作为朝鲜自治州唯一一个211需要在公众号上提前一天预约才能进去，晚上网红墙的夜市也很热闹。朝鲜风俗馆那里全是照相馆，橱窗里各种各样朝鲜服饰，国庆期间也有一条街的夜市，里面烧烤土豆串奶茶柚子水啥的都有。至于网上说的西市场完全就是一个硬挤出来的景点，转了一圈下来发现就是一个很普通的市场啊。<br><img data-src="/images/%E5%9C%A8%E9%80%83%E5%85%AC%E4%B8%BB%E4%BB%AC.jpg" title="这些网络朝鲜风女装还挺好看，而男装有点像仆人"><br><img data-src="/images/%E5%BB%B6%E5%90%89%E7%BD%91%E7%BA%A2%E5%A2%99.jpg" title="话说其实就是办公楼的招牌对外了而已，杭州也可以这么玩啊"><br><img data-src="/images/%E8%87%AA%E4%B9%A0%E5%AE%A4.jpg" title="这里开自习室也是一波清流"><br><img data-src="/images/%E9%B9%BF%E9%9E%AD.jpg" title="西市场5楼是鹿鞭、人参等等东北货的大卖场"></p>
<p>延吉恐龙乐园里的《花开永不败》还不错，据说官方途径是158一个人，我们是在咸鱼上买的票，75一个人，75块钱是值得的。整体的表现有点类似杭州宋城的《宋城千古情》，但是排场要比它小，舞美也没有宋城那么高级，但是整个的审美和舞蹈还是很在线的。<br><img data-src="/images/%E8%8A%B1%E5%BC%80%E6%B0%B8%E4%B8%8D%E8%B4%A5.jpg"></p>
<h2 id="本次的吃"><a href="#本次的吃" class="headerlink" title="本次的吃"></a>本次的吃</h2><p>到了朝鲜族的地盘，这几天我吃饭基本都不重样：<br>第一天：在二道白河吃了全州包饭，尝了石锅拌饭，炸明太鱼，米肠，石锅鸡蛋等等。<br><img data-src="/images/%E5%85%A8%E5%B7%9E%E5%8C%85%E9%A5%AD.jpg"><br>第二天：还是在二道白河的小黄牛特色汤饭馆尝了嫩牛肉，铁板酸菜和炖豆腐，喝了他们的52度人参散白泡酒。<br>第三天：珲春吃到了心心念念的帝王蟹！还要了一大盘子的扇贝生蚝。<br><img data-src="/images/%E5%B8%9D%E7%8E%8B%E8%9F%B9.jpg" title="我挑的这只帝王蟹是个大小手！"><br><img data-src="/images/%E6%89%87%E8%B4%9D%E7%94%9F%E8%9A%9D.jpg" title="吃到爽!"></p>
<p>第四天：在图们的莲钰汤饭来了一顿汤泡饭，晚上回到珲春在马克西姆餐厅吃了一顿俄罗斯菜。<br>第五天：珲春乳酸菌烤肉，下午到了延吉吃了一顿炸酱面和正谈烤鸡。夜宵是丰茂烤串。<br><img data-src="/images/%E4%B9%B3%E9%85%B8%E8%8F%8C%E7%83%A4%E8%82%89.jpg" title="烤猪皮很不错"><br><img data-src="/images/%E7%B1%B3%E9%85%92.jpg" title="乳酸菌米酒"><br>第六天：兴豆饭店爆满，就去吃了延吉网红墙的久多炉烤鸡、元奶奶包饭。<br>第七天：上飞机前吃了一下延吉大学对面的黄酥记的梅干菜芝士扣肉饼。<br><img data-src="/images/%E6%A2%85%E5%B9%B2%E8%8F%9C%E9%A5%BC.jpg" title="这玩意一大早就排队，你敢信？"></p>
<p>总体感觉下来朝鲜族的饮食特色跟南方的差距很大的，他们的绿叶菜很少炒，基本都是用来包菜吃，然后食物基本都离不开辣白菜，不过很多辣白菜里也会放白糖，做出来的菜有辣有甜，还有酱也是他们饭里不可少的一部分。珲春作为全中国可能吃帝王蟹最便宜的地方，十月份也是蟹肥的时候，我们挑了一个五斤三两的大帝王蟹，一蟹三吃—八只蟹脚清蒸，中间那部分辣炒，最后的蟹壳称炒饭，那顿饭1000+但是真的爽的一批。</p>
<p>珲春的乳酸菌烤肉也是一绝，套餐非常实惠。到了延吉，几个网红店排队非常严重，我们晚上10点多去丰茂烤串都等了30分钟左右，上了桌发现那个菠萝肉串已经卖光了。不过他们的羊肉串也不错。然后早上7点半去排黄酥记的梅干菜芝士扣肉饼，竟然也排了半个小时。</p>
<p>久多炉烤鸡里的黑胡椒味道不错，蒜苔味的相对比较一般，主要是蒜苔太硬了，咬不动。</p>
<p>总而言之，相比较玩的景点，这次是一次美食之旅，汤炒烤蒸都尝了一遍，我还有好几个饭店没有吃到。朝鲜族的食物做法的确比较多样，但是基本菜都是红彤彤的，用的牛猪肉比较多，我记得小时候延吉有很多的狗肉馆，可能为了迎合游客的需要，狗肉馆们都低调了很多。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>去之前我一直在想为啥天池是朝鲜人心中的那个精神图腾？我以前看过一个韩国综艺节目叫《二天一夜》，是姜虎东等人参演的，他们在2008年有一期节目就是来长白山取景，在天池附近他们做了一个比较有争议的事儿，就是把韩国的几个大江海洋的瓶子水倒进了长白山天池，这期节目在B站好像搜不到了。这次我去的时候，已经不能近距离接触天池了，估计就是为了防止这样的事情再次发生。资料可见：<a href="https://yule.sohu.com/20080618/n257579404.shtml">https://yule.sohu.com/20080618/n257579404.shtml</a> 和 <a href="https://baijiahao.baidu.com/s?id=1770912448095056328&wfr=spider&for=pc">https://baijiahao.baidu.com/s?id=1770912448095056328&amp;wfr=spider&amp;for=pc</a> 。</p>
<p>现在的天池有了更多的政治意义，它更多的代表了建国初我们国家跟朝鲜的革命情谊。韩国人对天池和长白山也有很深的文化认同，在曾经的2007年长春亚冬会上，韩国女子运动员在领奖台举牌宣称长白山应该是韩国的领土，这里面的历史问题非常复杂，各方有各方的说辞和证据。</p>
<p>这里插播一句，韩国的文化输出一直都非常强劲，他们的朝鲜古装剧也很有市场，在朝鲜文化传播上，韩国无疑走在我们朝鲜族和北朝鲜的前面。</p>
<p>至于珲春，不得不提到著名苏联歌曲《喀秋莎》，这歌好听是好听，但是里面的背景故事对中国人并不友好。<br><img data-src="/images/%E5%96%80%E7%A7%8B%E8%8E%8E.jpg" title="据说这个微博已经被删掉了"></p>
<p>而延吉作为朝鲜自治州的首府，它本身其实历史是不短的，据说在元朝的时候就有像样的历史了，但是直到今天里面的景点并不多，甚至历史名人纪念碑都少的可怜，让人不禁疑惑这里的过去除了恐龙还有啥。但是作为首府，延吉无疑是这里面交通相对最便利也是娱乐最多的地方。</p>
<p>这一趟旅行也是简单的回顾了一下中国朝鲜族的历史，毕竟旅游就是从住腻了的地方去别人住腻了的地方，这种“招牌上写中朝俄三种文字”的地方对我来说还是一个全新的体验，7天下来除了有些地方4G信号不好之外感受还是很棒的。但是不得不说北方的天气还是干，在南方住惯了的我最后几天都是用湿巾来润鼻子。</p>
<p>最后再来一张二道白河的林区公路照，阳光下森林公路的感觉真好！<br><img data-src="/images/%E5%85%AC%E8%B7%AF%E9%A3%8E%E6%99%AF.jpg" title="妥妥的北欧风，此时需要一辆摩托车"></p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>旅游</tag>
        <tag>延吉</tag>
        <tag>朝鲜</tag>
      </tags>
  </entry>
  <entry>
    <title>金山云api调用的几个例子</title>
    <url>/2018/03/29/%E9%87%91%E5%B1%B1%E4%BA%91api%E8%B0%83%E7%94%A8%E7%9A%84%E4%B8%A4%E4%B8%AA%E4%BE%8B%E5%AD%90/</url>
    <content><![CDATA[<p>今天另外一个运维要看一下金山云API返回的格式，于是就临时写了两个demo，也顺便记录下来，说不定以后开发脚本的时候可能用的着。</p>
<p>金山云跟阿里云的sdk不一样，阿里云有一个总的sdk，然后不同的服务还需要去分别下载对应具体的sdk；而金山的不是，他绝大多数的服务都是用那个总sdk。</p>
<h2 id="查询数据库的脚本"><a href="#查询数据库的脚本" class="headerlink" title="查询数据库的脚本"></a>查询数据库的脚本</h2><p>需要先获取<code>https://github.com/kscdb/krds_openapi_sdk.git</code>，然后执行<code>python setup.py install</code>安装所用的金山库。</p>
<p>这个脚本是查询某个数据库的具体情况：<br><img data-src="/images/ksapi4.png" alt="paradin"></p>
<p>脚本如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/usr/</span>bin/env python</span><br><span class="line"># -*- <span class="attr">encoding</span>:utf-<span class="number">8</span> -*-</span><br><span class="line"><span class="keyword">from</span> kscore.<span class="property">session</span> <span class="keyword">import</span> get_session</span><br><span class="line"><span class="keyword">from</span> krds_client <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">#密钥</span><br><span class="line"><span class="variable constant_">ACCESS_KEY_ID</span> = <span class="string">&quot;这里填写ak&quot;</span></span><br><span class="line"><span class="variable constant_">SECRET_ACCESS_KEY</span> = <span class="string">&quot;这里填写sk&quot;</span></span><br><span class="line"></span><br><span class="line">#连接</span><br><span class="line">s = <span class="title function_">get_session</span>()</span><br><span class="line">krds_client = <span class="title class_">KRDSClient</span>(<span class="variable constant_">ACCESS_KEY_ID</span>, <span class="variable constant_">SECRET_ACCESS_KEY</span>, <span class="string">&#x27;地域名&#x27;</span>)</span><br><span class="line">r = krds_client.<span class="title class_">DescribeDBInstances</span>(<span class="title class_">DBInstanceIdentifier</span>=<span class="string">&#x27;5c664b16-fbfe-4373-8a00-67c9476e7386&#x27;</span>,<span class="title class_">DBInstanceType</span>=<span class="string">&#x27;HA&#x27;</span>)	#<span class="title class_">DBInstanceIdentifier</span>后面是实例<span class="variable constant_">ID</span></span><br><span class="line">print r</span><br></pre></td></tr></table></figure></p>
<p>执行脚本之后，可以看到返回的结果包括数据库里很多的资料，如图：<br><img data-src="/images/ksapi1.png" alt="paradin" title="执行效果"></p>
<p>如果不加参数的话，就是返回账号内所有的数据库情况。</p>
<h2 id="查询服务器的脚本"><a href="#查询服务器的脚本" class="headerlink" title="查询服务器的脚本"></a>查询服务器的脚本</h2><p>需要先获取<code>https://github.com/KscSDK/ksc-sdk-python.git</code>，然后执行<code>python setup.py install</code>安装所用的金山库。</p>
<p>这个脚本是查询下面这个服务器的情况：<br><img data-src="/images/ksapi3.png" alt="paradin"></p>
<p>脚本如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/usr/</span>bin/env python</span><br><span class="line"># -*- <span class="attr">encoding</span>:utf-<span class="number">8</span> -*-</span><br><span class="line"><span class="keyword">from</span> kscore.<span class="property">session</span> <span class="keyword">import</span> get_session</span><br><span class="line"></span><br><span class="line">#密钥</span><br><span class="line"><span class="variable constant_">ACCESS_KEY_ID</span> = <span class="string">&quot;这里填写ak&quot;</span></span><br><span class="line"><span class="variable constant_">SECRET_ACCESS_KEY</span> = <span class="string">&quot;这里填写sk&quot;</span></span><br><span class="line"></span><br><span class="line">#连接</span><br><span class="line">s = <span class="title function_">get_session</span>()</span><br><span class="line">client = s.<span class="title function_">create_client</span>(<span class="string">&quot;kec&quot;</span>, <span class="string">&quot;地域名&quot;</span>, use_ssl=<span class="title class_">True</span>,ks_access_key_id=<span class="variable constant_">ACCESS_KEY_ID</span>, ks_secret_access_key=<span class="variable constant_">SECRET_ACCESS_KEY</span>)</span><br><span class="line">print client.<span class="title function_">describe_instances</span>(<span class="title class_">Search</span>=[<span class="string">&#x27;js-online-hlsproxy-20&#x27;</span>])	#<span class="title class_">Search</span>后面接实例名</span><br></pre></td></tr></table></figure></p>
<p>执行脚本之后，可以看到返回的结果包括数据库里很多的资料，如图：<br><img data-src="/images/ksapi2.png" alt="paradin" title="执行效果"></p>
<p>如果不加参数的话，就是返回账号内所有的服务器情况。</p>
<h2 id="弹性IP相关的脚本"><a href="#弹性IP相关的脚本" class="headerlink" title="弹性IP相关的脚本"></a>弹性IP相关的脚本</h2><p>脚本如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/usr/</span>bin/env python</span><br><span class="line">#coding=utf-<span class="number">8</span></span><br><span class="line">#这个脚本是用来修改金山云的eip带宽</span><br><span class="line"><span class="keyword">import</span> json,pprint</span><br><span class="line"><span class="keyword">from</span> kscore.<span class="property">session</span> <span class="keyword">import</span> get_session</span><br><span class="line"></span><br><span class="line"># 密钥</span><br><span class="line"><span class="variable constant_">ACCESS_KEY_ID</span> = <span class="string">&quot;这里是ak&quot;</span></span><br><span class="line"><span class="variable constant_">SECRET_ACCESS_KEY</span> = <span class="string">&quot;这里是sk&quot;</span></span><br><span class="line"></span><br><span class="line">s = <span class="title function_">get_session</span>()</span><br><span class="line">region=<span class="string">&#x27;cn-shanghai-2&#x27;</span></span><br><span class="line">eipClient = s.<span class="title function_">create_client</span>(<span class="string">&quot;eip&quot;</span>,region, use_ssl=<span class="title class_">False</span>,ks_access_key_id=<span class="variable constant_">ACCESS_KEY_ID</span>,ks_secret_access_key=<span class="variable constant_">SECRET_ACCESS_KEY</span>)</span><br><span class="line"></span><br><span class="line">#allEips=eipClient.<span class="title function_">get_lines</span>()	#这是获取<span class="title class_">LineID</span></span><br><span class="line">#allEips=eipClient.<span class="title function_">allocate_address</span>(<span class="title class_">LineId</span>:<span class="string">&quot;a2403858-2550-4612-850c-ea840fa343f9&quot;</span>,<span class="title class_">BandWidth</span>:<span class="number">5</span>,<span class="title class_">ChargeType</span>:<span class="string">&quot;PostPaidByDay&quot;</span>)	#这是创建eip</span><br><span class="line">#print allEips</span><br><span class="line">#allEips=eipClient.<span class="title function_">describe_addresses</span>(<span class="title class_">MaxResults</span>=<span class="number">7</span>)	#这是查询eip，一次输出<span class="number">7</span>次</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="title function_">open</span>(<span class="string">&quot;/具体路径/金山云eip名单.txt&quot;</span>):</span><br><span class="line">   	line = line.<span class="title function_">strip</span>(<span class="string">&#x27;\n&#x27;</span>)	#去掉回车</span><br><span class="line">   	eipClient.<span class="title function_">modify_address</span>(**&#123;<span class="string">&#x27;AllocationId&#x27;</span>:line,<span class="string">&#x27;BandWidth&#x27;</span>:<span class="number">1</span>&#125;)	#将文件里的所有的eip带宽改成1M</span><br><span class="line">   	<span class="title function_">print</span> (<span class="string">&quot;带宽已经调整完毕！&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>总体来说金山云的sdk文档还是比较挫。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/KscSDK/ksc-sdk-python">https://github.com/KscSDK/ksc-sdk-python</a><br><a href="https://github.com/kscdb/krds_openapi_sdk">https://github.com/kscdb/krds_openapi_sdk</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>金山云</tag>
      </tags>
  </entry>
  <entry>
    <title>防盗链的等等相关</title>
    <url>/2018/01/22/%E9%98%B2%E7%9B%97%E9%93%BE%E7%9A%84%E7%AD%89%E7%AD%89%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="为什么网站们都要限制流量？"><a href="#为什么网站们都要限制流量？" class="headerlink" title="为什么网站们都要限制流量？"></a>为什么网站们都要限制流量？</h2><p>无论是网站服务器亦或是游戏服务器还是邮件服务器，说穿了也是一台电脑，也有CPU和内存。只不过服务器的CPU功能比个人电脑的CPU功能强大，比如个人电脑的CPU一秒钟能算1亿个数，那么服务器的CPU一秒钟就能算十亿个数。毕竟个人电脑只针对个人，但是服务器是要“接客”的，有了强大的硬件做后盾，网页&#x2F;游戏&#x2F;邮箱才不会那么轻易的Down掉。</p>
<p>但是CPU不是人类大脑，人脑是越用越聪明，CPU是越用越磨损，毕竟始终在连电的环境下。于是乎，没有必要的运算能省就省，一个人省一次，十万个人就省十万次，一千万个人就省一千万次，这样达到积少成多的目的。</p>
<p>CPU计算的是各种数据，而这些数据也叫作流量。有用的流量、有价值的流量通过CPU计算无可厚非，但是出现了没有用的流量或者是别人盗用我们的资源，那么这种情况能避免都要避免。什么叫盗用我们的资源，比如自己网站（网站A）上的图片或者视频，被其他人直接复制网站然后粘贴到他们的主页（网站B）上，其他用户登录了B网站，然后点击了那个图片和视频，由于是网址重链接，里外里提供数据的还是我们的服务器。也就是说B网站就是一个中介，而真正提供服务的是网站A，但是广告费和点击率都要网站B赚走了，这事儿实在是叔可忍婶不可忍。</p>
<h2 id="什么是盗链？如何发现被盗链？"><a href="#什么是盗链？如何发现被盗链？" class="headerlink" title="什么是盗链？如何发现被盗链？"></a>什么是盗链？如何发现被盗链？</h2><p>什么叫盗链，上面已经说的差不多了，如果上面的文字没有看懂的话，举个例子，如果您看到了这两个图片，证明这个网站就是在盗链。<br><img data-src="/images/daolian1.jpg" alt="paradin"></p>
<p><img data-src="/images/daolian2.jpg" alt="paradin"><br>这两个就是一个盗取的是QQ空间的图片，另一个就是百度的图片。用其他网站的图片这事儿本身是无所谓的，只要不涉及版权问题，都希望自己的作品能广泛传播，但是请不要直接通过网址重定向，厚道一点的行为应该是：“图片另存为”，然后到目标网站上去重新上传一下。</p>
<p>这里再多说一点网站的基础知识。</p>
<p>PV值：<code>PV=page view</code>，网站是有少则一个网页多则N多网页组成的一个整体，PV值就是统计用户访问网站的总页数。比如<a href="http://www.jqk.com这个网站,今天有100个用户登录,平均每个用户翻阅了里面5个网页.那么这个网站的pv值就是500.若一个ip地址,对一个页面刷新10000次,pv值也是1.要查询网站的pv值登陆`http//www.alexa.cn%60%E5%B0%B1%E8%A1%8C%E3%80%82">www.JQK.com这个网站，今天有100个用户登录，平均每个用户翻阅了里面5个网页。那么这个网站的PV值就是500。若一个IP地址，对一个页面刷新10000次，PV值也是1.要查询网站的PV值登陆`http://www.alexa.cn`就行。</a></p>
<p>Hit值：这个就是对网页里每个元素的点击量，一个网页里的图片就是一个元素，一个flv文件也是一个元素，一首歌曲也是一个元素。这些的总量就是hit值，hit值越高就证明这个网站被人查看的情况越高，那么也证明网站的高人气，那么自然广告也会卖出去很多钱。</p>
<p>因为建网站这事儿关心到了金钱利益，网站越被人关注，自然价值也越大。于是会有一个公式来评判网站的“每日贡献”：<code>总流量=访问流量+下载流量= Page view值 x 页面大小+下载文件大小 x 下载次数</code></p>
<p>作为管理者，每天观察一下自己一亩三分地儿的网站数据情况是本职工作。但是有时候也会遇到网站流量很惊人的情况，一般来说，网站流量过大（CPU运转很多）的原因如下：</p>
<p>1）网站是一个很大的网站：比如说淘宝，京东，网易，youtube,facebook那种大网站，里面成万上亿的网页，而且每天又有那么多人登陆，自然浏览量很大。虽然这些大集团的服务器也是少则几千，多则上万，甚至在不同地区也会有不少的服务器集群，但是这几万台服务器需要提供的数据会很多也是不争的事实。这种现象是正常的。</p>
<p>2）网页内容太大：可能本身网站是一个小网站，加起来也就十页二十页的内容，但是每一天的流量依旧很惊人，那么很有可能是单页或者某几页的字节太大。比如网页里有太多的图片，太多的视频，太多的其他链接，也有可能是前端码农们给这个网页的规划不合理。导致这个网页每一次被点击都要大费周折（hit值和PV值不高，但是日流量很高），长此以往不仅会耽误用户的整体体验，对服务器也是一个重大伤害。</p>
<p>3）搜索引擎产生了大量的数据流量：网站需要推广，于是就在各种搜索引擎上打广告，也有自己网站的很多图片用于外部调用。这样的结果就是本身来观摩网站的人很少，但是“借着引擎经过”的人很多，所以就会有PV值不高，但是Hit值和日流量很高的现象出现。</p>
<p>4）图片或者其他元素被盗链：第一部分就说过了，别人拿我们的图片去吸引别人关注，然后别人想要深入了解，还要来使用我们的服务器去提供详细数据。这种“用我们的牌子住我们的房，吃我们的饭却不给我们钱”的现象实在应该被弄死。这种现象的特征也是PV值不高（没人真正点击网站），但是Hit值和日流量很大（自己服务器的数据都给别的网站提供了）。</p>
<p>5）网站被DDos攻击了：被一些恶意的IP地址频繁登陆，来回的刷流量。这样迫使CPU做出运算的行为其实就是在远程的破坏服务器的硬件CPU，遇到这种现象，之前Nginx文章里有写，要么通过access.log找到这些IP封掉，要么就在配置文件里加上限制<code>limit-rate</code>。</p>
<h2 id="服务器是如何知道图片是从站外而来的呢？"><a href="#服务器是如何知道图片是从站外而来的呢？" class="headerlink" title="服务器是如何知道图片是从站外而来的呢？"></a>服务器是如何知道图片是从站外而来的呢？</h2><p>在http协议里有一个重要的选项叫refer，这个选项的内容就是该元素的来源地址。如果这个元素是服务器自己提供的，那么头文件里是没有refer这个选项的。通过refer这个信息，我们也可以知道登陆网站的客户是从哪个网站点击链接而来的。这样方便进行一个统计和规划。</p>
<p>假如，我在QQ空间里面发现一个图，然后右键图片，选择”在新标签栏里打开图片”，这时候通过浏览器“审查元素”的功能，能查查看请求头信息和响应头信息，发现响应头信息里多了一个refer，里面的内容就是图片的源地址：<br><img data-src="/images/daolian3.jpg" alt="paradin"></p>
<p>我在QQ空间里看腾讯的照片自然是可以的，但是如果我在别的网站里看腾讯的照片，加重了腾讯服务器的负担，自然腾讯公司会不满意。于是腾讯服务器发现当前要引用这个图片的地址与refer头信息不是一个来源之后，就不会把这个图片的数据传送过来，于是就看到那个“此图片来自QQ空间，未经准许不可饮用”的警告图片。</p>
<p>既然知道了服务器是如何判断文件是否盗链，那么只要伪装一个refer就可以欺骗服务器达到“反防盗链”的目的了。至于这部分，可以自己单独研究。<br>如何使用Nginx反盗链？</p>
<p>同样的使用<code>Nginx.conf</code>，在http的大括号下面，新建一个location，加入如下信息：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">location</span><br><span class="line">	~ .*\.(wma|wmv|asf|mp3|mmf|zip|rar|jpg|gif|png|swf|flv)$ &#123;</span><br><span class="line">#指定对以上几种类型的文件建立防盗链</span><br><span class="line">   	 valid_referers</span><br><span class="line">	none blocked *.<span class="property">alala</span>.<span class="property">com</span> alala.<span class="property">com</span>;</span><br><span class="line">#盗链的范围不包括alala.<span class="property">com</span>和alala.<span class="property">com</span>下的二级网站，</span><br><span class="line">     <span class="keyword">if</span></span><br><span class="line">($invalid_referer)</span><br><span class="line"> &#123;</span><br><span class="line">     #rewrite</span><br><span class="line"> ^<span class="regexp">/ http:/</span><span class="regexp">/www.alala.com/</span>error.<span class="property">html</span>;</span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line"><span class="number">403</span>;</span><br><span class="line">#如果发现有引用以上文件的地址与refer头信息不符的情况，直接重定向成error.<span class="property">html</span>这个网页，服务器返回<span class="number">403</span>，forbidden。</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用第三方模块ngx-http-accesskey-module实现Nginx防盗链"><a href="#使用第三方模块ngx-http-accesskey-module实现Nginx防盗链" class="headerlink" title="使用第三方模块ngx_http_accesskey_module实现Nginx防盗链"></a>使用第三方模块ngx_http_accesskey_module实现Nginx防盗链</h2><p>实现方法如下：</p>
<ol>
<li><p>下载NginxHttpAccessKeyModule模块文件：<code>http://wiki.nginx.org/File:Nginx-accesskey-2.0.3.tar.gz</code>；</p>
</li>
<li><p>解压此文件后，找到nginx-accesskey-2.0.3下的config文件。编辑此文件：替换其中的<code>$HTTP_ACCESSKEY_MODULE</code>为<code>ngx_http_accesskey_module</code>；</p>
</li>
<li><p>用一下参数重新编译nginx：<br> .&#x2F;configure –add-module&#x3D;Nginx目录&#x2F;to&#x2F;nginx-accesskey<br>然后执行: <code>make &amp;&amp; make install</code></p>
</li>
<li><p>修改nginx的conf文件，添加以下几行：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">location /download &#123;</span><br><span class="line">  accesskey on;</span><br><span class="line">  accesskey_hashmethod md5;</span><br><span class="line">  accesskey_arg <span class="string">&quot;key&quot;</span>;</span><br><span class="line">  accesskey_signature <span class="string">&quot;mypass$remote_addr&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>其中：<br>1.accesskey为模块开关；<br>2.accesskey_hashmethod为加密方式MD5或者SHA-1；<br>3.accesskey_arg为url中的关键字参数；<br>4.accesskey_signature为加密值，此处为mypass和访问IP构成的字符串。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>网络相关</tag>
      </tags>
  </entry>
  <entry>
    <title>重庆七日行</title>
    <url>/2020/12/04/%E9%87%8D%E5%BA%86%E5%8D%81%E6%97%A5%E8%A1%8C/</url>
    <content><![CDATA[<p>重庆在我眼中一直是一个很神秘的地方，以前看过《疯狂的石头》的我对这个“山城和桥城”超级感兴趣，我想这要归功于重庆话的魔性。今年是我人生第一次到重庆，所住的地方是洪崖洞附近的民宿，18楼，顶层是27楼，但是18楼的楼道里走走竟然能走到另外建筑的一楼！然后上坡下坡，就能顺着到了马路边！彻身感触到这是一个立体化的城市。怪不得网上有段子说，重庆不是一个适合玩跑酷的地方，因为你永远不知道你翻过去的窗口所在的究竟是1楼还是30楼…</p>
<p>7天的安排如下:<br>第一天 下午萧山机场出发，晚上抵达重庆，办理民宿入驻，在洪崖洞、解放碑步行街和八一好吃街转了转<br>第二天 租了一个司机，出发去武隆天坑地缝<br>第三天 长江索道、罗汉寺、白公馆、磁器口<br>第四天 黄桷坪涂鸦艺术街、交通茶馆、军哥书屋<br>第五天 大坪天街散步购物撸狗外加看电影、九街<br>第六天 汉海海洋公园、解放碑天台看夜景<br>第七天 返程回杭州</p>
<h2 id="重庆的玩"><a href="#重庆的玩" class="headerlink" title="重庆的玩"></a>重庆的玩</h2><p>重庆的玩真的实在太多了，既有适合中年人游览的古迹，又有适合都市小年轻的酒吧夜店，既有狂野的“甩脑壳”动次打次，也有文艺的书店喝茶摆龙门阵。这是一个动静皆宜的城市，看到山上茫茫的雾有种仙仙的感觉，走在九街上满街的酒吧小哥问你“是否要订座”又让人会产生一种狂野的躁动。</p>
<p>重庆很大，附近周边有很多的景点，丰都鬼城啦，大足石刻啦。我这次选择去了天坑地缝。花钱雇了一个司机，来回开车在路上就跑了几乎7个小时，听了一路的草原歌曲，看了一路的山景雾气。到了天坑地缝，爬了一身汗，看到了奇石和瀑布，也呼吸到了清新又有点凉的空气。尤其看到《满城尽带黄金甲》里的那个驿站原型，觉得在这山谷里，这样的一个场景，天生就是为了拍武侠片服务的。<br><img data-src="/images/%E9%87%8D%E5%BA%86%E5%A4%A9%E5%9D%91%E9%A9%BF%E7%AB%99.jpg" alt="akb48" title="在驿站里，总觉得会有刺客从四面八方飞来"></p>
<p>渣滓洞和白公馆是著名红色爱国教育基地，可惜由于疫情，部分场地都没有对外开放，但是钱全是全价照收。这里也是一个人气景点，建议不要徒步了，全部都是上坡，走路太累了。很多游客在这里看着各种各样的老虎凳、狼牙棒和先烈的书信畅想曾经的岁月，讲述着或真实或地摊文学的故事。我还隔着大门远远的看到了小萝卜头同学的墓。路边有老太太卖着土匪烟，5到30元不等，大多数都是三无产品。</p>
<p>额外提一句，《红岩》的作者罗广斌当初就是以政治犯的身份被国民党抓捕，先后在渣滓洞和白公馆度过了400天，依旧可以作斗争绣红旗策划逃跑。但是后来在文化大革命里，这哥们抗争了5天就跳楼自杀了。嗯…蒋委员长的那些手下还是不得要领啊！</p>
<p>磁器口，说实话，我个人比较无感，因为跟全国各地的商业古镇差不多。下面各种商铺，编头发、卖网红冰淇淋、火锅底料，上面就是小酒吧，里面的歌手弹唱，彼此之间互相干扰，听的人都快精神分裂了。不过磁器口蛮大的，要走很久。但是我在里面走来走去，有一个出口直接是工地，当天还有点小雨。从工地到马路打车，踩了我一脚泥，原本无感的心情更是不爽了。</p>
<p>重庆黄桷坪有一条涂鸦街，在四川美术学院黄桷坪校区那里。那块也算是一个大学城，“交通茶馆”就在那附近，整个一条街都被搞艺术的同学们无情的涂鸦，搞得非常魔幻，画脸蛋画屁股画猴子画球星，其中也不乏各种向肖战、王一博、易烊千玺示爱的文字，当然这种文字不能算严格涂鸦，只能算是一种“宣言”。涂鸦街往南走会是一个待拆的老区，有住宅楼有工厂房，甚至还有铁轨，看上去很有八九十年代的风格，早已没有几个人居住了。铁轨边还有两个老头专门搭了一个棚子看着那些来拍照的人，估计等火车真的来了，告诉他们抓紧离开，注意安全。<br><img data-src="/images/%E9%87%8D%E5%BA%86%E5%BA%9F%E9%93%81%E8%BD%A8.JPG" alt="akb48" title="在黄角坪的废铁轨上一望无际"></p>
<p>重庆以前也是工业城市，自然老区就会弥漫这种浓浓的工业风，那么在这里就会看到军哥书屋，我不知道这个主人是靠什么过活的，可能是卖一点手工艺品吧，但是它的书的确不像是用来卖的，很多都是工具书，甚至还有政府工作报告。坊间里有一个黑猫，当时在无情的恰豆子。</p>
<p>黄桷坪以一种原生态地方式生长出这里独有的氛围：消融了艺术与生活的界限，艺术就是生活，生活也是艺术。这才是重庆最接地气的地方！<br><img data-src="/images/%E9%87%8D%E5%BA%86%E5%86%9B%E5%93%A5%E4%B9%A6%E5%B1%8B.jpg" alt="akb48" title="书屋的摆设很有老情怀，但是小说不多"></p>
<p>感谢抖音，让李子坝站现在成为了重庆的网红景点，很多人在站点下面的广场摆着各种pose来照相。重庆上下班高峰期堵车很严重的，坐轻轨是一个很棒的选择。在山脉与嘉陵江之间坐着轻轨在城市里穿梭，竟然有一种很日本的感觉，尤其是伴上轻轨拐弯的瞬间再加上夕阳西下的光线。</p>
<p>话说，重庆的7-11和Lawson这样的小卖店并不算多，我的苹果充电线坏了，从住的地方走了2个公里就为了找一个Lawson去买一个新线。去的时候上坡回来下坡，腿都给老子爬折了…</p>
<h2 id="重庆的吃"><a href="#重庆的吃" class="headerlink" title="重庆的吃"></a>重庆的吃</h2><p>说到重庆，火锅是逃不过的话题。记得《圆桌派》第二季有一期就是讲“火锅江湖”，讲的是重庆火锅和北京铜锅还有广东打边炉的区别。重庆火锅我吃的基本都是苍蝇馆子，环境虽不算好，但是口味是真的不错。基本上套路都差不多，排队好几个小时后，niangniang们热腾腾的端来一个锅，先肉后素的把点的东西倒进九宫格里，然后给自己的小碗倒上香油、蒜泥、醋、葱花等等东西，开始唠嗑等着东西变熟。但是要注意碗里的佐料是要根据汤里的实际情况搭配的，如果无脑的加加加，会被人说成火锅土鳖…<br><img data-src="/images/%E9%87%8D%E5%BA%86%E6%A5%A0%E7%81%AB%E9%94%85.JPG" alt="akb48" title="虽然就餐环境一般，但是鸡爪子是一绝！"></p>
<p>一口火锅，一瓶当地的冰天赋可乐or唯怡豆奶，再来一碗冰粉or冰沙，这些就是晚餐的全部内容。从火锅里夹出一筷子肉，在作料小碗里滚一圈后吹吹就塞进嘴巴里，烫的感觉瞬间充满整个口腔，然后喝下一大口可乐，嘴巴就由烫变成了冰，由辣变成甜，如此反复之后，变成了舌尖和舌两侧的麻。对于不是特别耐辣的我来说，这种感觉最后流到了胃，再最后就无限的蹲厕所…<br><img data-src="/images/%E9%87%8D%E5%BA%86%E6%A5%A0%E7%81%AB%E9%94%85%E5%86%B0%E7%B3%95.jpg" alt="akb48" title="真心没想到上来这么大一碗！"></p>
<p>这里重点提及一下他们的卤鸡爪和双椒牛肉，卤鸡爪既能直接吃也可以下火锅，已经卤的很嫩，舌头一抿就脱骨了，但是凉了跟汤汁结块了就不好吃了。记得楠火锅的鸡爪，我要了两碗吃，爽到飞起！不过我好像没有发现重庆哪家火锅店有萝卜块下锅的，不知道是不是我没发现到。</p>
<p>再补充一句，火锅的酥肉请谨慎选择“红糖酥肉”，因为一旦遇到不太好吃的番茄酱，那么这个红糖酥肉就有一股铁锈味…</p>
<p>重庆饭里汤水很多：火锅、鱼锅、兔肉锅。除了兔肉锅比较清淡，其他的都是红彤彤的。火锅吃多了难免有点想念米饭，于是就找到江湖菜去吃点炒菜，带上一个重庆本地的朋友帮你跟niangniang们交流，叫一个“花椒辣子鸡”、“回锅肉”和一个包浆豆腐，都是下饭菜，让我过了瘾。重庆的日料远不如杭州多，但是重庆也是一个依山傍水的城市呀，至于为啥日料这么贫瘠，我想可能是因为重庆人长期吃重口味的食物，相对清淡的日料并不会得到他们更多的爱。</p>
<p>重庆的路边摊也很多，比如炒板栗的车车，猪蹄子和酸辣粉的摊子基本是路边的标配。而且重庆还有很多的小吃我都叫不上名字，而且也不知道怎么写。还有那种汤圆奶茶，据说是汤圆串成串，然后先吃汤圆再喝奶茶，一小杯可以当一顿早餐了。<br><img data-src="/images/%E9%87%8D%E5%BA%86%E5%85%94%E8%82%89%E9%94%85.JPG" alt="akb48" title="兔兔那么可爱，但是不耽误我吧唧吧唧"></p>
<h2 id="重庆的人"><a href="#重庆的人" class="headerlink" title="重庆的人"></a>重庆的人</h2><p>虽然这一part的标题叫“重庆的人”，其实我更想说的是重庆的女人。</p>
<p>上面说了，重庆是一个动静皆宜的城市。反馈在重庆年青一代女人身上，既有火辣诱人的一面又有怡静可爱的一面。重庆妹子很敢穿，她们穿汉服、洛丽塔等奇异服饰远不如杭州多，但是夏天短裤吊带是常规操作，毕竟重庆夏天也是一个大火炉。重庆妹子们皮肤超级白，摸上去也很有弹性（别问我是怎么知道的）。为什么她们皮肤那么白？很多人都说是重庆多雾少阳光，湿润空气使人皮肤长期处于保湿状态中，这令重庆女人不显老。</p>
<p>重庆妹子说重庆本地话语速更快、更干脆，会给人比较“刚”的感觉，不如成都话软，而且重庆人说脏话也是常见的社会现象。但是这种“刚”与重庆妹子骨子里的“糯”成了反差，让重庆女人性格更精彩。她们敢爱敢恨，很少扭扭捏捏。而且当地妹子很多都很独立自信，张扬上进。她们更习惯自己挣钱自己花，而不是张嘴就找男人要钱。都说重庆夫妇幸福指数高，我想那些敢对重庆老婆凶的男人是不存在的，都被拿去烫火锅了。重庆女人漂亮又娇小，率真，不扭扭捏捏，会喝酒，有的也会抽烟。看着泼辣，骨子里却是温柔重情义。走路也会轻轻挽着旁边伴侣的胳膊，另一边吃着喜欢的板栗，一脸的小娇羞。</p>
<p>重庆人习惯加上“儿”话音，“幺儿”、“妈老汉儿”都是个极亲切的称呼，他们还喜欢说叠词，几天玩下来，我都有时候会情不自禁的蹦出来一两个叠词。</p>
<p>最近在看《陆犯焉识》，里面的韩念痕就是重庆人。她美颜主动又性感，在防空洞里她将自己年轻的身体给了主人公陆焉识，但是又骗他他自己已经和一个官员同居了。为什么要骗他，是为了让他嫉妒还是为了让他的占有心安理得？她那在颠倒众生的轻浮外表下，有着纯粹而勇敢的心。后来一边大费周章的调换工作，一边又默默付出无怨无悔。这种勇敢让人心疼，对重庆女人来说，爱是可以当饭吃的。<br><img data-src="/images/%E9%87%8D%E5%BA%86%E6%B1%9F%E8%BE%B9%E5%A4%9C%E6%99%AF.jpg" alt="akb48" title="张同学的手艺，很棒！"></p>
<p>7天的时间里，我大约只玩了重庆的40%，也只吃了重庆的40%，比如南山一棵树和观音桥都没有去，重庆小面、豆花饭这次都没有吃到。重庆是一个非常合格的网红城市，有好吃的又有好玩的也有自己独特的方言和文化。曾经作为中华民国陪都的它留下了不少文化大家的痕迹。虽然由于地理山脉的原因导致目前它的城市规划还不算很和谐，往往在高档CBD旁边还会有一些老破小存在，但是无疑重庆还是有它独特的魅力。那种又辣又甜的魅力，让人心生向往。<br><img data-src="/images/%E6%B1%89%E6%B5%B7%E6%B5%B7%E6%B4%8B%E5%85%AC%E5%9B%AD.JPG" alt="akb48" title="汉海海洋公园的大屏，感谢摄影师张同学，特么的帅我一脸血"></p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>国内旅游</tag>
        <tag>重庆</tag>
      </tags>
  </entry>
  <entry>
    <title>世界杯半决赛前瞻和C罗怎么办</title>
    <url>/2022/12/12/%E9%98%BF%E6%A0%B9%E5%BB%B7%E5%85%8B%E7%BD%97%E5%9C%B0%E4%BA%9A%E5%89%8D%E7%9E%BB%E5%92%8CC%E7%BD%97%E6%80%8E%E4%B9%88%E5%8A%9E/</url>
    <content><![CDATA[<h2 id="阿根廷VS克罗地亚"><a href="#阿根廷VS克罗地亚" class="headerlink" title="阿根廷VS克罗地亚"></a>阿根廷VS克罗地亚</h2><p>这次主要是做一个个人维度的阿根廷VS克罗地亚的猜想，毕竟这俩队伍也是老恩怨了，2018年世界杯他俩小组碰面，克罗地亚揍了阿根廷一个3:0。不过对比上次出场阵容，过了4年两边的人员有了不小的变化。</p>
<p>先说一下阿根廷队比较有危机的地方：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">后防线除了C罗梅罗没高点了，而克罗地亚的佩里西奇可是进过日本队的一个头球的；</span><br><span class="line">阿库尼亚和蒙铁尔禁赛。阿库尼亚的坑让塔利亚菲科去填的话，他是填不了的，比较吃力。不晓得会不会上利马，但是利马的出球能力差了点；</span><br><span class="line">迪玛利亚和德保罗的伤病直接关系到出场时间，这俩人提供的防守硬度和边路攻击能力对阿根廷非常重要；</span><br><span class="line">守门员马丁内斯目前<span class="number">7</span>脚被射中，只扑出去<span class="number">2</span>个，虽然这两个里包括没收了澳大利亚的绝平射门，但是总体的数据并不好，跟对方门将利瓦科维奇的扑救表现有差距；</span><br><span class="line">阿根廷的第二阵容能力比较差，跟第一阵容有明显个人差距。进了加时赛不利；</span><br></pre></td></tr></table></figure></p>
<p>再说一下克罗地亚：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">克罗地亚这个队伍是进攻不如荷兰，如果还拿盯人战术（估计是布罗佐维奇担任这个任务）盯梅西，本身进攻就费劲，这样真就是冲着点球大战去的;</span><br><span class="line">克罗地亚门将利瓦科维奇目前状态如开挂，需要用远射来敲开大门，而不是像巴西一样把时间浪费在中路渗透里，阿根廷的恩佐和梅西都有远射能力;</span><br><span class="line">面具哥格瓦迪奥尔跟洛夫伦的中卫搭配不见得比范戴克和阿克的差，但是他俩面对进攻有点能力的队都丢球了(感谢比利时卢卡库不杀之恩),而且上一轮面对巴西让巴西射中<span class="number">11</span>次，要不是门将开挂，丢<span class="number">3</span>个以上都是少的;</span><br></pre></td></tr></table></figure></p>
<p>而无论是精神属性还是体能储备来说，双方都是同一起跑线。所以说这一场是一个55开的对决，会非常的惨烈沉闷，因为双方都是慢节奏而且反击速度很慢的队伍，都依靠双方金球先生的灵光一现去一击毙命。我个人希望阿根廷90分钟内可以解决战斗，梅西在梅西走廊一脚穿云箭&#x2F;任意球直接破门送克罗地亚去踢季军赛。</p>
<p><img data-src="/images/%E6%A2%85%E8%A5%BF%E5%91%BD%E4%B8%AD%E7%82%B9%E7%90%83.gif" title="煤老板这次能否再次杀入世界杯决赛？"></p>
<h2 id="法国VS摩洛哥"><a href="#法国VS摩洛哥" class="headerlink" title="法国VS摩洛哥"></a>法国VS摩洛哥</h2><p>这还用分析吗？上边阿根廷-克罗地亚是5-5开，这俩就是10-0开。法国90分钟内不锤摩洛哥2个以上，就算摩洛哥赢。</p>
<p>法国这个队伍比较强的是，他不仅可以打现代的边路突突突足球，突突突不好使了，可以沉下心来跟你玩防反以及传统的头球攻门。这又能主动能被动的，的确是剩下四个队伍里唯一的一只存在了。</p>
<h2 id="C罗怎么办"><a href="#C罗怎么办" class="headerlink" title="C罗怎么办"></a>C罗怎么办</h2><p>C罗今年是无比郁闷的一年，先是跟曼联撕破脸皮，然后在世界杯几乎碌碌无为。那边梅西打出了自己世界杯最好表现，这边自己在淘汰赛阶段一共8场比赛0球0助攻。我想C罗的强壮、冲刺跟弹跳肯定是没问题的，他的硬件条件依旧出色。但是他现在无论是接球、盘带还是射门的那一下都是断崖式下滑。他现在无比的依赖中场的传球，而且还要传好球。但是现在就是即使传的是好球，让他可以不用调整直接射门，他都有可能射歪，比如踢韩国的那个头球。</p>
<p>C罗今天心态也不好，他一直有一个很坏的习惯就是踢得不爽了就打人。跟利物浦打过架，走廊打掉球迷手机，前几天跟摩洛哥的比赛第77分钟，回追摩洛哥77号看着追不上了，又动手只不过没打到。这种易燥易怒的心态对他的形象是一个不小的打击。</p>
<p>C罗想借着世界杯翻身的愿望彻底落空了，这届世界杯对他的身价是副作用的。跟梅西不一样，不愿意打替补且逐渐成为射门工具人的他现在的桌子上是很难有欧冠队伍的邀约合同的，哪怕是之前爱他爱的死去活来的切尔西估计都要退避三舍。我觉得C罗想留在五大联赛基本可能很低很低了，回到葡萄牙体育是他目前在欧洲最大的可能，毕竟他没有表示退出国家队，意味他还要挑战2年后的德国欧洲杯，但是他现阶段要付出薪水大打折扣的代价。</p>
<p>至于C罗的历史地位也不用多说了，毕竟人家是5个金球奖，又是欧冠总进球最多、欧冠淘汰赛阶段进球最多、国家队总进球最多等等进球相关霸榜的人，历史地位肯定低不到哪里去。但是梅罗谁更强，这个话题基本可以落下帷幕了。</p>
<h2 id="决赛前的前瞻"><a href="#决赛前的前瞻" class="headerlink" title="决赛前的前瞻"></a>决赛前的前瞻</h2><p>阿根廷3:0在半决赛复仇了克罗地亚挺进决赛，这一次阿根廷的策略是比较成功的，虽然控球率不高，但是几次反击打的非常有效，全场布罗佐维奇、佩里西奇和莫德里奇踢得都是比较郁闷的。小蜘蛛阿尔瓦雷斯抓住了洛夫伦身后的空挡，打入两球，而梅西无需多言，单打面具哥格瓦迪奥尔那个球再一次表现了自己的硬仗能力，这几天在短视频上出圈了。<br><img data-src="/images/%E6%A2%85%E8%A5%BF%E5%8D%95%E6%89%93%E6%A0%BC%E7%93%A6%E8%BF%AA%E5%A5%A5%E5%B0%94.gif" title="煤老板这一套操作让无数媒体人惊呼"></p>
<p>塔利亚菲科等人我开始还对他们有点担心，但是他们今天临危受命表现的非常好。</p>
<p>决赛阿根廷要面对上一次世界杯冠军而且是淘汰了自己的法国队，这支法国队是非常强大的，这一路单场丢球没有超过2个，防守可以说是非常的稳健。在纸面实力上法国无疑要优于阿根廷，而且法国队伍里很多球员都有世界杯夺冠的经验，法国教练德尚也是一个非常务实，肯降身段打防守反击的教练。而且现在很多的外界因素，比如休息、黄牌和斗志，双方都是持平的。</p>
<p>那么阿根廷要战胜法国需要做到如下几点：<br>	 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">不要三后卫，这很重要，拿半决赛赢球的<span class="number">4</span>-<span class="number">4</span>-<span class="number">1</span>-<span class="number">1</span>去对抗法国队，同时中场<span class="number">4</span>个人一字排开，不给法国队<span class="number">45</span>度角起高空球的机会；</span><br><span class="line">敢拿球，把比赛尽可能的踢慢（有反击的好机会肯定是要抓住），让法国队冲不起来，气势凶狠很重要。哪怕进了加时赛也不怕；</span><br><span class="line">敢拿球还有一个好处，就是尽可能的造格里兹曼的犯规，格里兹曼是这个法国队里很重要的一环，他如果背了黄牌，阿根廷会好打很多；</span><br><span class="line">把攻击中心放在他们的左路，也就是姆巴佩那一路，如果法国还是上乌帕梅卡诺，那就攻的更狠一点；</span><br></pre></td></tr></table></figure></p>
<p>决赛这场我预测迪玛利亚是不会首发的，我猜他会作为后补在加时赛里出场。作为这支球队里参加过2014巴西世界杯决赛唯二的老臣，迪玛利亚在今年世界杯的影响力小了很多，但是他出场还是能给阿根廷攻击助力，就像打荷兰的加时赛那样。</p>
<p>而法国它面对阿根廷是有心理优势的，毕竟他们2018年4：3战胜了阿根廷，那场姆巴佩一顿冲给三后卫冲垮了。不过这场有一些细节，这场比赛之前，阿根廷是死磕，最后4分侥幸出线。而法国小组赛最后一轮是大幅度轮换，所以他俩的面对是法国以逸待劳，但是阿根廷那三个进球有个两个是神仙球，所以如果法国那场如果往死里打是可以打进至少5个的。所以法国心里其实并不怕阿根廷，他只要正常发挥，左后卫特奥控制自己的动作幅度，问题就不大。</p>
<p>决赛阿根廷VS法国，也是国际足联和全球球迷非常想看到的一场比赛，阿根廷赢了有很多重大意义，比如时隔20年南美重新夺得世界杯、梅西生涯圆满等等，而如果法国夺冠，他们就成了历史第三支卫冕成功的球队、姆巴佩声名更响甚至有望拿下金球奖。所以让我们期待周日23点的对决，看一下哪个队伍先给自己的球衣正式绣上第三个星星。</p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>足球</tag>
        <tag>世界杯</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云RDS的内存增高与临时表</title>
    <url>/2019/10/11/%E9%98%BF%E9%87%8C%E4%BA%91RDS%E7%9A%84%E5%86%85%E5%AD%98%E5%A2%9E%E9%AB%98%E7%9A%84%E5%8E%9F%E5%9B%A0/</url>
    <content><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>mysql查看当前内存使用细节的语句是：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">show variables where variable_name <span class="keyword">in</span> (</span><br><span class="line"><span class="string">&#x27;innodb_buffer_pool_size&#x27;</span>,<span class="string">&#x27;innodb_log_buffer_size&#x27;</span>,<span class="string">&#x27;innodb_additional_mem_pool_size&#x27;</span>,<span class="string">&#x27;key_buffer_size&#x27;</span>,<span class="string">&#x27;query_cache_size&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>大部分内存占用告警，都是因为<code>buffer pool</code>增长导致，而<code>buffer pool</code>的增长是正常的，如图：<br><img data-src="/images/mysql7.png" alt="akb48"></p>
<p>如果说这个值高的令人发指（超过90%），那么基本就是两种可能：</p>
<ol>
<li>当前session太多，<code>show full processlist；</code>看一下是不是有太多空闲的对话，如果有，酌情调整timeout断开；</li>
<li>session不多，但是session里的私有内存占用过多，那么就要检查一下对应的sql语句，是不是语句里有大量的临时表、sort(排序)和join操作；</li>
</ol>
<p>如何判断是否使用了临时表？使用<code>explain</code>查看执行的sql语句，在Extra列看到<code>Using temporary</code>就意味着使用了临时表。比如这个：<br><img data-src="/images/mysql8.png" alt="akb48"></p>
<p>一般情况下，用到临时表就意味着性能较低。查看临时表大小的语句是<code>show global variables like &#39;%table_size%&#39;;</code>。</p>
<p>如果说某个SQL语句，它查询的内容非常的多（select *这种的），然后又对这个查询的内容进行了二次加工（sort或者join)就会生成一个巨大的临时表，那么内存可能就会放不下，导致mysql将这个表全部放到磁盘里，那么这样mysql的IO就会出现飙升、sql执行缓慢的现象。</p>
<p>查看临时表是在内存还是在磁盘上，可以通过<code>show global status like &#39;%Created_tmp%&#39;;</code>：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MySQL [(none)]&gt;  show <span class="keyword">global</span> status like <span class="string">&#x27;%Created_tmp%&#x27;</span>;</span><br><span class="line">+-------------------------+-----------+</span><br><span class="line">| Variable_name           | Value     |</span><br><span class="line">+-------------------------+-----------+</span><br><span class="line">| Created_tmp_disk_tables | <span class="number">53585768</span>  |			<span class="comment">#服务器在磁盘上创建表（最初或通过转换内存中的表）</span></span><br><span class="line">| Created_tmp_files       | <span class="number">807803</span>    |</span><br><span class="line">| Created_tmp_tables      | <span class="number">167011673</span> |			<span class="comment">#服务器创建内部临时表（在内存或磁盘上）</span></span><br><span class="line">+-------------------------+-----------+</span><br><span class="line"><span class="number">3</span> rows <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>遇到这样的情况，建议是将原语句拆成两个sql，然后用<code>in</code>操作拼接。</p>
<p>最后结论，MYSQL在上线部署后，导致内存激增，请检查是否出现了临时表。临时表如果大出了指定范围，写入到磁盘里，就会导致IO上升，拖垮SQL执行速度。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>在网站开发里，排序究竟是在程序(PHP)里排还是在数据库(mysql)里排？</p>
<p>在 PHP 中执行排序更优的情况举例如下：</p>
<ol>
<li>数据源不在MySQL中，存在硬盘、内存或者来自网络的请求等；</li>
<li>数据存在MySQL中，量不大，而且没有相应的索引，此时把数据取出来用PHP排序更快；</li>
<li>数据源来自于多个MySQL服务器，此时从多个MySQL中取出数据，然后在PHP中排序更快；</li>
<li>除了MySQL之外，存在其他数据源，比如硬盘、内存或者来自网络的请求等，此时不适合把这些数据存入MySQL后再排序。</li>
</ol>
<p>必须在MySQL中排序的实例如下：</p>
<ol>
<li>MySQL中已经存在这个排序的索引；</li>
<li>MySQL中数据量较大，而结果集需要其中很小的一个子集，比如1000000行数据，取TOP10；</li>
<li>对于一次排序、多次调用的情况，比如统计聚合的情形，可以提供给不同的服务使用，那么在MySQL中排序是首选的。另外，对于数据深度挖掘，通常做法是在应用层做完排序等复杂操作，把结果存入MySQL即可，便于多次使用。</li>
<li>不论数据源来自哪里，当数据量大到一定的规模后，由于占用内存的关系，不再适合PHP中排序了；此时把数据复制、导入或者存在MySQL，并用INDEX优化，是优于PHP的。不过，用Java，甚至C++ 来处理这类操作会更好。</li>
</ol>
<p>结论：从网站整体考虑，就必须加入人力和成本的考虑。假如网站规模和负载较小，而人力有限（人数和能力都可能有限），此时在应用层（PHP）做排序要做不少开发和调试工作，耗费时间，得不偿失；不如在 DB 中处理，简单快速。对于大规模的网站，电力、服务器的费用很高，在系统架构上精打细算，可以节约大量的费用，是公司持续发展之必要；此时如果能在应用层 (PHP) 进行排序并满足业务需求，尽量在应用层进行。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://dp.imysql.com:8080/node/97">https://dp.imysql.com:8080/node/97</a><br><a href="http://mysql.taobao.org/monthly/2019/04/01/">http://mysql.taobao.org/monthly/2019/04/01/</a><br><a href="http://blog.sae.sina.com.cn/archives/4096">http://blog.sae.sina.com.cn/archives/4096</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>阿里云</tag>
        <tag>RDS</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云Centos7开启swap虚拟内存</title>
    <url>/2018/08/13/%E9%98%BF%E9%87%8C%E4%BA%91Centos7%E5%BC%80%E5%90%AFswap%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<p>出差归来，几个开发反馈说gitlab网页卡的不行，上传代码也非常吃力。我登入服务器一看，原来是内存已经耗尽了。</p>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>gitlab本身就是一个特别吃内存的软件，服务器还是2核4G的配置。于是我就登陆到gitlab容器里，修改一下<code>/etc/gitlab/gitlab.rb</code>，把<code>unicorn[&#39;worker_processes&#39;]</code>手动改成了3，也就是比CPU大一个，这样可以少开一点进程。但是注意，这个参数最小值是2，如果设置成1，那么gitlab就会崩坏。</p>
<p>保存文件之后，<code>gitlab-ctl reconfigure</code>，看一下内存的情况，嗯，比刚才好一点点。如图：<br><img data-src="/images/swap1.png" alt="paradin"></p>
<h2 id="开启虚拟内存"><a href="#开启虚拟内存" class="headerlink" title="开启虚拟内存"></a>开启虚拟内存</h2><p>上面那个方法毕竟效果有限，时间长了还是会把内存一点点蚕食光，于是就要使用Swap分区，但是阿里云虚拟服务器默认是不带swap分区的，如何手动创建swap分区才是本文的要点。</p>
<p>这里我用了一个非生产环境的机器做实验。</p>
<p>创建swap分区主要的中心思想就是“创建一个文件，然后将这块文件格式化为swap格式”，首先先看一下当前的磁盘容量：<br><img data-src="/images/swap2.png" alt="paradin"></p>
<p>当前已用磁盘容量是16G，使用<code>cat /proc/swaps</code>看一下当前虚拟内存的情况：<br><img data-src="/images/swap3.png" alt="paradin"></p>
<p>这个情况说明没开启swap，于是就手动建立一个文件夹，比如叫&#x2F;swaps，在&#x2F;swaps这个路径下执行<code>dd if=/dev/zero of=swaps bs=512 count=8388616</code>，在这里创建swap大小为bs*count&#x3D;4294971392(4G)，这个过程需要一点时间，稍等片刻：<br><img data-src="/images/swap4.png" alt="paradin"></p>
<p>通过<code>mkswap swaps</code>命令将上面新建出的swaps文件做成swap分区：<br><img data-src="/images/swap5.png" alt="paradin"></p>
<p>此时使用<code>cat /proc/sys/vm/swappiness</code>查看数值应该是0，需要<code>sysctl -w vm.swappiness=60</code>把它改成60，这里60的含义是：100%-60%&#x3D;40%，即物理内存剩下40%的时候时启用虚拟内存。若想永久修改，则编辑<code>/etc/sysctl.conf</code>文件，改文件中有<code>vm.swappiness</code>变量配置。</p>
<p>再<code>swapon /swaps/swaps</code>：<br><img data-src="/images/swap6.png" alt="paradin"></p>
<p>最后就是添加开机自动挂载，即在<code>/etc/fstab</code>文件添加如下一句：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/swaps/swaps  swap      swap    defaults   <span class="number">0</span>       <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>再用<code>cat /proc/swaps</code>命令检查一下swap分区是否启动：<br><img data-src="/images/swap7.png" alt="paradin"></p>
<p>最后，重启一下服务器，看一下开机是否正常挂载上这个虚拟分区了：<br><img data-src="/images/swap8.png" alt="paradin"></p>
<p>可见原来使用了16G容量，现在用了20G，这中间差的4G就是拿来做了swap，于是内存就这样多了4个G…</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
        <tag>虚拟内存</tag>
        <tag>阿里云服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云centos7升级内核到4.17过程</title>
    <url>/2018/06/11/%E9%98%BF%E9%87%8C%E4%BA%91centos7%E5%8D%87%E7%BA%A7%E5%86%85%E6%A0%B8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>docker对内核的支持要求很高，详情可以看：<a href="https://www.szyhf.org/2017/01/07/%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%8Ecentos%E5%86%85%E6%A0%B8%E9%97%AE%E9%A2%98/#comment-54">https://www.szyhf.org/2017/01/07/%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%8Ecentos%E5%86%85%E6%A0%B8%E9%97%AE%E9%A2%98/#comment-54</a> 。文中也有阿里云容器的工程师亲自回复的升级内核的方法，不过他那套是升级内核到<code>4.4</code>，现在已经是<code>4.17</code>了，这里写一下如何升级到最新内核的过程。</p>
<p>而阿里云默认的centos7的内核是3.10的，如图：<br><img data-src="/images/neihe1.png" alt="paradin"></p>
<p>首先，安装elrepo的yum源，命令如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[root@iZ23pg8sy5bZ ~]#rpm --<span class="keyword">import</span> <span class="attr">https</span>:<span class="comment">//www.elrepo.org/RPM-GPG-KEY-elrepo.org</span></span><br><span class="line">[root@iZ23pg8sy5bZ ~]#rpm -<span class="title class_">Uvh</span> <span class="attr">http</span>:<span class="comment">//www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm                                                  </span></span><br><span class="line"><span class="title class_">Retrieving</span> <span class="attr">http</span>:<span class="comment">//www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm</span></span><br><span class="line"><span class="title class_">Retrieving</span> <span class="attr">http</span>:<span class="comment">//elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm</span></span><br><span class="line"><span class="title class_">Preparing</span>...                          ################################# [<span class="number">100</span>%]</span><br><span class="line"><span class="title class_">Updating</span> / installing...</span><br><span class="line">   <span class="number">1</span>:elrepo-release-<span class="number">7.0</span>-<span class="number">3.</span>el7.<span class="property">elrepo</span>  ################################# [<span class="number">100</span>%]</span><br></pre></td></tr></table></figure></p>
<p>其次是安装最新的内核，命令是<code>yum -y --enablerepo=elrepo-kernel install kernel-ml</code>，如果是要安装长期支持的内核，命令是<code>yum –enablerepo=elrepo-kernel -y install kernel-lt</code>，在一顿噼里啪啦之后，就会出现如下的字样，提示我们已经安装了4.17的kernel内核了：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Downloading packages:</span><br><span class="line">kernel-ml-4.17.0-1.el7.elrepo.x86_64.rpm                                                                                                                                   |  45 MB  00:00:03     </span><br><span class="line">Running transaction check</span><br><span class="line">Running transaction test</span><br><span class="line">Transaction test succeeded</span><br><span class="line">Running transaction</span><br><span class="line">Warning: RPMDB altered outside of yum.</span><br><span class="line">  Installing : kernel-ml-4.17.0-1.el7.elrepo.x86_64                                                                                                                                           1/1 </span><br><span class="line"> 	Verifying  : kernel-ml-4.17.0-1.el7.elrepo.x86_64                                                                                                                                           1/1 </span><br><span class="line">Installed:</span><br><span class="line"> 	kernel-ml.x86_64 0:4.17.0-1.el7.elrepo                                                                                                                                                          </span><br><span class="line">Complete!</span><br></pre></td></tr></table></figure></p>
<p>centos7内核升级完毕后，还需要我们修改内核的启动顺序，<code>vim /etc/default/grub</code>，修改一处地方：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRUB_TIMEOUT=5</span><br><span class="line">GRUB_DISTRIBUTOR=&quot;$(sed &#x27;s, release .*$,,g&#x27; /etc/system-release)&quot;</span><br><span class="line">GRUB_DEFAULT=saved		#把这里的saved改成0</span><br><span class="line">GRUB_DISABLE_SUBMENU=true</span><br><span class="line">GRUB_TERMINAL_OUTPUT=&quot;console&quot;</span><br><span class="line">GRUB_CMDLINE_LINUX=&quot;crashkernel=auto rhgb quiet net.ifnames=0&quot;</span><br><span class="line">GRUB_DISABLE_RECOVERY=&quot;true&quot;</span><br><span class="line">~</span><br></pre></td></tr></table></figure></p>
<p>接下来还需要运行<code>grub2-mkconfig</code>命令来重新创建内核配置，命令是<code>grub2-mkconfig -o /boot/grub2/grub.cfg</code>，如下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Generating grub configuration file ...</span><br><span class="line">Found linux image: /boot/vmlinuz-4.17.0-1.el7.elrepo.x86_64</span><br><span class="line">Found initrd image: /boot/initramfs-4.17.0-1.el7.elrepo.x86_64.img</span><br><span class="line">Found linux image: /boot/vmlinuz-3.10.0-693.2.2.el7.x86_64</span><br><span class="line">Found initrd image: /boot/initramfs-3.10.0-693.2.2.el7.x86_64.img</span><br><span class="line">Found linux image: /boot/vmlinuz-3.10.0-693.el7.x86_64</span><br><span class="line">Found initrd image: /boot/initramfs-3.10.0-693.el7.x86_64.img</span><br><span class="line">Found linux image: /boot/vmlinuz-0-rescue-f0f31005fb5a436d88e3c6cbf54e25aa</span><br><span class="line">Found initrd image: /boot/initramfs-0-rescue-f0f31005fb5a436d88e3c6cbf54e25aa.img</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>执行完毕之后，回到阿里云控制台重启一下这个机器，然后查看一下内核情况：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">uname -r</span><br><span class="line"><span class="number">4.17</span><span class="number">.0</span>-<span class="number">1.</span>el7.<span class="property">elrepo</span>.<span class="property">x86_64</span></span><br></pre></td></tr></table></figure></p>
<p><img data-src="/images/ronaldogoal1.gif" alt="akb48" title="罗纳尔多在98年世界杯半决赛对荷兰的进球"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title>centos服务器更改系统时间</title>
    <url>/2018/01/25/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9B%B4%E6%94%B9%E6%97%B6%E5%8C%BA%E4%B8%BAutc/</url>
    <content><![CDATA[<h2 id="将时区改为utc"><a href="#将时区改为utc" class="headerlink" title="将时区改为utc"></a>将时区改为utc</h2><p>开发提出需求说，某个模块是给洋人使用，于是把阿里云服务器里的时间改成UTC时间。我登陆到服务器里使用<code>date</code>查看了一下，发现目前使用的是东八区时间，如图：<br><img data-src="/images/time1.png" alt="goodbye,Kobe"></p>
<p>首先先开启UTC，方法就是在<code>/etc/sysconfig/clock</code>的文件里修改这样一处：<code>UTC=true</code>。这样即使机器重启，UTC时间依旧会“<code>BIOS ▶ UTC时区转换 ▶ 系统时间</code>”的顺序正常使用。</p>
<p>在Centos 6.5里，各时区的时间是在一个叫<code>/usr/share/zoneinfo/</code>的文件夹下，在里面我们发现了我们的目标—-<code>UTC</code>，如图：<br><img data-src="/images/time2.png" alt="goodbye,Kobe"></p>
<p>然后就是修改，方法如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mv /etc/localtime /etc/localtime-bak</span><br><span class="line">ln -s /usr/share/zoneinfo/<span class="variable constant_">UTC</span> /etc/localtime</span><br></pre></td></tr></table></figure></p>
<p>先把老的时间文件备份，然后把UTC文件做一个软连接过来即可。我们所熟悉的<code>date</code>命令就是<code>/etc/localtime</code>的输出结果。</p>
<p>现在去<code>date</code>一下，看看结果，果然改成了<code>UTC</code>：<br><img data-src="/images/time3.png" alt="goodbye,Kobe"></p>
<p>这个时候，如果你服务器里装的是nginx的话，就会发现nginx日志里的时间也会变成<code>UTC</code>而不会再是<code>CST</code>了。</p>
<h2 id="更改系统时间"><a href="#更改系统时间" class="headerlink" title="更改系统时间"></a>更改系统时间</h2><p>云服务器一般来说系统时间都是正确的，但是自己的服务器可能在安装系统之后的时间是不统一的，这样可能在集群里就会出问题。时间同步的步骤如下：<br>	<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y ntpdate		#下载ntp同步工具</span><br><span class="line">mv /etc/localtime /etc/localtime-bak		#备份原有文件</span><br><span class="line">cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime		#时区调整为上海</span><br><span class="line">ntpdate us.pool.ntp.org		#与时区服务器同步时间</span><br></pre></td></tr></table></figure></p>
<p>然后在crontab里添加一个每10分钟同步时间的命令：<code>*/10 * * * * /usr/sbin/ntpdate us.pool.ntp.org | logger -t NTP</code>。</p>
<p>如果服务器是没有公网的，那么也就无法下载ntpdate，此时只能用<code>date -s</code>命令手动更改时间，比如：<code>date -s 23:40:00</code>、<code>date -s 20180703</code>。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云获取DTS服务延迟值的脚本</title>
    <url>/2018/02/24/%E9%98%BF%E9%87%8C%E4%BA%91%E8%8E%B7%E5%8F%96DTS%E6%9C%8D%E5%8A%A1%E5%BB%B6%E8%BF%9F%E7%9A%84%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>春节“嗖”的一下就过完了，在年前领导交代另一个任务，想要每天统计一下在阿里云DTS（数据同步）服务的延迟情况，于是我就要使用阿里云的api去写一个脚本，每小时运行一次，然后将这24个数字输出出来给领导过目。</p>
<p>阿里云dts的sdk包在这里：<a href="https://help.aliyun.com/document_detail/57694.html?spm=a2c4g.11186623.6.675.W811bN">https://help.aliyun.com/document_detail/57694.html?spm=a2c4g.11186623.6.675.W811bN</a> ，直接点击<code>Python</code>下载即可，不过这个地址经我测试使用非国内IP 地址是打不开的，需要使用国内IP地址下载。</p>
<p>下载完毕之后，上传到linux服务器并解压，解压后的样子如图：<br><img data-src="/images/dts1.png" alt="paradin"></p>
<p>由于我们这次只是查看同步作业状态，所用的py就是<code>DescribeSynchronizationJobStatusRequest.py</code>，现在我们就可以写脚本，假设这个脚本叫<code>getDTS.py</code>,那么整个内容如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/usr/</span>bin/env python</span><br><span class="line">#coding=utf-<span class="number">8</span></span><br><span class="line">#<span class="attr">auther</span>:<span class="title class_">ChrisChan</span>@<span class="number">2018</span>-<span class="number">2</span>-<span class="number">24</span></span><br><span class="line">#这个脚本是用来获取<span class="variable constant_">DTS</span>服务的延迟值</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore <span class="keyword">import</span> client</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.<span class="property">acs_exception</span>.<span class="property">exceptions</span> <span class="keyword">import</span> <span class="title class_">ClientException</span></span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.<span class="property">acs_exception</span>.<span class="property">exceptions</span> <span class="keyword">import</span> <span class="title class_">ServerException</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> sys	#由于这个包不是通过pip install的方式安装,要调用其它路径的python脚本就要使用sys方法</span><br><span class="line">sys.<span class="property">path</span>.<span class="title function_">append</span>(<span class="string">&#x27;sdk压缩包的绝对路径&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">DescribeSynchronizationJobStatusRequest</span>	</span><br><span class="line"></span><br><span class="line"># 创建<span class="title class_">Client</span>实例</span><br><span class="line">clt = client.<span class="title class_">AcsClient</span>(<span class="string">&#x27;阿里云AK&#x27;</span>,<span class="string">&#x27;阿里云SK&#x27;</span>,<span class="string">&#x27;所属地域&#x27;</span>)</span><br><span class="line"></span><br><span class="line"># 创建request并设置参数</span><br><span class="line">request = <span class="title class_">DescribeSynchronizationJobStatusRequest</span>.<span class="title class_">DescribeSynchronizationJobStatusRequest</span>()</span><br><span class="line">request.<span class="title function_">set_accept_format</span>(<span class="string">&#x27;json&#x27;</span>)</span><br><span class="line"></span><br><span class="line"># 写上对应的服务<span class="variable constant_">ID</span></span><br><span class="line">request.<span class="title function_">set_SynchronizationJobId</span>(<span class="string">&quot;这里写上DTS的ID&quot;</span>)</span><br><span class="line"></span><br><span class="line">response = clt.<span class="title function_">do_action_with_exception</span>(request)</span><br><span class="line">print response</span><br><span class="line">delay = json.<span class="title function_">loads</span>(response)</span><br><span class="line">print <span class="string">&quot;====================================================&quot;</span></span><br><span class="line">print <span class="string">&quot;当前延迟是：&quot;</span> + <span class="title function_">str</span>(delay[<span class="string">&quot;DataSynchronizationStatus&quot;</span>][<span class="string">&quot;Delay&quot;</span>])</span><br><span class="line">print <span class="string">&quot;当前同步速度是：&quot;</span> + <span class="title function_">str</span>(delay[<span class="string">&quot;Performance&quot;</span>][<span class="string">&quot;FLOW&quot;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>整个脚本执行的效果如下：<br><img data-src="/images/dts2.png" alt="paradin"></p>
<p>dts的延迟时间是5秒计算一次，API请求会取到最新的延迟时间，控制台是每隔20秒才刷新一次。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><code>getDTS.py</code>这个脚本获取到的<code>response</code>是一个str字符串，这里我使用<code>json.loads</code>来将其转化成了<code>dict</code>模式。但是除了这个方法还有两个方法：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; user</span><br><span class="line"><span class="string">&quot;&#123;&#x27;name&#x27; : &#x27;jim&#x27;, &#x27;sex&#x27; : &#x27;male&#x27;, &#x27;age&#x27;: 18&#125;&quot;</span></span><br><span class="line">&gt;&gt;&gt; b=<span class="built_in">eval</span>(user)</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;jim&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;</span><br><span class="line">&gt;&gt;&gt; print b[<span class="string">&#x27;sex&#x27;</span>]</span><br><span class="line">male</span><br><span class="line">&gt;&gt;&gt; <span class="title function_">exec</span>(<span class="string">&quot;c=&quot;</span>+user)</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;jim&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;	</span><br><span class="line">&gt;&gt;&gt; print c[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">jim</span><br></pre></td></tr></table></figure></p>
<p><font color=red>但是要注意！上面这两个方法有一定的安全隐患，而且只能全是字符串可用，如果有的<code>value</code>是<code>True</code>、<code>False</code>、<code>Null</code>这样的字眼的话，<code>eval</code>是不支持的，所以没法正确转换，就会爆这样的错：<code>NameError: name &#39;True&#39; is not defined</code>。</font></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://help.aliyun.com/document_detail/49453.html?spm=a2c4g.11186623.6.667.sRyVqY">https://help.aliyun.com/document_detail/49453.html?spm=a2c4g.11186623.6.667.sRyVqY</a><br><a href="https://segmentfault.com/q/1010000000174694">https://segmentfault.com/q/1010000000174694</a><br><a href="https://www.crifan.com/resolved_in_python_using_eval_to_force_variable_to_convert_a_string_to_a_dictionary_when_the_error_nameerror_name_39null39_is_not_defined/">https://www.crifan.com/resolved_in_python_using_eval_to_force_variable_to_convert_a_string_to_a_dictionary_when_the_error_nameerror_name_39null39_is_not_defined/</a><br><a href="https://segmentfault.com/q/1010000000345915">https://segmentfault.com/q/1010000000345915</a><br><img data-src="/images/suyaleisi.jpg" alt="paradin" title="状态越来越好~"></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云购买、启动、停止ecs等等操作的python脚本</title>
    <url>/2018/01/24/%E9%98%BF%E9%87%8C%E4%BA%91%E8%B4%AD%E4%B9%B0%E3%80%81%E5%90%AF%E5%8A%A8%E3%80%81%E5%81%9C%E6%AD%A2ecs%E7%9A%84python%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>以下所有脚本都是在python 2.7的环境亲自测试的。<br>阿里云的ak&#x2F;sk是没有地域概念的，在任何地域都可以使用。</p>
<h2 id="购买服务器"><a href="#购买服务器" class="headerlink" title="购买服务器"></a>购买服务器</h2><p>以在新加坡购买服务器为例子：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/usr/</span>bin/env python</span><br><span class="line">#coding=utf-<span class="number">8</span></span><br><span class="line">#注意！服务器创建完毕之后，状态是关机的。</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore <span class="keyword">import</span> client</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.<span class="property">acs_exception</span>.<span class="property">exceptions</span> <span class="keyword">import</span> <span class="title class_">ClientException</span></span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.<span class="property">acs_exception</span>.<span class="property">exceptions</span> <span class="keyword">import</span> <span class="title class_">ServerException</span></span><br><span class="line"><span class="keyword">from</span> aliyunsdkecs.<span class="property">request</span>.<span class="property">v20140526</span> <span class="keyword">import</span> <span class="title class_">CreateInstanceRequest</span></span><br><span class="line"># 创建 <span class="title class_">Client</span> 实例</span><br><span class="line">clt = client.<span class="title class_">AcsClient</span>(<span class="string">&#x27;阿里云ak&#x27;</span>,<span class="string">&#x27;阿里云sk&#x27;</span>,<span class="string">&#x27;新加坡的地域&#x27;</span>)		#各地域的缩写请看：<span class="attr">https</span>:<span class="comment">//help.aliyun.com/document_detail/40654.html?spm=5176.doc25499.2.14.yh6n8c</span></span><br><span class="line"></span><br><span class="line"># 创建 request，并设置参数</span><br><span class="line">request = <span class="title class_">CreateInstanceRequest</span>.<span class="title class_">CreateInstanceRequest</span>()</span><br><span class="line"></span><br><span class="line"># 设置<span class="variable constant_">ECS</span>细节</span><br><span class="line">request.<span class="title function_">set_ImageId</span>(<span class="string">&quot;centos_7_04_64_20G_alibase_201701015.vhd&quot;</span>)	#这里是镜像</span><br><span class="line">request.<span class="title function_">set_InstanceName</span>(<span class="string">&quot;xjp-test-001&quot;</span>)		#这里写名称xjp-test-<span class="number">001</span></span><br><span class="line">request.<span class="title function_">set_SecurityGroupId</span>(<span class="string">&quot;sg-23t6c6mjw&quot;</span>)		#这里是安全组</span><br><span class="line">request.<span class="title function_">set_Password</span>(<span class="string">&quot;W2.bi7FX1dyb)T3Wh^,[&quot;</span>)	#这里是密码，推荐使用https传输，安全</span><br><span class="line">request.<span class="title function_">set_InstanceChargeType</span>(<span class="string">&quot;PrePaid&quot;</span>)	#确定是包年包月</span><br><span class="line">request.<span class="title function_">set_Period</span>(<span class="string">&quot;2&quot;</span>)		#先买两个月的</span><br><span class="line">request.<span class="title function_">set_SystemDiskCategory</span>(<span class="string">&quot;cloud_efficiency&quot;</span>)	#注意，如果是海外的机器的话，要额外说明，海外的机器只有高速云盘和<span class="variable constant_">SSD</span>盘</span><br><span class="line"></span><br><span class="line"># 设置实例规格</span><br><span class="line">request.<span class="title function_">set_InstanceType</span>(<span class="string">&quot;ecs.s2.large&quot;</span>)</span><br><span class="line"></span><br><span class="line"># 发起 <span class="variable constant_">API</span> 请求并打印返回</span><br><span class="line">response = clt.<span class="title function_">do_action_with_exception</span>(request)</span><br><span class="line">print response</span><br></pre></td></tr></table></figure></p>
<h2 id="服务器停机"><a href="#服务器停机" class="headerlink" title="服务器停机"></a>服务器停机</h2><p>停止ECS的脚本如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/usr/</span>bin/env python</span><br><span class="line">#coding=utf-<span class="number">8</span></span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore <span class="keyword">import</span> client</span><br><span class="line"><span class="keyword">from</span> aliyunsdkecs.<span class="property">request</span>.<span class="property">v20140526</span> <span class="keyword">import</span> <span class="title class_">StopInstanceRequest</span></span><br><span class="line">list1 = [<span class="string">&#x27;要停机的ecs id1&#x27;</span>,<span class="string">&#x27;要停机的ecs id2&#x27;</span>,<span class="string">&#x27;要停机的ecs id3&#x27;</span>...]</span><br><span class="line"></span><br><span class="line">clt = client.<span class="title class_">AcsClient</span>(<span class="string">&#x27;阿里云ak&#x27;</span>,<span class="string">&#x27;阿里云sk&#x27;</span>,<span class="string">&#x27;地域名&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="attr">list1</span>:</span><br><span class="line">       shutdown = <span class="title class_">StopInstanceRequest</span>.<span class="title class_">StopInstanceRequest</span>()</span><br><span class="line">       shutdown.<span class="title function_">set_InstanceId</span>(i)</span><br><span class="line">       action = clt.<span class="title function_">do_action_with_exception</span>(shutdown)</span><br><span class="line">       print <span class="string">&quot;现在停机:&quot;</span> + i</span><br><span class="line">       print action</span><br></pre></td></tr></table></figure></p>
<h2 id="服务器启动"><a href="#服务器启动" class="headerlink" title="服务器启动"></a>服务器启动</h2><p>启动ECS的脚本如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/usr/</span>bin/env python</span><br><span class="line">#coding=utf-<span class="number">8</span></span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore <span class="keyword">import</span> client</span><br><span class="line"><span class="keyword">from</span> aliyunsdkecs.<span class="property">request</span>.<span class="property">v20140526</span> <span class="keyword">import</span> <span class="title class_">StartInstanceRequest</span></span><br><span class="line">list = [<span class="string">&#x27;要停机的ecs id1&#x27;</span>,<span class="string">&#x27;要停机的ecs id2&#x27;</span>,<span class="string">&#x27;要停机的ecs id3&#x27;</span>...]</span><br><span class="line"></span><br><span class="line">clt = client.<span class="title class_">AcsClient</span>(<span class="string">&#x27;阿里云ak&#x27;</span>,<span class="string">&#x27;阿里云sk&#x27;</span>,<span class="string">&#x27;地域名&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="attr">list</span>:</span><br><span class="line">       start = <span class="title class_">StartInstanceRequest</span>.<span class="title class_">StartInstanceRequest</span>()</span><br><span class="line">       start.<span class="title function_">set_InstanceId</span>(i)</span><br><span class="line">       action = clt.<span class="title function_">do_action_with_exception</span>(start)</span><br><span class="line">       print <span class="string">&quot;现在启动:&quot;</span> + i</span><br><span class="line">       print action</span><br></pre></td></tr></table></figure></p>
<h2 id="查询阿里云镜像"><a href="#查询阿里云镜像" class="headerlink" title="查询阿里云镜像"></a>查询阿里云镜像</h2><p>查询ECS镜像的脚本如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/usr/</span>bin/env python</span><br><span class="line">#coding=utf-<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore <span class="keyword">import</span> client</span><br><span class="line"><span class="keyword">from</span> aliyunsdkecs.<span class="property">request</span>.<span class="property">v20140526</span> <span class="keyword">import</span> <span class="title class_">DescribeImagesRequest</span></span><br><span class="line"><span class="keyword">import</span> aliyunsdkcore.<span class="property">request</span></span><br><span class="line"></span><br><span class="line">clt = client.<span class="title class_">AcsClient</span>(<span class="string">&#x27;阿里云ak&#x27;</span>,<span class="string">&#x27;阿里云sk&#x27;</span>,<span class="string">&#x27;地域名&#x27;</span>)</span><br><span class="line"></span><br><span class="line">request = <span class="title class_">DescribeImagesRequest</span>.<span class="title class_">DescribeImagesRequest</span>()</span><br><span class="line">request.<span class="title function_">set_accept_format</span>(<span class="string">&#x27;json&#x27;</span>)</span><br><span class="line"></span><br><span class="line"># 发起请求</span><br><span class="line">response = clt.<span class="title function_">do_action_with_exception</span>(request)</span><br><span class="line">print response</span><br></pre></td></tr></table></figure></p>
<h2 id="查询服务器规格"><a href="#查询服务器规格" class="headerlink" title="查询服务器规格"></a>查询服务器规格</h2><p>查询ECS规格的脚本如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/usr/</span>bin/env python</span><br><span class="line">#coding=utf-<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore <span class="keyword">import</span> client</span><br><span class="line"><span class="keyword">from</span> aliyunsdkecs.<span class="property">request</span>.<span class="property">v20140526</span> <span class="keyword">import</span> <span class="title class_">DescribeInstanceTypesRequest</span></span><br><span class="line"><span class="keyword">import</span> aliyunsdkcore.<span class="property">request</span></span><br><span class="line"></span><br><span class="line">clt = client.<span class="title class_">AcsClient</span>(<span class="string">&#x27;阿里云ak&#x27;</span>,<span class="string">&#x27;阿里云sk&#x27;</span>,<span class="string">&#x27;地域名&#x27;</span>)</span><br><span class="line"></span><br><span class="line">request = <span class="title class_">DescribeInstanceTypesRequest</span>.<span class="title class_">DescribeInstanceTypesRequest</span>()</span><br><span class="line">request.<span class="title function_">set_accept_format</span>(<span class="string">&#x27;json&#x27;</span>)</span><br><span class="line"></span><br><span class="line"># 发起请求</span><br><span class="line">response = clt.<span class="title function_">do_action_with_exception</span>(request)</span><br><span class="line">print response</span><br></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://help.aliyun.com/document_detail/25499.html?spm=5176.doc25501.6.857.wR0MHP">https://help.aliyun.com/document_detail/25499.html?spm=5176.doc25501.6.857.wR0MHP</a></p>
<p><img data-src="/images/xiaomage.jpg" alt="小马哥" title="GOOD LUCK AND THANK U,Masche."></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>阿里云api</tag>
      </tags>
  </entry>
  <entry>
    <title>Django前端输入变量通过内部脚本加工返回前端展示之六</title>
    <url>/2018/12/03/%E9%A1%B5%E9%9D%A2%E5%B1%80%E9%83%A8%E5%88%B7%E6%96%B0%E5%BE%97%E5%88%B0AES%E5%8A%A0%E5%AF%86%E5%80%BC/</url>
    <content><![CDATA[<h2 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h2><p>python：<code>3.6.5</code><br>Django：<code>2.1.1</code><br>Project：<code>Kubernetes</code>，文件夹路径就是<code>/django/Kubernetes/</code><br>App：<code>createyaml</code>，文件夹路径就是<code>/django/Kubernetes/createyaml</code><br>前文地址：<a href="https://rorschachchan.github.io/2018/11/29/Django%E4%B8%8EJquery%E3%80%81Ajax%E7%9A%84%E8%81%94%E5%90%88%E8%BF%90%E7%94%A8/">https://rorschachchan.github.io/2018/11/29/Django%E4%B8%8EJquery%E3%80%81Ajax%E7%9A%84%E8%81%94%E5%90%88%E8%BF%90%E7%94%A8/</a></p>
<h2 id="需求说明以及实现思路"><a href="#需求说明以及实现思路" class="headerlink" title="需求说明以及实现思路"></a>需求说明以及实现思路</h2><p>原来通过前端输入值到后台脚本执行结果再反回页面是这样的：<br><img data-src="/images/django24.gif" alt="akb48"></p>
<p>现在接触了<code>jQuery+ajax</code>，那么就可以使用<code>局部刷新</code>来让界面变的更加友好。</p>
<p>我们在页面里配置了<code>ajax</code>，也要在<code>views.py</code>里配置<code>request.POST.get</code>，但是要注意，执行顺序是先执行<code>ajax</code>后执行<code>request.POST.get</code>，也就是说<code>request.POST.get</code>得到的是<code>ajax</code>加工过的值。如果是json字符串，就加一个<code>dataType:&#39;json&#39;</code>说明一下。</p>
<p>如果是一般的form表单形式，那么ajax的data部分可以这么写：<br>	<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: url,</span><br><span class="line">    data: &#123;</span><br><span class="line">        limit: 10</span><br><span class="line">    &#125;,</span><br><span class="line">    type: &#x27;post&#x27;,</span><br><span class="line">    dataType: &#x27;json&#x27;</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure></p>
<p>如果是直接发送一个json字符串到服务器，那么就要这么写：<br>	<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: url,</span><br><span class="line">    data: JSON.stringify(&#123;</span><br><span class="line">        limit: 10</span><br><span class="line">    &#125;),</span><br><span class="line">    type: &#x27;post&#x27;,</span><br><span class="line">    dataType: &#x27;json&#x27;,</span><br><span class="line">    contentType: &#x27;text/plain&#x27;</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure></p>
<p>更多的使用方法可以去<a href="https://www.haorooms.com/post/jquery_ajax_wg">https://www.haorooms.com/post/jquery_ajax_wg</a> 观摩一番。</p>
<h2 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h2><p>前端文件<code>encrypt.html</code>内容如下：<br>	<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends &#x27;base.html&#x27; %&#125;		</span><br><span class="line">&#123;% block title %&#125;</span><br><span class="line">        AES加密</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">                &#123;% csrf_token %&#125;</span><br><span class="line">                <span class="tag">&lt;<span class="name">h2</span>&gt;</span>AES加密<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>				//将原来的form都取消了</span><br><span class="line">                要加密的字段：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&#x27;word&#x27;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span>&gt;</span>查询加密结果<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;ask&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">h2</span>&gt;</span>这里是结果<span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>		//设定id=ask，那么下面也要说明ask的div是要被局部刷新的</span><br><span class="line">                <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                        $(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                                $(<span class="string">&quot;button&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;  </span></span><br><span class="line"><span class="language-javascript">                                <span class="keyword">var</span> keyword=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;word&#x27;</span>).<span class="property">value</span> 	<span class="comment">//获取输入框的值，即name</span></span></span><br><span class="line"><span class="language-javascript">                                        $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">                                        <span class="attr">type</span>:<span class="string">&quot;POST&quot;</span>,	<span class="comment">//指定方法是POST，如果不说明就是GET</span></span></span><br><span class="line"><span class="language-javascript">                                        <span class="attr">url</span>:<span class="string">&quot;&#123;% url &quot;</span>get_encrypt<span class="string">&quot; %&#125;&quot;</span>,   	<span class="comment">//目标url就是get_encrypt函数结果          </span></span></span><br><span class="line"><span class="language-javascript">                                        <span class="attr">data</span>:&#123;<span class="attr">word</span>:keyword&#125;,         <span class="comment">//规定name等于上面那个id，然后传递参数给django的views.py </span></span></span><br><span class="line"><span class="language-javascript">                                        <span class="attr">success</span>:<span class="keyword">function</span>(<span class="params">result</span>)&#123;$(<span class="string">&quot;#ask&quot;</span>).<span class="title function_">html</span>(result);&#125;	<span class="comment">//返回get_encrypt函数结果</span></span></span><br><span class="line"><span class="language-javascript">                                        &#125;);</span></span><br><span class="line"><span class="language-javascript">                                &#125;);</span></span><br><span class="line"><span class="language-javascript">                        &#125;);</span></span><br><span class="line"><span class="language-javascript">                </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>urls.py</code>对应的部分如下：<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">path</span>(r<span class="string">&#x27;encrypt/&#x27;</span>,views.<span class="property">encrypt</span>,name=<span class="string">&#x27;encrypt&#x27;</span>),</span><br><span class="line"><span class="title function_">path</span>(r<span class="string">&#x27;get_encrypt/&#x27;</span>,views.<span class="property">get_encrypt</span>,name=<span class="string">&#x27;get_encrypt&#x27;</span>),		#这个是展示结果对应的函数</span><br></pre></td></tr></table></figure></p>
<p><code>views.py</code>对应的部分如下：<br>	<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">默认部分略</span><br><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">request</span>):</span><br><span class="line">	<span class="keyword">return</span> render(request,<span class="string">&#x27;encrypt.html&#x27;</span>)	<span class="comment">#请求encrypt就是展示encrypt.html页面</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@csrf_exempt		</span><span class="comment">#POST不检查csrf，正式环境不要这么用</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_encrypt</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        word = request.POST.get(<span class="string">&#x27;word&#x27;</span>)	<span class="comment">#获取到name值，这个name是ajax加工过的</span></span><br><span class="line">        result = (<span class="string">&quot;加密的结果是：&quot;</span>+<span class="built_in">list</span>(subprocess.getstatusoutput(<span class="string">&quot;java -jar /yunwei/AES/aesEncrpt.jar &quot;</span>+ word))[<span class="number">1</span>].split(<span class="string">&quot;=&quot;</span>)[<span class="number">1</span>])	<span class="comment">#这里执行java的命令得到结果</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(result)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p>
<p>启动django之后，打开对应的页面，效果如下：<br><img data-src="/images/django26.gif" alt="akb48"></p>
<p>而<code>Request Headers</code>部分如下：<br><img data-src="/images/django27.png" alt="akb48"></p>
<h2 id="input标签id与name的区别"><a href="#input标签id与name的区别" class="headerlink" title="input标签id与name的区别"></a>input标签id与name的区别</h2><p>最简单的说明：id就像是一个人的身份证号码，而name就像是他的名字，id显然是唯一的，而name是可以重复的，checkbox和radio都可以用name。id要符合标识的要求，比如大小写敏感，最好不要包含下划线（因为不兼容CSS）。而name基本上没有什么要求，甚至可以用数字。</p>
<p>如果在<code>reset</code>便签里这么写的话，重置功能将不会生效，因为<code>id=&quot;reset&quot; name=&quot;reset&quot;</code>，所以请极力避免用reset作为关键词。<br>	<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;reset&quot;</span> id=<span class="string">&quot;reset&quot;</span> name=<span class="string">&quot;reset&quot;</span> value=<span class="string">&quot;Reset&quot;</span> /&gt;</span><br></pre></td></tr></table></figure></p>
<p>更多的区别可以看<a href="https://stackoverflow.com/questions/7470268/html-input-name-vs-id">https://stackoverflow.com/questions/7470268/html-input-name-vs-id</a> 。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/mingliangniwo/article/details/45533201">https://blog.csdn.net/mingliangniwo/article/details/45533201</a><br><a href="https://thief.one/2017/09/14/3/">https://thief.one/2017/09/14/3/</a><br><a href="https://www.haorooms.com/post/jquery_ajax_wg">https://www.haorooms.com/post/jquery_ajax_wg</a><br><a href="http://www.cnblogs.com/birdshome/archive/2005/01/31/99562.html">http://www.cnblogs.com/birdshome/archive/2005/01/31/99562.html</a></p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>Jquery</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>从韩国民主电影三部曲浅谈我对民主的认识</title>
    <url>/2018/03/04/%E9%9F%A9%E5%9B%BD%E6%B0%91%E4%B8%BB%E7%94%B5%E5%BD%B1%E4%B8%89%E9%83%A8%E6%9B%B2/</url>
    <content><![CDATA[<p>这个周末周五晚上看了《出租车司机》，周六下午看了《1987：黎明到来的那一天》，再加上之前就在B站看过又被下架的《辩护人》，韩国民主运动三部曲都看完了。</p>
<p>韩国民主运动电影还有一部叫《华丽的假期》，这个片子是2007年公映的，也是讲光州事件，但是这部片从电影角度上不如上面这三者，所以影响力和传播程度相对有限。</p>
<p>一直以来我对韩国的政治采取一种“黑”的态度，因为他们的总统基本没有好下场，哪怕是我个人比较喜欢的卢武铉总统也是以自杀结束了自己的一生，而且他们的演艺圈和体育圈也是以各种“黑”和“潜规则”出名。但是我不得不佩服韩国正直电影人的精神以及韩国正直记者们的精神，他们坚持了自己的操守而且履行了自己的职责，用骨气和勇气记录了他们能接触到的真相并且在日后拍成电影反思历史。</p>
<p>论民主化运动，韩国可以说是亚洲里第一档的存在，大型示威的次数加起来比越南、缅甸、柬埔寨加起来还要多，远超于同样是发达国家的日本。韩国民主化运动主要集中在1980-1987年全斗焕执政那一段时间，那时韩国人民虽然经历了初期经济水平腾飞的甜蜜，但是对后期经济调控不力和政府打压言论表示不满和愤怒。暴动的人民反抗意识比较强，不仅有大规模游行，甚至有这几部电影里没有提到的抢劫军火库的行为。而这些抢劫军火的行为日后也成了全斗焕在法庭上力图脱罪的一个辩控点。</p>
<p>这几部电影虽然被部分人影评“有明显的韩国特色，会导致审美疲劳”，但是并不耽误它们一次又一次的刷新票房记录，可见参与政治追求民主和公平其实是公民的一种本能。但是说实话，截止至今，光州事件虽然被平反但是没有得到彻底的清算。新闻说现任韩国总统文在寅先后观看了《出租车司机》和《1987：黎明到来的那一天》，会不会重审当年的光州罪犯，我们拭目以待。</p>
<p>民主可能本身不是一个效率很高的政治制度，因为它要坚持“少数服从多数”的原则，在具体条款颁布和施行的时候，由于不同人看待事物的水平和深度有高有低，以及侧重面的不同，那么肯定会有一些不一样的声音。而独裁的“一言堂”则相对效率很快，从历史来看，独裁政府甚至有战争上打败民主政府的先例，而且独裁政府挑头并且通过集权形式搞经济的话，在国家原有经济非常落后的前提下，的确可以快速进步，但是这种进步并不是那种“可持续发展”式的，而且中后期会由于民众监督不力，导致政府腐败的先例数不胜数。所以说集权就是一个春药，服用肯定会上瘾，但是也只会用暂时的爽换来将来的无穷尽的苦。独裁无论是理论还是事实都已经被当今社会唾弃，只有民主化才是迟早的选择，因为它至少可以守得住下限。</p>
<p>而且我个人认为，民主是一个持续的过程而不是一个简单的结果。绝对意义上的民主和拖沓低效的民主只会害了广大的底层百姓，极力避免的同时，也要最小程度的限制人滥用民主，这些就需要政府工作的透明化和规范化。</p>
<p>不过韩国的民主也有它的独特性，主要就是它有特殊的外界因素—-既不能得罪美国人，又不能惹毛了朝鲜（这一点跟台湾很像），所以无论是强权政府还是抗议民众都没有把事情搞得太过火。其次还有韩国中产阶级在抗议中也扮演了“理性和保守的一面”：他们是经济发展的受益者，对秩序有相当的敏感性，一旦社会民主斗争极端化，中产阶级便会退出民主运动，这是其保守性的表现。除此之外，还有比如基督教的传播代替了原有的儒家思想更追求自由等等因素，我这里水平有限，就不展开了。</p>
<p>最后补充一句，各位都知道《辩护人》里宋康昊的原型是卢武铉总统，据说片里宋康昊parter的原型就是韩国现在的总统—文在寅。</p>
<p><img data-src="/images/koreaD.png" alt="paradin"></p>
]]></content>
      <categories>
        <category>坠乱花天</category>
      </categories>
      <tags>
        <tag>政治</tag>
        <tag>亚洲民主</tag>
        <tag>影评</tag>
      </tags>
  </entry>
  <entry>
    <title>在excel里用k和m来作为单位展示</title>
    <url>/2026/01/13/%E5%9C%A8excel%E9%87%8C%E7%94%A8k%E5%92%8Cm%E6%9D%A5%E4%BD%9C%E4%B8%BA%E5%8D%95%E4%BD%8D%E5%B1%95%E7%A4%BA/</url>
    <content><![CDATA[<p>虽然人类已经进化到“AI这，机器人那”。但是到了数据统计区域，excel目前还是那唯一的王。</p>
<p>不过在excel默认的单元格格式里，是不自带k 和 m这样单位的能力的，那么比如我们想把50000展示成50k，把7000000展示成7m，就要自己写这一段公式了：</p>
<p>首先，选择包含要设置格式的数字的单元格，然后选择“单元格格式”。</p>
<p>然后，在“单元格格式”对话框中的“类别“选择“自定义”，然后在类型里输入： [&lt;999950]0.0,”K”;[&lt;999950000]0.0,,”M”;0.0,,,”B”，请参见屏幕截图：<br><img data-src="/images/excel%E8%BD%AC%E5%8C%96km.jpg" alt="paradin"></p>
<p>最后，然后点击 OK 按钮，所有数字均已根据数字格式化为所需格式，请参见屏幕截图：<br><img data-src="/images/excel%E8%BD%AC%E5%8C%96km2.jpg" alt="paradin"></p>
<p>如果你只想用k这一个单位，同时保留2位小数，那么很简单：0.00,”k” 即可，0.00表示小数点后2位，“,”表示i一个comma,即“千”，这是Excel内置语法，1个逗号代表将原始数值自动除以1000。最后补上k这个符号后缀即可。注意，这样仅改变显示样式，不影响单元格实际数值。</p>
]]></content>
      <categories>
        <category>工作与技术</category>
      </categories>
      <tags>
        <tag>excel</tag>
      </tags>
  </entry>
</search>
